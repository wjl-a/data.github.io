<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.c++_线程</title>
      <link href="/data.github.io/post/52d1a938.html"/>
      <url>/data.github.io/post/52d1a938.html</url>
      
        <content type="html"><![CDATA[<h1 id="c-线程"><a href="#c-线程" class="headerlink" title="c++线程"></a>c++线程</h1><ul><li>最好在linux下面运行</li><li><ul><li>g++ -pthread test.cpp -o test：产生可执行文件</li></ul></li><li>.&#x2F;test：运行执行文件就行</li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul><li>头文件：#<code>include &lt;thread&gt;</code></li><li>线程类：<code>std::thread</code></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol><li>**thread() noexcept;**：默认构造函数，构造一个线程对象，不执行任何任务（不会创建&#x2F;启动子线程）<ol><li>noexcept 是一个异常规范说明符，表示该函数不会抛出异常</li></ol></li><li><strong>创建线程对象</strong>，在线程中执行任务函数fx中的代码，args是要传递给任务函数fx的参数</li></ol><ul><li>任务函数fx可以是普通函数、类的非静态成员函数、类的静态成员函数、lambda函数、仿函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(Function&amp;&amp; fx, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>thread(const thread&amp; ) &#x3D; delete;<ul><li>删除拷贝构造函数，不允许线程对象之间的拷贝。</li></ul></li><li>thread(thread&amp;&amp; other ) noexcept;<ul><li>移动构造函数，将线程other的资源所有权转移给新创建的线程对象</li></ul></li></ol><p><strong>赋值函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line">thread&amp; <span class="keyword">operator</span>= (<span class="type">const</span> other&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><ul><li>线程中的资源不能被复制，如果other是右值，会进行资源所有权的转移，如果other是左值，禁止拷贝。<br><strong>注意</strong></li><li>先创建的子线程不一定跑得最快（程序运行的速度有很大的偶然性）。</li><li>线程的任务函数返回后，子线程将终止。</li><li>如果主程序（主线程）退出（不论是正常退出还是意外终止），全部的子线程将强行被终止</li><li><strong>用linux平台去运行，直接用快捷键去运行回报错</strong>，需要在终端当前文件夹下：<ul><li>g++ -pthread test.cpp -o test：产生可执行文件</li><li>.&#x2F;test：运行执行文件就行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mythread1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中有静态成员函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mythread2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中有普通成员函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mythread3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用普通函数创建线程。</span></span><br><span class="line"><span class="comment">// thread t1(func, 3, &quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"><span class="comment">// thread t2(func, 8, &quot;我有一只小小鸟。&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用lambda函数创建线程。</span></span><br><span class="line"><span class="comment">// auto f = [](int bh, const string&amp; str) &#123;</span></span><br><span class="line"><span class="comment">// for (int ii = 1; ii &lt;= 10; ii++)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;第&quot; &lt;&lt; ii &lt;&lt; &quot;次表白：亲爱的&quot; &lt;&lt; bh &lt;&lt; &quot;号，&quot; &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// std::this_thread::sleep_for(std::chrono::seconds(1));   // 休眠1秒。</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// thread t3(f, 3, &quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用仿函数创建线程。</span></span><br><span class="line"><span class="function">thread <span class="title">t4</span><span class="params">(mythread1(), <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类的静态成员函数创建线程。</span></span><br><span class="line"><span class="comment">//thread t5(mythread2::func, 3, &quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类的普通成员函数创建线程。</span></span><br><span class="line">mythread3 myth;   <span class="comment">// 必须先创建类的对象，必须保证对象的生命周期比子线程要长。</span></span><br><span class="line"><span class="function">thread <span class="title">t6</span><span class="params">(&amp;mythread3::func, &amp;myth, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;  <span class="comment">// 第二个参数必须填对象的this指针，否则会拷贝对象。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;任务开始。\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;执行任务中......\n&quot;</span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));   <span class="comment">// 假设执行任务需要时间。</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;任务完成。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// t1.join();         // 回收线程t1的资源，回收后才不会报错</span></span><br><span class="line"><span class="comment">// t2.join();         // 回收线程t2的资源。</span></span><br><span class="line"><span class="comment">// t3.join();         // 回收线程t3的资源。</span></span><br><span class="line">t4.<span class="built_in">join</span>();         <span class="comment">// 回收线程t4的资源。</span></span><br><span class="line"><span class="comment">// t5.join();         // 回收线程t5的资源。</span></span><br><span class="line">t6.<span class="built_in">join</span>();         <span class="comment">// 回收线程t6的资源。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="线程的回收"><a href="#线程的回收" class="headerlink" title="线程的回收"></a>线程的回收</h2><p>虽然同一个进程的多个线程共享进程的栈空间，但是，每个<strong>子线程在这个栈中拥有自己私有的栈空间</strong>。所以，线程结束时需要回收资源。<br><strong>回收子线程的资源有两种方法</strong></p><ul><li>在主程序中，调用join()成员函数等待子线程退出，回收它的资源。如果子线程已退出，join()函数立即返回，否则会阻塞等待，直到子线程退出。</li><li>在主程序中，调用detach()成员函数分离子线程，子线程退出时，系统将自动回收资源。分离后的子线程不可join()。</li><li>用joinable()成员函数可以判断子线程的分离状态，函数返回布尔类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用普通函数创建线程。</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">detach</span>(); t2.<span class="built_in">detach</span>();  <span class="comment">// 分离子线程，就退出，在后面需要加上延时函数，否则会直接退出主函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;任务开始。\n&quot;;</span></span><br><span class="line"><span class="comment">//for (int ii = 0; ii &lt; 12; ii++) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;执行任务中......\n&quot;;</span></span><br><span class="line"><span class="comment">//std::this_thread::sleep_for(std::chrono::seconds(1));   // 假设执行任务需要时间。</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;任务完成。\n&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//t1.join();         // 回收线程t1的资源。</span></span><br><span class="line"><span class="comment">//t2.join();         // 回收线程t2的资源。</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">12</span>));<span class="comment">//要加大点，否则会没运行就退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="this-thread的全局函数"><a href="#this-thread的全局函数" class="headerlink" title="this_thread的全局函数"></a>this_thread的全局函数</h2><ul><li>C++11提供了命名空间this_thread来表示当前线程，该命名空间中有四个函数：get_id()、sleep_for()、sleep_until()、yield()。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">get_id</span>()</span><br><span class="line"><span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">该函数用于获取线程ID，thread类也有同名的成员函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）<span class="built_in">sleep_for</span>()  <span class="function">VS  <span class="title">Sleep</span><span class="params">(<span class="number">1000</span>)</span>   Linux <span class="title">sleep</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Rep, <span class="keyword">class</span> Period&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">sleep_for</span> <span class="params">(<span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line">该函数让线程休眠一段时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）<span class="built_in">sleep_until</span>()          <span class="number">2022</span><span class="number">-01</span><span class="number">-01</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">35</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sleep_until</span> <span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line">该函数让线程休眠至指定时间点。（可实现定时任务）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）<span class="built_in">yield</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">该函数让线程主动让出自己已经抢到的CPU时间片。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）thread类其它的成员函数</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(std::thread&amp; other)</span></span>;    <span class="comment">// 交换两个线程对象。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">hardware_concurrency</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// 返回硬件线程上下文的数量。</span></span><br></pre></td></tr></table></figure>示例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">3</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用普通函数创建线程。</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;线程t1：&quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;线程t2：&quot;</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="call-once函数"><a href="#call-once函数" class="headerlink" title="call_once函数"></a>call_once函数</h2><ul><li><p>在多线程环境中，某些函数只能被调用一次，例如：初始化某个对象，而这个对象只能被初始化一次。</p></li><li><p>在线程的任务函数中，可以用<strong>std::call_once()来保证某个函数只被调用一次</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件：<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Function&amp;&amp; fx, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>第一个参数是std::once_flag，用于标记函数fx是否已经被执行过。</p></li><li><p>第二个参数是需要执行的函数fx。</p></li><li><p>后面的可变参数是传递给函数fx的参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>        <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>        <span class="comment">// std::once_flag和std::call_once()函数需要包含这个头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">once_flag onceflag;       <span class="comment">// once_flag全局变量。本质是取值为0和1的锁。</span></span><br><span class="line"><span class="comment">// 在线程中，打算只调用一次的函数。在创建多个子线程中也会执行一次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">once_func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span>  </span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;once_func() bh= &quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;, str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">call_once</span>(onceflag,once_func,<span class="number">0</span>, <span class="string">&quot;各位观众，我要开始表白了。&quot;</span>);<span class="comment">//在子线程中只会执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">3</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用普通函数创建线程。</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="native-handle函数"><a href="#native-handle函数" class="headerlink" title="native_handle函数"></a>native_handle函数</h2><ul><li>C++11定义了线程标准，不同的平台和编译器在实现的时候，本质上都是对操作系统的线程库进行封装，会损失一部分功能。</li><li>为了弥补C++11线程库的不足，thread类提供了native_handle()成员函数，<strong>用于获得与操作系统相关的原生线程句柄</strong>，操作系统原生的线程库就可以用原生线程句柄操作线程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>        <span class="comment">// Linux的pthread线程库头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span>    <span class="comment">// 线程任务函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">10</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">// 休眠1秒。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">tt</span><span class="params">(func)</span></span>;          <span class="comment">// 创建线程。</span></span><br><span class="line"></span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));    <span class="comment">// 休眠5秒，使当前线程休眠相应的时间。//这个函数可以用于在程序中暂停执行一段时间</span></span><br><span class="line"></span><br><span class="line">  <span class="type">pthread_t</span> thid= tt.<span class="built_in">native_handle</span>();  <span class="comment">// 获取Linux操作系统原生的线程句柄。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cancel</span>(thid);  <span class="comment">// 强制取消线程，注销后这里将会运行10次；否则5次</span></span><br><span class="line">  <span class="comment">//join() 只会等待线程结束，而不会强制终止线程的执行。如果你想要强制终止线程的执行，可以使用 std::thread::native_handle() 获取线程的原生句柄，然后使用平台特定的方法来取消线程的执行，如使用 pthread_cancel() 函数来取消线程。</span></span><br><span class="line">  tt.<span class="built_in">join</span>();   <span class="comment">// 等待线程退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li>同一个进程中的多个线程共享该进程中的全部资源</li><li>多个线程访问同一个共享资源会产生冲突</li><li>顺序性，可见性，原子性<ul><li><strong>顺序性</strong>：程序按照代码的先后顺序执行</li><li><strong>可见性</strong>：线程共享变量，会将该变量从内存中加载到CPU缓存中，修改该变量后，CPU会立即更新缓存，但不一定会立即将他写入内存，这时候，如果其他线程访问该变量，从内存中读到的是旧数据，而非第一个线程操作后的数据</li><li><strong>原子性</strong>：CPU执行指令——读取指令，读取内存，执行指令，写回内存</li></ul></li></ul><p><strong>volatile关键字</strong></p><ul><li>保证内存变量可见性</li><li>禁止代码优化(重排序)<br>要解决线程安全</li><li>原子操作</li><li>线程同步锁<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>        <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> aa = <span class="number">0</span>;     <span class="comment">// 定义全局变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数，把全局变量aa加1000000次。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">1000000</span>; ii++)</span><br><span class="line">aa++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用普通函数创建线程。</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;     <span class="comment">// 创建线程t1，把全局变量aa加1000000次。</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;     <span class="comment">// 创建线程t2，把全局变量aa加1000000次。</span></span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aa=&quot;</span> &lt;&lt; aa &lt;&lt; endl;   <span class="comment">// 显示全局变量aa的值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题所在</span></span><br><span class="line"><span class="comment">// 代码存在一个潜在的问题，即多个线程同时对全局变量 aa 进行写操作，可能导致竞态条件（Race Condition）。竞态条件是指多个线程对共享资源进行读写操作时的不确定行为，导致结果的不可预测性。</span></span><br><span class="line"><span class="comment">// 在代码中，两个线程同时对全局变量 aa 进行加法操作，可能导致以下情况之一：</span></span><br><span class="line"><span class="comment">// 1.线程之间发生了交替执行，导致最后的结果正确，aa 的值为 2000000；</span></span><br><span class="line"><span class="comment">// 2/线程之间发生了交替执行，并且发生了竞态条件，导致最后的结果不正确，aa 的值小于 2000000。</span></span><br><span class="line"><span class="comment">// 为了避免竞态条件，你可以使用互斥锁（std::mutex）来保护共享资源，确保在任意时刻只有一个线程可以访问共享资源。具体做法是在访问 aa 的代码块前后加锁和解锁操作。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li>线程同步：多个线程协同工作，协商如何使用共享资源</li><li>有三种模型<ul><li>互斥锁</li><li>条件变量</li><li>生产&#x2F;消费模型</li></ul></li></ul><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul><li>加锁和解锁，确保同一时间只有一个线程访问共享资源</li><li>访问共享资源之前加莎，访问完后释放</li><li>如果某线程持有锁，其他的线程形成等待队列</li></ul><p><strong>C++11提供了四种互斥锁</strong>：<br>    • mutex：互斥锁。<br>    • timed_mutex：带超时机制的互斥锁。<br>    • recursive_mutex：递归互斥锁。<br>    • recursive_timed_mutex：带超时机制的递归互斥锁。<br>包含头文件：<code>#include &lt;mutex&gt;</code></p><h4 id="mutex类"><a href="#mutex类" class="headerlink" title="mutex类"></a>mutex类</h4><p><strong>加锁lock()</strong></p><ul><li>互斥锁有锁定和未锁定两种状态。</li><li>如果互斥锁是未锁定状态，调用lock()成员函数的线程会得到互斥锁的所有权，并将其上锁。</li><li>如果互斥锁是锁定状态，调用lock()成员函数的线程就会阻塞等待，直到互斥锁变成未锁定状态。</li></ul><p><strong>解锁unlock()</strong></p><ul><li>只有持有锁的线程才能解锁。</li></ul><p><strong>尝试加锁try_lock()</strong></p><ul><li>如果互斥锁是未锁定状态，则加锁成功，函数返回true。</li><li>如果互斥锁是锁定状态，则加锁失败，函数立即返回false。（线程不会阻塞等待）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;        <span class="comment">// 创建互斥锁，保护共享资源cout对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();      <span class="comment">// 申请加锁。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">mtx.<span class="built_in">unlock</span>();  <span class="comment">// 解锁。</span></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));     <span class="comment">// 休眠1秒。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用普通函数创建线程。</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t4</span><span class="params">(func, <span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t5</span><span class="params">(func, <span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line">t3.<span class="built_in">join</span>();         <span class="comment">// 回收线程t3的资源。</span></span><br><span class="line">t4.<span class="built_in">join</span>();         <span class="comment">// 回收线程t4的资源。</span></span><br><span class="line">t5.<span class="built_in">join</span>();         <span class="comment">// 回收线程t5的资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="timed-mutex类"><a href="#timed-mutex类" class="headerlink" title="timed_mutex类"></a>timed_mutex类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增加了两个成员函数：</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock_for</span><span class="params">(时间长度)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock_until</span><span class="params">(时间点)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="recursive-mutex类"><a href="#recursive-mutex类" class="headerlink" title="recursive_mutex类"></a>recursive_mutex类</h4><p>递归互斥锁允许同一线程多次获得互斥锁，可以解决同一线程多次加锁造成的死锁问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>        <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">recursive_mutex m_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了func1()\n&quot;</span>;</span><br><span class="line">m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了func2()\n&quot;</span>;</span><br><span class="line"><span class="built_in">func1</span>();</span><br><span class="line">m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AA aa;</span><br><span class="line"><span class="comment">//aa.func1();</span></span><br><span class="line">aa.<span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lock-guard类"><a href="#lock-guard类" class="headerlink" title="lock_guard类"></a>lock_guard类</h4><ul><li>lock_guard是模板类，可以简化互斥锁的使用，也更安全</li><li>lock_guard在构造函数中加锁，在析构函数中解锁</li><li>lock_guard采用了RAII思想（在类构造函数中分配资源，在析构函数中释放资源，保证资源在离开作用域时自动释放）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(Mutex&amp; mtx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件变量-生产消费者模型"><a href="#条件变量-生产消费者模型" class="headerlink" title="条件变量-生产消费者模型"></a>条件变量-生产消费者模型</h2><ul><li>比较常用</li><li>当条件不满足时，相关线程被一直阻塞，直到每种条件出现，这些线程才被唤醒</li><li>为保护共享资源，条件变量需要和互斥锁结合一起使用</li><li>生产&#x2F;消费者模型<br>![[Pasted image 20231226111524.png]]</li><li>条件变量是一种线程同步机制。当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。</li><li>C++11的条件变量提供了两个类：<ul><li>condition_variable：只支持与普通mutex搭配，效率更高。</li><li>condition_variable_any：是一种通用的条件变量，可以与任意mutex搭配（包括用户自定义的锁类型）。</li></ul></li><li>包含头文件：<code>&lt;condition_variable&gt;</code></li></ul><h3 id="condition-variable类"><a href="#condition-variable类" class="headerlink" title="condition_variable类"></a>condition_variable类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要成员函数：</span><br><span class="line"><span class="number">1</span>）<span class="built_in">condition_variable</span>() 默认构造函数。</span><br><span class="line"><span class="number">2</span>）<span class="built_in">condition_variable</span>(<span class="type">const</span> condition_variable &amp;)=<span class="keyword">delete</span> 禁止拷贝。</span><br><span class="line"><span class="number">3</span>）condition_variable&amp; condition_variable::<span class="keyword">operator</span>=(<span class="type">const</span> condition_variable &amp;)=<span class="keyword">delete</span> 禁止赋值。</span><br><span class="line"><span class="number">4</span>）<span class="built_in">notify_one</span>() 通知一个等待的线程。</span><br><span class="line"><span class="number">5</span>）<span class="built_in">notify_all</span>() 通知全部等待的线程。</span><br><span class="line"><span class="number">6</span>）<span class="built_in">wait</span>(unique_lock&lt;mutex&gt; lock) 阻塞当前线程，直到通知到达。</span><br><span class="line"><span class="number">7</span>）<span class="built_in">wait</span>(unique_lock&lt;mutex&gt; lock,Pred pred) 循环的阻塞当前线程，直到通知到达且谓词满足。</span><br><span class="line"><span class="number">8</span>）<span class="built_in">wait_for</span>(unique_lock&lt;mutex&gt; lock,时间长度)</span><br><span class="line"><span class="number">9</span>）<span class="built_in">wait_for</span>(unique_lock&lt;mutex&gt; lock,时间长度,Pred pred)</span><br><span class="line"><span class="number">10</span>）<span class="built_in">wait_until</span>(unique_lock&lt;mutex&gt; lock,时间点)</span><br><span class="line"><span class="number">11</span>）<span class="built_in">wait_until</span>(unique_lock&lt;mutex&gt; lock,时间点,Pred pred)</span><br></pre></td></tr></table></figure><h3 id="unique-lock类"><a href="#unique-lock类" class="headerlink" title="unique_lock类"></a>unique_lock类</h3><ul><li><code>template &lt;class Mutex&gt; class unique_lock</code>是模板类，模板参数为互斥锁类型。</li><li>unique_lock和lock_guard都是管理锁的辅助类，都是RAII风格（在构造时获得锁，在析构时释放锁）。它们的区别在于：为了配合condition_variable，unique_lock还有lock()和unlock()成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                      <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                      <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>                      <span class="comment">// deque容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>                      <span class="comment">// queue容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  <span class="comment">// 条件变量的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex m_mutex;                                    <span class="comment">// 互斥锁。</span></span><br><span class="line">    condition_variable m_cond;                  <span class="comment">// 条件变量。</span></span><br><span class="line">    queue&lt;string, deque&lt;string&gt;&gt; m_q;   <span class="comment">// 缓存队列，底层容器用deque。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incache</span><span class="params">(<span class="type">int</span> num)</span>     <span class="comment">// 生产数据，num指定数据的个数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   <span class="comment">// 申请加锁，离开作用域会自动解锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span> ; ii&lt;num ; ii++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> bh = <span class="number">1</span>;           <span class="comment">// 超女编号。</span></span><br><span class="line">            string message = <span class="built_in">to_string</span>(bh++) + <span class="string">&quot;号超女&quot;</span>;    <span class="comment">// 拼接出一个数据。</span></span><br><span class="line">            m_q.<span class="built_in">push</span>(message);     <span class="comment">// 把生产出来的数据入队。</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_cond.<span class="built_in">notify_one</span>();     <span class="comment">// 若生产数据只有一个，用他；否则用下面那个。唤醒一个被当前条件变量阻塞的线程。</span></span><br><span class="line">        <span class="comment">//m_cond.notify_all();          // 唤醒全部被当前条件变量阻塞的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outcache</span><span class="params">()</span>       <span class="comment">// 消费者线程任务函数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string message;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把互斥锁转换成unique_lock&lt;mutex&gt;，并申请加锁。</span></span><br><span class="line">                <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (m_q.<span class="built_in">empty</span>())    <span class="comment">// 如果队列空，进入循环，否则直接处理数据。必须用循环，不能用if</span></span><br><span class="line">                    m_cond.<span class="built_in">wait</span>(lock);  <span class="comment">// 等待生产者的唤醒信号。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 数据元素出队。</span></span><br><span class="line">                message = m_q.<span class="built_in">front</span>();  m_q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理出队的数据（把数据消费掉）。</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));   <span class="comment">// 假设处理数据需要1毫秒。</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA aa;</span><br><span class="line">  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t1。</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t2。</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t3。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));    <span class="comment">// 休眠2秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">3</span>);      <span class="comment">// 生产3个数据。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));    <span class="comment">// 休眠3秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">5</span>);      <span class="comment">// 生产5个数据。</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();   <span class="comment">// 回收子线程的资源。</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>示例2<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                      <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                      <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>                      <span class="comment">// deque容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>                      <span class="comment">// queue容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  <span class="comment">// 条件变量的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex m_mutex;                                    <span class="comment">// 互斥锁。</span></span><br><span class="line">    condition_variable m_cond;                  <span class="comment">// 条件变量。</span></span><br><span class="line">    queue&lt;string, deque&lt;string&gt;&gt; m_q;   <span class="comment">// 缓存队列，底层容器用deque。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incache</span><span class="params">(<span class="type">int</span> num)</span>     <span class="comment">// 生产数据，num指定数据的个数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   <span class="comment">// 申请加锁。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span> ; ii&lt;num ; ii++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> bh = <span class="number">1</span>;           <span class="comment">// 超女编号。</span></span><br><span class="line">            string message = <span class="built_in">to_string</span>(bh++) + <span class="string">&quot;号超女&quot;</span>;    <span class="comment">// 拼接出一个数据。</span></span><br><span class="line">            m_q.<span class="built_in">push</span>(message);     <span class="comment">// 把生产出来的数据入队。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//m_cond.notify_one();     // 唤醒一个被当前条件变量阻塞的线程。</span></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();          <span class="comment">// 唤醒全部被当前条件变量阻塞的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outcache</span><span class="params">()</span>   </span>&#123;    <span class="comment">// 消费者线程任务函数。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)   &#123;</span><br><span class="line">            <span class="comment">// 把互斥锁转换成unique_lock&lt;mutex&gt;，并申请加锁。</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件变量虚假唤醒：消费者线程被唤醒后，缓存队列中没有数据。</span></span><br><span class="line">            <span class="comment">//while (m_q.empty())    // 如果队列空，进入循环，否则直接处理数据。必须用循环，不能用if</span></span><br><span class="line">            <span class="comment">//    m_cond.wait(lock);  // 1）把互斥锁解开；2）阻塞，等待被唤醒；3）给互斥锁加锁。</span></span><br><span class="line">            m_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !m_q.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据元素出队。</span></span><br><span class="line">            string message = m_q.<span class="built_in">front</span>();  m_q.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();      <span class="comment">// 手工解锁。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理出队的数据（把数据消费掉）。</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));   <span class="comment">// 假设处理数据需要1毫秒。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA aa;</span><br><span class="line">  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t1。</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t2。</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t3。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));    <span class="comment">// 休眠2秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">2</span>);      <span class="comment">// 生产2个数据。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));    <span class="comment">// 休眠3秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">5</span>);      <span class="comment">// 生产5个数据。</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();   <span class="comment">// 回收子线程的资源。</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h2><ul><li>C++11提供了<code>atomic&lt;T&gt;</code>模板类（结构体），用于支持原子类型，模板参数可以是bool、char、int、long、long long、指针类型（不支持浮点类型和自定义数据类型）。</li><li>原子操作由CPU指令提供支持，它的性能比锁和消息传递更高，并且，不需要程序员处理加锁和释放锁的问题，支持修改、读取、交换、比较并交换等操作。</li><li>头文件：<code>#include &lt;atomic&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">构造函数：</span><br><span class="line"><span class="built_in">atomic</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;  <span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="built_in">atomic</span>(T val) <span class="keyword">noexcept</span>;  <span class="comment">// 转换函数。</span></span><br><span class="line"><span class="built_in">atomic</span>(<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁用拷贝构造函数。</span></span><br><span class="line">赋值函数：</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>=(<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;   <span class="comment">// 禁用赋值函数。</span></span><br><span class="line">常用函数：</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// 把val的值存入原子变量。</span></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 读取原子变量的值。</span></span><br><span class="line"><span class="function">T <span class="title">fetch_add</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 把原子变量的值与val相加，返回原值。</span></span><br><span class="line"><span class="function">T <span class="title">fetch_sub</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 把原子变量的值减val，返回原值。</span></span><br><span class="line"><span class="function">T <span class="title">exchange</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 把val的值存入原子变量，返回原值。</span></span><br><span class="line"><span class="function">T <span class="title">compare_exchange_strong</span><span class="params">(T &amp;expect,<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 比较原子变量的值和预期值expect，如果当两个值相等，把val存储到原子变量中，函数返回true；如果当两个值不相等，用原子变量的值更新预期值，函数返回false。CAS指令。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_lock_free</span><span class="params">()</span></span>;  <span class="comment">// 查询某原子类型的操作是直接用CPU指令（返回true），还是编译器内部的锁（返回false）。</span></span><br></pre></td></tr></table></figure><strong>原子类型</strong><br><strong>![[Pasted image 20231226185416.png]]</strong><br>• <code>atomic&lt;T&gt;</code>模板类重载了整数操作的各种运算符。<br>• <code>atomic&lt;T&gt;</code>模板类的模板参数支持指针，但不表示它所指向的对象是原子类型。<br>• 原子整型可以用作计数器，布尔型可以用作开关。<br>• CAS指令是实现无锁队列基础。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// atomic&lt;int&gt; a = 3; //会报错</span></span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; a; <span class="comment">// 声明一个原子变量a</span></span><br><span class="line">    a = <span class="number">3</span>; <span class="comment">// 使用赋值操作符给a赋值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 读取原子变量a的值并输出</span></span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">store</span>(<span class="number">8</span>); <span class="comment">// 把8存储到原子变量中</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 读取原子变量a的值并输出</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    old = a.<span class="built_in">fetch_add</span>(<span class="number">5</span>); <span class="comment">// 把原子变量a的值与5相加，返回原值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;old = &quot;</span> &lt;&lt; old &lt;&lt; <span class="string">&quot;，a = &quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 输出原值和更新后的a的值</span></span><br><span class="line">    old = a.<span class="built_in">fetch_sub</span>(<span class="number">2</span>); <span class="comment">// 把原子变量a的值减2，返回原值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;old = &quot;</span> &lt;&lt; old &lt;&lt; <span class="string">&quot;，a = &quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 输出原值和更新后的a的值</span></span><br><span class="line"></span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; ii; <span class="comment">// 声明一个新的原子变量ii</span></span><br><span class="line">    ii = <span class="number">3</span>; <span class="comment">// 使用赋值操作符给ii赋值</span></span><br><span class="line">    <span class="type">int</span> expect = <span class="number">4</span>; <span class="comment">// 定义一个期望值</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">5</span>; <span class="comment">// 定义要存入原子变量的值</span></span><br><span class="line">    <span class="comment">// 比较原子变量ii的值和期望值expect，</span></span><br><span class="line">    <span class="comment">// 如果两个值相等，将val存储到原子变量中；</span></span><br><span class="line">    <span class="comment">// 如果两个值不相等，用原子变量的值更新期望值。</span></span><br><span class="line">    <span class="comment">// 执行存储操作时返回true，否则返回false。</span></span><br><span class="line">    <span class="type">bool</span> bret = ii.<span class="built_in">compare_exchange_strong</span>(expect, val);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bret=&quot;</span> &lt;&lt; bret &lt;&lt; endl; <span class="comment">// 输出比较交换的结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 读取原子变量ii的值并输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;expect=&quot;</span> &lt;&lt; expect &lt;&lt; endl; <span class="comment">// 输出更新后的期望值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="可调用对象的绑定器和包装器"><a href="#可调用对象的绑定器和包装器" class="headerlink" title="可调用对象的绑定器和包装器"></a>可调用对象的绑定器和包装器</h1><ul><li>在C++中，可以像函数一样调用的有：普通函数、类的静态成员函数、仿函数、lambda函数、类的非静态成员函数、可被转换为函数的类的对象，统称可调用对象或函数对象。</li><li>可调用对象有类型，可以用指针存储它们的地址，可以被引用（类的成员函数除外）</li></ul><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><ul><li>普通函数类型可以声明函数、定义函数指针和函数引用，但是，不能定义函数的实体<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span> (<span class="type">int</span>, <span class="type">const</span> string&amp;);  <span class="comment">// 普通函数类型的别名。</span></span><br><span class="line">Fun show;        <span class="comment">// 声明普通函数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">show</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 直接调用普通函数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span>(*fp1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = show;<span class="comment">// 声明函数指针，指向普通函数。</span></span><br><span class="line"><span class="built_in">void</span>(&amp;fr1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = show;<span class="comment">// 声明函数引用，引用普通函数。</span></span><br><span class="line"><span class="built_in">fp1</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数指针调用普通函数。</span></span><br><span class="line"><span class="built_in">fr1</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数引用调用普通函数。</span></span><br><span class="line"></span><br><span class="line">Fun* fp2 = show;<span class="comment">// 声明函数指针，指向普通函数。</span></span><br><span class="line">Fun&amp; fr2 = show;<span class="comment">// 声明函数引用，引用普通函数。</span></span><br><span class="line"><span class="built_in">fp2</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数指针调用普通函数。</span></span><br><span class="line"><span class="built_in">fr2</span>(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数引用调用普通函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码是错误的，不能用函数类型定义函数的实体。</span></span><br><span class="line"><span class="comment">//Func show1 &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; bh &lt;&lt; &quot;，&quot; &lt;&lt; message &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="类的静态成员函数"><a href="#类的静态成员函数" class="headerlink" title="类的静态成员函数"></a>类的静态成员函数</h3><p>类的静态成员函数和普通函数本质上是一样的，把普通函数放在类中而已</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span> (<span class="type">int</span>, <span class="type">const</span> string&amp;);  <span class="comment">// 普通函数类型的别名。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AA</span><span class="comment">// 类中有静态成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AA::<span class="built_in">show</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 直接调用静态成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span>(*fp1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = AA::show;<span class="comment">// 用函数指针指向静态成员函数。</span></span><br><span class="line"><span class="built_in">void</span>(&amp;fr1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = AA::show;<span class="comment">// 引用静态成员函数。</span></span><br><span class="line"><span class="built_in">fp1</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数指针调用静态成员函数。</span></span><br><span class="line"><span class="built_in">fr1</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数引用调用静态成员函数。</span></span><br><span class="line"></span><br><span class="line">Fun* fp2 = AA::show;<span class="comment">// 用函数指针指向静态成员函数。</span></span><br><span class="line">Fun&amp; fr2 = AA::show;<span class="comment">// 引用静态成员函数。</span></span><br><span class="line"><span class="built_in">fp2</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数指针调用静态成员函数。</span></span><br><span class="line"><span class="built_in">fr2</span>(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数引用调用静态成员函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><ul><li>仿函数的本质是类，调用的代码像函数。</li><li>仿函数的类型就是类的类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BB</span><span class="comment">// 仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BB bb;</span><br><span class="line"><span class="built_in">bb</span>(<span class="number">11</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用对象调用仿函数。</span></span><br><span class="line"><span class="built_in">BB</span>()(<span class="number">12</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用匿名对象调用仿函数。</span></span><br><span class="line"></span><br><span class="line">BB&amp; br = bb;           <span class="comment">// 引用函数</span></span><br><span class="line"><span class="built_in">br</span>(<span class="number">13</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用对象的引用调用仿函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>lambda函数的本质是仿函数，仿函数的本质是类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建lambda对象。</span></span><br><span class="line"><span class="keyword">auto</span> lb = [](<span class="type">int</span> bh, <span class="type">const</span> string&amp; message) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; lr = lb;  <span class="comment">// 引用lambda对象。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lb</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用lambda对象调用仿函数。</span></span><br><span class="line"><span class="built_in">lr</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用lambda对象的引用调用仿函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的非静态成员函数"><a href="#类的非静态成员函数" class="headerlink" title="类的非静态成员函数"></a>类的非静态成员函数</h3><ul><li>类的非静态成员函数有地址，但是，只能通过类的对象才能调用它，所以，C++对它做了特别处理。</li><li>类的非静态成员函数只有指针类型，没有引用类型，不能引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CC</span><span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CC cc;</span><br><span class="line">cc.<span class="built_in">show</span>(<span class="number">14</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (CC::* fp11)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = &amp;CC::show;<span class="comment">// 定义类的成员函数的指针。</span></span><br><span class="line">(cc.*fp11)(<span class="number">15</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用类的成员函数的指针调用成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> pFun = <span class="built_in">void</span> (CC::*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);<span class="comment">// 类成员函数的指针类型。</span></span><br><span class="line">pFun fp12 = &amp;CC::show;<span class="comment">// 让类成员函数的指针指向类的成员函数的地址。</span></span><br><span class="line">(cc.*fp12)(<span class="number">16</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用类成员函数的指针调用类的成员函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可被转换为函数指针的类对象"><a href="#可被转换为函数指针的类对象" class="headerlink" title="可被转换为函数指针的类对象"></a>可被转换为函数指针的类对象</h3><ul><li>类可以重载类型转换运算符operator 数据类型() ，如果数据类型是函数指针或函数引用类型，那么该类实例也将成为可调用对象。</li><li>它的本质是类，调用的代码像函数。</li><li>在实际开发中，意义不大<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DD</span><span class="comment">// 可以被转换为函数指针的类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> show;<span class="comment">// 返回普通函数。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DD dd;</span><br><span class="line"><span class="built_in">dd</span>(<span class="number">17</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 可以被转换为函数指针的类对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="包装器function"><a href="#包装器function" class="headerlink" title="包装器function"></a>包装器function</h2><ul><li>std::function模板类是<strong>一个通用的可调用对象的包装器</strong>，用简单的、统一的方式处理可调用对象</li><li>std::function是一个通用的函数封装器，<strong>可以用来存储和调用任何可调用对象，包括函数指针、函数对象、Lambda表达式等</strong>。它类似于一个类型安全的函数指针，可以在运行时决定要调用的具体函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>……</span><br></pre></td></tr></table></figure></li><li><code>_Fty是可调用对象的类型，格式：返回类型(参数列表)。</code></li><li>包含头文件：<code>#include &lt;functional&gt;</code></li><li>注意：<br>  • 重载了bool运算符，用于判断是否包装了可调用对象。<br>  • 如果std::function对象未包装可调用对象，使用std::function对象将抛出std::bad_function_call异常。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span><span class="comment">// 类中有静态成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span><span class="comment">// 仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span><span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span><span class="comment">// 可以被转换为普通函数指针的类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);    <span class="comment">// 函数指针的别名。</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> show;<span class="comment">// 返回普通函数show的地址。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;);  <span class="comment">// 函数类型的别名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="built_in">void</span>(*fp1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = show;<span class="comment">// 声明函数指针，指向函数对象。</span></span><br><span class="line"><span class="built_in">fp1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数指针调用普通函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn1 = show;    <span class="comment">// 包装普通全局函数show。</span></span><br><span class="line"><span class="built_in">fn1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用普通全局函数show。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的静态成员函数。</span></span><br><span class="line"><span class="built_in">void</span>(*fp3)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = AA::show;<span class="comment">// 用函数指针指向类的静态成员函数。</span></span><br><span class="line"><span class="built_in">fp3</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用函数指针调用类的静态成员函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn3 = AA::show;<span class="comment">// 包装类的静态成员函数。</span></span><br><span class="line"><span class="built_in">fn3</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用类的静态成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数。</span></span><br><span class="line">BB bb;</span><br><span class="line"><span class="built_in">bb</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用仿函数对象调用仿函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn4 = <span class="built_in">BB</span>();<span class="comment">// 包装仿函数。</span></span><br><span class="line"><span class="built_in">fn4</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用仿函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建lambda对象。</span></span><br><span class="line"><span class="keyword">auto</span> lb = [](<span class="type">int</span> bh, <span class="type">const</span> string&amp; message) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lb</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);          <span class="comment">// 调用lambda函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn5 = lb;<span class="comment">// 包装lamba函数。</span></span><br><span class="line"><span class="built_in">fn5</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用lamba函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的非静态成员函数。</span></span><br><span class="line">CC cc;</span><br><span class="line"><span class="built_in">void</span> (CC:: * fp11)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = &amp;CC::show;<span class="comment">// 定义类成员函数的指针。</span></span><br><span class="line">(cc.*fp11)(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用类成员函数的指针调用类的成员函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(CC&amp;,<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn11 = &amp;CC::show;<span class="comment">// 包装成员函数。</span></span><br><span class="line"><span class="built_in">fn11</span>(cc,<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以被转换为函数指针的类对象。</span></span><br><span class="line">DD dd;</span><br><span class="line"><span class="built_in">dd</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用可以被转换为函数指针的类对象调用普通函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn12 = dd;<span class="comment">// 包装可以被转换为函数指针的类。</span></span><br><span class="line"><span class="built_in">fn12</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用它。</span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fx=dd;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fx) <span class="built_in">fx</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (std::bad_function_call e) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;抛出了std::bad_function_call异常。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="适配器bind"><a href="#适配器bind" class="headerlink" title="适配器bind"></a>适配器bind</h2><ul><li>std::bind用于<strong>将函数和其参数绑定为一个可调用的对象</strong>。它可以创建一个新的可调用对象，使得在调用时可以传递参数、绑定参数或者重排参数的顺序</li><li>包含头文件：<code>#include &lt;functional&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数原型：</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Fx</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">function&lt;&gt; <span class="built_in">bind</span> (Fx&amp;&amp; fx, Args&amp;...args);</span><br></pre></td></tr></table></figure></li><li>Fx：需要绑定的可调用对象（可以是前两节课介绍的那六种，也可以是function对象）。</li><li>args：绑定参数列表，可以是左值、右值和参数占位符<code>std::placeholders::_n</code>，如果参数不是占位符，缺省为值传递，std:: ref(参数)则为引用传递。</li><li>std::bind()返回std::function的对象。</li><li>std::bind()的本质是仿函数。<br>示例1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">std::cout&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// std::placeholders::_n指的在原来函数形参的第n个位置</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyFunc = std::<span class="built_in">bind</span>(Multiply, std::placeholders::_2, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line">    <span class="comment">// 绑定Multiply函数，将第二个参数绑定为5，第一个参数绑定为占位符_2，第三个参数绑定为占位符_1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multiplyFunc</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 调用multiplyFunc，传递参数3作为占位符_2的值，传递参数2作为占位符_1的值，固定的参数5保持不变</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>示例2<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn1 = show;</span><br><span class="line"><span class="comment">//std::placeholders::_1是C++标准库提供的一个占位符</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn2 = <span class="built_in">bind</span>(show, placeholders::_1, placeholders::_2);</span><br><span class="line"><span class="built_in">fn1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"><span class="built_in">fn2</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">const</span> string&amp;, <span class="type">int</span>)&gt; fn3 = <span class="built_in">bind</span>(show, placeholders::_2, placeholders::_1);</span><br><span class="line"><span class="built_in">fn3</span>(<span class="string">&quot;我是一只傻傻鸟。&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">const</span> string&amp;)&gt; fn4 = <span class="built_in">bind</span>(show, <span class="number">3</span>, placeholders::_1);</span><br><span class="line"><span class="built_in">fn4</span>(<span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;,<span class="type">int</span>)&gt; fn5 = <span class="built_in">bind</span>(show, placeholders::_1, placeholders::_2);</span><br><span class="line"><span class="built_in">fn5</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>, <span class="number">88</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>示例3<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AA</span><span class="comment">// 类中有静态成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BB</span><span class="comment">// 仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CC</span><span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DD</span><span class="comment">// 可以被转换为普通函数指针的类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);    <span class="comment">// 函数指针的别名。</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> show;<span class="comment">// 返回普通函数show的地址。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn1 = <span class="built_in">bind</span>(show, placeholders::_1, placeholders::_2);    <span class="comment">// 绑定普通全局函数show。</span></span><br><span class="line"><span class="built_in">fn1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用普通全局函数show。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的静态成员函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn3 = <span class="built_in">bind</span>(AA::show, placeholders::_1, placeholders::_2);<span class="comment">// 绑定类的静态成员函数。</span></span><br><span class="line"><span class="built_in">fn3</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用类的静态成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn4 = <span class="built_in">bind</span>(<span class="built_in">BB</span>(), placeholders::_1, placeholders::_2);<span class="comment">// 绑定仿函数。</span></span><br><span class="line"><span class="built_in">fn4</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用仿函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建lambda对象。</span></span><br><span class="line"><span class="keyword">auto</span> lb = [](<span class="type">int</span> bh, <span class="type">const</span> string&amp; message) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn5 = <span class="built_in">bind</span>(lb, placeholders::_1, placeholders::_2);<span class="comment">// 绑定lamba函数。</span></span><br><span class="line"><span class="built_in">fn5</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用lamba函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的非静态成员函数。</span></span><br><span class="line">CC cc;</span><br><span class="line"><span class="comment">//function&lt;void(CC&amp;, int, const string&amp;)&gt; fn11 = bind(&amp;CC::show, placeholders::_1, placeholders::_2, placeholders::_3);// 绑定成员函数。</span></span><br><span class="line"><span class="comment">//fn11(cc, 5, &quot;我是一只傻傻鸟。&quot;);// 用function对象调用成员函数。</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn11 = <span class="built_in">bind</span>(&amp;CC::show,&amp;cc,placeholders::_1, placeholders::_2);<span class="comment">// 绑定成员函数。</span></span><br><span class="line"><span class="built_in">fn11</span>(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以被转换为函数指针的类对象。</span></span><br><span class="line">DD dd;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn12 = <span class="built_in">bind</span>(dd, placeholders::_1, placeholders::_2);<span class="comment">// 绑定可以被转换为函数指针的类。</span></span><br><span class="line"><span class="built_in">fn12</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);<span class="comment">// 用function对象调用它。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="可变函数和参数"><a href="#可变函数和参数" class="headerlink" title="可变函数和参数"></a>可变函数和参数</h3><ul><li>写一个函数，函数的参数是函数对象及参数，功能和thread类的构造函数相同。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>        </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show0</span><span class="params">()</span> </span>&#123;  <span class="comment">// 普通函数。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的，我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show1</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;  <span class="comment">// 普通函数。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CC</span><span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="comment">//std::bind函数接受一个可调用对象和一些参数，并返回一个函数对象，该函数对象绑定了可调用对象和参数。在这里，我们使用了完美转发（std::forward）来将传入的可调用对象和参数进行转发</span></span><br><span class="line"><span class="comment">//bind(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...)相当于接受传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">show</span><span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;...args)</span> -&gt; <span class="title">decltype</span><span class="params">(bind(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出表白前的准备工作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表白前的准备工作......\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用bind函数创建一个函数对象f，绑定了可调用对象fn和参数args...</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">bind</span>(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用函数对象f，执行绑定的可调用对象和参数</span></span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表白完成。\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 将函数对象f返回</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">show</span>(show0);</span><br><span class="line"><span class="built_in">show</span>(show1,<span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">CC cc;</span><br><span class="line"><span class="keyword">auto</span> f = <span class="built_in">show</span>(&amp;CC::show2,&amp;cc, <span class="number">3</span>,<span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread t1(show0);</span></span><br><span class="line"><span class="comment">//thread t2(show1,&quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"><span class="comment">//CC cc;</span></span><br><span class="line"><span class="comment">//thread t3(&amp;CC::show2,&amp;cc, 3,&quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"><span class="comment">//t1.join();</span></span><br><span class="line"><span class="comment">//t2.join();</span></span><br><span class="line"><span class="comment">//t3.join();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h3><ul><li>在消息队列和网络库的框架中，当接收到消息（报文）时，回调用户自定义的函数对象，把消息（报文）参数传给它，由它决定如何处理<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                      <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                      <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>                      <span class="comment">// deque容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>                      <span class="comment">// queue容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  <span class="comment">// 条件变量的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;  <span class="comment">// 处理业务的普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;处理数据：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BB</span> &#123;  <span class="comment">// 处理业务的类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;处理表白数据：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex m_mutex;                                    <span class="comment">// 互斥锁。</span></span><br><span class="line">    condition_variable m_cond;                  <span class="comment">// 条件变量。</span></span><br><span class="line">    queue&lt;string, deque&lt;string&gt;&gt; m_q;   <span class="comment">// 缓存队列，底层容器用deque。</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">const</span> string&amp;)&gt; m_callback;  <span class="comment">// 回调函数对象。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册回调函数，回调函数只有一个参数（消费者接收到的数据）。</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">callback</span><span class="params">(Fn &amp;&amp; fn, Args&amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">        m_callback = <span class="built_in">bind</span>(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)..., std::placeholders::_1);  <span class="comment">// 绑定回调函数。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incache</span><span class="params">(<span class="type">int</span> num)</span>     <span class="comment">// 生产数据，num指定数据的个数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   <span class="comment">// 申请加锁。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; num; ii++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> bh = <span class="number">1</span>;           <span class="comment">// 超女编号。</span></span><br><span class="line">            string message = <span class="built_in">to_string</span>(bh++) + <span class="string">&quot;号超女&quot;</span>;    <span class="comment">// 拼接出一个数据。</span></span><br><span class="line">            m_q.<span class="built_in">push</span>(message);     <span class="comment">// 把生产出来的数据入队。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//m_cond.notify_one();     // 唤醒一个被当前条件变量阻塞的线程。</span></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();          <span class="comment">// 唤醒全部被当前条件变量阻塞的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outcache</span><span class="params">()</span> </span>&#123;    <span class="comment">// 消费者线程任务函数。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 把互斥锁转换成unique_lock&lt;mutex&gt;，并申请加锁。</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1）把互斥锁解开；2）阻塞，等待被唤醒；3）给互斥锁加锁。</span></span><br><span class="line">            m_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !m_q.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据元素出队。</span></span><br><span class="line">            string message = m_q.<span class="built_in">front</span>();  m_q.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();      <span class="comment">// 手工解锁。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理出队的数据（把数据消费掉）。</span></span><br><span class="line">            <span class="keyword">if</span> (m_callback) <span class="built_in">m_callback</span>(message);  <span class="comment">// 回调函数，把收到的数据传给它。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA aa;</span><br><span class="line">    <span class="comment">// aa.callback(show);                   // 把普通函数show()注册为回调函数。</span></span><br><span class="line">    BB bb;</span><br><span class="line">    aa.<span class="built_in">callback</span>(&amp;BB::show, &amp;bb);    <span class="comment">// 把类成员函数BB::show()注册为回调函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t1。</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t2。</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t3。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));    <span class="comment">// 休眠2秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">2</span>);      <span class="comment">// 生产2个数据。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));    <span class="comment">// 休眠3秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">5</span>);      <span class="comment">// 生产5个数据。</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();   <span class="comment">// 回收子线程的资源。</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在ros中的回调函数"><a href="#在ros中的回调函数" class="headerlink" title="在ros中的回调函数"></a>在ros中的回调函数</h3><p>[[ROS#回调函数传入多个参数|回调函数传入多个参数]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类中的直接使用的回调函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uav_info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ros::Subscriber state_sub;<span class="comment">//订阅飞控中的当前无人机的状态，在后面的代码中使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立一个订阅消息体类型的变量，用于存储当前状态的信息</span></span><br><span class="line">    mavros_msgs::State current_state;</span><br><span class="line">    <span class="built_in">Uav_info</span>(ros::NodeHandle nh,std::string model_name)&#123;</span><br><span class="line">        state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;/&quot;</span> + model_name + <span class="string">&quot;/mavros/state&quot;</span>, <span class="number">10</span>, boost::<span class="built_in">bind</span>(&amp;Uav_info::state_cb, <span class="keyword">this</span>, _1, boost::<span class="built_in">ref</span>(current_state)));</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg, mavros_msgs::State&amp; current_state)</span> </span>&#123;</span><br><span class="line">        current_state = *msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类中的回调函数无其他参数写法</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pose_x=nh.<span class="built_in">subscribe</span>&lt;std_msgs::Float32&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/pose_x&quot;</span>, <span class="number">10</span>,</span><br><span class="line">                                                              boost::<span class="built_in">bind</span>(&amp;Uav_info::Pose_x_cb, <span class="keyword">this</span>, _1));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Uav_info::Pose_x_cb</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">const</span> std_msgs::Float32&gt;&amp; msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setpoint_pose.pose.position.x=msg-&gt;data;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Pub_pos</span>(<span class="keyword">this</span>-&gt;setpoint_pose.pose.position.x,<span class="keyword">this</span>-&gt;setpoint_pose.pose.position.y,<span class="keyword">this</span>-&gt;setpoint_pose.pose.position.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法（用于类内部）：</span></span><br><span class="line"><span class="comment">// state_sub = nh.subscribe&lt;mavros_msgs::State&gt;(&quot;/&quot; + model_name + &quot;/mavros/state&quot;, 10, </span></span><br><span class="line"><span class="comment">//             boost::bind(&amp;Uav_info::state_cb, this, _1, boost::ref(current_state)));</span></span><br><span class="line"><span class="comment">// 在这种写法中，使用了boost::bind将成员函数state_cb绑定到回调函数上，并使用this指针来指定对象。也就是说，回调函数中的第一个参数将是对象的指针this，用于访问类的成员变量和成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法（用于函数）：</span></span><br><span class="line"><span class="comment">// state_sub = nh.subscribe&lt;mavros_msgs::State&gt;(&quot;/&quot;+model_name+&quot;/mavros/state&quot;, 10, </span></span><br><span class="line"><span class="comment">//             boost::bind(&amp;Uav_info::state_cb, _1, boost::ref(this-&gt;current_state)));</span></span><br><span class="line"><span class="comment">// 在这种写法中，同样使用了boost::bind将成员函数state_cb绑定到回调函数上。但是这次没有使用this指针来指定对象，而是使用了_1占位符。这意味着回调函数的第一个参数将是接收到的消息指针，而不是对象的指针。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="取代虚函数"><a href="#取代虚函数" class="headerlink" title="取代虚函数"></a>取代虚函数</h2><ul><li>C++虚函数在执行过程中会跳转两次（先查找对象的函数表，再次通过该函数表中的地址找到真正的执行地址），这样的话，CPU会跳转两次，而普通函数只跳转一次。</li><li>CPU每跳转一次，预取指令要作废很多，所以效率会很低。（百度）</li><li>为了管理的方便（基类指针可指向派生类对象和自动析构派生类），保留类之间的继承关系。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hero</span>  &#123;<span class="comment">// 英雄基类</span></span><br><span class="line"><span class="comment">//virtual void show() &#123; cout &lt;&lt; &quot;英雄释放了技能。\n&quot;; &#125;</span></span><br><span class="line">function&lt;<span class="type">void</span>()&gt; m_callback;        <span class="comment">// 用于绑定子类的成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册子类成员函数，子类成员函数没有参数。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">m_callback = <span class="built_in">bind</span>(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">m_callback</span>(); &#125;   <span class="comment">// 调用子类的成员函数。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">XS</span> :<span class="keyword">public</span> Hero  &#123;<span class="comment">// 西施派生类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;西施释放了技能。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HX</span> :<span class="keyword">public</span> Hero  &#123;<span class="comment">// 韩信派生类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;韩信释放了技能。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 根据用户选择的英雄，施展技能。</span></span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>;     <span class="comment">// 英雄的id。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入英雄（1-西施；2-韩信。）：&quot;</span>;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基类指针，将指向派生类对象，用基类指针调用派生类的成员函数。</span></span><br><span class="line">Hero* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>) &#123;            <span class="comment">// 1-西施</span></span><br><span class="line">ptr = <span class="keyword">new</span> XS;</span><br><span class="line">ptr-&gt;<span class="built_in">callback</span>(&amp;XS::show, <span class="built_in">static_cast</span>&lt;XS*&gt;(ptr));  <span class="comment">// 注册子类成员函数。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;     <span class="comment">// 2-韩信</span></span><br><span class="line">ptr = <span class="keyword">new</span> HX;</span><br><span class="line">ptr-&gt;<span class="built_in">callback</span>(&amp;HX::show, <span class="built_in">static_cast</span>&lt;HX*&gt;(ptr));  <span class="comment">// 注册子类成员函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">ptr-&gt;<span class="built_in">show</span>();<span class="comment">// 调用子类的成员函数。</span></span><br><span class="line"><span class="keyword">delete</span> ptr;<span class="comment">// 释放派生类对象。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.c+++_智能指针_文件操作</title>
      <link href="/data.github.io/post/861cd88b.html"/>
      <url>/data.github.io/post/861cd88b.html</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul><li><strong>unique_ptr独享它指向的对象</strong>，也就是说，同时只有一个unique_ptr指向同一个对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁。</li><li>包含头文件：<code>#include &lt;memory&gt;</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer p) <span class="keyword">noexcept</span>;<span class="comment">// 不可用于转换函数。</span></span><br><span class="line">~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span>;    </span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="type">const</span>;            <span class="comment">// 重载*操作符。</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span>;  <span class="comment">// 重载-&gt;操作符。</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;   <span class="comment">// 禁用拷贝构造函数。</span></span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁用赋值函数。</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr &amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// 右值引用。</span></span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr &amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// 右值引用。</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pointer ptr;  <span class="comment">// 内置的指针。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一个模板参数T：指针指向的数据类型。</span></span><br><span class="line"><span class="comment">//第二个模板参数D：指定删除器，缺省用delete释放资源。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">测试类AA的定义：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function">unique_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>;     <span class="comment">// 分配内存并初始化。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">unique_ptr&lt;AA&gt; p0 = <span class="built_in">make_unique</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);   <span class="comment">// C++14标准。</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; pp1=<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;();         <span class="comment">// 数据类型为int。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pp2 = <span class="built_in">make_unique</span>&lt;AA&gt;();       <span class="comment">// 数据类型为AA，默认构造函数。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pp3 = <span class="built_in">make_unique</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 数据类型为AA，一个参数的构造函数。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pp4 = <span class="built_in">make_unique</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>); <span class="comment">// 数据类型为AA，两个参数的构造函数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法三（不推荐）：</span><br><span class="line">AA* p = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(p)</span></span>;                  <span class="comment">// 用已存在的地址初始化。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用方法</strong></p><ul><li>智能指针重载了<code>*和-&gt;</code>操作符，可以像使用指针一样使用unique_ptr</li><li>不支持普通的拷贝和赋值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AA* p = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">unique_ptr&lt;AA&gt; pu2 = p;              <span class="comment">// 错误，不能把普通指针直接赋给智能指针。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pu3 = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>); <span class="comment">// 错误，不能把普通指针直接赋给智能指针。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pu2 = pu1;           <span class="comment">// 错误，不能用其它unique_ptr拷贝构造。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pu3;</span><br><span class="line">pu3 = pu1;                            <span class="comment">// 错误，不能用=对unique_ptr进行赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>不要用同一个裸指针初始化多个unique_ptr对象。</li><li>get()方法返回裸指针。</li><li>不要用unique_ptr管理不是new分配的内存。</li></ul><p><strong>用于函数的参数</strong></p><ul><li>传引用（不能传值，因为unique_ptr没有拷贝构造函数）</li><li>裸指针</li></ul><p><strong>不支持指针的运算（+、-、++、–）</strong></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>1）将一个unique_ptr赋给另一个时，如果源unique_ptr是一个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器禁止这样做。一般用于函数的返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;AA&gt; p0;</span><br><span class="line">p0 = <span class="built_in">unique_ptr</span>&lt;AA&gt;(<span class="keyword">new</span> <span class="built_in">AA</span> (<span class="string">&quot;西瓜&quot;</span>));</span><br></pre></td></tr></table></figure><p>2）用nullptr给unique_ptr赋值将释放对象，空的<code>unique_ptr==nullptr。</code><br>3）release()释放对原始指针的控制权，将unique_ptr置为空，返回裸指针。（可用于把unique_ptr传递给子函数，子函数将负责释放对象）<br>4）std::move()可以转移对原始指针的控制权。（可用于把unique_ptr传递给子函数，子函数形参也是unique_ptr）<br>5）reset()释放对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T * _ptr= (T *) <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">pp.<span class="built_in">reset</span>();        <span class="comment">// 释放pp对象指向的资源对象。</span></span><br><span class="line">pp.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);  <span class="comment">// 释放pp对象指向的资源对象</span></span><br><span class="line">pp.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;bbb&quot;</span>));  <span class="comment">// 释放pp指向的资源对象，同时指向新的对象。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6）swap()交换两个unique_ptr的控制权：<code>void swap(unique_ptr&lt;T&gt; &amp;_Right);</code><br>7）unique_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样<br>8）unique_ptr不是绝对安全，如果程序中调用exit()退出，全局的unique_ptr可以自动释放，但局部的unique_ptr无法释放<br>9）unique_ptr提供了支持数组的具体化版本。：数组版本的unique_ptr，重载了操作符<code>[]</code>，操作符[]返回的是引用，可以作为左值使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_ptr&lt;int[]&gt; parr1(new int[3]);          // 不指定初始值。</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">parr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span> &#125;)</span></span>;  <span class="comment">// 指定初始值。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr1[0]=&quot;</span> &lt;&lt; parr1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr1[1]=&quot;</span> &lt;&lt; parr1[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr1[2]=&quot;</span> &lt;&lt; parr1[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;AA[]&gt; <span class="title">parr2</span><span class="params">(<span class="keyword">new</span> AA[<span class="number">3</span>]&#123;string(<span class="string">&quot;西施&quot;</span>), string(<span class="string">&quot;冰冰&quot;</span>), string(<span class="string">&quot;幂幂&quot;</span>)&#125;)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[0].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">0</span>].m_name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[1].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">1</span>].m_name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[2].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">2</span>].m_name &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func1()需要一个指针，但不对这个指针负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> AA* a)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func2()需要一个指针，并且会对这个指针负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(AA* a)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func3()需要一个unique_ptr，不会对这个unique_ptr负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">const</span> unique_ptr&lt;AA&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func4()需要一个unique_ptr，并且会对这个unique_ptr负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(unique_ptr&lt;AA&gt; a)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_ptr&lt;AA&gt; <span class="title">pu</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;开始调用函数。\n&quot;</span>;</span><br><span class="line"><span class="comment">//func1(pu.get());        // 函数func1()需要一个指针，但不对这个指针负责。</span></span><br><span class="line"><span class="comment">//func2(pu.release());  // 函数func2()需要一个指针，并且会对这个指针负责。</span></span><br><span class="line"><span class="comment">//func3(pu);                // 函数func3()需要一个unique_ptr，不会对这个unique_ptr负责。</span></span><br><span class="line"><span class="built_in">func4</span>(<span class="built_in">move</span>(pu));     <span class="comment">// 函数func4()需要一个unique_ptr，并且会对这个unique_ptr负责。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用函数完成。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pu == <span class="literal">nullptr</span>) cout &lt;&lt; <span class="string">&quot;pu是空指针。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//AA* parr1 = new AA[2];   // 普通指针数组。</span></span><br><span class="line"><span class="comment">////AA* parr1 = new AA[2]&#123; string(&quot;西施&quot;), string(&quot;冰冰&quot;) &#125;;</span></span><br><span class="line"><span class="comment">//parr1[0].m_name = &quot;西施1&quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;parr1[0].m_name=&quot; &lt;&lt; parr1[0].m_name &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//parr1[1].m_name = &quot;西施2&quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;parr1[1].m_name=&quot; &lt;&lt; parr1[1].m_name &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//delete [] parr1;</span></span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;AA[]&gt; <span class="title">parr2</span><span class="params">(<span class="keyword">new</span> AA[<span class="number">2</span>])</span></span>;   <span class="comment">// unique_ptr数组。</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;AA[]&gt; parr2(new AA[2]&#123; string(&quot;西施&quot;), string(&quot;冰冰&quot;) &#125;);</span></span><br><span class="line">parr2[<span class="number">0</span>].m_name = <span class="string">&quot;西施1&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[0].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">0</span>].m_name &lt;&lt; endl;</span><br><span class="line">parr2[<span class="number">1</span>].m_name = <span class="string">&quot;西施2&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[1].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">1</span>].m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><ul><li>[[6、数组、指针和字符串#智能指针|智能指针]]</li><li>shared_ptr共享它指向的对象，<strong>多个shared_ptr可以指向（关联）相同的对象</strong>，在内部采用计数机制来实现。</li><li>当新的shared_ptr与对象关联时，引用计数增加1。</li><li>当shared_ptr超出作用域时，引用计数减1。当引用计数变为0时，则表示没有任何shared_ptr与对象关联，则释放该对象</li></ul><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><strong>shared_ptr的构造函数也是explicit</strong>，但是，没有删除拷贝构造函数和赋值函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>;     <span class="comment">// 分配内存并初始化。</span></span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">shared_ptr&lt;AA&gt; p0 = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);  <span class="comment">// C++11标准，效率更高。</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; pp1=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();         <span class="comment">// 数据类型为int。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pp2 = <span class="built_in">make_shared</span>&lt;AA&gt;();       <span class="comment">// 数据类型为AA，默认构造函数。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pp3 = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 数据类型为AA，一个参数的构造函数。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pp4 = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>); <span class="comment">// 数据类型为AA，两个参数的构造函数。</span></span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">AA* p = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(p)</span></span>;                  <span class="comment">// 用已存在的地址初始化。</span></span><br><span class="line"></span><br><span class="line">方法四：</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>; </span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p1</span><span class="params">(p0)</span></span>;                 <span class="comment">// 用已存在的shared_ptr初始化，计数加1。</span></span><br><span class="line">shared_ptr&lt;AA&gt; p1=p0;                 <span class="comment">// 用已存在的shared_ptr初始化，计数加1。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>智能指针重载了<code>*和-&gt;</code>操作符，可以像使用指针一样使用shared_ptr</li><li>use_count()方法返回引用计数器的值</li><li>unique()方法，如果use_count()为1，返回true，否则返回false</li><li>shared_ptr支持赋值，左值的shared_ptr的计数器将减1，右值shared_ptr的计算器将加1</li><li>get()方法返回裸指针</li><li>不要用同一个裸指针初始化多个shared_ptr</li><li>不要用shared_ptr管理不是new分配的内存</li></ul><p><strong>用于函数的参数</strong>：与unique_ptr的原理相同。<br><strong>不支持指针的运算（+、-、++、–）</strong></p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>2）用nullptr给shared_ptr赋值将把计数减1，如果计数为0，将释放对象，空的<code>shared_ptr==nullptr</code><br>4）std::move()可以转移对原始指针的控制权。还可以将unique_ptr转移成shared_ptr。<br>5）reset()改变与资源的关联关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pp.<span class="built_in">reset</span>();        <span class="comment">// 解除与资源的关系，资源的引用计数减1。</span></span><br><span class="line">pp. <span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;bbb&quot;</span>));  <span class="comment">// 解除与资源的关系，资源的引用计数减1。关联新资源。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6）swap()交换两个shared_ptr的控制权：<code>void swap(shared_ptr&lt;T&gt; &amp;_Right);</code><br>7）shared_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样。<br>8）shared_ptr不是绝对安全，如果程序中调用exit()退出，全局的shared_ptr可以自动释放，但局部的shared_ptr无法释放。<br>9）shared_ptr提供了支持数组的具体化版本。<br>数组版本的shared_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用。<br>10）shared_ptr的线程安全性：</p><ul><li>shared_ptr的引用计数本身是线程安全（引用计数是原子操作）。</li><li>多个线程同时读同一个shared_ptr对象是线程安全的。</li><li>如果是多个线程对同一个shared_ptr对象进行读和写，则需要加锁。</li><li>多线程读写shared_ptr所指向的同一个对象，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，也需要加锁保护。</li></ul><p>11）如果unique_ptr能解决问题，就不要用shared_ptr。unique_ptr的效率更高，占用的资源更少。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">pa0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施a&quot;</span>))</span></span>;     <span class="comment">// 初始化资源西施a。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pa1 = pa0;                       <span class="comment">// 用已存在的shared_ptr拷贝构造，计数加1。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pa2 = pa0;                       <span class="comment">// 用已存在的shared_ptr拷贝构造，计数加1。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pa0.use_count()=&quot;</span> &lt;&lt; pa0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为3。</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">pb0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施b&quot;</span>))</span></span>;    <span class="comment">// 初始化资源西施b。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pb1 = pb0;                      <span class="comment">// 用已存在的shared_ptr拷贝构造，计数加1。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pb0.use_count()=&quot;</span> &lt;&lt; pb0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为2。</span></span><br><span class="line"></span><br><span class="line">pb1 = pa1;      <span class="comment">// 资源西施a的引用加1，资源西施b的引用减1。</span></span><br><span class="line">pb0 = pa1;      <span class="comment">// 资源西施a的引用加1，资源西施b的引用成了0，将被释放。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pa0.use_count()=&quot;</span> &lt;&lt; pa0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为5。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pb0.use_count()=&quot;</span> &lt;&lt; pb0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为5。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="智能指针的删除器"><a href="#智能指针的删除器" class="headerlink" title="智能指针的删除器"></a>智能指针的删除器</h2><ul><li>在默认情况下，智能指针过期的时候，用delete原始指针; 释放它管理的资源。</li><li>程序员可以自定义删除器，<strong>改变智能指针释放资源的行为</strong>。</li><li>删除器可以是全局函数、仿函数和Lambda表达式，形参为原始指针。</li><li>智能指针（如 std::unique_ptr、std::shared_ptr）默认使用 delete 操作符来释放资源。但在某些情况下，可能需要自定义资源的释放方式，例如使用 C 标准库的 free 函数释放动态分配的内存，或使用自定义的析构函数来释放资源。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletefunc</span><span class="params">(AA* a)</span> </span>&#123;    <span class="comment">// 删除器，普通函数。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义删除器（全局函数）。\n&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">deleteclass</span>               <span class="comment">// 删除器，仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(AA* a)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义删除器（仿函数）。\n&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> deleterlamb = [](AA* a) &#123;   <span class="comment">// 删除器，Lambda表达式。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义删除器（Lambda）。\n&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">pa1</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施a&quot;</span>), deletefunc)</span></span>;</span><br><span class="line"><span class="comment">//shared_ptr&lt;AA&gt; pa2(new AA(&quot;西施b&quot;), deleteclass());</span></span><br><span class="line"><span class="comment">//shared_ptr&lt;AA&gt; pa3(new AA(&quot;西施c&quot;), deleterlamb);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr&lt;AA,decltype(deletefunc)*&gt; pu1(new AA(&quot;西施1&quot;), deletefunc);</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;AA, void (*)(AA*)&gt; pu0(new AA(&quot;西施1&quot;), deletefunc);</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;AA, deleteclass&gt; pu2(new AA(&quot;西施2&quot;), deleteclass());</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;AA, decltype(deleterlamb)&gt; pu3(new AA(&quot;西施3&quot;), deleterlamb);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><strong>shared_ptr存在的问题</strong></p><ul><li>shared_ptr内部维护了一个共享的引用计数器，多个shared_ptr可以指向同一个资源。</li><li>如果出现了循环引用的情况，引用计数永远无法归0，资源不会被释放。</li></ul><p><strong>weak_ptr</strong></p><ul><li>weak_ptr 是为了配合shared_ptr而引入的，它指向一个由shared_ptr管理的资源但不影响资源的生命周期。也就是说，<strong>将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数</strong></li><li>不论是否有weak_ptr指向，如果最后一个指向资源的shared_ptr被销毁，资源就会被释放</li><li><strong>weak_ptr更像是shared_ptr的助手而不是智能指针</strong></li></ul><p><strong>使用weak_ptr</strong></p><ul><li>weak_ptr没有重载 -&gt;和 <code>*操作符</code>，不能直接访问资源。</li><li>有以下成员函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="keyword">operator</span>=();  <span class="comment">// 把shared_ptr或weak_ptr赋值给weak_ptr。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">expired</span>();     <span class="comment">// 判断它指资源是否已过期（已经被销毁）。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">lock</span>();        <span class="comment">// 返回shared_ptr，如果资源已过期，返回空的shared_ptr。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">reset</span>();       <span class="comment">// 将当前weak_ptr指针置为空。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">swap</span>();       <span class="comment">// 交换。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>weak_ptr不控制对象的生命周期，但是，它知道对象是否还活着</li><li>用lock()函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr</li><li>提升的行为（lock()）是线程安全的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">weak_ptr&lt;BB&gt; m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="built_in">BB</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数BB()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="built_in">BB</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数BB(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~BB(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">weak_ptr&lt;AA&gt; m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">shared_ptr&lt;AA&gt; pa = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施a&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">shared_ptr&lt;BB&gt; pb = <span class="built_in">make_shared</span>&lt;BB&gt;(<span class="string">&quot;西施b&quot;</span>);</span><br><span class="line"></span><br><span class="line">pa-&gt;m_p = pb;</span><br><span class="line">pb-&gt;m_p = pa;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;BB&gt; pp = pa-&gt;m_p.<span class="built_in">lock</span>();            <span class="comment">// 把weak_ptr提升为shared_ptr。</span></span><br><span class="line"><span class="keyword">if</span> (pp == <span class="literal">nullptr</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;语句块内部：pa-&gt;m_p已过期。\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;语句块内部：pp-&gt;m_name=&quot;</span> &lt;&lt; pp-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;BB&gt; pp = pa-&gt;m_p.<span class="built_in">lock</span>();            <span class="comment">// 把weak_ptr提升为shared_ptr。</span></span><br><span class="line"><span class="keyword">if</span> (pp == <span class="literal">nullptr</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;语句块外部：pa-&gt;m_p已过期。\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;语句块外部：pp-&gt;m_name=&quot;</span> &lt;&lt; pp-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="写入文本文件"><a href="#写入文本文件" class="headerlink" title="写入文本文件"></a>写入文本文件</h2><ul><li>文本文件一般以行的形式组织数</li><li>包含头文件：<code>#include &lt;fstream&gt;</code></li><li>类：<code>ofstream（output file stream）</code><br><strong>ofstream打开文件的模式（方式）</strong></li><li>对于ofstream，不管用哪种模式打开文件，如果文件不存在，都会创建文件。</li><li>ios::out                 缺省值：会截断文件内容。</li><li>ios::trunc  截断文件内容。（truncate）</li><li>ios::app   不截断文件内容，只在文件未尾追加文件。（append）<br>示例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ofstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line"><span class="comment">//  1）&quot;D:\data\txt\test.txt&quot;       // 错误。</span></span><br><span class="line"><span class="comment">//  2）R&quot;(D:\data\txt\test.txt)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line"><span class="comment">//  3）&quot;D:\\data\\txt\\test.txt&quot;   // 转义字符。</span></span><br><span class="line"><span class="comment">//  4）&quot;D:/tata/txt/test.txt&quot;        // 把斜线反着写。</span></span><br><span class="line"><span class="comment">//  5）&quot;/data/txt/test.txt&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">string filename = <span class="string">R&quot;(C:\Users\wjl\Desktop\code\test\test.txt)&quot;</span>;</span><br><span class="line"><span class="comment">//char    filename[] = R&quot;(D:\data\txt\test.txt)&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件输出流对象，打开文件，如果文件不存在，则创建它。</span></span><br><span class="line"><span class="comment">// ios::out     缺省值：会截断文件内容。</span></span><br><span class="line"><span class="comment">// ios::trunc  截断文件内容。（truncate）</span></span><br><span class="line"><span class="comment">// ios::app   不截断文件内容，只在文件未尾追加文件。（append）</span></span><br><span class="line"><span class="comment">//ofstream fout(filename);</span></span><br><span class="line"><span class="comment">//ofstream fout(filename, ios::out);</span></span><br><span class="line"><span class="comment">//ofstream fout(filename, ios::trunc);</span></span><br><span class="line"><span class="comment">//ofstream fout(filename, ios::app);</span></span><br><span class="line"></span><br><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(filename,ios::app);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line"><span class="comment">// 失败的原因主要有：1）目录不存在；2）磁盘空间已满；3）没有权限，Linux平台下很常见。</span></span><br><span class="line"><span class="keyword">if</span> (fout.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件中写入数据。</span></span><br><span class="line">fout &lt;&lt; <span class="string">&quot;西施|19|极漂亮\n&quot;</span>;</span><br><span class="line">fout &lt;&lt; <span class="string">&quot;冰冰|22|漂亮\n&quot;</span>;</span><br><span class="line">fout &lt;&lt; <span class="string">&quot;幂幂|25|一般\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">fout.<span class="built_in">close</span>();   <span class="comment">// 关闭文件，fout对象失效前会自动调用close()。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ul><li>包含头文件：<code>#include &lt;fstream&gt;</code></li><li>类：ifstream</li><li>ifstream打开文件的模式（方式）：</li><li>对于ifstream，如果文件不存在，则打开文件失败。</li><li>ios::in     缺省值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ifstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>     <span class="comment">// getline()函数需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line"><span class="comment">//  1）&quot;D:\data\txt\test.txt&quot;       // 错误。</span></span><br><span class="line"><span class="comment">//  2）R&quot;(D:\data\txt\test.txt)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line"><span class="comment">//  3）&quot;D:\\data\\txt\\test.txt&quot;   // 转义字符。</span></span><br><span class="line"><span class="comment">//  4）&quot;D:/tata/txt/test.txt&quot;        // 把斜线反着写。</span></span><br><span class="line"><span class="comment">//  5）&quot;/data/txt/test.txt&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">string filename = <span class="string">R&quot;(C:\Users\wjl\Desktop\code\test\test.txt)&quot;</span>;</span><br><span class="line"><span class="comment">//char    filename[] = R&quot;(D:\data\txt\test.txt)&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件输入流对象，打开文件，如果文件不存在，则打开文件失败。。</span></span><br><span class="line"><span class="comment">// ios::in     缺省值。</span></span><br><span class="line"><span class="comment">//ifstream fin(filename);</span></span><br><span class="line"><span class="comment">//ifstream fin(filename, ios::in);</span></span><br><span class="line"></span><br><span class="line">ifstream fin;</span><br><span class="line">fin.<span class="built_in">open</span>(filename,ios::in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line"><span class="comment">// 失败的原因主要有：1）目录不存在；2）文件不存在；3）没有权限，Linux平台下很常见。</span></span><br><span class="line"><span class="keyword">if</span> (fin.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 第一种方法。</span></span><br><span class="line"><span class="comment">//string buffer;  // 用于存放从文件中读取的内容。</span></span><br><span class="line"><span class="comment">//// 文本文件一般以行的方式组织数据。</span></span><br><span class="line"><span class="comment">//while (getline(fin, buffer))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 第二种方法。</span></span><br><span class="line"><span class="comment">//char buffer[16];   // 存放从文件中读取的内容。</span></span><br><span class="line"><span class="comment">//// 注意：如果采用ifstream.getline()，一定要保证缓冲区足够大。</span></span><br><span class="line"><span class="comment">//while (fin.getline(buffer, 15))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方法。</span></span><br><span class="line">string buffer;</span><br><span class="line"><span class="keyword">while</span> (fin &gt;&gt; buffer)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fin.<span class="built_in">close</span>();   <span class="comment">// 关闭文件，fin对象失效前会自动调用close()。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="写入二进制文件"><a href="#写入二进制文件" class="headerlink" title="写入二进制文件"></a>写入二进制文件</h2><ul><li>二进制文件以数据块的形式组织数据，把内存中的数据直接写入文件。</li><li>包含头文件：<code>#include &lt;fstream&gt;</code></li><li>类：ofstream（output file stream）</li><li>ofstream打开文件的模式（方式）：</li><li>对于ofstream，不管用哪种模式打开文件，如果文件不存在，都会创建文件。<ul><li>ios::out     缺省值：会截断文件内容。</li><li>ios::trunc  截断文件内容。（truncate）</li><li>ios::app   不截断文件内容，只在文件未尾追加文件。（append）</li><li>ios::binary   以二进制方式打开文件。</li></ul></li></ul><p><strong>操作文本文件和二进制文件的一些细节</strong><br>1）在windows平台下，文本文件的换行标志是<code>&quot;\r\n&quot;</code>。<br>2）在linux平台下，文本文件的换行标志是<code>&quot;\n&quot;</code>。<br>3）在windows平台下，如果以<strong>文本方式打开文件，写入数据的时候，系统会将”\n”转换成”\r\n”；读取数据的时候，系统会将”\r\n”转换成”\n”。 如果以二进制方式打开文件，写和读都不会进行转换</strong>。<br>4）在Linux平台下，以文本或二进制方式打开文件，系统不会做任何转换。<br>5）以文本方式读取文件的时候，遇到换行符停止，读入的内容中没有换行符；以二制方式读取文件的时候，遇到换行符不会停止，读入的内容中会包含换行符（换行符被视为数据）。</p><ul><li>在实际开发中，从兼容和语义考虑，一般：<ul><li>以<strong>文本模式</strong>打开文本文件，用<strong>行</strong>的方法操作它；</li><li>以<strong>二进制模式</strong>打开二进制文件，用<strong>数据块</strong>的方法操作它；</li><li>以二进制模式打开文本文件和二进制文件，用数据块的方法操作它，这种情况表示不关心数据的内容。（例如复制文件和传输文件）</li><li>不要以文本模式打开二进制文件，也不要用行的方法操作二进制文件，可能会破坏二进制数据文件的格式，也没有必要。（因为二进制文件中的某字节的取值可能是换行符，但它的意义并不是换行，可能是整数n个字节中的某个字节）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ofstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line"><span class="comment">//  1）&quot;D:\data\bin\test.dat&quot;       // 错误。</span></span><br><span class="line"><span class="comment">//  2）R&quot;(D:\data\bin\test.dat)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line"><span class="comment">//  3）&quot;D:\\data\\bin\\test.dat&quot;   // 转义字符。</span></span><br><span class="line"><span class="comment">//  4）&quot;D:/tata/bin/test.dat&quot;        // 把斜线反着写。</span></span><br><span class="line"><span class="comment">//  5）&quot;/data/bin/test.dat&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">string filename = <span class="string">R&quot;(D:\data\bin\test.dat)&quot;</span>;</span><br><span class="line"><span class="comment">//char    filename[] = R&quot;(D:\data\bin\test.dat)&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件输出流对象，打开文件，如果文件不存在，则创建它。</span></span><br><span class="line"><span class="comment">// ios::out     缺省值：会截断文件内容。</span></span><br><span class="line"><span class="comment">// ios::trunc  截断文件内容。（truncate）</span></span><br><span class="line"><span class="comment">// ios::app   不截断文件内容，只在文件未尾追加文件。（append）</span></span><br><span class="line"><span class="comment">// ios::binary   以二进制方式打开文件。</span></span><br><span class="line"><span class="comment">//ofstream fout(filename, ios::binary);</span></span><br><span class="line"><span class="comment">//ofstream fout(filename, ios::out | ios::binary);</span></span><br><span class="line"><span class="comment">//ofstream fout(filename, ios::trunc | ios::binary);</span></span><br><span class="line"><span class="comment">//ofstream fout(filename, ios::app | ios::binary);</span></span><br><span class="line"></span><br><span class="line">ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(filename, ios::app | ios::binary);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line"><span class="comment">// 失败的原因主要有：1）目录不存在；2）磁盘空间已满；3）没有权限，Linux平台下很常见。</span></span><br><span class="line"><span class="keyword">if</span> (fout.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件中写入数据。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> &#123;               <span class="comment">// 超女结构体。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">31</span>];         <span class="comment">// 姓名。</span></span><br><span class="line"><span class="type">int</span>    no;                    <span class="comment">// 编号。   </span></span><br><span class="line"><span class="type">char</span> memo[<span class="number">301</span>];      <span class="comment">// 备注。</span></span><br><span class="line"><span class="type">double</span> weight;         <span class="comment">// 体重。</span></span><br><span class="line">&#125;girl;</span><br><span class="line">girl = &#123; <span class="string">&quot;西施&quot;</span>,<span class="number">3</span>,<span class="string">&quot;中国历史第一美女。&quot;</span> ,<span class="number">45.8</span> &#125;;</span><br><span class="line">fout.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp; girl, <span class="built_in">sizeof</span>(st_girl));   <span class="comment">// 写入第一块数据。</span></span><br><span class="line">girl = &#123; <span class="string">&quot;冰冰&quot;</span>,<span class="number">8</span>,<span class="string">&quot;也是个大美女哦。&quot;</span>,<span class="number">55.2</span>&#125;;</span><br><span class="line">fout.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;girl, <span class="built_in">sizeof</span>(st_girl));     <span class="comment">// 写入第二块数据。</span></span><br><span class="line">fout.<span class="built_in">close</span>();   <span class="comment">// 关闭文件，fout对象失效前会自动调用close()。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><ul><li>包含头文件：<code>#include &lt;fstream&gt;</code></li><li>类：ifstream</li><li>ifstream打开文件的模式（方式）：</li><li>对于ifstream，如果文件不存在，则打开文件失败</li><li>ios::in     缺省值</li><li>ios::binary   以二进制方式打开文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ifstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line"><span class="comment">//  1）&quot;D:\data\bin\test.dat&quot;       // 错误。</span></span><br><span class="line"><span class="comment">//  2）R&quot;(D:\data\bin\test.dat)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line"><span class="comment">//  3）&quot;D:\\data\\bin\\test.dat&quot;   // 转义字符。</span></span><br><span class="line"><span class="comment">//  4）&quot;D:/tata/bin/test.dat&quot;        // 把斜线反着写。</span></span><br><span class="line"><span class="comment">//  5）&quot;/data/bin/test.dat&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">string filename = <span class="string">R&quot;(D:\data\bin\test.dat)&quot;</span>;</span><br><span class="line"><span class="comment">//char    filename[] = R&quot;(D:\data\bin\test.dat)&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件输入流对象，打开文件，如果文件不存在，则打开文件失败。。</span></span><br><span class="line"><span class="comment">// ios::in     缺省值。</span></span><br><span class="line"><span class="comment">// ios::binary   以二进制方式打开文件。</span></span><br><span class="line"><span class="comment">//ifstream fin(filename , ios::binary);</span></span><br><span class="line"><span class="comment">//ifstream fin(filename , ios::in | ios::binary);</span></span><br><span class="line"></span><br><span class="line">ifstream fin;</span><br><span class="line">fin.<span class="built_in">open</span>(filename, ios::in | ios::binary);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line"><span class="comment">// 失败的原因主要有：1）目录不存在；2）文件不存在；3）没有权限，Linux平台下很常见。</span></span><br><span class="line"><span class="keyword">if</span> (fin.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制文件以数据块（数据类型）的形式组织数据。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> &#123;               <span class="comment">// 超女结构体。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">31</span>];         <span class="comment">// 姓名。</span></span><br><span class="line"><span class="type">int</span>    no;                    <span class="comment">// 编号。   </span></span><br><span class="line"><span class="type">char</span> memo[<span class="number">301</span>];      <span class="comment">// 备注。</span></span><br><span class="line"><span class="type">double</span> weight;         <span class="comment">// 体重。</span></span><br><span class="line">&#125;girl;</span><br><span class="line"><span class="keyword">while</span> (fin.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;girl, <span class="built_in">sizeof</span>(girl)))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; girl.name &lt;&lt; <span class="string">&quot;，no=&quot;</span> &lt;&lt; girl.no &lt;&lt; </span><br><span class="line"><span class="string">&quot;，memo=&quot;</span> &lt;&lt; girl.memo &lt;&lt; <span class="string">&quot;，weight=&quot;</span> &lt;&lt; girl.weight &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">fin.<span class="built_in">close</span>();   <span class="comment">// 关闭文件，fin对象失效前会自动调用close()。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="随机存取"><a href="#随机存取" class="headerlink" title="随机存取"></a>随机存取</h2><h3 id="fstream类"><a href="#fstream类" class="headerlink" title="fstream类"></a>fstream类</h3><ul><li>fstream类既可以读文本&#x2F;二进制文件，也可以写文本&#x2F;二进制文件。</li><li>fstream类的缺省模式是ios::in | ios::out，如果文件不存在，则创建文件；但是，不会清空文件原有的内容。</li></ul><p><strong>普遍的做法是</strong></p><ul><li>如果只想写入数据，用ofstream；如果只想读取数据，用ifstream；如果想写和读数据，用fstream，这种情况不多见。不同的类体现不同的语义。</li><li>在Linux平台下，文件的写和读有严格的权限控制。（需要的权限越少越好）</li></ul><h3 id="文件的位置指针"><a href="#文件的位置指针" class="headerlink" title="文件的位置指针"></a>文件的位置指针</h3><ul><li>对文件进行读&#x2F;写操作时，文件的位置指针指向当前文件读&#x2F;写的位置。</li><li>很多资料用“文件读指针的位置”和“文件写指针的位置”，容易误导人。不管用哪个类操作文件，文件的位置指针只有一个。</li></ul><ol><li><strong>获取文件位置指针</strong></li></ol><ul><li>ofstream类的成员函数是tellp()；ifstream类的成员函数是tellg()；fstream类两个都有，效果相同。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::streampos <span class="title">tellp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::streampos <span class="title">tellg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>移动文件位置指针</strong></li></ol><ul><li>ofstream类的函数是seekp()；ifstream类的函数是seekg()；fstream类两个都有，效果相同<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="function">std::istream &amp; <span class="title">seekg</span><span class="params">(std::streampos _Pos)</span></span>;  </span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">128</span>);   <span class="comment">// 把文件指针移到第128字节。</span></span><br><span class="line">fin.<span class="built_in">seekp</span>(<span class="number">128</span>);   <span class="comment">// 把文件指针移到第128字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(ios::beg) <span class="comment">// 把文件指针移动文件的开始。</span></span><br><span class="line">fin.<span class="built_in">seekp</span>(ios::end) <span class="comment">// 把文件指针移动文件的结尾。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="function">std::istream &amp; <span class="title">seekg</span><span class="params">(std::streamoff _Off,std::ios::seekdir _Way)</span></span>;</span><br><span class="line">在ios中定义的枚举类型：</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">seek_dir</span> &#123;beg, cur, end&#125;;  <span class="comment">// beg-文件的起始位置；cur-文件的当前位置；end-文件的结尾位置。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">30</span>, ios::beg);    <span class="comment">// 从文件开始的位置往后移30字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">-5</span>, ios::cur);     <span class="comment">// 从当前位置往前移5字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>( <span class="number">8</span>, ios::cur);     <span class="comment">// 从当前位置往后移8字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">-10</span>, ios::end);   <span class="comment">// 从文件结尾的位置往前移10字节。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="随机存取-1"><a href="#随机存取-1" class="headerlink" title="随机存取"></a>随机存取</h3><ul><li>随机存取是指直接移动文件的位置指针，在指定位置读取&#x2F;写入数据<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// fstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string filename = <span class="string">R&quot;(C:\Users\wjl\Desktop\code\test\test.txt)&quot;</span>;</span><br><span class="line"></span><br><span class="line">fstream fs;</span><br><span class="line">fs.<span class="built_in">open</span>(filename, ios::in | ios::out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fs.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs.<span class="built_in">seekg</span>(<span class="number">26</span>);    <span class="comment">// 把文件位置指针移动到第26字节处。</span></span><br><span class="line">fs &lt;&lt; <span class="string">&quot;我是一只傻傻的小菜鸟。\n&quot;</span>; </span><br><span class="line"><span class="comment">/*string buffer; </span></span><br><span class="line"><span class="comment">while (fs &gt;&gt; buffer)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">fs.<span class="built_in">close</span>();   <span class="comment">// 关闭文件，fs对象失效前会自动调用close()。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="打开文件的模式"><a href="#打开文件的模式" class="headerlink" title="打开文件的模式"></a>打开文件的模式</h4><p>如果文件不存在，各种模式都会创建文件。</p><ul><li>ios::out                会截断文件；可以用seekp()移动文件指针。</li><li>ios:trunc       会截断文件；可以用seekp()移动文件指针。</li><li>ios::app         不会截断文件；文件指针始终在文件未尾，不能用seekp()移动文件指针。</li><li>ios::ate    打开文件时文件指针指向文件末尾，但是，可以在文件中的任何地方写数据。</li><li>ios::in        打开文件进行读操作，即读取文件中的数据。</li><li>ios::binary       打开文件为二进制文件，否则为文本文件。</li><li>注：ate是at end的缩写，trunc是truncate（截断）的缩写，app是append（追加）的缩写。</li></ul><h2 id="缓冲区及流状态"><a href="#缓冲区及流状态" class="headerlink" title="缓冲区及流状态"></a>缓冲区及流状态</h2><h3 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h3><ul><li>文件缓冲区（缓存）是系统预留的内存空间，用于存放输入或输出的数据。</li><li>根据输出和输入流，分为输出缓冲区和输入缓冲区。</li><li>注意，在C++中，<strong>每打开一个文件，系统就会为它分配缓冲区</strong>。不同的流，缓冲区是独立的。</li><li>程序员不用关心输入缓冲区，只关心输出缓冲区就行了。</li><li>在缺省模式下，输出缓冲区中的数据满了才把数据写入磁盘，但是，这种模式不一定能满足业务的需求。</li></ul><p><strong>输出缓冲区的操作</strong></p><ul><li>flush()成员函数：刷新缓冲区，把缓冲区中的内容写入磁盘文件</li><li>endl：换行，然后刷新缓冲区</li><li>unitbuf：fout &lt;&lt; unitbuf;<ul><li>设置fout输出流，在每次操作之后自动刷新缓冲区。</li></ul></li><li>nounitbuf：fout &lt;&lt; nounitbuf;<ul><li>设置fout输出流，让fout回到缺省的缓冲方式。</li></ul></li></ul><h3 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h3><ul><li>流状态有三个：<strong>eofbit、badbit和failbit</strong>，取值：1-设置；或0-清除。</li><li>当三个流状成都为0时，表示一切顺利，good()成员函数返回true。</li><li>eofbit<ul><li>当输入流操作到达文件未尾时，将设置eofbit。</li><li>eof()成员函数检查流是否设置了eofbit。</li></ul></li><li>badbit<ul><li>无法诊断的失败破坏流时，将设置badbit。（例如：对输入流进行写入；磁盘没有剩余空间）。</li><li>bad()成员函数检查流是否设置了badbit。</li></ul></li><li>failbit<ul><li>当输入流操作未能读取预期的字符时，将设置failbit（非致命错误，可挽回，一般是软件错误，例如：想读取一个整数，但内容是一个字符串；文件到了未尾）I&#x2F;O失败也可能设置failbit。</li><li>fail()成员函数检查流是否设置了failbit。</li></ul></li><li>clear()成员函数清理流状态。</li><li>setstate()成员函数重置流状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>          <span class="comment">// ofstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;C:/Users/wjl/Desktop/code/test/test.txt&quot;</span>)</span></span>;   <span class="comment">// 打开文件。</span></span><br><span class="line">  fout &lt;&lt; unitbuf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">1000</span>; ii++)  <span class="comment">// 循环1000次。</span></span><br><span class="line">  &#123;</span><br><span class="line">    fout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;，我是一只傻傻傻傻傻傻傻傻傻傻傻傻傻傻的鸟。\n&quot;</span>;</span><br><span class="line">    <span class="comment">//fout.flush();      // 刷新缓冲区。</span></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100000</span>);    <span class="comment">// 睡眠十分之一秒。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout.<span class="built_in">close</span>();  <span class="comment">// 关闭文件。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="C-异常"><a href="#C-异常" class="headerlink" title="C++异常"></a>C++异常</h1><h2 id="异常的语法"><a href="#异常的语法" class="headerlink" title="异常的语法"></a>异常的语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）捕获全部的异常</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的代码。</span></span><br><span class="line">        <span class="comment">// throw 异常对象;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不管什么异常，都在这里统一处理。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2</span>）捕获指定的异常</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的代码。</span></span><br><span class="line">        <span class="comment">// throw 异常对象;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception1 e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发生exception1异常时的处理代码。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception2 e)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 发生exception2异常时的处理代码。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在try语句块中，如果没有发生异常，执行完try语句块中的代码后，将继续执行try语句块之后的代码；如果发生了异常，用throw抛出异常对象，异常对象的类型决定了应该匹配到哪个catch语句块，如果没有匹配到catch语句块，程序将调用abort()函数中止。</li><li>如果try语句块中用throw抛出异常对象，并且匹配到了catch语句块，执行完catch语句块中的代码后，将继续执行catch语句块之后的代码，不会回到try语句块中。</li><li>如果程序中的异常没有被捕获，程序将异常中止。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的代码。</span></span><br><span class="line">        <span class="type">int</span> ii = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你是一只什么鸟？（1-傻傻鸟；2-小小鸟）&quot;</span>;</span><br><span class="line">        cin &gt;&gt; ii;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ii==<span class="number">1</span>)  <span class="keyword">throw</span> <span class="string">&quot;不好，有人说我是一只傻傻鸟。&quot;</span>;            <span class="comment">// throw抛出const char *类型的异常。</span></span><br><span class="line">        <span class="keyword">if</span> (ii==<span class="number">2</span>)  <span class="keyword">throw</span> ii;                                                             <span class="comment">// throw抛出int类型的异常。</span></span><br><span class="line">        <span class="keyword">if</span> (ii==<span class="number">3</span>)  <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;不好，有人说我是一只傻傻鸟。&quot;</span>); <span class="comment">// throw抛出string类型的异常。</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我不是一只傻傻鸟，哦耶。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> ii)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;异常的类型是int=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* ss)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;异常的类型是const char *=&quot;</span> &lt;&lt; ss &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (string str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;异常的类型是string=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//catch (...)  // 不管什么异常，都在这里处理。</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;捕获到异常，具体没管是什么异常。\n&quot;;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序继续运行......\n&quot;</span>;   <span class="comment">// 执行完try ... catch ...后，将继续执行程序中其它的代码。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h3><ul><li>异常被抛出后，从进入try语句块开始，到异常被抛出之前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。</li><li>也就是在执行throw前，在try执行期间构造的所有对象被自动析构后，才会进入catch匹配。</li><li>在堆上构造的对象肿么办？</li></ul><h2 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++<span class="number">98</span>标准提出了异常规范，目的是为了让使用者知道函数可能会引发哪些异常</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A, B, C)</span></span>;     <span class="comment">// 表示该函数可能会抛出A、B、C类型的异常。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;           <span class="comment">// 表示该函数不会抛出异常。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>;                  <span class="comment">// 该函数不符合C++98的异常规范。</span></span><br><span class="line"><span class="comment">//C++11标准弃用了异常规范，使用新增的关键字noexcept指出函数不会引发异常。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;         <span class="comment">// 该函数不会抛出异常。</span></span><br></pre></td></tr></table></figure><ul><li>在实际开发中，大部分程序员懒得在函数后面加noexcept，弃用异常已是共识，没必要多此一举。</li><li>关键字noexcept也可以用作运算符，判断表达试（操作数）是否可能引发异常；如果表达式可能引发异常，则返回false，否则返回true。</li></ul><h2 id="C-标准库异常"><a href="#C-标准库异常" class="headerlink" title="C++标准库异常"></a>C++标准库异常</h2><p>![[Pasted image 20231225193731.png]]</p><h3 id="重点关注的异常"><a href="#重点关注的异常" class="headerlink" title="重点关注的异常"></a>重点关注的异常</h3><p>1）std::bad_alloc</p><ul><li>如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。<br>2）std::bad_cast</li><li>dynamic_cast可以用于引用，但是，C++没有与空指针对应的引用值，如果转换请求不正确，会出现std::bad_cast异常。<br>3）std::bad_typeid</li><li>假设有表达式<code>typeid(*ptr)</code>，当ptr是空指针时，如果ptr是多态的类型，将引发std::bad_typeid异常。</li></ul><h1 id="C-断言"><a href="#C-断言" class="headerlink" title="C++断言"></a>C++断言</h1><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><ul><li>断言（assertion）是一种常用的编程手段，用于排除程序中不应该出现的逻辑错误。</li><li>使用断言需要包含头文件<code>&lt;cassert&gt;</code>或<code>&lt;assert.h&gt;</code>，头文件中提供了带参数的宏assert，用于程序在运行时进行断言。</li><li>语法：<strong>assert(表达式);</strong></li><li><strong>断言就是判断(表达式)的值，如果为0（false），程序将调用abort()函数中止，如果为非0（true），程序继续执行</strong>。</li><li>断言可以提高程序的可读性，帮助程序员定位违反了某些前提条件的错误。<br><strong>注意</strong></li><li>断言用于处理程序中不应该发生的错误，而非逻辑上可能会发生的错误。</li><li>不要把需要执行的代码放到断言的表达式中。</li><li>断言的代码一般放在函数&#x2F;成员函数的第一行，表达式多为函数的形参。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span>              <span class="comment">// 断言assert宏需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">copydata</span><span class="params">(<span class="type">void</span> *ptr1,<span class="type">void</span> *ptr2)</span>   <span class="comment">// 把ptr2中的数据复制到ptr1中。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(ptr1&amp;&amp;ptr2);  <span class="comment">// 断言ptr1和ptr2都不会为空。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;继续执行复制数据的代码......\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ii=<span class="number">0</span>,jj=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">copydata</span>(&amp;ii, &amp;jj);  <span class="comment">// 把ptr2中的数据复制到ptr1中。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="C-11静态断言"><a href="#C-11静态断言" class="headerlink" title="C++11静态断言"></a>C++11静态断言</h2><ul><li>assert宏是运行时断言，在程序运行的时候才能起作用。</li><li>C++11新增了静态断言static_assert，用于在编译时检查源代码。</li><li>使用静态断言不需要包含头文件。</li><li>语法：<strong>static_assert(常量表达式,提示信息);</strong></li><li>注意：static_assert的第一个参数是常量表达式。而assert的表达式既可以是常量，也可以是变量</li></ul><h1 id="C-新标准"><a href="#C-新标准" class="headerlink" title="C++新标准"></a>C++新标准</h1><p><strong>long long类型</strong></p><ul><li>新增了类型long long和unsigned long long，以支持64位（或更宽）的整型。</li><li>在VS中，int和long都是4字节，long long是8字节。</li><li>在Linux中，int是4字节，long和long long是8字节。</li></ul><h2 id="统一的初始化（列表）"><a href="#统一的初始化（列表）" class="headerlink" title="统一的初始化（列表）"></a>统一的初始化（列表）</h2><p>C++11丰富了大括号的使用范围，用大括号括起来的列表（统一的初始化列表）可以用于所有内置类型和用户自定义类型。使用统一的初始化列表时，可以添加等号（&#x3D;），也可以不添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span> y&#123;<span class="number">2.75</span>&#125;;</span><br><span class="line"><span class="type">short</span> quar[<span class="number">5</span>]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一的初始化列表也可以用于new表达式中：</span></span><br><span class="line"><span class="type">int</span> *ar=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象时，也可以使用大括号（而不是圆括号）来调用构造函数：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_bh;</span><br><span class="line">    string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>(<span class="type">int</span> bh,string name) : <span class="built_in">m_bh</span>(bh),<span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Girl <span class="title">g1</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;西施&quot;</span>)</span></span>;    <span class="comment">// C++98的风格。</span></span><br><span class="line">Girl g2=&#123;<span class="number">5</span>, <span class="string">&quot;冰冰&quot;</span>&#125;;  <span class="comment">// C++11的风格。</span></span><br><span class="line">Girl g3&#123;<span class="number">8</span>, <span class="string">&quot;幂幂&quot;</span>&#125;;    <span class="comment">// C++11的风格。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//STL容器提供了将initializer_list模板类作为参数的构造函数：</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// 把v1初始化为10个元素。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;   <span class="comment">// 把v2初始化为1个元素，这个元素的值是10。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;   <span class="comment">// 把v3初始化为3个元素，值分别是3、5、8。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="强类型枚举（枚举类）"><a href="#强类型枚举（枚举类）" class="headerlink" title="强类型枚举（枚举类）"></a>强类型枚举（枚举类）</h2><ul><li>传统的C++枚举提供了一种创建常量的方式，但类型检查比较低级。还有，如果在同一作用域内定义的两个枚举，它们的成员不能同名。</li><li>针对枚举的缺陷，C++11 标准引入了枚举类，又称强类型枚举。</li><li>声明强类型枚举非常简单，只需要在enum后加上关键字 class。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">e1</span>&#123; red, green &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e2</span> &#123; red, green, blue &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e3</span> &#123; red, green, blue, yellow &#125;;</span><br><span class="line"><span class="comment">//使用强类型枚举时，要在枚举成员名前面加枚举名和::，以免发生名称冲突，如：e2::red，e3::blue</span></span><br><span class="line"><span class="comment">//强类型枚举默认的类型为int，也可以显式地指定类型，具体做法是在枚举名后面加上:type，type可以是除wchar_t以外的任何整型。</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e2</span>:<span class="type">char</span> &#123; red, green, blue &#125;;</span><br></pre></td></tr></table></figure><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul><li>final关键字用于<strong>限制某个类不能被继承，或者某个虚函数不能被重写</strong>。</li><li>final关键字放在类名或虚函数名的后面。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AA class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">public</span> AA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span>    <span class="comment">// 如果有其它类继承BB，test()方法将不允许重写。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BB class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> : <span class="keyword">public</span> BB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span>  <span class="comment">// 错误，BB类中的test()后面有final，不允许重写。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CC class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="override关键字"><a href="#override关键字" class="headerlink" title="override关键字"></a>override关键字</h2><ul><li>在<strong>派生类中，把override放在成员函数的后面，表示重写基类的虚函数</strong>，提高代码的可读性。</li><li>在派生类中，如果某成员函数不是重写基类的虚函数，随意的加上override关键字，编译器会报错。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AA class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">public</span> AA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BB class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="常量表达式constexpr关键字"><a href="#常量表达式constexpr关键字" class="headerlink" title="常量表达式constexpr关键字"></a>常量表达式constexpr关键字</h2><p>const关键字从功能上来说有双重语义：<strong>只读变量和修饰常量</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> len1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// len1是只读变量，不是常量。</span></span><br><span class="line">    <span class="type">int</span> array1[len1]=&#123;<span class="number">0</span>&#125;;        <span class="comment">// VS会报错，Linux平台的数组长度支持变量，不会报错。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len2 = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> array2[len2]=&#123;<span class="number">0</span>&#125;;      <span class="comment">// 正确，len2是常量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C++11标准为了解决const关键字的双重语义问题，保留了const表示“只读”的语义，而将<strong>“常量”的语义划分给了新添加的constexpr关键字</strong>。</li><li>所以，C++11 标准中，建议将const和constexpr的功能区分开，<strong>表达“只读”语义的场景用const，表达“常量”语义的场景用constexpr。</strong></li></ul><h2 id="默认函数控制-default与-delete"><a href="#默认函数控制-default与-delete" class="headerlink" title="默认函数控制&#x3D;default与&#x3D;delete"></a>默认函数控制&#x3D;default与&#x3D;delete</h2><ul><li>在C++中自定义的类，编译器会默认生成一些成员函数：</li><li>无参构造函数</li><li>拷贝构造函数</li><li>拷贝赋值函数</li><li>移动构造函数</li><li>移动赋值函数</li><li>析构函数</li><li>&#x3D;default表示启用默认函数。</li><li>&#x3D;delete表示禁用默认函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_bh = <span class="number">20</span>;                  <span class="comment">// 年龄。</span></span><br><span class="line">    string m_name = <span class="string">&quot;美女&quot;</span>;  <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">char</span> m_xb = <span class="string">&#x27;X&#x27;</span>;               <span class="comment">// 性别。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>() = <span class="keyword">default</span>;                          <span class="comment">// 启用默认构造函数。</span></span><br><span class="line">    <span class="built_in">Girl</span>(<span class="type">int</span> bh, string name) : <span class="built_in">m_bh</span>(bh), <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="built_in">Girl</span>(<span class="type">const</span> Girl&amp; g) = <span class="keyword">delete</span>;      <span class="comment">// 删除拷贝构造函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;bh=&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;,m_name=&quot;</span> &lt;&lt; m_name &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Girl g1;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// Girl g2 = g1;            // 错误，拷贝构造函数已删除。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="委托构造和继承构造"><a href="#委托构造和继承构造" class="headerlink" title="委托构造和继承构造"></a>委托构造和继承构造</h2><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><ul><li>在实际的开发中，为了满足不同的需求，一个类可能会重载多个构造函数。多个构造函数之间可能会有重复的代码。例如变量初始化，如果在每个构造函数中都写一遍，这样代码会显得臃肿。</li><li><strong>委托构造就是在一个构造函数的初始化列表中调用另一个构造函数</strong>。</li><li>不要生成环状的构造过程。</li><li>一旦使用委托构造，就不能在初始化列表中初始化其它的成员变量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>      m_a;</span><br><span class="line">    <span class="type">int</span>      m_b;</span><br><span class="line">    <span class="type">double</span>   m_c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有一个参数的构造函数，初始化m_c</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">double</span> c) &#123;</span><br><span class="line">        m_c = c + <span class="number">3</span>;     <span class="comment">// 初始化m_c</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; AA(double c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有两个参数的构造函数，初始化m_a和m_b</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        m_a = a + <span class="number">1</span>;     <span class="comment">// 初始化m_a</span></span><br><span class="line">        m_b = b + <span class="number">2</span>;    <span class="comment">// 初始化m_b</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; AA(int a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数委托AA(int a, int b)初始化m_a和m_b</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">const</span> string&amp; str) : <span class="built_in">AA</span>(a, b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_a=&quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot;,m_b=&quot;</span> &lt;&lt; m_b &lt;&lt; <span class="string">&quot;,str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数委托AA(double c)初始化m_c</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">double</span> c, <span class="type">const</span> string&amp; str) : <span class="built_in">AA</span>(c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_c=&quot;</span> &lt;&lt; m_c &lt;&lt; <span class="string">&quot;,str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AA <span class="title">a1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">AA <span class="title">a2</span><span class="params">(<span class="number">3.8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><ul><li>在C++11之前，派生类如果要使用基类的构造函数，可以在派生类构造函数的初始化列表中指定</li><li>C++11推出了继承构造（Inheriting Constructor），<strong>在派生类中使用using来声明继承基类的构造函数</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>       <span class="comment">// 基类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>      m_a;</span><br><span class="line">    <span class="type">int</span>      m_b;</span><br><span class="line">    <span class="comment">// 有一个参数的构造函数，初始化m_a</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a) : <span class="built_in">m_a</span>(a) &#123; cout &lt;&lt; <span class="string">&quot; AA(int a)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 有两个参数的构造函数，初始化m_a和m_b</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b) &#123; cout &lt;&lt; <span class="string">&quot; AA(int a, int b)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> :<span class="keyword">public</span> AA       <span class="comment">// 派生类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span>   m_c;</span><br><span class="line">    <span class="keyword">using</span> AA::AA;     <span class="comment">// 使用基类的构造函数。</span></span><br><span class="line">    <span class="comment">// 有三个参数的构造函数，调用A(a,b)初始化m_a和m_b，同时初始化m_c</span></span><br><span class="line">    <span class="built_in">BB</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> c) : <span class="built_in">AA</span>(a, b), <span class="built_in">m_c</span>(c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; BB(int a, int b, double c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;m_a=&quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot;,m_b=&quot;</span> &lt;&lt; m_b &lt;&lt; <span class="string">&quot;,m_c=&quot;</span> &lt;&lt; m_c &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将使用基类有一个参数的构造函数，初始化m_a</span></span><br><span class="line">    <span class="function">BB <span class="title">b1</span><span class="params">(<span class="number">10</span>)</span></span>;       </span><br><span class="line">    b1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用基类有两个参数的构造函数，初始化m_a和m_b</span></span><br><span class="line">    <span class="function">BB <span class="title">b2</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;  </span><br><span class="line">    b2.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用派生类自己有三个参数的构造函数，调用A(a,b)初始化m_a和m_b，同时初始化m_c</span></span><br><span class="line">    <span class="function">BB <span class="title">b3</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">10.58</span>)</span></span>;  </span><br><span class="line">    b3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><ul><li>lambda函数是C++11标准新增的语法糖，<strong>也称为lambda表达式或匿名函数</strong>。</li><li>lambda函数的特点是：距离近、简洁、高效和功能强大</li><li><strong>捕获列表用于获取外部变量的值或引用</strong>，<strong>参数列表用于传递参数</strong>，返回类型指定函数返回值的类型，函数体定义Lambda函数的具体逻辑。</li><li>示例：<code>[](const int&amp; no) -&gt; void &#123; cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; no &lt;&lt; &quot;号：我是一只傻傻鸟。\n&quot;; &#125;;</code></li><li>语法：![[Pasted image 20231225201706.png]]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表白函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zsshow</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; no)</span>  </span>&#123;  </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表白仿函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">czs</span>   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; no)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span> &#125;;   <span class="comment">// 存放超女编号的容器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数是普通函数。</span></span><br><span class="line">for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), zsshow);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数是仿函数。</span></span><br><span class="line">for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), <span class="built_in">czs</span>());       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数是lambda表达式。</span></span><br><span class="line">for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), </span><br><span class="line">[](<span class="type">const</span> <span class="type">int</span>&amp; no) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>参数列表</strong></li><li>参数列表是可选的，类似普通函数的参数列表，如果没有参数列表，()可以省略不写。</li><li>与普通函数的不同：<ul><li>lambda函数不能有默认参数。</li><li>所有参数必须有参数名。</li><li>不支持可变参数。</li></ul></li></ul><p><strong>返回类型</strong></p><ul><li>用后置的方法书写返回类型，类似于普通函数的返回类型，如果不写返回类型，编译器会根据函数体中的代码推断出来</li><li>如果有返回类型，建议显式的指定，自动推断可能与预期不一致</li></ul><p><strong>函数体</strong>：类似于普通函数的函数体。<br><strong>捕获列表</strong></p><ul><li>通过捕获列表，<strong>lambda函数可以访问父作用域中的非静态局部变量</strong>（静态局部变量可以直接访问，不能访问全局变量）。</li><li>捕获列表书写在<code>[]</code>中，与函数参数的传递类似，捕获方式可以是值和引用。</li><li>以下列出了不同的捕获列表的方式。<br>![[Pasted image 20231225202050.png]]<br><strong>值捕获</strong></li><li>与传递参数类似，采用值捕获的前提是变量可以拷贝。</li><li>与传递参数不同，变量的值是在lambda函数创建时拷贝，而不是调用时拷贝</li><li>由于被捕获的值是在lambda函数创建时拷贝，因此在随后对其修改不会影响到lambda内部的值</li><li>默认情况下，如果以传值方式捕获变量，则在lambda函数中不能修改变量的值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [ v1 ]  &#123; <span class="keyword">return</span> v1; &#125;;<span class="comment">// 使用了值捕获，将v1拷贝到名为f的可调用对象。</span></span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();    <span class="comment">// j为42，f保存了我们创建它是v1的拷贝。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>引用捕获</strong></li><li>和函数引用参数一样，引用变量的值在lambda函数体中改变时，将影响被引用的对象</li><li>如果采用引用方式捕获变量，就必须保证被引用的对象在lambda执行的时候是存在的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [ &amp;v1 ]  &#123; <span class="keyword">return</span> v1; &#125;; <span class="comment">// 引用捕获，将v1拷贝到名为f的可调用对象。</span></span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">// j为0。</span></span><br></pre></td></tr></table></figure><strong>隐式捕获</strong></li><li>除了显式列出我们希望使用的父作域的变量之外，还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。</li><li>隐式捕获有两种方式，分别是<code>[=]和[&amp;]</code>。<code>[=]</code>表示以值捕获的方式捕获外部变量，<code>[&amp;]</code>表示以引用捕获的方式捕获外部变量。</li></ul><p><strong>混合方式捕获</strong></p><ul><li>lambda函数还支持混合方式捕获，即同时使用显式捕获和隐式捕获</li><li>混合捕获时，捕获列表中的第一个元素必须是 &#x3D; 或 &amp;，此符号指定了默认捕获的方式是值捕获或引用捕获</li><li>需要注意的是：显式捕获的变量必须使用和默认捕获不同的方式捕获<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>  j = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [ =, &amp;i] () &#123; <span class="keyword">return</span> j + i; &#125;;<span class="comment">// 正确，默认值捕获，显式是引用捕获</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [ =, i] () &#123; <span class="keyword">return</span> i + j; &#125;;<span class="comment">// 编译出错，默认值捕获，显式值捕获，冲突了</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [ &amp;, &amp;i] () &#123; <span class="keyword">return</span> i +j; &#125;;<span class="comment">// 编译出错，默认引用捕获，显式引用捕获，冲突了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>修改值捕获变量的值</strong></li><li>在lambda函数中，如果以传值方式捕获变量，则函数体中不能修改该变量，否则会引发编译错误</li><li>在lambda函数中，如果希望修改值捕获变量的值，可以加mutable选项，但是，在lambda函数的外部，变量的值不会被修改<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; cout &lt;&lt; ++a &lt;&lt; endl; &#125;; <span class="comment">// 不会报错</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出：123</span></span><br><span class="line"><span class="built_in">f</span>(); <span class="comment">// 输出：124</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出：123</span></span><br></pre></td></tr></table></figure><strong>异常说明</strong></li><li>lambda可以抛出异常，用throw(…)指示异常的类型，用noexcept指示不抛出任何异常</li></ul><h3 id="lambda函数的本质"><a href="#lambda函数的本质" class="headerlink" title="lambda函数的本质"></a>lambda函数的本质</h3><ul><li>当我们编写了一个lambda函数之后，编译器将它翻译成一个类，该类中有一个重载了()的函数。<br><strong>采用值捕获</strong></li><li>采用值捕获时，lambda函数生成的类用捕获变量的值初始化自己的成员变量</li><li>默认情况下，由lambda函数生成的类是const成员函数，所以变量的值不能修改。如果加上mutable，相当于去掉const。这样上面的限制就能讲通了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> addfun = [=] (<span class="type">const</span> <span class="type">int</span> c ) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a+c; &#125;;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">addfun</span>(b);    </span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">等同于：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_a;<span class="comment">// 该成员变量对应通过值捕获的变量。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Myclass</span>( <span class="type">int</span> a ) : <span class="built_in">m_a</span>(a)&#123;&#125;;<span class="comment">// 该形参对应捕获的变量。</span></span><br><span class="line"><span class="comment">// 重载了()运算符的函数，返回类型、形参和函数体都与lambda函数一致。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> c)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>采用引用捕获</strong></p><ul><li>如果lambda函数采用引用捕获的方式，编译器直接引用就行了。</li><li>唯一需要注意的是，lambda函数执行时，程序必须保证引用的对象有效<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Lambda函数作为参数传递给标准库的算法函数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda函数的变量捕获和调用</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sum = [x, y]() &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">sum</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> product = [&amp;x, &amp;y]() &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product: &quot;</span> &lt;&lt; <span class="built_in">product</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">sum</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product: &quot;</span> &lt;&lt; <span class="built_in">product</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h3><ul><li>在C++中，所有的值不是左值，就是右值。<strong>左值是指表达式结束后依然存在的持久化对象</strong>，<strong>右值是指表达式结束后就不再存在的临时对象</strong>。有名字的对象都是左值，右值没有名字。</li><li>还有一个可以区分左值和右值的便捷方法：看能不能对<strong>表达式取地址，如果能，则为左值</strong>，否则为右值。</li><li>C++11扩展了右值的概念，将右值分为了纯右值和将亡值。</li><li>纯右值<ul><li>非引用返回的临时变量；</li><li>运算表达式产生的结果；</li><li>字面常量（C风格字符串除外，它是地址）。</li></ul></li><li>将亡值<ul><li>与右值引用相关的表达式，例如：将要被移动的对象、T&amp;&amp;函数返回的值、std::move()的返回值、转换成T&amp;&amp;的类型的转换函数的返回值。</li></ul></li><li>不懂纯右值和将亡值的区别其实没关系，统一看作右值即可，不影响使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">AA <span class="title">getTemp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ii = <span class="number">3</span>;       <span class="comment">// ii是左值，3是右值。</span></span><br><span class="line"><span class="type">int</span> jj = ii+<span class="number">8</span>;    <span class="comment">// jj是左值，ii+8是右值。</span></span><br><span class="line">AA aa = <span class="built_in">getTemp</span>();   <span class="comment">// aa是左值 ，getTemp()的返回值是右值（临时变量）。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h3><ul><li>C++98中的引用很常见，就是给变量取个别名，在C++11中，因为增加了右值引用(rvalue reference)的概念，所以C++98中的引用都称为了左值引用(lvalue reference)。</li><li>右值引用就是给右值取个名字。</li><li>语法：<code>数据类型&amp;&amp; 变量名=右值;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a=<span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">AA <span class="title">getTemp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; a = <span class="number">3</span>;         <span class="comment">// 3是右值。</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">8</span>;               <span class="comment">// b是左值。</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; c = b + <span class="number">5</span>;   <span class="comment">//  b+5是右值。</span></span><br><span class="line">    AA&amp;&amp; aa = <span class="built_in">getTemp</span>();   <span class="comment">// getTemp()的返回值是右值（临时变量）。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;aa.m_a=&quot;</span> &lt;&lt; aa.m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>getTemp()的返回值本来在表达式语句结束后其生命也就该终结了（因为是临时变量），而通过右值引用重获了新生，其生命周期将与右值引用类型变量aa的生命周期一样，只要aa还活着，该右值临时变量将会一直存活下去。</li><li><strong>引入右值引用的主要目的是实现移动语义</strong>。</li><li>左值引用只能绑定（关联、指向）左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。</li><li>但是，常量左值引用却是个奇葩，它可以算是一个万能的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;        </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ra = a;   <span class="comment">// a是非常量左值。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rb = b;  <span class="comment">// b是常量左值。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rc = <span class="number">1</span>;   <span class="comment">// 1是右值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>总结一下，其中T是一个具体类型：<br>1）左值引用， 使用 <strong>T&amp;,</strong> <strong>只能绑定左值</strong>。<br>2）右值引用， 使用 <strong>T&amp;&amp;， 只能绑定右值</strong>。<br>3）<strong>已命名的右值引用是左值</strong>。<br>4）常量左值，使用 const T&amp;, 既可以绑定左值又可以绑定右值。</p><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><ul><li>如果一个对象中有堆区资源，需要编写拷贝构造函数和赋值函数，实现深拷贝。</li><li>深拷贝把对象中的堆区资源复制了一份，如果源对象（被拷贝的对象）是临时对象，拷贝完就没什么用了，这样会造成没有意义的资源申请和释放操作。<strong>如果能够直接使用源对象拥有的资源</strong>，可以节省资源申请和释放的时间。C++11新增加的<strong>移动语义就能够做到这一点</strong></li><li>实现移动语义要增加两个函数：<strong>移动构造函数和移动赋值函数</strong>。</li><li>移动构造函数的语法：<strong>类名(类名&amp;&amp; 源对象){……}</strong></li><li>移动赋值函数的语法：<strong>类名&amp; operator&#x3D;(类名&amp;&amp; 源对象){……}</strong><br>注意：<br>1）对于一个左值，会调用拷贝构造函数，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11为了解决这个问题，提供了std::move()方法来将左值转义为右值，从而方便使用移动语义。它其实就是告诉编译器，虽然我是一个左值，但不要对我用拷贝构造函数，用移动构造函数吧。左值对象被转移资源后，不会立刻析构，只有在离开自己的作用域的时候才会析构，如果继续使用左值中的资源，可能会发生意想不到的错误。<br>2）如果没有提供移动构造&#x2F;赋值函数，只提供了拷贝构造&#x2F;赋值函数，编译器找不到移动构造&#x2F;赋值函数就去寻找拷贝构造&#x2F;赋值函数。<br>3）C++11中的所有容器都实现了移动语义，避免对含有资源的对象发生无谓的拷贝。<br>4）移动语义对于拥有资源（如内存、文件句柄）的对象有效，如果是基本类型，使用移动语义没有意义。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* m_data = <span class="literal">nullptr</span>;  <span class="comment">// 数据成员，指向堆区资源的指针。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AA</span>() = <span class="keyword">default</span>;             <span class="comment">// 启用默认构造函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;                <span class="comment">// 给数据成员m_data分配内存。</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">int</span>;                       <span class="comment">// 分配内存。</span></span><br><span class="line">        <span class="built_in">memset</span>(m_data, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 初始化已分配的内存。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">const</span> AA&amp; a) &#123;     <span class="comment">// 拷贝构造函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了拷贝构造函数。\n&quot;</span>;            <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data == <span class="literal">nullptr</span>) <span class="built_in">alloc</span>();                     <span class="comment">// 如果没有分配内存，就分配。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_data, a.m_data, <span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">// 把数据从源对象中拷贝过来。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AA</span>(AA&amp;&amp; a) &#123;     <span class="comment">// 移动构造函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了移动构造函数。\n&quot;</span>;            <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) <span class="keyword">delete</span> m_data;         <span class="comment">// 如果已分配内存，先释放掉。</span></span><br><span class="line">        m_data = a.m_data;                                   <span class="comment">// 把资源从源对象中转移过来。</span></span><br><span class="line">        a.m_data = <span class="literal">nullptr</span>;                                    <span class="comment">// 把源对象中的指针置空。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AA&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AA&amp; a) &#123; <span class="comment">// 赋值函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了赋值函数。\n&quot;</span>;                   <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a)   <span class="keyword">return</span> *<span class="keyword">this</span>;                      <span class="comment">// 避免自我赋值。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data == <span class="literal">nullptr</span>) <span class="built_in">alloc</span>();                     <span class="comment">// 如果没有分配内存，就分配。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_data, a.m_data, <span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">// 把数据从源对象中拷贝过来。</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AA&amp; <span class="keyword">operator</span>=(AA&amp;&amp; a) &#123; <span class="comment">// 移动赋值函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了移动赋值函数。\n&quot;</span>;            <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a)   <span class="keyword">return</span> *<span class="keyword">this</span>;                      <span class="comment">// 避免自我赋值。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) <span class="keyword">delete</span> m_data;         <span class="comment">// 如果已分配内存，先释放掉。</span></span><br><span class="line">        m_data = a.m_data;                                   <span class="comment">// 把资源从源对象中转移过来。</span></span><br><span class="line">        a.m_data = <span class="literal">nullptr</span>;                                    <span class="comment">// 把源对象中的指针置空。</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ~<span class="built_in">AA</span>() &#123;                 <span class="comment">// 析构函数。</span></span><br><span class="line">         <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">             <span class="keyword">delete</span> m_data; m_data = <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA a1;                  <span class="comment">// 创建对象a1。</span></span><br><span class="line">    a1.<span class="built_in">alloc</span>();             <span class="comment">// 分配堆区资源。</span></span><br><span class="line">    *a1.m_data = <span class="number">3</span>;   <span class="comment">// 给堆区内存赋值。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1.m_data=&quot;</span> &lt;&lt; *a1.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    AA a2 = a1;         <span class="comment">// 将调用拷贝构造函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.m_data=&quot;</span> &lt;&lt; *a2.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    AA a3;</span><br><span class="line">    a3 = a1;              <span class="comment">// 将调用赋值函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a3.m_data=&quot;</span> &lt;&lt; *a3.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [] &#123; AA aa; aa.<span class="built_in">alloc</span>(); *aa.m_data = <span class="number">8</span>; <span class="keyword">return</span> aa; &#125;;   <span class="comment">// 返回AA类对象的lambda函数。</span></span><br><span class="line">    AA a4 = <span class="built_in">f</span>();                <span class="comment">// lambda函数返回临时对象，是右值，将调用移动构造函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a4.m_data=&quot;</span> &lt;&lt; *a4.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    AA a6;</span><br><span class="line">    a6 = <span class="built_in">f</span>();              <span class="comment">// lambda函数返回临时对象，是右值，将调用移动赋值函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a6.m_data=&quot;</span> &lt;&lt; *a6.m_data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><ul><li>在函数模板中，可以将参数“完美”的转发给其它函数。所谓完美，即不仅能准确的转发参数的值，还能保证被转发参数的左、右值属性不变</li><li>C++11标准引入了右值引用和移动语义，所以，能否实现完美转发，决定了该参数在传递过程使用的是拷贝语义还是移动语义</li><li>为了支持完美转发，C++11提供了以下方案：<ul><li>如果模板中（包括类模板和函数模板）函数的参数书写成为T&amp;&amp; 参数名，那么，函数既可以接受左值引用，又可以接受右值引用</li><li>提供了模板函数<code>std::forward&lt;T&gt;(参数)</code> ，用于转发参数，如果 参数是一个右值，转发之后仍是右值引用；如果参数是一个左值，转发之后仍是左值引用</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp; ii)</span> </span>&#123;        <span class="comment">// 如果参数是左值，调用此函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数是左值=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp;&amp; ii)</span> </span>&#123;     <span class="comment">// 如果参数是右值，调用此函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数是右值=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）如果模板中（包括类模板和函数模板）函数的参数书写成为T&amp;&amp; 参数名，</span></span><br><span class="line"><span class="comment">// 那么，函数既可以接受左值引用，又可以接受右值引用。</span></span><br><span class="line"><span class="comment">// 2）提供了模板函数std::forward&lt;T&gt;(参数) ，用于转发参数，</span></span><br><span class="line"><span class="comment">// 如果参数是一个右值，转发之后仍是右值引用；如果 参数是一个左值，转发之后仍是左值引用。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(TT&amp;&amp; ii)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>(forward&lt;TT&gt;(ii));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ii = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">func</span>(ii);       <span class="comment">// 实参是左值。</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">8</span>);       <span class="comment">// 实参是右值。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><ul><li>可变参数模版是C++11新增的最强大的特性之一，它对参数进行了泛化，能支持任意个数、任意数据类型的参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T girl)</span>      <span class="comment">// 向超女表白的函数，参数可能是超女编号，也可能是姓名，所以用T。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; girl &lt;&lt; <span class="string">&quot;，我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止时调用的非模板函数，函数名要与展开参数包的递归函数模板相同。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;递归终止。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开参数包的递归函数模板。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;参数： &quot; &lt;&lt; arg &lt;&lt; endl;         // 显示本次展开的参数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">show</span>(arg);        <span class="comment">// 把参数用于表白。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;还有&quot; &lt;&lt; sizeof...(args) &lt;&lt; &quot;个参数未展开。&quot; &lt;&lt; endl;  // 显示未展开变参的个数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args...);     <span class="comment">// 继续展开参数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp; str, Args...args)</span>   <span class="comment">// 除了可变参数，还可以有其它常规参数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;    <span class="comment">// 表白之前，喊句口号。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(args...);    <span class="comment">// 展开可变参数包。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;表白完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//print(&quot;金莲&quot;, 4, &quot;西施&quot;);   </span></span><br><span class="line"><span class="comment">//print(&quot;冰冰&quot;, 8, &quot;西施&quot;, 3);</span></span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;我是绝世帅歌。&quot;</span>, <span class="string">&quot;冰冰&quot;</span>, <span class="number">8</span>, <span class="string">&quot;西施&quot;</span>, <span class="number">3</span>);  <span class="comment">// &quot;我是绝世帅歌。&quot;不是可变参数，其它的都是。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="时间操作chrono库"><a href="#时间操作chrono库" class="headerlink" title="时间操作chrono库"></a>时间操作chrono库</h1><ul><li>C++11提供了chrono模版库，实现了一系列时间相关的操作（时间长度、系统时间和计时器）。</li><li>头文件：<code>#include &lt;chrono&gt;</code></li><li>命名空间：<code>std::chrono</code></li></ul><h2 id="时间长度"><a href="#时间长度" class="headerlink" title="时间长度"></a>时间长度</h2><ul><li><strong>duration模板类用于表示一段时间</strong>（时间长度、时钟周期），如：1小时、8分钟、5秒。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">duration的定义如下:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration</span><br><span class="line">&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>为了方便使用，定义了一些常用的时间长度，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于std::chrono命名空间下，定义如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> hours= duration&lt;Rep, std::ratio&lt;<span class="number">3600</span>&gt;&gt;<span class="comment">// 小时</span></span><br><span class="line"><span class="keyword">using</span> minutes= duration&lt;Rep, std::ratio&lt;<span class="number">60</span>&gt;&gt;<span class="comment">// 分钟</span></span><br><span class="line"><span class="keyword">using</span> seconds= duration&lt;Rep&gt;<span class="comment">// 秒</span></span><br><span class="line"><span class="keyword">using</span> milliseconds= duration&lt;Rep, std::milli&gt;<span class="comment">// 毫秒</span></span><br><span class="line"><span class="keyword">using</span> microseconds  = duration&lt;Rep, std::micro&gt;  <span class="comment">// 微秒</span></span><br><span class="line"><span class="keyword">using</span> nanoseconds = duration&lt;Rep, std::nano&gt;  <span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure><strong>注意</strong></li><li>duration模板类重载了各种算术运算符，用于操作duration对象。</li><li>duration模板类提供了count()方法，获取duration对象的值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>      <span class="comment">// chrono库的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::hours  <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;                                  <span class="comment">// 1小时</span></span><br><span class="line">    <span class="function">chrono::minutes  <span class="title">t2</span><span class="params">(<span class="number">60</span>)</span></span>;                            <span class="comment">//  60分钟</span></span><br><span class="line">    <span class="function">chrono::seconds  <span class="title">t3</span><span class="params">(<span class="number">60</span> * <span class="number">60</span>)</span></span>;                    <span class="comment">//  60*60秒</span></span><br><span class="line">    <span class="function">chrono::milliseconds  <span class="title">t4</span><span class="params">(<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span></span>;  <span class="comment">// 60*60*1000毫秒</span></span><br><span class="line">    <span class="function">chrono::microseconds <span class="title">t5</span><span class="params">(<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span></span>;          <span class="comment">// 警告：整数溢出。</span></span><br><span class="line">    <span class="function">chrono::nanoseconds <span class="title">t6</span><span class="params">(<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>*<span class="number">1000</span>)</span></span>;  <span class="comment">// 警告：整数溢出。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t1 == t2)    cout &lt;&lt; <span class="string">&quot;t1==t2\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == t3)    cout &lt;&lt; <span class="string">&quot;t1==t3\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == t4)    cout &lt;&lt; <span class="string">&quot;t1==t4\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时钟周期的值，返回的是int整数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1=&quot;</span> &lt;&lt; t1.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t2=&quot;</span> &lt;&lt; t2.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t3=&quot;</span> &lt;&lt; t3.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t4=&quot;</span> &lt;&lt; t4.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">chrono::seconds <span class="title">t7</span><span class="params">(<span class="number">1</span>)</span></span>;                                         <span class="comment">// 1秒</span></span><br><span class="line">    <span class="function">chrono::milliseconds  <span class="title">t8</span><span class="params">(<span class="number">1000</span>)</span></span>;                           <span class="comment">// 1000毫秒</span></span><br><span class="line">    <span class="function">chrono::microseconds <span class="title">t9</span><span class="params">(<span class="number">1000</span> * <span class="number">1000</span>)</span></span>;              <span class="comment">// 1000*1000微秒</span></span><br><span class="line">    <span class="function">chrono::nanoseconds <span class="title">t10</span><span class="params">(<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span></span>;  <span class="comment">//  1000*1000*1000纳秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t7 == t8)    cout &lt;&lt; <span class="string">&quot;t7==t8\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t7 == t9)    cout &lt;&lt; <span class="string">&quot;t7==t9\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t7 == t10)  cout &lt;&lt; <span class="string">&quot;t7==t10\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时钟周期的值。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t7=&quot;</span> &lt;&lt; t7.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t8=&quot;</span> &lt;&lt; t8.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t9=&quot;</span> &lt;&lt; t9.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t10=&quot;</span> &lt;&lt; t10.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="系统时间"><a href="#系统时间" class="headerlink" title="系统时间"></a>系统时间</h2><p>system_clock类支持了对系统时钟的访问，提供了三个静态成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间的时间点。</span></span><br><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::system_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间点time_point类型转换为std::time_t 类型。</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::<span class="type">time_t</span> <span class="title">to_time_t</span><span class="params">( <span class="type">const</span> time_point&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将std::time_t类型转换为时间点time_point类型。</span></span><br><span class="line"><span class="type">static</span> std::chrono::<span class="function">system_clock::time_point <span class="title">from_time_t</span><span class="params">( std::<span class="type">time_t</span> t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS  <span class="comment">// localtime()需要这个宏。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>   <span class="comment">// put_time()函数需要包含的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1）静态成员函数chrono::system_clock::now()用于获取系统时间。（C++时间）</span></span><br><span class="line">    <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2）静态成员函数chrono::system_clock::to_time_t()把系统时间转换为time_t。（UTC时间）</span></span><br><span class="line">    <span class="keyword">auto</span> t_now = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t_now = t_now + 24*60*60;   // 把当前时间加1天。</span></span><br><span class="line">    <span class="comment">// t_now = t_now + -1*60*60;   // 把当前时间减1小时。</span></span><br><span class="line">    <span class="comment">// t_now = t_now + 120;           // 把当前时间加120秒。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3）std::localtime()函数把time_t转换成本地时间。（北京时）</span></span><br><span class="line">    <span class="comment">// localtime()不是线程安全的，VS用localtime_s()代替，Linux用localtime_r()代替。</span></span><br><span class="line">    <span class="keyword">auto</span> tm_now = std::<span class="built_in">localtime</span>(&amp;t_now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4）格式化输出tm结构体中的成员。</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y-%m-%d&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y%m%d%H%M%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    stringstream ss;   <span class="comment">// 创建stringstream对象ss，需要包含&lt;sstream&gt;头文件。</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);    <span class="comment">// 把时间输出到对象ss中。</span></span><br><span class="line">    string timestr = ss.<span class="built_in">str</span>();     <span class="comment">// 把ss转换成string的对象。</span></span><br><span class="line">    cout &lt;&lt; timestr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><ul><li>steady_clock类相当于秒表，操作系统只要启动就会进行时间的累加，常用于耗时的统计（精确到纳秒）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态成员函数chrono::steady_clock::now()获取开始的时间点。</span></span><br><span class="line">    <span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些代码，让它消耗一些时间。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;计时开始 ...... \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">1000000</span>; ii++) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;我是一只傻傻鸟。\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;计时完成 ...... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数chrono::steady_clock::now()获取结束的时间点。</span></span><br><span class="line">    <span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算消耗的时间，单位是纳秒。</span></span><br><span class="line">    <span class="keyword">auto</span> dt = end - start;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;耗时: &quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;纳秒（&quot;</span>&lt;&lt;(<span class="type">double</span>)dt.<span class="built_in">count</span>()/(<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>)&lt;&lt;<span class="string">&quot;秒）&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6.c++_STL</title>
      <link href="/data.github.io/post/6ad37afc.html"/>
      <url>/data.github.io/post/6ad37afc.html</url>
      
        <content type="html"><![CDATA[<h1 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><ul><li>string是字符容器，内部维护了一个动态的字符数组。</li><li>与普通的字符数组相比，string容器有三个优点：<ul><li>使用的时候，不必考虑内存分配和释放的问题；</li><li>动态管理内存（可扩展）；</li><li>提供了大量操作容器的API。缺点是效率略有降低，占用的资源也更多。</li></ul></li><li>string类是std::basic_string类模板的一个具体化版本的别名。</li><li><code>using std::string=std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;</code></li></ul><h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><ul><li>静态常量成员string::npos为字符数组的最大长度（通常为unsigned int的最大值）；</li><li>NBTS（null-terminated string）：C风格的字符串（以空字符0结束的字符串）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string类有七个构造函数（C++<span class="number">11</span>新增了两个）：</span><br><span class="line"><span class="number">1</span>）<span class="built_in">string</span>(); <span class="comment">// 创建一个长度为0的string对象（默认构造函数）。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *s); <span class="comment">// 将string对象初始化为s指向的NBTS（转换函数）。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">string</span>(<span class="type">const</span> string &amp;str); <span class="comment">// 将string对象初始化为str（拷贝构造函数）。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">size_t</span> n); <span class="comment">// 将string对象初始化为s指向的地址后n字节的内容。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">string</span>(<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos=<span class="number">0</span>,<span class="type">size_t</span> n=npos); <span class="comment">// 将sring对象初始化为str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">string</span><span class="params">(T begin,T end)</span></span>; <span class="comment">// 将string对象初始化为区间[begin,end]内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">string</span>(<span class="type">size_t</span> n,<span class="type">char</span> c); <span class="comment">// 创建一个由n个字符c组成的string对象。</span></span><br><span class="line">析构函数~<span class="built_in">string</span>()释放内存空间。</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增加</span></span><br><span class="line"><span class="number">1</span>）<span class="built_in">string</span>(string &amp;&amp; str) <span class="keyword">noexcept</span>：它将一个string对象初始化为string对象str，并可能修改str（移动构造函数）。</span><br><span class="line"><span class="number">2</span>）<span class="built_in">string</span>(initializer_list&lt;<span class="type">char</span>&gt; il)：它将一个string对象初始化为初始化列表il中的字符。</span><br><span class="line"></span><br></pre></td></tr></table></figure>示例1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1）string()：创建一个长度为0的string对象（默认构造函数）。</span></span><br><span class="line">    string s1;        <span class="comment">// 创建一个长度为0的string对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1=&quot;</span> &lt;&lt; s1 &lt;&lt; endl;       <span class="comment">// 将输出s1=</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.capacity()=&quot;</span> &lt;&lt; s1.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size()=&quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;容器动态数组的首地址=&quot;</span> &lt;&lt; (<span class="type">void</span> *)s1.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    s1 = <span class="string">&quot;xxxxxxxxxxxxxxxxxxxx&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.capacity()=&quot;</span> &lt;&lt; s1.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size()=&quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;容器动态数组的首地址=&quot;</span> &lt;&lt; (<span class="type">void</span> *)s1.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2）string(const char *s)：将string对象初始化为s指向的NBTS（转换函数）。</span></span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2=&quot;</span> &lt;&lt; s2 &lt;&lt; endl;       <span class="comment">// 将输出s2=hello world</span></span><br><span class="line">    string s3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s3=&quot;</span> &lt;&lt; s3 &lt;&lt; endl;       <span class="comment">// 将输出s3=hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3）string(const string &amp; str)：将string对象初始化为str（拷贝构造函数）。</span></span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(s3)</span></span>;                                     <span class="comment">// s3 = &quot;hello world&quot;;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s4=&quot;</span> &lt;&lt; s4 &lt;&lt; endl;       <span class="comment">// 将输出s4=hello world</span></span><br><span class="line">    string s5 = s3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s5=&quot;</span> &lt;&lt; s5 &lt;&lt; endl;       <span class="comment">// 将输出s5=hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4）string(const char* s, size_t n)：将string对象初始化为s指向的NBTS的前n个字符，即使超过了NBTS结尾。</span></span><br><span class="line">    <span class="function">string <span class="title">s6</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s6=&quot;</span> &lt;&lt; s6 &lt;&lt; endl;       <span class="comment">// 将输出s6=hello</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s6.capacity()=&quot;</span> &lt;&lt; s6.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s6.size()=&quot;</span> &lt;&lt; s6.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    <span class="function">string <span class="title">s7</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">50</span>)</span></span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s7=&quot;</span> &lt;&lt; s7 &lt;&lt; endl;       <span class="comment">// 将输出s7=hello未知内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s7.capacity()=&quot;</span> &lt;&lt; s7.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s7.size()=&quot;</span> &lt;&lt; s7.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5）string(const string &amp; str, size_t pos = 0, size_t n = npos)：</span></span><br><span class="line">    <span class="comment">// 将string对象初始化为str从位置pos开始到结尾的字符，或从位置pos开始的n个字符。</span></span><br><span class="line">    <span class="function">string <span class="title">s8</span><span class="params">(s3, <span class="number">3</span>, <span class="number">5</span>)</span></span>;                               <span class="comment">// s3 = &quot;hello world&quot;;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s8=&quot;</span> &lt;&lt; s8 &lt;&lt; endl;         <span class="comment">// 将输出s8=lo wo</span></span><br><span class="line">    <span class="function">string <span class="title">s9</span><span class="params">(s3, <span class="number">3</span>)</span></span>;          </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s9=&quot;</span> &lt;&lt; s9 &lt;&lt; endl;         <span class="comment">// 将输出s9=lo world</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s9.capacity()=&quot;</span> &lt;&lt; s9.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s9.size()=&quot;</span> &lt;&lt; s9.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    <span class="function">string <span class="title">s10</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s10=&quot;</span> &lt;&lt; s10 &lt;&lt; endl;       <span class="comment">// 将输出s10=lo wo</span></span><br><span class="line">    <span class="function">string <span class="title">s11</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">3</span>)</span></span>;                <span class="comment">// 注意：不会用构造函数5），而是用构造函数4）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s11=&quot;</span> &lt;&lt; s11 &lt;&lt; endl;       <span class="comment">// 将输出s11=hel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6）template&lt;class T&gt; string(T begin, T end)：将string对象初始化为区间[begin, end]内的字符，</span></span><br><span class="line">    <span class="comment">//      其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7）string(size_t n, char c)：创建一个由n个字符c组成的string对象。</span></span><br><span class="line">    <span class="function">string <span class="title">s12</span><span class="params">(<span class="number">8</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s12=&quot;</span> &lt;&lt; s12 &lt;&lt; endl;       <span class="comment">// 将输出s12=xxxxxxxx</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s12.capacity()=&quot;</span> &lt;&lt; s12.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// s12.capacity()=15</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s12.size()=&quot;</span> &lt;&lt; s12.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// s12.size()=8</span></span><br><span class="line">    <span class="function">string <span class="title">s13</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s13=&quot;</span> &lt;&lt; s13 &lt;&lt; endl;       <span class="comment">// 将输出s13=</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s13.capacity()=&quot;</span> &lt;&lt; s13.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// s13.capacity()=31</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s13.size()=&quot;</span> &lt;&lt; s13.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// s12.size()=30 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>示例2：将字符空间用于字符串，int型等</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> cc[<span class="number">8</span>];   <span class="comment">// 在栈上分配8字节的内存空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把cc的内存空间用于字符串。</span></span><br><span class="line"><span class="built_in">strcpy</span>(cc, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cc=&quot;</span> &lt;&lt; cc &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把cc的内存空间用于int型整数。</span></span><br><span class="line"><span class="type">int</span>* a, * b;</span><br><span class="line">a = (<span class="type">int</span> *)cc;          <span class="comment">// 前4个字节的空间用于整数a。</span></span><br><span class="line">b = (<span class="type">int</span> *)cc + <span class="number">4</span>;   <span class="comment">// 后4个字节的空间用于整数b。</span></span><br><span class="line">*a = <span class="number">12345</span>;</span><br><span class="line">*b = <span class="number">54321</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*a=&quot;</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*b=&quot;</span> &lt;&lt; *b &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把cc的内存空间用于double。</span></span><br><span class="line"><span class="type">double</span>* d = (<span class="type">double</span>*)cc;</span><br><span class="line">*d = <span class="number">12345.7</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*d=&quot;</span> &lt;&lt; *d &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把cc的内存空间用于结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b[<span class="number">4</span>];</span><br><span class="line">&#125;*st;</span><br><span class="line">st = (<span class="keyword">struct</span> stt*)cc;</span><br><span class="line">st-&gt;a = <span class="number">38</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(st-&gt;b, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st-&gt;a=&quot;</span> &lt;&lt; st-&gt;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st-&gt;b=&quot;</span> &lt;&lt; st-&gt;b &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* malloc(size_t size);</span></span><br><span class="line"><span class="comment">//char* cc1 = (char*)malloc(8);</span></span><br><span class="line"><span class="comment">//int* cc1 = (int*)malloc(8);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>示例3：将结构体信息添加到字符串中</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">st_girl</span> &#123;   <span class="comment">// 超女结构体。</span></span><br><span class="line">        <span class="type">int</span>    bh;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">        <span class="type">bool</span> yz;</span><br><span class="line">        <span class="type">double</span> weight;</span><br><span class="line">        string memo;</span><br><span class="line">    &#125; girl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;超女结构体的大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string buffer;  <span class="comment">// 创建一个空的string容器buffer。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成10名超女的信息，存入buffer中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对超女结构体成员赋值。    </span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;girl, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));  </span><br><span class="line">        girl.bh = ii;</span><br><span class="line">        <span class="built_in">sprintf</span>(girl.name, <span class="string">&quot;西施%02d&quot;</span>, ii);</span><br><span class="line">        girl.yz = <span class="literal">true</span>;</span><br><span class="line">        girl.weight = <span class="number">48.5</span> + ii;</span><br><span class="line">        girl.memo = <span class="string">&quot;中国历史第一美女。&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把超女结构追加到buffer中。</span></span><br><span class="line">        buffer.<span class="built_in">append</span>((<span class="type">char</span>*)&amp;girl, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;buffer.capacity()=&quot;</span> &lt;&lt; buffer.<span class="built_in">capacity</span>() &lt;&lt; endl;  <span class="comment">// 显示容量。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;buffer.size()=&quot;</span> &lt;&lt; buffer.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 显示实际大小。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个循环，把buffer容器中全部的数据取出来。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; buffer.<span class="built_in">size</span>() / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl); ii++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;girl, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));  <span class="comment">// 初始化超女结构体。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把容器中的数据复制到超女结构体。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;girl , buffer.<span class="built_in">data</span>() + ii * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl), <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">        <span class="comment">// buffer.copy((char*)&amp;girl, sizeof(struct st_girl), ii * sizeof(struct st_girl));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示超女结构体成员的值。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bh=&quot;</span> &lt;&lt; girl.bh &lt;&lt;  <span class="string">&quot;,name=&quot;</span> &lt;&lt; girl.name &lt;&lt; <span class="string">&quot;,yz=&quot;</span> &lt;&lt; girl.yz &lt;&lt; <span class="string">&quot;,weight=&quot;</span> </span><br><span class="line">                &lt;&lt; girl.weight &lt;&lt; <span class="string">&quot;,memo=&quot;</span> &lt;&lt; girl.memo &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="特性操作"><a href="#特性操作" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 返回string对象的最大长度string::npos，此函数意义不大。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 返回容器中数据的大小（字符串语义）。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">// 返回容器中数据的大小（容器语义）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器，清空后，size()将返回0。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;      <span class="comment">// 将容器的容量降到实际大小（需要重新分配内存）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">( <span class="type">size_t</span> size=<span class="number">0</span>)</span></span>;  <span class="comment">// 将容器的容量设置为至少size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> len,<span class="type">char</span> c=<span class="number">0</span>)</span></span>;  <span class="comment">// 把容器的实际大小置为len，如果len&lt;实际大小，</span></span><br><span class="line"><span class="comment">//截断多出的部分；如果len&gt;实际大小，就用字符c填充。resize()后，length()和size()将返回len。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n); </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;  <span class="comment">// 只读。</span></span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;          <span class="comment">// 只读。</span></span><br><span class="line"><span class="comment">//operator[]和at()返回容器中的第n个元素，但at函数提供范围检查，当越界时会抛出out_of_range异常，operator[]不提供范围检查。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回容器中动态数组的首地址，语义：寻找以null结尾的字符串。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回容器中动态数组的首地址，语义：只关心容器中的数据。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">// 把当前容器中的内容，从pos开始的n个字节拷贝到s中，返回实际拷贝的数目。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给已存在的容器赋值，将覆盖容器中原有的内容。</span></span><br><span class="line"><span class="number">1</span>）string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;str); <span class="comment">// 把容器str赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>; <span class="comment">// 将string对象赋值为s指向的NBTS。</span></span><br><span class="line"><span class="number">3</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>; <span class="comment">// 将string对象赋值为str。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">size_t</span> n)</span></span>; <span class="comment">// 将string对象赋值为s指向的地址后n字节的内容。</span></span><br><span class="line"><span class="number">5</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos=<span class="number">0</span>,<span class="type">size_t</span> n=npos)</span></span>; <span class="comment">// 将sring对象赋值为str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; string &amp;<span class="title">assign</span><span class="params">(T begin,T end)</span></span>; <span class="comment">// 将string对象赋值为区间[begin,end]内的字符。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">size_t</span> n,<span class="type">char</span> c)</span></span>; <span class="comment">// 将string对象赋值为由n个字符c。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">把内容追加到已存在容器的后面。</span><br><span class="line"><span class="number">1</span>）string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> string &amp;str); <span class="comment">//把容器str连接到当前容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>; <span class="comment">// 把指向s的NBTS连接到当前容器。</span></span><br><span class="line"><span class="number">3</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>; <span class="comment">// 把容器str连接到当前容器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">size_t</span> n)</span></span>; <span class="comment">// 将s指向的地址后n字节的内容连接到当前容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos=<span class="number">0</span>,<span class="type">size_t</span> n=npos)</span></span>; <span class="comment">// 将str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）连接到当前容器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; string &amp;<span class="title">append</span> <span class="params">(T begin,T end)</span></span>; <span class="comment">// 将区间[begin,end]内的字符连接到容器。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">size_t</span> n,<span class="type">char</span> c)</span></span>; <span class="comment">// 将n个字符c连接到当前容器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h3><ul><li><code>void swap(string &amp;str);    // 把当前容器与str交换。</code></li><li>如果数据量很小，交换的是动态数组中的内容，如果数据量比较大，交换的是动态数组的地址。</li></ul><h3 id="截取操作"><a href="#截取操作" class="headerlink" title="截取操作"></a>截取操作</h3><ol><li><code>string substr(size_t pos = 0,size_t n = npos) const; // 返回pos开始的n个字节组成的子容器。</code></li></ol><h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> string &amp;str1,<span class="type">const</span> string &amp;str2) <span class="type">const</span>; <span class="comment">// 比较两个字符串是否相等。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;str)</span> <span class="type">const</span></span>; <span class="comment">// 比较当前字符串和str1的大小。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> string &amp;str)</span> <span class="type">const</span></span>; <span class="comment">// 比较当前字符串从pos开始的n个字符组成的字符串与str的大小。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos2,<span class="type">size_t</span> n2)</span><span class="type">const</span></span>; <span class="comment">// 比较当前字符串从pos开始的n个字符组成的字符串与str中pos2开始的n2个字符组成的字符串的大小。</span></span><br><span class="line">以下几个函数用于和C风格字符串比较。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> pos2)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="built_in">compre</span>()函数有异常，慎用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen = npos)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; str)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen = npos)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul><li><code>string &amp;erase(size_t pos = 0, size_t n = npos); // 删除pos开始的n个字符。</code></li></ul><h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><ul><li>vector容器封装了动态数组。</li><li>包含头文件： <code>#include&lt;vector&gt;</code></li></ul><p>类模板声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = allocator&lt;T&gt;&gt;<span class="comment">//类型 Alloc 表示我们要使用的内存分配器类型。默认情况下，使用 allocator&lt;T&gt; 作为内存分配器</span></span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T *start_; </span><br><span class="line">T *finish_;</span><br><span class="line">T *end_;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>分配器</strong>：各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存</li><li>如果省略该模板参数的值，将默认使用<code>allocator&lt;T&gt;</code>，用new和delete分配和释放内存。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">vector</span>();  <span class="comment">// 创建一个空的vector容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">vector</span>(initializer_list&lt;T&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; v);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">vector</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建vector容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">vector</span>(vector&lt;T&gt;&amp;&amp; v);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;   <span class="comment">// 创建vector容器，元素个数为n（容量和实际大小都是n）。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">vector</span>(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value);  <span class="comment">// 创建vector容器，元素个数为n，值均为value。</span></span><br><span class="line">析构函数~<span class="built_in">vector</span>()释放内存空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="特性操作-1"><a href="#特性操作-1" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回容器的最大长度，此函数意义不大。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 返回容器的容量。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 返回容器的实际大小（已使用的空间）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;               <span class="comment">// 清空容器。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> size)</span></span>;   <span class="comment">// 将容器的容量设置为至少size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;       <span class="comment">// 将容器的容量降到实际大小（需要重新分配内存）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;    <span class="comment">// 把容器的实际大小置为size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size,<span class="type">const</span> T &amp;value)</span></span>;  <span class="comment">// 把容器的实际大小置为size，如果size&lt;实际大小，会截断多出的部分；如果size&gt;实际大小，就用value填充。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n); </span><br><span class="line"><span class="type">const</span> T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;  <span class="comment">// 只读。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;          <span class="comment">// 只读。</span></span><br><span class="line"><span class="function">T *<span class="title">data</span><span class="params">()</span></span>;            <span class="comment">// 返回容器中动态数组的首地址。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回容器中动态数组的首地址。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;        <span class="comment">// 第一个元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;  <span class="comment">// 第一个元素，只读。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;  <span class="comment">// 最后一个元素，只读。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;        <span class="comment">// 最后一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="赋值操作-1"><a href="#赋值操作-1" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给已存在的容器赋值，将覆盖容器中原有的内容。</span><br><span class="line"><span class="number">1</span>）vector &amp;<span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt; &amp;v);    <span class="comment">// 把容器v赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）vector &amp;<span class="keyword">operator</span>=(initializer_list&lt;T&gt; il); <span class="comment">// 用统一初始化列表给当前容器赋值。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(initializer_list&lt;T&gt; il)</span></span>;        <span class="comment">// 使用统一初始化列表赋值。</span></span><br><span class="line"><span class="number">4</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(Iterator first, Iterator last)</span></span>;  <span class="comment">// 用迭代器赋值。</span></span><br><span class="line"><span class="number">5</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 把n个value给容器赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;     <span class="comment">// 使用统一初始化列表赋值。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; v1.<span class="built_in">size</span>(); ii++) cout &lt;&lt; v1[ii] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">v2 = v1;                    <span class="comment">// 把容器v1赋值给当前容器。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; v2.<span class="built_in">size</span>(); ii++) cout &lt;&lt; v2[ii] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">v3.<span class="built_in">assign</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;);   <span class="comment">// 用assign()函数给当前容器赋值，参数是统一初始化列表。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; v3.<span class="built_in">size</span>(); ii++) cout &lt;&lt; v3[ii] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交换操作-1"><a href="#交换操作-1" class="headerlink" title="交换操作"></a>交换操作</h3><ul><li><code>void swap(vector&lt;T&gt; &amp;v);    // 把当前容器与v交换</code>。</li><li>交换的是动态数组的地址</li></ul><h3 id="比较操作-1"><a href="#比较操作-1" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> vector&lt;T&gt; &amp; v) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> vector&lt;T&gt; &amp; v) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在容器的尾部追加一个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(…)</span></span>;           <span class="comment">// 在容器的尾部追加一个元素，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">3</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在指定位置插入一个元素，返回指向插入元素的迭代器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">iterator <span class="title">emplace</span> <span class="params">(iterator pos, …)</span></span>;  <span class="comment">// 在指定位置插入一个元素，…用于构造元素，返回指向插入元素的迭代器。C++11</span></span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, iterator first, iterator last)</span></span>;  <span class="comment">// 在指定位置插入一个区间的元素，返回指向第一个插入元素的迭代器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;                      <span class="comment">// 从容器尾部删除一个元素。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;             <span class="comment">// 删除指定位置的元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 删除指定区间的元素，返回下一个有效的迭代器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_bh;               <span class="comment">// 编号。</span></span><br><span class="line">string m_name;     <span class="comment">// 姓名。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AA</span>()      <span class="comment">// 默认构造函数。</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;默认构造函数AA()。\n&quot;; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> <span class="type">int</span> &amp;bh,<span class="type">const</span> string&amp; name) : <span class="built_in">m_bh</span>(bh),<span class="built_in">m_name</span>(name)   <span class="comment">// 有两个参数的构造函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;构造函数，name=&quot; &lt;&lt; m_name &lt;&lt; &quot;。\n&quot;; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> AA&amp; g) :<span class="built_in">m_bh</span>(g.m_bh), <span class="built_in">m_name</span>(g.m_name)                       <span class="comment">// 拷贝构造函数。</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;拷贝构造函数，name=&quot; &lt;&lt; m_name &lt;&lt; &quot;。\n&quot;; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//~AA() &#123; cout &lt;&lt; &quot;析构函数。\n&quot;; &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;AA&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt;endl&lt;&lt; v.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AA a(18,&quot;西施&quot;); </span></span><br><span class="line"><span class="comment">//v.push_back(a);</span></span><br><span class="line"><span class="comment">//v.emplace_back(a);</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">18</span>,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bh=&quot;</span> &lt;&lt; v[<span class="number">10</span>].m_bh &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; v[<span class="number">10</span>].m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vector嵌套"><a href="#vector嵌套" class="headerlink" title="vector嵌套"></a>vector嵌套</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vv;   <span class="comment">// 创建一个vector容器vv，元素的数据类型是vector&lt;int&gt;。</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;        <span class="comment">// 创建一个容器v，它将作为容器vv的元素。</span></span><br><span class="line"></span><br><span class="line">v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;      <span class="comment">// 用统一初始化列表给v赋值。</span></span><br><span class="line">vv.<span class="built_in">push_back</span>(v);    <span class="comment">// 把容器v作为元素追加到vv中。</span></span><br><span class="line"></span><br><span class="line">v = &#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span> &#125;;   <span class="comment">// 用统一初始化列表给v赋值。</span></span><br><span class="line">vv.<span class="built_in">push_back</span>(v);                      <span class="comment">// 把容器v作为元素追加到vv中。</span></span><br><span class="line"></span><br><span class="line">v = &#123; <span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span> &#125;;     <span class="comment">// 用统一初始化列表给v赋值。</span></span><br><span class="line">vv.<span class="built_in">push_back</span>(v);    <span class="comment">// 把容器v作为元素追加到vv中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用嵌套的循环，把vv容器中的数据显示出来。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; vv.<span class="built_in">size</span>(); ii++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; vv[ii].<span class="built_in">size</span>(); jj++)</span><br><span class="line">cout &lt;&lt; vv[ii][jj] &lt;&lt; <span class="string">&quot; &quot;</span>;      <span class="comment">// 像二维数组一样使用容器vv。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>迭代器失效的问题：resize()、reserve()、assign()、push_back()、pop_back()、insert()、erase()等函数会引起vector容器的动态数组发生变化，可能导致vector迭代器失效。</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li>迭代器是访问容器中元素的通用方法。</li><li>如果使用迭代器，不同的容器，访问元素的方法是相同的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代器支持的基本操作：赋值（=）、解引用（*）、比较（==和!=）、从左向右遍历（++）。</span><br></pre></td></tr></table></figure></li><li>一般情况下，迭代器是指针和移动指针的方法。</li></ul><h3 id="正向迭代器"><a href="#正向迭代器" class="headerlink" title="正向迭代器"></a>正向迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能使用++运算符从左向右遍历容器，每次沿容器向右移动一个元素。</span></span><br><span class="line">容器名&lt;元素类型&gt;::iterator 迭代器名;        <span class="comment">// 正向迭代器。</span></span><br><span class="line">容器名&lt;元素类型&gt;::const_iterator 迭代器名;  <span class="comment">// 常正向迭代器。</span></span><br><span class="line"><span class="comment">//相关的成员函数：</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span></span>;  <span class="comment">// 配合auto使用。</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用正向迭代器遍历 vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h3><p>具备正向迭代器的功能，还可以反向（从右到左）遍历容器（也是用++），不管是正向还是反向遍历，都可以用–让迭代器后退一个元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">容器名&lt;元素类型&gt;:: reverse_iterator 迭代器名;        <span class="comment">// 反向迭代器。</span></span><br><span class="line">容器名&lt;元素类型&gt;:: const_reverse_iterator 迭代器名;  <span class="comment">// 常反向迭代器。</span></span><br><span class="line">相关的成员函数：</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">crbegin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">crend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">具备双向迭代器的功能，还支持以下操作：</span><br><span class="line">用于比较两个迭代器相对位置的关系运算（&lt;、&lt;=、&gt;、&gt;=）。</span><br><span class="line">迭代器和一个整数值的加减法运算（+、+=、-、-=）。</span><br><span class="line">支持下标运算（iter[n]）。</span><br><span class="line">数组的指针是纯天然的随机访问迭代器。</span><br></pre></td></tr></table></figure><h3 id="输入和输出迭代器"><a href="#输入和输出迭代器" class="headerlink" title="输入和输出迭代器"></a>输入和输出迭代器</h3><p>这两种迭代器比较特殊，它们不是把容器当做操作对象，而是把输入&#x2F;输出流作为操作对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>   <span class="comment">// 单链表的结点。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> item;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">find_</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span>&amp; val)</span>  <span class="comment">// 在整型数组arr中查找值为val的元素。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; n; ii++)                     <span class="comment">// 遍历数组。</span></span><br><span class="line"><span class="keyword">if</span> (arr[ii] == val) <span class="keyword">return</span> &amp;arr[ii];       <span class="comment">// 如果找到了，返回数组中元素的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">find_</span><span class="params">(<span class="type">int</span>* begin, <span class="type">int</span>* end, <span class="type">const</span> <span class="type">int</span>&amp; val)</span>  <span class="comment">// 在整型数组的区间中查找值为val的元素。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>* iter = begin; iter != end; iter++)      <span class="comment">// 遍历查找区间。</span></span><br><span class="line"><span class="keyword">if</span> (*iter == val) <span class="keyword">return</span> iter;                         <span class="comment">// 如果找到了元素，返回区间中的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">find_</span><span class="params">(Node* begin, Node* end, <span class="type">const</span> Node&amp; val)</span>         <span class="comment">// 在单链表中查找值为val的元素。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Node * iter = begin; iter != end; iter = iter-&gt;next)     <span class="comment">// 遍历链表。</span></span><br><span class="line"><span class="keyword">if</span> (iter-&gt;item == val.item) <span class="keyword">return</span> iter;           <span class="comment">// 如果找到了，返回链表中结点的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素的算法。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  </span><br><span class="line"><span class="comment">// begin-查找区间开始的位置；end-查找区间结束的位置；val-待查找的值。</span></span><br><span class="line"><span class="function">T1 <span class="title">find_</span><span class="params">(T1 begin, T1 end, <span class="type">const</span> T2 &amp;val)</span>      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (T1 iter = begin; iter != end; iter++)     <span class="comment">// 遍历查找区间。</span></span><br><span class="line"><span class="keyword">if</span> (*iter == val) <span class="keyword">return</span> iter;                       <span class="comment">// 如果找到了元素，返回区间中的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 在vector容器中查找元素。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;      <span class="comment">// 初始化vector容器。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it2 = <span class="built_in">find_</span>(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"><span class="keyword">if</span> (it2 != vv.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;查找成功。\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在list容器中查找元素。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; ll = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;               <span class="comment">// 初始化vector容器。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it3 = <span class="built_in">find_</span>(ll.<span class="built_in">begin</span>(), ll.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it3 != ll.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;查找成功。\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><ul><li>对于一个有范围的集合来说，在程序代码中指定循环的范围有时候是多余的，还可能犯错误</li><li>C++11中引入了基于范围的for循环<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (迭代的变量 : 迭代的范围)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 循环体。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1</span>）迭代的范围可以是数组名、容器名、初始化列表或者可迭代的对象（支持<span class="built_in">begin</span>()、<span class="built_in">end</span>()、++、==）</span><br><span class="line"><span class="number">2</span>）数组名传入函数后，已退化成指针，不能作为容器名</span><br><span class="line"><span class="number">3</span>）如果容器中的元素是结构体和类，迭代器变量应该申明为引用，加<span class="type">const</span>约束表示只读</span><br><span class="line"><span class="number">4</span>）注意迭代器失效的问题</span><br></pre></td></tr></table></figure>例子<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;默认构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;构造函数，name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> AA&amp; a) : <span class="built_in">m_name</span>(a.m_name) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数，name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">AA&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AA&amp; a) &#123; m_name = a.m_name;  cout &lt;&lt; <span class="string">&quot;赋值函数，name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;。\n&quot;</span>;  <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数，name=&quot;</span> &lt;&lt; m_name&lt;&lt;<span class="string">&quot;。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for (auto it = vv.begin(); it != vv.end(); it++)     // 用迭代器遍历容器vv。</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> val : vv)      <span class="comment">// 用基于范围的for循环遍历数组vv。</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">vv.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*vector&lt;AA&gt; v;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;1111，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">v.emplace_back(&quot;西施&quot;);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;2222，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">v.emplace_back(&quot;冰冰&quot;);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;3333，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">v.emplace_back(&quot;幂幂&quot;);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;4444，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (const auto &amp;a : v)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; a.m_name &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><ul><li>list容器封装了双链表。</li><li>包含头文件： <code>#include&lt;list&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">iterator head;</span><br><span class="line">iterator tail;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">list</span>();  <span class="comment">// 创建一个空的list容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">list</span>(initializer_list&lt;T&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">list</span>(<span class="type">const</span> list&lt;T&gt;&amp; l);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">list</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建list容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">list</span>(list&lt;T&gt;&amp;&amp; l);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">explicit</span> <span class="title">list</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;   <span class="comment">// 创建list容器，元素个数为n。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">list</span>(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value);  <span class="comment">// 创建list容器，元素个数为n，值均为value。</span></span><br><span class="line">析构函数~<span class="built_in">list</span>()释放内存空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1）list();  // 创建一个空的list容器。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l1;</span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;li.capacity()=&quot; &lt;&lt; l1.capacity() &lt;&lt; endl;  // 链表没有容量说法。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;li.size()=&quot;</span> &lt;&lt; l1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）list(initializer_list&lt;T&gt; il); // 使用统一初始化列表。</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l2</span><span class="params">(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;)</span></span>;</span><br><span class="line"><span class="comment">// list&lt;int&gt; l2=&#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span></span><br><span class="line"><span class="comment">// list&lt;int&gt; l2  &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : l2)       <span class="comment">// 用基于范围的for循环遍历容器。</span></span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）list(const list&lt;T&gt;&amp; l);  // 拷贝构造函数。</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(l2)</span></span>;</span><br><span class="line"><span class="comment">// list&lt;int&gt; l3=l2;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : l3)    </span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）list(Iterator first, Iterator last);  // 用迭代器创建list容器。</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l4</span><span class="params">(l3.begin(), l3.end())</span></span>;      <span class="comment">// 用list容器的迭代器。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : l4)  </span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;  <span class="comment">// 创建vector容器。</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l5</span><span class="params">(v1.begin() + <span class="number">2</span>, v1.end() - <span class="number">3</span>)</span></span>;          <span class="comment">// 用vector容器的迭代器创建list容器。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : l5)   </span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;   <span class="comment">// 创建数组。</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l6</span><span class="params">(a1 + <span class="number">2</span>, a1 + <span class="number">10</span> - <span class="number">3</span>)</span></span>;           <span class="comment">// 用数组的指针作为迭代器创建list容器。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> value : l6)     </span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;         <span class="comment">// 定义C风格字符串。</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(str + <span class="number">1</span>, str + <span class="number">7</span>)</span></span>;          <span class="comment">// 用C风格字符串创建string容器。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> value : s1)                   <span class="comment">// 遍历string容器。</span></span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;                 <span class="comment">// 以字符串的方式显示string容器。</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(l3.begin(), l3.end())</span></span>;   <span class="comment">// 用list迭代器创建vector容器。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> value : v2)                               <span class="comment">// 遍历vector容器。</span></span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="特性操作-2"><a href="#特性操作-2" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回容器的最大长度，此函数意义不大。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 返回容器的实际大小（已使用的空间）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;   <span class="comment">// 把容器的实际大小置为size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size,<span class="type">const</span> T &amp;value)</span></span>;  <span class="comment">// 把容器的实际大小置为size，如果size&lt;实际大小，会截断多出的部分；如果size&gt;实际大小，就用value填充。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元素操作-1"><a href="#元素操作-1" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;        <span class="comment">// 第一个元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;  <span class="comment">// 第一个元素，只读。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;  <span class="comment">// 最后一个元素，只读。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;        <span class="comment">// 最后一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="赋值操作-2"><a href="#赋值操作-2" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给已存在的容器赋值，将覆盖容器中原有的内容。</span></span><br><span class="line"><span class="number">1</span>）list &amp;<span class="keyword">operator</span>=(<span class="type">const</span> list&lt;T&gt; &amp;l);         <span class="comment">// 把容器l赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）list &amp;<span class="keyword">operator</span>=(initializer_list&lt;T&gt; il);  <span class="comment">// 用统一初始化列表给当前容器赋值。</span></span><br><span class="line"><span class="number">3</span>）<span class="function">list <span class="title">assign</span><span class="params">(initializer_list&lt;T&gt; il)</span></span>;        <span class="comment">// 使用统一初始化列表赋值。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">list <span class="title">assign</span><span class="params">(Iterator first, Iterator last)</span></span>;  <span class="comment">// 用迭代器赋值。</span></span><br><span class="line"><span class="number">5</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 把n个value给容器赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交换、反转、排序、归并"><a href="#交换、反转、排序、归并" class="headerlink" title="交换、反转、排序、归并"></a>交换、反转、排序、归并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(list&lt;T&gt; &amp;l)</span></span>;   <span class="comment">// 把当前容器与l交换，交换的是链表结点的地址。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>;           <span class="comment">// 反转链表。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;              <span class="comment">// 对容器中的元素进行升序排序。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(_Pr2 _Pred)</span></span>;    <span class="comment">// 对容器中的元素进行排序，排序的方法由_Pred决定（二元函数）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&lt;T&gt; &amp;l)</span></span>;  <span class="comment">// 采用归并法合并两个已排序的list容器，合并后的list容器仍是有序的。</span></span><br></pre></td></tr></table></figure><h3 id="比较操作-2"><a href="#比较操作-2" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> vector&lt;T&gt; &amp; l) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> vector&lt;T&gt; &amp; l) <span class="type">const</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在链表的尾部追加一个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(…)</span></span>;           <span class="comment">// 在链表的尾部追加一个元素，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">3</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在指定位置插入一个元素，返回指向插入元素的迭代器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">iterator <span class="title">emplace</span> <span class="params">(iterator pos, …)</span></span>;  <span class="comment">// 在指定位置插入一个元素，…用于构造元素，返回指向插入元素的迭代器。C++11</span></span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, iterator first, iterator last)</span></span>;  <span class="comment">// 在指定位置插入一个区间的元素，返回指向第一个插入元素的迭代器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;                      <span class="comment">// 从链表尾部删除一个元素。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;             <span class="comment">// 删除指定位置的元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 删除指定区间的元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">9</span>）<span class="built_in">push_front</span>(<span class="type">const</span> T&amp; value);  <span class="comment">// 在链表的头部插入一个元素。</span></span><br><span class="line"><span class="number">10</span>）<span class="built_in">emplace_front</span>(…);          <span class="comment">// 在链表的头部插入一个元素，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">11</span>）<span class="built_in">splice</span>(iterator pos, <span class="type">const</span> vector&lt;T&gt; &amp; l);  <span class="comment">// 把另一个链表连接到当前链表。</span></span><br><span class="line"><span class="number">12</span>）<span class="built_in">splice</span>(iterator pos, <span class="type">const</span> vector&lt;T&gt; &amp; l, iterator first, iterator last);<span class="comment">// 把另一个链表指定的区间连接到当前链表。</span></span><br><span class="line"><span class="number">13</span>）<span class="built_in">splice</span>(iterator pos, <span class="type">const</span> vector&lt;T&gt; &amp; l, iterator first);<span class="comment">// 把另一个链表从first开始的结点连接到当前链表。</span></span><br><span class="line"><span class="number">14</span>）<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>; <span class="comment">// 删除链表中所有值等于value的元素。</span></span><br><span class="line"><span class="number">15</span>）<span class="function"><span class="type">void</span> <span class="title">remove_if</span><span class="params">(_Pr1 _Pred)</span></span>;    <span class="comment">// 删除链表中满足条件的元素，参数_Pred是一元函数。</span></span><br><span class="line"><span class="number">16</span>）<span class="function"><span class="type">void</span> <span class="title">unique</span><span class="params">()</span></span>;                 <span class="comment">// 删除链表中相邻的重复元素，只保留一个。</span></span><br><span class="line"><span class="number">17</span>）<span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;              <span class="comment">// 从链表头部删除一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;  la = &#123; <span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : la) cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;  lb = &#123; <span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : lb) cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> first = lb.<span class="built_in">begin</span>();</span><br><span class="line">first++;</span><br><span class="line"><span class="keyword">auto</span> last = lb.<span class="built_in">end</span>();</span><br><span class="line">last--;</span><br><span class="line"></span><br><span class="line">la.<span class="built_in">splice</span>(la.<span class="built_in">begin</span>(), lb, first, last);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : la) cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lb.size()=&quot;</span> &lt;&lt; lb.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : lb) cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pair键值对"><a href="#pair键值对" class="headerlink" title="pair键值对"></a>pair键值对</h2><ul><li>pair是类模板，一般用于表示key&#x2F;value数据，其实是结构体。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pair结构模板的定义如下：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> </span><br><span class="line">&#123; </span><br><span class="line">    T1 first;     <span class="comment">// 第一个成员，一般表示key。</span></span><br><span class="line">    T2 second;  <span class="comment">// 第二个成员，一般表示value。</span></span><br><span class="line"><span class="built_in">pair</span>();       <span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="built_in">pair</span>(<span class="type">const</span> T1 &amp;val1,<span class="type">const</span> T2 &amp;val2);   <span class="comment">// 有两个参数的构造函数。</span></span><br><span class="line"><span class="built_in">pair</span>(<span class="type">const</span> pair&lt;T1,T2&gt; &amp;p);           <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair&lt;T1,T2&gt; &amp;p)</span></span>;           <span class="comment">// 交换两个pair。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//make_pair函数模板的定义如下：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="built_in">make_pair</span>(<span class="type">const</span> T1 &amp;first,<span class="type">const</span> T2 &amp;second)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;T1,T2&gt;(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>例子<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line">T1 first;        <span class="comment">// 第一个成员，一般表示key。</span></span><br><span class="line">T2 second;  <span class="comment">// 第二个成员，一般表示value。</span></span><br><span class="line"><span class="built_in">Pair</span>()  &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了有默认的构造函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Pair</span>(<span class="type">const</span> T1&amp; val1, <span class="type">const</span> T2&amp; val2) :<span class="built_in">first</span>(val1), <span class="built_in">second</span>(val2)  &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了有两个参数的构造函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Pair</span>(<span class="type">const</span> Pair&lt;T1, T2&gt;&amp; p) : <span class="built_in">first</span>(p.first),<span class="built_in">second</span>(p.second)  &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了拷贝构造函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function">Pair&lt;T1, T2&gt; <span class="title">make_Pair</span><span class="params">(<span class="type">const</span> T1&amp; first, <span class="type">const</span> T2&amp; second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Pair&lt;T1, T2&gt; p(first, second);</span></span><br><span class="line"><span class="comment">// return p;        // 返回局部对象。</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Pair</span>&lt;T1, T2&gt;(first, second);  <span class="comment">// 返回临时对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//pair&lt;int, string&gt; p0;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p0 first=&quot; &lt;&lt; p0.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p0.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pair&lt;int, string&gt; p1(1, &quot;西施1&quot;);    // 两个参数的构造函数。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p1 first=&quot; &lt;&lt; p1.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p1.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pair&lt;int, string&gt; p2 = p1;             // 拷贝构造。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p2 first=&quot; &lt;&lt; p2.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p2.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pair&lt;int, string&gt; p3 = &#123; 3, &quot;西施3&quot; &#125;;   // 两个参数的构造函数。</span></span><br><span class="line"><span class="comment">//// pair&lt;int, string&gt; p3 &#123; 3, &quot;西施3&quot; &#125;;   // 两个参数的构造函数，省略了等于号。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p3 first=&quot; &lt;&lt; p3.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p3.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p4 = <span class="built_in">Pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;西施4&quot;</span>);   <span class="comment">// 匿名对象（显式调用构造函数）。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p4 first=&quot;</span> &lt;&lt; p4.first &lt;&lt; <span class="string">&quot;,second=&quot;</span> &lt;&lt; p4.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p5 = <span class="built_in">make_Pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">5</span>, <span class="string">&quot;西施5&quot;</span>);   <span class="comment">// make_pair()返回的临时对象。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p5 first=&quot;</span> &lt;&lt; p5.first &lt;&lt; <span class="string">&quot;,second=&quot;</span> &lt;&lt; p5.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pair&lt;int, string&gt; p6 = make_pair(6, &quot;西施6&quot;);  // 慎用，让make_pair()函数自动推导，再调用拷贝构造，再隐式转换。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p6 first=&quot; &lt;&lt; p6.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p6.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//auto p7 = make_pair(7, &quot;西施7&quot;);    // 慎用，让make_pair()函数自动推导，再调用拷贝构造。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p7 first=&quot; &lt;&lt; p7.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p7.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p5.swap(p4);   // 交换两个pair。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p4 first=&quot; &lt;&lt; p4.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p4.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p5 first=&quot; &lt;&lt; p5.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p5.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//struct st_girl</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//string name;</span></span><br><span class="line"><span class="comment">//int   age;</span></span><br><span class="line"><span class="comment">//double height;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//// 用pair存放结构体数据。</span></span><br><span class="line"><span class="comment">//pair&lt;int, st_girl&gt; p = &#123; 3,&#123;&quot;西施&quot;,23,48.6&#125; &#125;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p first=&quot; &lt;&lt; p.first &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p second.name=&quot; &lt;&lt; p.second.name &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p second.age=&quot; &lt;&lt; p.second.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;p second.height=&quot; &lt;&lt; p.second.height &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h2><ul><li>map 容器封装了红黑树（平衡二叉排序树），用于查找。</li><li>包含头文件： <code>#include&lt;map&gt;</code></li><li>map容器的元素是pair键值对。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map类模板的声明：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">P</span> = less&lt;K&gt;, <span class="keyword">class</span> _Alloc = allocator&lt;pair&lt;<span class="type">const</span> K, V &gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map : <span class="keyword">public</span> _Tree&lt;_Tmap_traits&lt; K, V, P, _Alloc, <span class="literal">false</span>&gt;&gt; </span><br><span class="line">&#123;</span><br><span class="line">   … </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>第一个模板参数K：key的数据类型（pair.first）。</li><li>第二个模板参数V：value的数据类型（pair.second）。</li><li>第三个模板参数P：排序方法，缺省按key升序。</li><li>第四个模板参数_Alloc：分配器，缺省用new和delete。</li><li>map提供了双向迭代器。</li></ul><h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">map</span>();  <span class="comment">// 创建一个空的map容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">map</span>(initializer_list&lt;pair&lt;K,V&gt;&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">map</span>(<span class="type">const</span> map&lt;K,V&gt;&amp; m);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">map</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建map容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">map</span>(map&lt;K,V&gt;&amp;&amp; m);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1）map();  // 创建一个空的map容器。</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）map(initializer_list&lt;pair&lt;K, V&gt;&gt; il); // 使用统一初始化列表。</span></span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, string&gt; <span class="title">m2</span><span class="params">( &#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="number">7</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line"><span class="comment">// map&lt;int, string&gt; m2=&#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line"><span class="comment">// map&lt;int, string&gt; m2   &#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m2)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）map(const map&lt;K, V&gt;&amp;m);  // 拷贝构造函数。</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m3 = m2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m3)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）map(Iterator first, Iterator last);  // 用迭代器创建map容器。</span></span><br><span class="line"><span class="keyword">auto</span> first = m3.<span class="built_in">begin</span>();  first++;</span><br><span class="line"><span class="keyword">auto</span> last = m3.<span class="built_in">end</span>();  last--;</span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, string&gt; <span class="title">m4</span><span class="params">(first,last)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m4)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5）map(map&lt;K, V&gt; &amp;&amp; m);  // 移动构造函数（C++11标准）。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="特性操作-3"><a href="#特性操作-3" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 返回容器的实际大小（已使用的空间）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元素操作-2"><a href="#元素操作-2" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K key);             <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="type">const</span> V &amp;<span class="keyword">operator</span>[](K key) <span class="type">const</span>;  <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K key)</span></span>;                     <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> V &amp;<span class="title">at</span><span class="params">(K key)</span> <span class="type">const</span></span>;         <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>1）<code>[ ]</code>运算符：如果指定键不存在，会向容器中添加新的键值对；如果指定键不存在，则读取或修改容器中指定键的值。<br>2）at()成员函数：如果指定键不存在，不会向容器中添加新的键值对，而是直接抛出out_of_range 异常<br>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">map&lt;string, string&gt; <span class="title">m</span><span class="params">( &#123; &#123; <span class="string">&quot;08&quot;</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="string">&quot;03&quot;</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="string">&quot;01&quot;</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="string">&quot;07&quot;</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="string">&quot;05&quot;</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m[08]=&quot;</span> &lt;&lt; m[<span class="string">&quot;08&quot;</span>] &lt;&lt; endl;     <span class="comment">// 显示key为08的元素的value。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m[09]=&quot;</span> &lt;&lt; m[<span class="string">&quot;09&quot;</span>] &lt;&lt; endl;    <span class="comment">// 显示key为09的元素的value。key为09的元素不存在，将添加新的键值对。</span></span><br><span class="line">m[<span class="string">&quot;07&quot;</span>] = <span class="string">&quot;花花&quot;</span>;                                          <span class="comment">// 把key为07的元素的value修改为花花。</span></span><br><span class="line">m[<span class="string">&quot;12&quot;</span>] = <span class="string">&quot;小乔&quot;</span>;                                          <span class="comment">// 将添加新的键值对。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="赋值操作-3"><a href="#赋值操作-3" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给已存在的容器赋值，将覆盖容器中原有的内容。</span><br><span class="line"><span class="number">1</span>）map&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> map&lt;K,V&gt;&amp; m);         <span class="comment">// 把容器m赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）map&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  <span class="comment">// 用统一初始化列表给当前容器赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交换操作-2"><a href="#交换操作-2" class="headerlink" title="交换操作"></a>交换操作</h3><ul><li><code>void swap(map&lt;K,V&gt;&amp; m);    // 把当前容器与m交换。</code></li><li>交换的是树的根结点。</li></ul><h3 id="比较操作-3"><a href="#比较操作-3" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> map&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> map&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h3><p><strong>查找键值为key的键值对</strong></p><ul><li>在map容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span>; </span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>查找键值&gt;&#x3D;key的键值对</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在map容器中查找第一个键值&gt;=key的键值对，成功返回迭代器；失败返回<span class="built_in">end</span>()。</span><br><span class="line">iterator <span class="built_in">lower_bound</span>(<span class="type">const</span> K &amp;key); </span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure><p><strong>查找键&gt;key的键值对</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在map容器中查找第一个键值&gt;key的键值对，成功返回迭代器；失败返回<span class="built_in">end</span>()。</span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span>; </span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure><p><strong>统计键值对的个数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">统计map容器中键值为key的键值对的个数。</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">map&lt;string, string&gt; <span class="title">m</span><span class="params">( &#123; &#123; <span class="string">&quot;08&quot;</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="string">&quot;03&quot;</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="string">&quot;01&quot;</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="string">&quot;07&quot;</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="string">&quot;05&quot;</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。</span></span><br><span class="line"><span class="keyword">auto</span> it1 = m.<span class="built_in">find</span>(<span class="string">&quot;05&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it1 != m.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; it1-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it1-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map容器中查找第一个键值 &gt;= key的键值对，成功返回迭代器；失败返回end()。</span></span><br><span class="line"><span class="keyword">auto</span> it2 = m.<span class="built_in">lower_bound</span>(<span class="string">&quot;05&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it2 != m.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; it2-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it2-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在map容器中查找第一个键值 &gt; key的键值对，成功返回迭代器；失败返回end()。</span></span><br><span class="line"><span class="keyword">auto</span> it3 = m.<span class="built_in">upper_bound</span>(<span class="string">&quot;05&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (it3 != m.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; it3-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it3-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计map容器中键值为key的键值对的个数。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count(05)=&quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;05&quot;</span>) &lt;&lt; endl;   <span class="comment">// 返回1。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count(06)=&quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;06&quot;</span>) &lt;&lt; endl;   <span class="comment">// 返回0。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入和删除-2"><a href="#插入和删除-2" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(initializer_list&lt;pair&lt;K,V&gt;&gt; il)</span></span>;  <span class="comment">// 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K,V&gt; &amp;value)</span></span>;  <span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器插入一个区间的元素。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">emplace</span> <span class="params">(...)</span></span>;  <span class="comment">// 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">例：mm.<span class="built_in">emplace</span>(piecewise_construct, forward_as_tuple(<span class="number">8</span>), forward_as_tuple(<span class="string">&quot;冰冰&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator pos,...)</span></span>; <span class="comment">// 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义，如果提示的位置是正确的，对性能有提升，如果提示的位置不正确，性能反而略有下降，但是，插入是否成功与该参数元关。该参数常用end()和begin()。成功返回新插入元素的迭代器；如果元素已经存在，则插入失败，返回现有元素的迭代器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K &amp; key)</span></span>;  <span class="comment">// 从容器中删除指定key的元素，返回已删除元素的个数。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;  <span class="comment">// 用迭代器删除元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器删除一个区间的元素，返回下一个有效的迭代器。</span></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>        <span class="comment">// 超女类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;   <span class="comment">// 超女姓名。</span></span><br><span class="line"><span class="type">int</span>      m_age;       <span class="comment">// 超女年龄。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*CGirl() : m_age(0) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;默认构造函数。\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> string name, <span class="type">const</span> <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个参数的构造函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp; g) : <span class="built_in">m_name</span>(g.m_name), <span class="built_in">m_age</span>(g.m_age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//map&lt;int, CGirl&gt; mm;</span></span><br><span class="line"><span class="comment">//mm.insert     (pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">//mm.insert     (make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">//mm.emplace(pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">//mm.emplace(make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">//mm.emplace(8, CGirl(&quot;冰冰&quot;, 18));                                             // 一次构造函数，一次拷贝构造函数。</span></span><br><span class="line"><span class="comment">//mm.emplace(8, &quot;冰冰&quot;, 18);                                                        // 错误。</span></span><br><span class="line"><span class="comment">//mm.emplace(piecewise_construct, forward_as_tuple(8), forward_as_tuple(&quot;冰冰&quot;, 18));  // 一次构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (const auto&amp; val : mm)</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; val.first &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;  &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）void insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  // 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125;&#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123; <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span>), <span class="built_in">make_pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;金莲&quot;</span>), &#123;<span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span>&#125;&#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">18</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）pair&lt;iterator,bool&gt; insert(const pair&lt;K,V&gt; &amp;value);  </span></span><br><span class="line"><span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="keyword">auto</span> ret = m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">18</span>, <span class="string">&quot;花花&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (ret.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）void insert(iterator first, iterator last);  // 用迭代器插入一个区间的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）pair&lt;iterator, bool&gt; emplace(...);  </span></span><br><span class="line"><span class="comment">// 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。</span></span><br><span class="line"><span class="comment">// 返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="keyword">auto</span> ret1 = m.<span class="built_in">emplace</span>(<span class="number">20</span>, <span class="string">&quot;花花&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret1.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret1.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret1.first-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5）iterator emplace_hint(const_iterator pos, ...); </span></span><br><span class="line"><span class="comment">// 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义，如果提示的位置是正确的，</span></span><br><span class="line"><span class="comment">// 对性能有提升，如果提示的位置不正确，性能反而略有下降，但是，插入是否成功与该参数元关。</span></span><br><span class="line"><span class="comment">// 该参数常用end()和begin()。成功返回新插入元素的迭代器；如果元素已经存在，则插入失败，返回现</span></span><br><span class="line"><span class="comment">// 有元素的迭代器。</span></span><br><span class="line">m.<span class="built_in">emplace_hint</span>(m.<span class="built_in">begin</span>(), piecewise_construct, forward_as_tuple(<span class="number">23</span>), forward_as_tuple(<span class="string">&quot;冰棒&quot;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="unordered-map容器"><a href="#unordered-map容器" class="headerlink" title="unordered_map容器"></a>unordered_map容器</h2><ul><li>unordered_map容器封装了哈希表，查找、插入和删除元素时，只需要比较几次key的值。</li><li>包含头文件： <code>#include&lt;unordered_map&gt;</code></li><li>unordered_map容器的元素是pair键值对。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unordered_map类模板的声明：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">_Hasher</span> = hash&lt;K&gt;, <span class="keyword">class</span> _Keyeq = equal_to&lt;K&gt;,</span><br><span class="line">    <span class="keyword">class</span> _Alloc = allocator&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_map : <span class="keyword">public</span> _Hash&lt;_Umap_traits&lt;K, V, _Uhash_compare&lt;K, _Hasher, _Keyeq&gt;, _Alloc, <span class="literal">false</span>&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建std::unordered_map类模板的别名：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> K,<span class="keyword">class</span> V&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>第一个模板参数K：key的数据类型（pair.first）</li><li>第二个模板参数V：value的数据类型（pair.second）</li><li>第三个模板参数_Hasher：哈希函数，默认值为<code>std::hash&lt;K&gt;</code></li><li>第四个模板参数_Keyeq：比较函数，用于判断两个key是否相等，默认值是<code>std::equal_to&lt;K&gt;</code></li><li>第五个模板参数_Alloc：分配器，缺省用new和delete</li></ul><h3 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">umap</span>();  <span class="comment">// 创建一个空的umap容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">umap</span>(<span class="type">size_t</span> bucket);  <span class="comment">// 创建一个空的umap容器，指定了桶的个数，下同。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">umap</span>(initializer_list&lt;pair&lt;K,V&gt;&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">umap</span>(initializer_list&lt;pair&lt;K,V&gt;&gt; il, <span class="type">size_t</span> bucket); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">umap</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建umap容器。</span></span><br><span class="line"><span class="number">6</span>）<span class="built_in">umap</span>(Iterator first, Iterator last, <span class="type">size_t</span> bucket);  <span class="comment">// 用迭代器创建umap容器。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">umap</span>(<span class="type">const</span> umap&lt;K,V&gt;&amp; m);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">8</span>）<span class="built_in">umap</span>(umap&lt;K,V&gt;&amp;&amp; m);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1）umap();  // 创建一个空的map容器。</span></span><br><span class="line">umap&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）umap(initializer_list&lt;pair&lt;K, V&gt;&gt; il); // 使用统一初始化列表。</span></span><br><span class="line"><span class="function">umap&lt;<span class="type">int</span>, string&gt; <span class="title">m2</span><span class="params">(&#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="number">7</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125;)</span></span>;</span><br><span class="line"><span class="comment">// umap&lt;int, string&gt; m2=&#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line"><span class="comment">// umap&lt;int, string&gt; m2   &#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m2)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）umap(const map&lt;K, V&gt;&amp;m);  // 拷贝构造函数。</span></span><br><span class="line">umap&lt;<span class="type">int</span>, string&gt; m3 = m2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m3)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）umap(Iterator first, Iterator last);  // 用迭代器创建map容器。</span></span><br><span class="line"><span class="keyword">auto</span> first = m3.<span class="built_in">begin</span>();  first++;</span><br><span class="line"><span class="keyword">auto</span> last = m3.<span class="built_in">end</span>();  last--;</span><br><span class="line"><span class="function">umap&lt;<span class="type">int</span>, string&gt; <span class="title">m4</span><span class="params">(first, last)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m4)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5）umap(map&lt;K, V&gt; &amp;&amp; m);  // 移动构造函数（C++11标准）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性操作-4"><a href="#特性操作-4" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 返回容器中元素的个数。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function"><span class="type">size_t</span> <span class="title">max_bucket_count</span><span class="params">()</span></span>;     <span class="comment">// 返回容器底层最多可以使用多少桶，无意义。</span></span><br><span class="line"><span class="number">5</span>）<span class="function"><span class="type">size_t</span> <span class="title">bucket_count</span><span class="params">()</span></span>;          <span class="comment">// 返回容器桶的数量，空容器有8个桶。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">float</span> <span class="title">load_factor</span><span class="params">()</span></span>;   <span class="comment">// 返回容器当前的装填因子，load_factor() = size() / bucket_count()。</span></span><br><span class="line"><span class="number">7</span>）<span class="function"><span class="type">float</span> <span class="title">max_load_factor</span><span class="params">()</span></span>;        <span class="comment">// 返回容器的最大装填因子，达到该值后，容器将扩充，缺省为1。</span></span><br><span class="line"><span class="number">8</span>）<span class="function"><span class="type">void</span> <span class="title">max_load_factor</span> <span class="params">(<span class="type">float</span> z )</span></span>; <span class="comment">// 设置容器的最大装填因子。</span></span><br><span class="line"><span class="number">9</span>）<span class="function">iterator <span class="title">begin</span><span class="params">(<span class="type">size_t</span> n)</span></span>;        <span class="comment">// 返回第n个桶中第一个元素的迭代器。</span></span><br><span class="line"><span class="number">10</span>）<span class="function">iterator <span class="title">end</span><span class="params">(<span class="type">size_t</span> n)</span></span>;          <span class="comment">// 返回第n个桶中最后一个元素尾后的迭代器。</span></span><br><span class="line"><span class="number">11</span>）<span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span>;          <span class="comment">// 将容器设置为至少n个桶。</span></span><br><span class="line"><span class="number">12</span>）<span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">(<span class="type">size_t</span> n)</span></span>;           <span class="comment">// 将桶的数量调整为&gt;=n。如果n大于当前容器的桶数，该方法会将容器重新哈希；如果n的值小于当前容器的桶数，该方法可能没有任何作用。</span></span><br><span class="line"><span class="number">13</span>）<span class="function"><span class="type">size_t</span> <span class="title">bucket_size</span><span class="params">(<span class="type">size_t</span> n)</span></span>;     <span class="comment">// 返回第n个桶中元素的个数，0 &lt;= n &lt; bucket_count()。</span></span><br><span class="line"><span class="number">14</span>）<span class="function"><span class="type">size_t</span> <span class="title">bucket</span><span class="params">(K &amp;key)</span></span>;          <span class="comment">// 返回值为key的元素对应的桶的编号。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元素操作-3"><a href="#元素操作-3" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K key);             <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="type">const</span> V &amp;<span class="keyword">operator</span>[](K key) <span class="type">const</span>;  <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K key)</span></span>;                     <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> V &amp;<span class="title">at</span><span class="params">(K key)</span> <span class="type">const</span></span>;         <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">umap&lt;string, string&gt; <span class="title">m</span><span class="params">( &#123; &#123; <span class="string">&quot;08&quot;</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="string">&quot;03&quot;</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="string">&quot;01&quot;</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="string">&quot;07&quot;</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="string">&quot;05&quot;</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m[08]=&quot;</span> &lt;&lt; m[<span class="string">&quot;08&quot;</span>] &lt;&lt; endl;     <span class="comment">// 显示key为08的元素的value。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m[09]=&quot;</span> &lt;&lt; m[<span class="string">&quot;09&quot;</span>] &lt;&lt; endl;    <span class="comment">// 显示key为09的元素的value。key为09的元素不存在，将添加新的键值对。</span></span><br><span class="line">m[<span class="string">&quot;07&quot;</span>] = <span class="string">&quot;花花&quot;</span>;                                          <span class="comment">// 把key为07的元素的value修改为花花。</span></span><br><span class="line">m[<span class="string">&quot;12&quot;</span>] = <span class="string">&quot;小乔&quot;</span>;                                          <span class="comment">// 将添加新的键值对。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="赋值操作-4"><a href="#赋值操作-4" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给已存在的容器赋值，将覆盖容器中原有的内容。</span><br><span class="line"><span class="number">1</span>）umap&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> umap&lt;K,V&gt;&amp; m);       <span class="comment">// 把容器m赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）umap&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  <span class="comment">// 用统一初始化列表给容器赋值。</span></span><br></pre></td></tr></table></figure><h3 id="交换操作-3"><a href="#交换操作-3" class="headerlink" title="交换操作"></a>交换操作</h3><ul><li><code>void swap(umap&lt;K,V&gt;&amp; m);</code>    &#x2F;&#x2F; 把当前容器与m交换。</li><li>交换的是树的根结点。</li></ul><h3 id="比较操作-4"><a href="#比较操作-4" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> umap&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> umap&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找操作-2"><a href="#查找操作-2" class="headerlink" title="查找操作"></a>查找操作</h3><p><strong>查找键值为key的键值对</strong><br>在umap容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span>; </span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure><p><strong>统计键值对的个数</strong><br>统计umap容器中键值为key的键值对的个数。</p><ul><li><code>size_t count(const K &amp;key) const;</code></li></ul><h3 id="插入和删除-3"><a href="#插入和删除-3" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(initializer_list&lt;pair&lt;K,V&gt;&gt; il)</span></span>;  <span class="comment">// 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K,V&gt; &amp;value)</span></span>;  <span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器插入一个区间的元素。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">emplace</span> <span class="params">(...)</span></span>;  <span class="comment">// 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">例：mm.<span class="built_in">emplace</span>(piecewise_construct, forward_as_tuple(<span class="number">8</span>), forward_as_tuple(<span class="string">&quot;冰冰&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator pos,...)</span></span>; <span class="comment">// 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义。对哈希容器来说，此函数意义不大。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K &amp; key)</span></span>;  <span class="comment">// 从容器中删除指定key的元素，返回已删除元素的个数。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;  <span class="comment">// 用迭代器删除元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器删除一个区间的元素，返回下一个有效的迭代器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>        <span class="comment">// 超女类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;   <span class="comment">// 超女姓名。</span></span><br><span class="line"><span class="type">int</span>      m_age;       <span class="comment">// 超女年龄。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*CGirl() : m_age(0) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;默认构造函数。\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> string name, <span class="type">const</span> <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个参数的构造函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; g) : <span class="built_in">m_name</span>(g.m_name), <span class="built_in">m_age</span>(g.m_age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//umap&lt;int, CGirl&gt; mm;</span></span><br><span class="line"><span class="comment">////mm.insert     (pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">////mm.insert     (make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">////mm.emplace(pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">////mm.emplace(make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line"><span class="comment">////mm.emplace(8, CGirl(&quot;冰冰&quot;, 18));                                             // 一次构造函数，一次拷贝构造函数。</span></span><br><span class="line"><span class="comment">////// mm.emplace(8, &quot;冰冰&quot;, 18);                                                        // 错误。</span></span><br><span class="line"><span class="comment">//mm.emplace(piecewise_construct, forward_as_tuple(8), forward_as_tuple(&quot;冰冰&quot;, 18));  // 一次构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (const auto&amp; val : mm)</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; val.first &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;  &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"></span><br><span class="line">umap&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）void insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  // 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125; &#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123; <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span>), <span class="built_in">make_pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;金莲&quot;</span>), &#123;<span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span>&#125; &#125;);</span><br><span class="line">m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">18</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）pair&lt;iterator,bool&gt; insert(const pair&lt;K,V&gt; &amp;value);  </span></span><br><span class="line"><span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="keyword">auto</span> ret = m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">18</span>, <span class="string">&quot;花花&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (ret.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）void insert(iterator first, iterator last);  // 用迭代器插入一个区间的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）pair&lt;iterator, bool&gt; emplace(...);  </span></span><br><span class="line"><span class="comment">// 将创建新键值对所需的数据作为参数直接传入，umap容器将直接构造元素。</span></span><br><span class="line"><span class="comment">// 返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="keyword">auto</span> ret1 = m.<span class="built_in">emplace</span>(<span class="number">20</span>, <span class="string">&quot;花花&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret1.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret1.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret1.first-&gt;second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5）iterator emplace_hint(const_iterator pos, ...); </span></span><br><span class="line">m.<span class="built_in">emplace_hint</span>(m.<span class="built_in">begin</span>(), piecewise_construct, forward_as_tuple(<span class="number">23</span>), forward_as_tuple(<span class="string">&quot;冰棒&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><ul><li>queue容器的逻辑结构是队列，物理结构可以是数组或链表，主要用于多线程之间的数据共享。</li><li>包含头文件： <code>#include&lt;queue&gt;</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue类模板的声明：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">_Container</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>第一个模板参数T：元素的数据类型。</li><li>第二个模板参数_Container：底层容器的类型，缺省是std::deque，可以用std::list，还可以用自定义的类模板。</li><li>queue容器不支持迭代器</li></ul><h3 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">queue</span>();  <span class="comment">// 创建一个空的队列。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">queue</span>(<span class="type">const</span> queue&lt;T&gt;&amp; q);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">queue</span>(queue&lt;T&gt;&amp;&amp; q);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line">析构函数~<span class="built_in">queue</span>()释放内存空间。</span><br></pre></td></tr></table></figure><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 元素入队。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">emplace</span><span class="params">(…)</span></span>;           <span class="comment">// 元素入队，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 返回队列中元素的个数。</span></span><br><span class="line"><span class="number">4</span>）<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 判断队列是否为空。</span></span><br><span class="line"><span class="number">5</span>）<span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;                 <span class="comment">// 返回队头元素。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;           <span class="comment">// 返回队头元素，只读。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;                 <span class="comment">// 返回队尾元素。</span></span><br><span class="line"><span class="number">8</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;           <span class="comment">// 返回队头元素，只读。</span></span><br><span class="line"><span class="number">9</span>）<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;                <span class="comment">// 出队，删除队头的元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">girl</span>       <span class="comment">// 超女类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_bh;             <span class="comment">// 编号。</span></span><br><span class="line">string m_name;  <span class="comment">// 姓名。</span></span><br><span class="line"><span class="built_in">girl</span>(<span class="type">const</span> <span class="type">int</span>&amp; bh, <span class="type">const</span> string&amp; name) : <span class="built_in">m_bh</span>(bh), <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// template &lt;class T, class _Container = deque&lt;T&gt;&gt;</span></span><br><span class="line"><span class="comment">// class queue &#123;</span></span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 第一个模板参数T：元素的数据类型。</span></span><br><span class="line"><span class="comment">// 第二个模板参数_Container：底层容器的类型，缺省是std::deque，可以用std::list，还可以用自定义的类模板。</span></span><br><span class="line"></span><br><span class="line">queue&lt;girl, list&lt;girl&gt;&gt; q;          <span class="comment">// 物理结构为链表。</span></span><br><span class="line"><span class="comment">//queue&lt;girl, deque&lt;girl&gt;&gt; q;    // 物理结构为数组。</span></span><br><span class="line"><span class="comment">//queue&lt;girl&gt; q;                           // 物理结构为数组。</span></span><br><span class="line"><span class="comment">//queue&lt;girl, vector&lt;girl&gt;&gt; q;    // 物理结构为vector，不可以。</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">girl</span>(<span class="number">3</span>, <span class="string">&quot;西施&quot;</span>));   <span class="comment">// 效率不高。</span></span><br><span class="line">q.<span class="built_in">emplace</span>(<span class="number">8</span>, <span class="string">&quot;冰冰&quot;</span>);     <span class="comment">// 效率更高。</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">girl</span>(<span class="number">5</span>, <span class="string">&quot;幂幂&quot;</span>));</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">girl</span>(<span class="number">2</span>, <span class="string">&quot;西瓜&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;编号：&quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_bh &lt;&lt; <span class="string">&quot;，姓名：&quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_name &lt;&lt; endl;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）queue &amp;<span class="keyword">operator</span>=(<span class="type">const</span> queue&lt;T&gt; &amp;q);    <span class="comment">// 赋值。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(queue&lt;T&gt; &amp;q)</span></span>;    <span class="comment">// 交换。</span></span><br><span class="line"><span class="number">3</span>）<span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> queue&lt;T&gt; &amp; q) <span class="type">const</span>; <span class="comment">// 重载==操作符。</span></span><br><span class="line"><span class="number">4</span>）<span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> queue&lt;T&gt; &amp; q) <span class="type">const</span>; <span class="comment">// 重载!=操作符。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="STL其它容器"><a href="#STL其它容器" class="headerlink" title="STL其它容器"></a>STL其它容器</h2><h3 id="array（静态数组）"><a href="#array（静态数组）" class="headerlink" title="array（静态数组）"></a>array（静态数组）</h3><p><strong>物理结构</strong><br>在栈上分配内存，创建数组的时候，数组长度必须是常量，创建后的数组大小不可变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">array</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T elems_[size]; </span><br><span class="line">……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>迭代器</strong>：随机访问迭代器。<br><strong>特点</strong>：部分场景中，比常规数组更方便（能用于模板），可以代替常规数组。<br><strong>各种操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span>;     <span class="comment">// 给数组填充值（清零）。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;               <span class="comment">// 返回数组的大小。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 无意义。</span></span><br><span class="line"><span class="number">4</span>）T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n); </span><br><span class="line"><span class="number">5</span>）<span class="type">const</span> T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;  <span class="comment">// 只读。</span></span><br><span class="line"><span class="number">6</span>）<span class="function">T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="number">7</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;          <span class="comment">// 只读。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">T *<span class="title">data</span><span class="params">()</span></span>;            <span class="comment">// 返回数组的首地址。</span></span><br><span class="line"><span class="number">9</span>）<span class="function"><span class="type">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回数组的首地址。</span></span><br><span class="line"><span class="number">10</span>）<span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;          <span class="comment">// 第一个元素。</span></span><br><span class="line"><span class="number">11</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;    <span class="comment">// 第一个元素，只读。</span></span><br><span class="line"><span class="number">12</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;    <span class="comment">// 最后一个元素，只读。</span></span><br><span class="line"><span class="number">13</span>）<span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;        <span class="comment">// 最后一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">////void func(int arr[][6],int len)</span></span><br><span class="line"><span class="comment">//void func(int (* arr)[6], int len)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//for (int ii = 0; ii &lt; len; ii++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//for (int jj = 0; jj &lt; 6; jj++)</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; arr[ii][jj] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void func(const array &lt; array&lt;int, 5&gt;, 10 &gt;&amp; arr)  </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//for (int ii = 0; ii &lt; arr.size(); ii++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//for (int jj = 0; jj &lt; arr[ii].size(); jj++)</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; arr[ii][jj] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; arr.<span class="built_in">size</span>(); ii++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; arr[ii].<span class="built_in">size</span>(); jj++)</span><br><span class="line">cout &lt;&lt; arr[ii][jj] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int aa[11] = &#123;1,2,3,4,5,6,7,8,9,10,11&#125;;         // 一维数组。</span></span><br><span class="line"><span class="comment">//array&lt;int, 10&gt; aa = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;         // 一维数组。</span></span><br><span class="line"><span class="comment">//for (int ii = 0; ii &lt; 10; ii++)            // 传统的方法。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; aa[ii] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//for (int ii = 0; ii &lt; aa.size(); ii++)  // 利用array的size()方法。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; aa[ii] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//for (auto it= aa.begin(); it &lt; aa.end(); it++)      // 使用迭代器。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (auto val : aa)                           // 基于范围的for循环。</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//int bb[10][6];</span></span><br><span class="line"><span class="comment">//for (int ii = 0; ii &lt; 10; ii++)  // 对二维数组赋值。</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//for (int jj = 0; jj &lt; 6; jj++)</span></span><br><span class="line"><span class="comment">//bb[ii][jj] = jj * 10 + ii;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func(bb,10);  // 把二维数组传给函数。</span></span><br><span class="line"></span><br><span class="line">array&lt; array&lt;<span class="type">int</span>, 5&gt;, 10 &gt; bb;  <span class="comment">// 二维数组，相当于int bb[10][5]。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; bb.<span class="built_in">size</span>(); ii++)  <span class="comment">// 对二维数组赋值。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; bb[ii].<span class="built_in">size</span>(); jj++)</span><br><span class="line">bb[ii][jj] = jj * <span class="number">10</span> + ii;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(bb);  <span class="comment">// 把二维数组传给函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="deque（双端队列）"><a href="#deque（双端队列）" class="headerlink" title="deque（双端队列）"></a>deque（双端队列）</h3><p>![[Pasted image 20231225163854.png]]<br><strong>物理结构</strong></p><ul><li>deque容器存储数据的空间是多段等长的连续空间构成，各段空间之间并不一定是连续的。</li><li>为了管理这些连续空间的分段，deque容器用一个数组存放着各分段的首地址。<br>![[Pasted image 20231225163918.png]]</li><li>通过建立数组，deque容器的分段的连续空间能实现整体连续的效果。</li><li>当deque容器在头部或尾部增加元素时，会申请一段新的连续空间，同时在数组中添加指向该空间的指针。<br><strong>迭代器</strong>：随机访问迭代器。<br><strong>特点</strong></li><li>提高了在两端插入和删除元素的效率，扩展空间的时候，不需要拷贝以前的元素。</li><li>在中间插入和删除元素的效率比vector更糟糕。</li><li>随机访问的效率比vector容器略低。<br><strong>各种操作</strong>：与vector容器相同。</li></ul><h3 id="forward-list（单链表）"><a href="#forward-list（单链表）" class="headerlink" title="forward_list（单链表）"></a>forward_list（单链表）</h3><ul><li>物理结构：单链表。</li><li>迭代器：正向迭代器。</li><li>特点<ul><li>比双链表少了一个指针，可节省一丢丢内存，减少了两次对指针的赋值操作。</li></ul></li><li>如果单链表能满足业务需求，建议使用单链表而不是双链表。</li><li>各种操作：与list容器相同。</li></ul><h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><ul><li>底层是红黑树</li><li>multimap和map的区别在：multimap允许关键字重复，而map不允许重复。</li><li>各种操作与map容器相同。</li></ul><h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&amp;multiset"></a>set&amp;multiset</h3><ul><li>底层是红黑树</li><li>set和map的区别在：map中存储的是键值对，而set只保存关键字</li><li>multiset和set的区别在：multiset允许关键字重复，而set不允许重复</li><li>各种操作与map容器相同</li></ul><h3 id="unordered-set-unordered-multiset"><a href="#unordered-set-unordered-multiset" class="headerlink" title="unordered_set&amp;unordered_multiset"></a>unordered_set&amp;unordered_multiset</h3><ul><li>底层是哈希表。</li><li>unordered_set和unordered_map的区别在：unordered_map中存储的是键值对，而unordered_set只保存关键字。</li><li>unordered_multiset和unordered_set的区别在：unordered_multiset允许关键字重复，而unordered_set不允许重复。</li><li>各种操作与unordered_map容器相同。</li></ul><h3 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" class="headerlink" title="priority_queue（优先队列）"></a>priority_queue（优先队列）</h3><ul><li>优先级队列相当于一个有权值的单向队列queue，在这个队列中，所有元素是按照优先级排列的。</li><li>底层容器可以用deque和list。</li><li>各种操作与queue容器相同。</li></ul><h3 id="stack（栈）"><a href="#stack（栈）" class="headerlink" title="stack（栈）"></a>stack（栈）</h3><ul><li>底层容器可以用deque和list。</li></ul><h1 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h1><p>STL提供了很多处理容器的函数模板，它们的设计是相同的，有以下特点：</p><ul><li>用迭代器表示需要处理数据的区间。</li><li>返回迭代器放置处理数据的结果（如果有结果）。</li><li>接受一个函数对象参数（结构体模板），用于处理数据（如果需要）</li></ul><h2 id="函数的对象"><a href="#函数的对象" class="headerlink" title="函数的对象"></a>函数的对象</h2><p>很多STL算法都使用函数对象，也叫函数符（functor），包括函数名、函数指针和仿函数。<br>函数符的概念：</p><ul><li>生成器（generator）：不用参数就可以调用的函数符。</li><li>一元函数（unary function）：用一个参数可以调用的函数符。</li><li>二元函数（binary function）：用两个参数可以调用的函数符。</li><li>改进的概念：<ul><li>一元谓词（predicate）：返回bool值的一元函数。</li><li>二元谓词（binary predicate）：返回bool值的二元函数。</li></ul></li></ul><h2 id="预定义的函数对象"><a href="#预定义的函数对象" class="headerlink" title="预定义的函数对象"></a>预定义的函数对象</h2><ul><li>STL定义了多个基本的函数符，用于支持STL的算法函数。</li><li>包含头文件：<code>#include &lt;functional&gt;</code><br>![[Pasted image 20231225164701.png]]</li></ul><h2 id="算法函数"><a href="#算法函数" class="headerlink" title="算法函数"></a>算法函数</h2><p>STL将算法函数分成四组：<br>1）<strong>非修改式序列操作</strong>：对区间中的每个元素进行操作，这些操作不修改容器的内容。<br>2）<strong>修改式序列操作</strong>：对区间中的每个元素进行操作，这些操作可以容器的内容（可以修改值，也可以修改排列顺序）。<br>3）<strong>排序和相关操作</strong>：包括多个排序函数和其它各种函数，如集合操作。<br>4）<strong>通用数字运算</strong>：包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。通常，这些都是数组的操作特性，因此vector是最有可能使用这些操作的容器。<br>前三组在头文件<code>#include &lt;algorithm&gt;</code>中，第四组专用于数值数据，在<code>#include &lt;numeric&gt;</code>中。</p><p>![[Pasted image 20231225164902.png]]</p><p>![[Pasted image 20231225164911.png]]![[Pasted image 20231225164918.png]]![[Pasted image 20231225164929.png]]![[Pasted image 20231225164945.png]]<br>1）如果容器有成员函数，则使用成员函数，如果没有才考虑用STL的算法函数。<br>2）把全部的STL算法函数过一遍，知道大概有些什么东西。<br>3）如果打算采用某算法函数，一定要搞清楚它的原理，关注它的效率。<br>4）不要太看重这些算法函数，自己写一个也就那么回事。<br>5）不是因为简单，而是因为不常用</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li>具体示例见文档<br>1）for_each()遍历<br>2）find()遍历<br>3）find_if()遍历<br>4）find_not_if()遍历<br>5）sort()排序</li></ul><ol start="6"><li>for_each<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">girl</span>   &#123;</span><br><span class="line">T   m_yz;         <span class="comment">// 统计的颜值。</span></span><br><span class="line"><span class="type">int</span> m_count;   <span class="comment">// 符合条件的元素个数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">girl</span>(<span class="type">const</span> T yz) : <span class="built_in">m_yz</span>(yz), <span class="built_in">m_count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; yz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (yz==m_yz) m_count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span> &#125;;   <span class="comment">// 1-极漂亮；2-漂亮；3-普通；4-歪瓜裂枣</span></span><br><span class="line"></span><br><span class="line">girl&lt;<span class="type">int</span>&gt; g=for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), <span class="built_in">girl</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));       <span class="comment">// 按颜值统计超女人数。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;g.m_count=&quot;</span> &lt;&lt; g.m_count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li>STL的sort算法，数据量大时采用QuickSort(快速排序)，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort的递归调用带来过大的额外负荷，就改用InsertSort（插入排序）。如果递归层次过深，还会改用HeapSort（堆排序）。</li><li>适用于数组容器vector、string、deque（list容器有sort成员函数，红黑树和哈希表没有排序的说法）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变结构无人机仿真</title>
      <link href="/data.github.io/post/b7b02208.html"/>
      <url>/data.github.io/post/b7b02208.html</url>
      
        <content type="html"><![CDATA[<ul><li>[[soildworks#soildworks导出urdf|基本部署]]</li><li><a href="https://blog.csdn.net/weixin_51772802/article/details/129150396?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-1-129150396-blog-51417742.235%5Ev38%5Epc_relevant_anti_t3&spm=1001.2101.3001.4242.2&utm_relevant_index=4">ros小车寻纪教程</a></li></ul><h1 id="src控制"><a href="#src控制" class="headerlink" title="src控制"></a>src控制</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>新建src文件夹实现控制,新建control_joint.cpp<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/Float64.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>  *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);<span class="comment">//将当前程序的本地化环境设置为默认值</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;control_joint&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::Publisher right_front_joint3_InforPub = nh.<span class="built_in">advertise</span>&lt;std_msgs::Float64&gt;(<span class="string">&quot;/var_strc_uav/right_front_joint3_control/command&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    std_msgs::Float64 Left_Front_Joint3_Infor_Storage;</span><br><span class="line">    Left_Front_Joint3_Infor_Storage.data=<span class="number">0.0</span>;<span class="comment">//data是double类型</span></span><br><span class="line">    <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Left_Front_Joint3_Infor_Storage.data=<span class="number">0.0</span>;Left_Front_Joint3_Infor_Storage.data&lt;=<span class="number">1.5</span>;Left_Front_Joint3_Infor_Storage.data+=<span class="number">0.01</span>)</span><br><span class="line">        &#123;</span><br><span class="line">    right_front_joint3_InforPub.<span class="built_in">publish</span>(Left_Front_Joint3_Infor_Storage);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发送的消息:%f&quot;</span>,Left_Front_Joint3_Infor_Storage);</span><br><span class="line">    r.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Left_Front_Joint3_Infor_Storage.data=<span class="number">1.5</span>;Left_Front_Joint3_Infor_Storage.data&gt;=<span class="number">0.0</span>;Left_Front_Joint3_Infor_Storage.data-=<span class="number">0.01</span>)</span><br><span class="line">        &#123;</span><br><span class="line">    right_front_joint3_InforPub.<span class="built_in">publish</span>(Left_Front_Joint3_Infor_Storage);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发送的消息:%f&quot;</span>,Left_Front_Joint3_Infor_Storage);</span><br><span class="line">    r.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>按照之前的教程，catkin_make,cpp文件回报错，就是roscpp配置问题（还未直接解决）</li><li>所以，我们将现有的var_strc_uav文件夹复制一份（只有第一次编译通过才这样做）</li><li>在catkin_ws&#x2F;src路径下输入命令,创建包<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg var_strc_uav roscpp std_msgs roslaunch controller_manager gazebo_ros gazebo_ros_control joint_state_publisher robot_state_publisher roscpp rospy xacro</span><br></pre></td></tr></table></figure></li><li>接着将原来的文件除了CMakeList.txt和package.xml文件的其他文件都复制过来</li><li>然后在CMakeList.txt文件中写入<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在build注释后面添加</span></span><br><span class="line"><span class="keyword">add_executable</span>(control_joint src/control_joint.cpp) <span class="comment">#将之生成可执行文件</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(control_joint <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#指定库以链接库或可执行目标</span></span><br></pre></td></tr></table></figure></li><li>最后编译</li><li>输入命令：<code>roslaunch var_strc_uav gazebo_test.launch</code>和<code>rosrun var_strc_uav control_joint1</code>即可运行控制</li></ul><h1 id="搭建时的记录"><a href="#搭建时的记录" class="headerlink" title="搭建时的记录"></a>搭建时的记录</h1><ul><li><a href="https://blog.csdn.net/Lovely_him/article/details/107806662">控制器讲解</a></li><li>可以通过<strong>rqt_graph</strong>去查看当前节点的状态关系<ul><li>rosrun rqt_gui rqt_gui用rqt_gui查看<ul><li>在里面可以发布话题信息</li></ul></li></ul></li><li>rostopic可以查看当前话题<ul><li>rostopic echo 话题,就可以查看当前话题信息</li></ul></li></ul><h4 id="gazebo插件编写"><a href="#gazebo插件编写" class="headerlink" title="gazebo插件编写"></a>gazebo插件编写</h4><ul><li>[[gazebo_插件#gazebo插件|插件编写]]</li></ul><h3 id="PID调节"><a href="#PID调节" class="headerlink" title="PID调节"></a>PID调节</h3><p><strong>查看关节状态运动</strong></p><ul><li>rosrun rqt_gui rqt_gui</li><li>rosrun rqt_tf_tree rqt_tf_tree看tf树</li><li>在界面中Plugins-&gt;Visualization点击Plot,弹出框，接着在输入话题并点击加号即可查看对应信息(一般有数据如data才行)</li></ul><p><strong>动态调PID</strong></p><ul><li>在rqt_gui界面中Plugins-&gt;Configuration-&gt;Dynamic Reconfigure,可以输入来调节pid信息<br>![[Pasted image 20231108161908.png]]</li></ul><p>将文件转为sdf文件控制</p><h1 id="编写pid动态调参"><a href="#编写pid动态调参" class="headerlink" title="编写pid动态调参"></a>编写pid动态调参</h1><ul><li><a href="https://blog.csdn.net/Arcann/article/details/109720695?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170117028716800192284615%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170117028716800192284615&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109720695-null-null.142%5Ev96%5Epc_search_result_base6&utm_term=ros%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0&spm=1018.2226.3001.4187">来源</a></li><li>运行<code>rosrun pid updatePID_node.py</code>在srcipts下运行<br>新建功能包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd catkin_ws/src</span><br><span class="line">catkin_create_pkg pid roscpp rospy rosmsg std_msgs dynamic_reconfigure </span><br><span class="line">mkdir cfg</span><br></pre></td></tr></table></figure><p>在cfg中新建<strong>PID.cfg</strong></p><ul><li><p>动态调整参数入下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> roslib</span><br><span class="line"><span class="keyword">from</span> dynamic_reconfigure.parameter_generator_catkin <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">PACKAGE = <span class="string">&quot;pid&quot;</span>  <span class="comment">#功能包名</span></span><br><span class="line">roslib.load_manifest(PACKAGE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个参数生成器</span></span><br><span class="line">gen = ParameterGenerator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数说明，便于后续生成界面</span></span><br><span class="line"><span class="comment">#             参数名    类型               等级       参数描述             默认值        最小值         最大值</span></span><br><span class="line">gen.add(<span class="string">&quot;p&quot;</span>,double_t,<span class="number">0</span>,<span class="string">&quot;KP param.&quot;</span>,<span class="number">0.0</span>,-<span class="number">100.00</span>,<span class="number">100.00</span>)</span><br><span class="line">gen.add(<span class="string">&quot;i&quot;</span>,double_t,<span class="number">0</span>,<span class="string">&quot;KI param.&quot;</span>,<span class="number">0.0</span>,-<span class="number">100.00</span>,<span class="number">100.00</span>)</span><br><span class="line">gen.add(<span class="string">&quot;d&quot;</span>,double_t,<span class="number">0</span>,<span class="string">&quot;KD param.&quot;</span>,<span class="number">0.0</span>,-<span class="number">100.00</span>,<span class="number">100.00</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用生成器生成config配置文件</span></span><br><span class="line"><span class="comment">#                                   包名           节点名称    生成文件名</span></span><br><span class="line">exit(gen.generate(PACKAGE, PACKAGE, <span class="string">&quot;PID&quot;</span>))<span class="comment">#这里的PID会生成PIDConfig.py和PIDConfig.h，编译后</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将PID.cfg设置为可执行文件：chmod a+x PID.cfg</p></li><li><p>CMakeLists.txt添加,接着catkin_make编译（多编译几次）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generate_dynamic_reconfigure_options(</span><br><span class="line">cfg/PID.cfg<span class="comment"># 注意这里要填自己的路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>在scripts下新建updatePID_node.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入依赖</span></span><br><span class="line"><span class="keyword">from</span> pid.cfg <span class="keyword">import</span> PIDConfig     <span class="comment">#pid.cfg是定义的cfg文件，PIDConfig编译后的PIDConfig.py</span></span><br><span class="line"><span class="keyword">from</span> dynamic_reconfigure.server <span class="keyword">import</span> Server</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> Float32MultiArray</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdatePID</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        rospy.init_node(<span class="string">&quot;update_pid&quot;</span>)</span><br><span class="line">        rospy.on_shutdown(self.shutdown)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 执行频率</span></span><br><span class="line">        rate = rospy.Rate(<span class="number">20</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 声明一个消息发布者, 将消息发布到driver</span></span><br><span class="line">        self.publisher_pid = rospy.Publisher(<span class="string">&quot;/pid&quot;</span>, Float32MultiArray, queue_size=<span class="number">100</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 启动参数配置服务器         当参数变化时的回调</span></span><br><span class="line">        Server(PIDConfig, self.dynamic_callback)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印一个启动成功的日志</span></span><br><span class="line">        rospy.loginfo(<span class="string">&quot;updatePID_node start success! Bring up rqt_reconfigure to control the pid ...&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 让ros节点跑起来</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">            rate.sleep()</span><br><span class="line">            </span><br><span class="line"><span class="comment"># 通过回调函数中获取rqt界面上的数值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dynamic_callback</span>(<span class="params">self, config, level</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当参数发生变化时的回调函数</span></span><br><span class="line"><span class="string">        :param config: 配置文件</span></span><br><span class="line"><span class="string">        :param level: 修改的状态</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 封装消息</span></span><br><span class="line">        kp = config[<span class="string">&quot;p&quot;</span>]</span><br><span class="line">        ki = config[<span class="string">&quot;i&quot;</span>]</span><br><span class="line">        kd = config[<span class="string">&quot;d&quot;</span>]</span><br><span class="line"></span><br><span class="line">        pid_msg = Float32MultiArray()</span><br><span class="line">        pid_msg.data.append(kp)</span><br><span class="line">        pid_msg.data.append(ki)</span><br><span class="line">        pid_msg.data.append(kd)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将消息发布出去</span></span><br><span class="line">        self.publisher_pid.publish(pid_msg)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> (config, level)</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;stop robot ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    UpdatePID()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>给权限：chmod a+x updatePID_node.py</p></li><li><p>roscore,rosrun pid updatePID_node.py(在scripts下运行好)</p></li></ul><h2 id="对于c"><a href="#对于c" class="headerlink" title="对于c++"></a>对于c++</h2><ul><li>要把cfg文件弄好</li><li>在src文件夹下新建server.cpp</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dynamic_reconfigure/server.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pid/PIDConfig.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(pid::PIDConfig &amp;config, <span class="type">uint32_t</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Reconfigure Request: %f %f %f&quot;</span>,</span><br><span class="line">             config.p,</span><br><span class="line">             config.i,</span><br><span class="line">             config.d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pid_set&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dynamic_reconfigure::Server&lt;pid::PIDConfig&gt; server;</span><br><span class="line">    dynamic_reconfigure::Server&lt;pid::PIDConfig&gt;::CallbackType f;</span><br><span class="line"></span><br><span class="line">    f = boost::<span class="built_in">bind</span>(&amp;callback, _1, _2);</span><br><span class="line">    server.<span class="built_in">setCallback</span>(f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spinning node&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>CMakeLists.txt编写<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(pid_set src/server.cpp)<span class="comment">#描述将cpp变成velocity_publisher可执行文件,这里添加编译文件名的名称</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(pid_set <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li><li>编译后，运行roscore ,rosrun pid pid_set</li></ul><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/Float32.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dynamic_reconfigure/server.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pid/PIDConfig.h&gt;</span></span></span><br><span class="line"><span class="comment">//单个电机信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Joint_info</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    std::string topic_path_p;</span><br><span class="line">    std::string topic_path_i;</span><br><span class="line">    std::string topic_path_d;</span><br><span class="line">    std::string joint_name;</span><br><span class="line">    ros::Publisher joint_pub_p;</span><br><span class="line">    ros::Publisher joint_pub_i;</span><br><span class="line">    ros::Publisher joint_pub_d;</span><br><span class="line">    std_msgs::Float32 current_info_p;</span><br><span class="line">    std_msgs::Float32 current_info_i;</span><br><span class="line">    std_msgs::Float32 current_info_d;</span><br><span class="line">    <span class="built_in">Joint_info</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init_info</span><span class="params">(std::string joint_name,ros::NodeHandle nh)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_name=joint_name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;topic_path_p=<span class="string">&quot;/var_strc_uav/&quot;</span>+joint_name+<span class="string">&quot;/pid_p&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;topic_path_i=<span class="string">&quot;/var_strc_uav/&quot;</span>+joint_name+<span class="string">&quot;/pid_i&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;topic_path_d=<span class="string">&quot;/var_strc_uav/&quot;</span>+joint_name+<span class="string">&quot;/pid_d&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub_p=nh.<span class="built_in">advertise</span>&lt;std_msgs::Float32&gt;(<span class="keyword">this</span>-&gt;topic_path_p,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub_i=nh.<span class="built_in">advertise</span>&lt;std_msgs::Float32&gt;(<span class="keyword">this</span>-&gt;topic_path_i,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub_d=nh.<span class="built_in">advertise</span>&lt;std_msgs::Float32&gt;(<span class="keyword">this</span>-&gt;topic_path_d,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub_p.<span class="built_in">publish</span>(<span class="keyword">this</span>-&gt;current_info_p);</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub_i.<span class="built_in">publish</span>(<span class="keyword">this</span>-&gt;current_info_i);</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub_d.<span class="built_in">publish</span>(<span class="keyword">this</span>-&gt;current_info_d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arm_Motor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Joint_info motor1;</span><br><span class="line">    Joint_info motor2;</span><br><span class="line">    <span class="built_in">Arm_Motor</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init_info</span><span class="params">(std::string arm_name,ros::NodeHandle nh)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;motor1.<span class="built_in">Init_info</span>(arm_name+<span class="string">&quot;1&quot;</span>,nh);</span><br><span class="line">        <span class="keyword">this</span>-&gt;motor2.<span class="built_in">Init_info</span>(arm_name+<span class="string">&quot;2&quot;</span>,nh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        motor1.<span class="built_in">Pub</span>();</span><br><span class="line">        motor2.<span class="built_in">Pub</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">All_motor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Arm_Motor right_front;</span><br><span class="line">    Arm_Motor right_hind;</span><br><span class="line">    Arm_Motor left_hind;</span><br><span class="line">    Arm_Motor left_front;</span><br><span class="line">    pid::PIDConfig config;</span><br><span class="line">    <span class="built_in">All_motor</span>(std::string arm_name1,std::string arm_name2,std::string arm_name3,std::string arm_name4,ros::NodeHandle nh)&#123;</span><br><span class="line">        right_front.<span class="built_in">Init_info</span>(arm_name1,nh);</span><br><span class="line">        right_hind.<span class="built_in">Init_info</span>(arm_name2,nh);</span><br><span class="line">        left_hind.<span class="built_in">Init_info</span>(arm_name3,nh);</span><br><span class="line">        left_front.<span class="built_in">Init_info</span>(arm_name4,nh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Assign_Pid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_front.motor1.current_info_p.data=<span class="keyword">this</span>-&gt;config.right_front_joint1_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_front.motor1.current_info_i.data=<span class="keyword">this</span>-&gt;config.right_front_joint1_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_front.motor1.current_info_d.data=<span class="keyword">this</span>-&gt;config.right_front_joint1_d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_front.motor2.current_info_p.data=<span class="keyword">this</span>-&gt;config.right_front_joint2_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_front.motor2.current_info_i.data=<span class="keyword">this</span>-&gt;config.right_front_joint2_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_front.motor2.current_info_d.data=<span class="keyword">this</span>-&gt;config.right_front_joint2_d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;right_hind.motor1.current_info_p.data=<span class="keyword">this</span>-&gt;config.right_hind_joint1_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_hind.motor1.current_info_i.data=<span class="keyword">this</span>-&gt;config.right_hind_joint1_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_hind.motor1.current_info_d.data=<span class="keyword">this</span>-&gt;config.right_hind_joint1_d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_hind.motor2.current_info_p.data=<span class="keyword">this</span>-&gt;config.right_hind_joint2_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_hind.motor2.current_info_i.data=<span class="keyword">this</span>-&gt;config.right_hind_joint2_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right_hind.motor2.current_info_d.data=<span class="keyword">this</span>-&gt;config.right_hind_joint2_d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;left_hind.motor1.current_info_p.data=<span class="keyword">this</span>-&gt;config.left_hind_joint1_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_hind.motor1.current_info_i.data=<span class="keyword">this</span>-&gt;config.left_hind_joint1_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_hind.motor1.current_info_d.data=<span class="keyword">this</span>-&gt;config.left_hind_joint1_d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_hind.motor2.current_info_p.data=<span class="keyword">this</span>-&gt;config.left_hind_joint2_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_hind.motor2.current_info_i.data=<span class="keyword">this</span>-&gt;config.left_hind_joint2_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_hind.motor2.current_info_d.data=<span class="keyword">this</span>-&gt;config.left_hind_joint2_d;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;left_front.motor1.current_info_p.data=<span class="keyword">this</span>-&gt;config.left_front_joint1_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_front.motor1.current_info_i.data=<span class="keyword">this</span>-&gt;config.left_front_joint1_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_front.motor1.current_info_d.data=<span class="keyword">this</span>-&gt;config.left_front_joint1_d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_front.motor2.current_info_p.data=<span class="keyword">this</span>-&gt;config.left_front_joint2_p;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_front.motor2.current_info_i.data=<span class="keyword">this</span>-&gt;config.left_front_joint2_i;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left_front.motor2.current_info_d.data=<span class="keyword">this</span>-&gt;config.left_front_joint2_d;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">Assign_Pid</span>();</span><br><span class="line">        right_front.<span class="built_in">Pub</span>();</span><br><span class="line">        right_hind.<span class="built_in">Pub</span>();</span><br><span class="line">        left_front.<span class="built_in">Pub</span>();</span><br><span class="line">        left_hind.<span class="built_in">Pub</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(pid::PIDConfig &amp;config, <span class="type">uint32_t</span> level,All_motor&amp; all_motor)</span> </span>&#123;</span><br><span class="line">    all_motor.config=config;</span><br><span class="line">    all_motor.<span class="built_in">Pub</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pid_set&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="function">All_motor <span class="title">all_motor</span><span class="params">(<span class="string">&quot;right_front_joint&quot;</span>,<span class="string">&quot;right_hind_joint&quot;</span>,<span class="string">&quot;left_hind_joint&quot;</span>,<span class="string">&quot;left_front_joint&quot;</span>,nh)</span></span>;</span><br><span class="line">    dynamic_reconfigure::Server&lt;pid::PIDConfig&gt; server;<span class="comment">//创建参数服务器</span></span><br><span class="line">    dynamic_reconfigure::Server&lt;pid::PIDConfig&gt;::CallbackType f;<span class="comment">//回调函数类型变量</span></span><br><span class="line"></span><br><span class="line">    f = boost::<span class="built_in">bind</span>(&amp;callback, _1, _2,boost::<span class="built_in">ref</span>(all_motor));</span><br><span class="line">    server.<span class="built_in">setCallback</span>(f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spinning node&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>soildworks</title>
      <link href="/data.github.io/post/5d3e3d8b.html"/>
      <url>/data.github.io/post/5d3e3d8b.html</url>
      
        <content type="html"><![CDATA[<h1 id="模拟力学仿真计算"><a href="#模拟力学仿真计算" class="headerlink" title="模拟力学仿真计算"></a>模拟力学仿真计算</h1><ul><li><a href="https://blog.csdn.net/seek97/article/details/124368553">插件总结</a><ul><li>Motion 使用完整的运动性建模来计算零部件运动</li><li>SimulationXpress：一个简单形变仿真的向导，可以显示单个零件受力后的形变过程</li><li>simulation：静应力分析，拓扑优化等</li><li>Flow Simulation：研究流体力学</li></ul></li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ul><li>首先点击simulation 插件中的simulation premium，待标题栏出现simulation后点击图标</li><li>接着点击新算例，一般选择静应力分析，</li><li>先对应用材料信息进行设置（最好先在零件中完成设置）<ul><li>在零件编辑树中右键—材料—编辑材料，可自定义材料信息<br>![[Pasted image 20231020090729.png]]</li></ul></li><li>选择夹具顾问中的固定几何体，进而对零件某个面进行固定</li><li>点击运行此算例中的<strong>运行网格</strong>，网格密度一般选择中间（网格越密效果越好）</li><li>在外部载荷顾问中选择合适的力</li><li>点击运行此算例，接着就可以在结果一栏中看到分析结果<ul><li>有应变，位移应变分析,下图是放大了4000倍<br>![[Pasted image 20231020095505.png]]</li></ul></li><li>最终结果是看实际机械结构的最大应力，然后仿真结果进行对比，看是否超出范围</li></ul><h1 id="soildworks导出urdf"><a href="#soildworks导出urdf" class="headerlink" title="soildworks导出urdf"></a>soildworks导出urdf</h1><ul><li><a href="https://blog.csdn.net/lun55423/article/details/113859961#:~:text=%E5%AF%BC%E5%85%A5Gazebo%201%20%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%B0workspace%E7%9A%84src%E7%9B%AE%E5%BD%95%E4%B8%8B,2%20%E8%BF%94%E5%9B%9E%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E7%9B%AE%E5%BD%95%EF%BC%8Ccatkin_make%E7%BC%96%E8%AF%91%EF%BC%8Csource%E4%B8%80%E4%B8%8B%203%20%E8%BF%90%E8%A1%8Cgazebo.launch%E6%96%87%E4%BB%B6%EF%BC%8C%E5%AE%8C%E6%88%90">来源1</a></li><li><a href="https://www.cnblogs.com/vcan123/p/14264202.html">来源</a></li><li><a href="https://blog.csdn.net/shdhckcjc/article/details/129331111">细节</a></li><li>在装配装配体前首先设置好原点，这样可以保证初始的坐标系<ul><li>也就是装配体插入第一个零件时，先设置成浮动，接着使原点和零件中的原点重合</li><li>最后配合好的形状也就是urdf和gazebo中的初始状态模型</li><li>注意base_link的坐标要设置在与地面接触的地方，若在机身中会在gazebo中零件会不规律，报错</li></ul></li><li>首先先安装urdf插件</li><li>对于模型需要设置坐标系的零件来说，首先先设置好基准轴(旋转轴)<ul><li>插入—参考几何体—基准轴、坐标系</li><li>由于自动生成的坐标系可能有问题，所以说需要我们自己去设置基准轴，坐标系等</li><li>思路，先设置出基准轴，接着根据轴与平面(或者其他轴)相交产生一个点,根据这个点生成坐标系并调整。<ul><li>对于坐标系来说，需要限定两个方向才能将这个坐标系固定</li></ul></li></ul></li><li>工具—Tools—Export-URDF</li></ul><p><strong>设置坐标系</strong></p><ul><li>首先是base_link，最好将底座设置中心设置成原点<br>![[Pasted image 20231028103244.png]]</li><li>点击子节点进行设置即可，对于子节点，joint type设置的是旋转类型，后面添加的零件是该部分link的所有零件<ul><li><a href="https://blog.csdn.net/weixin_41420355/article/details/104310896">join标签详解</a></li><li><strong>添加的零件是绕着该旋转轴直接旋转的关节</strong>，最好添加完整，否则只会显示添加的零件，也就是让这个轴旋转的所有关节b，但b(b包含a)不包含以b为父关节的子关节a</li><li>Link代表骨骼，就是每一个部分。joint代表关节，就是两个关节的组合(以腿为例：Link_小腿，Link_大腿，组合成joint_膝盖)<br>![[Pasted image 20231028104404.png]]</li></ul></li></ul><table><thead><tr><th align="left">continuous</th><th align="left">一个不受限制的，绕着一根轴的转动副</th></tr></thead><tbody><tr><td align="left">revolute</td><td align="left">一个转动角度限制的，绕着一根轴的转动副</td></tr><tr><td align="left">prismatic</td><td align="left">一个沿着一根轴的滑动副，并有限位</td></tr><tr><td align="left">fixed</td><td align="left">固定关节</td></tr><tr><td align="left">Automatically Detect</td><td align="left">可以后面调整具体</td></tr><tr><td align="left">floating</td><td align="left">这个关节允许6个自由度运动，浮动关节</td></tr></tbody></table><p><strong>基本设置好后</strong></p><ul><li>√是保存模型信息(添加模型信息和命名后最好保存下)，添加坐标轴和坐标系最好最后添加（保存后再次打开会变成Automatically Generate），全部完成后点击Preview and Export…<br>![[Pasted image 20231028123338.png]]</li><li>接着会自动生成坐标系，因为生成的可能是错误的，如果是手动调整好的就不管，其中origin中的坐标是相对于上个坐标系的偏移与偏角。</li><li>点击next后，Inertial是电脑计算的惯性矩等信息，最终导出得到文件夹<br>![[Pasted image 20231028131321.png]]</li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>通过该插件去生成装配体的惯性矩阵有点问题，这样会在gazebo中仿真时会产生抖动问题</li><li><strong>urdf的惯性张量是相对于重心的惯性张量</strong></li><li><a href="https://blog.csdn.net/joyopirate/article/details/131102160?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170478771616800197011940%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=170478771616800197011940&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-131102160-null-null.142%5Ev99%5Epc_search_result_base2&utm_term=sw2urdf%E5%AF%BC%E5%87%BA%E7%9A%84urdf%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%83%AF%E6%80%A7%E5%8F%82%E6%95%B0(inertial)%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98&spm=1018.2226.3001.4187">问题说明与解决</a></li><li>如果我们对模型设置了覆盖物体质量(10g)，通过urdf方式导出的还是原来的质量(30g)，所以如果我要用覆盖的物体信息就需要我们手动设置</li></ul><h3 id="手动设置教程"><a href="#手动设置教程" class="headerlink" title="手动设置教程"></a>手动设置教程</h3><ul><li>首先通过上述操作导出得到urdf文件，接着我们修改惯性质量类型信息，在质量属性点击选项，按照下面设置<br>![[Pasted image 20240109192953.png]]</li><li>接着填入对应信息，选择该物体当前坐标系，在link处填入信息<br>![[Pasted image 20240109194605.png]]</li><li><strong>填信息时，ixx和iyy,izz就是原来的值，而ixy,ixz,iyz需要在数值上取个负号</strong></li><li>小于小数8位的我默认为0<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;inertial&gt;</span><br><span class="line">      &lt;origin</span><br><span class="line">        xyz=<span class="string">&quot;0 0 0.03874541&quot;</span></span><br><span class="line">        rpy=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span><br><span class="line">      &lt;mass</span><br><span class="line">        value=<span class="string">&quot;0.0107437191784595&quot;</span> /&gt;</span><br><span class="line">      &lt;inertia</span><br><span class="line">        ixx=<span class="string">&quot;3.364e-05&quot;</span></span><br><span class="line">        ixy=<span class="string">&quot;3.6e-07&quot;</span></span><br><span class="line">        ixz=<span class="string">&quot;0&quot;</span></span><br><span class="line">        iyy=<span class="string">&quot;2e-07&quot;</span></span><br><span class="line">        iyz=<span class="string">&quot;0&quot;</span></span><br><span class="line">        izz=<span class="string">&quot;3.374e-05&quot;</span> /&gt;</span><br><span class="line">    &lt;/inertial&gt;</span><br></pre></td></tr></table></figure></li><li>对于多个零件组成的能测量，把他们<strong>新建成子装配体</strong>就行了(记得提前保存)</li></ul><h2 id="urdf文件内容详解"><a href="#urdf文件内容详解" class="headerlink" title="urdf文件内容详解"></a>urdf文件内容详解</h2><ul><li><p><a href="https://blog.csdn.net/qq_41306193/article/details/122349085?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169872657416800180639152%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169872657416800180639152&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122349085-null-null.142%5Ev96%5Epc_search_result_base6&utm_term=urdf&spm=1018.2226.3001.4187">手写移动机器人urdf详解</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/407576104#:~:text=4.%20urdf%E7%AE%97%E6%83%AF%E9%87%8F%E5%BC%A0%E9%87%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%20Origin%E5%9D%90%E6%A0%87%E7%B3%BB%20%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E,%E5%BD%93%E5%89%8Djoint%E5%9D%90%E6%A0%87%E7%B3%BB%20%E7%9A%84%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E3%80%82%20%E5%B9%B6%E4%B8%94%E6%83%AF%E6%80%A7%E5%BC%A0%E9%87%8F%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%98%AF%E7%94%B1%E9%87%8D%E5%BF%83%E5%86%B3%E5%AE%9A%EF%BC%8C%E5%B9%B6%E4%B8%94xyz%E4%B8%89%E8%BD%B4%E6%96%B9%E5%90%91%E5%AF%B9%E9%BD%90Origin%E8%BE%93%E5%87%BA%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%88%E4%B8%80%E8%88%ACOrigin%E5%9D%90%E6%A0%87%E7%B3%BB%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E4%B8%8B%E5%8F%AA%E4%BC%9A%E5%9C%A8Joint%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%B9%B3%E7%A7%BB%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%B9%B3%E7%99%BD%E6%97%A0%E6%95%85%E8%BF%9B%E8%A1%8C%E5%86%8D%E6%AC%A1%E6%97%8B%E8%BD%AC%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%BD%93%E6%88%90%E5%AF%B9%E9%BD%90Joint%E5%9D%90%E6%A0%87%E7%B3%BB%EF%BC%89%E3%80%82%205.">URDF各参数设置备忘</a></p></li><li><p><strong>urdf中坐标系的对应关系是</strong>，<strong>当前joint坐标系是对上一个joint坐标系的变换，当前inertial坐标系是相对于当前joint坐标系的变化</strong>（是重心相对于当前坐标系的距离，<strong>urdf的惯性张量是相对于重心的惯性张量</strong>），当前visual坐标系是相对于当前joint坐标系的变换，当前collision坐标系是相对于当前joint坐标系的变换。</p></li><li><p><strong>这里的rpy变换一定要注意</strong>，是先按当前z轴（即上一级joint坐标系的z轴）进行旋转（rpy中y的值），然后绕变换以后的坐标系y轴进行变换（rpy中p的值），最后绕上一次绕y轴变换之后坐标系的x轴进行变换（rpy中r的值）。所以urdf的rpy变换，属于intrinsic范畴，按矩阵连乘表示，<strong>按照顺序——Z，Y，X</strong></p></li></ul><p>以var_strc_uav文件夹为例</p><ul><li>config：包含这joint_names_var_strc_uav.yaml文件，里面包含着关节名，config文件夹用以保存rviz的配置文件</li><li>launch：包含diaplay.launch(rviz启动)，gazebo.launch(gazebo启动)</li><li>meshes：包含着模型文件(stl格式)，防止urdf中引用的模型渲染文件</li><li>textures:</li><li>urdf：包含var_strc_uav.urdf和var_strc_uav.csv，可以存放机器人模型的urdf或者xacro文件文件</li><li>CmakeLists.txt：直接规定了这个功能包需要依赖哪些package，要编译生成哪些目标，如何编译等流程</li><li>package.xml：描述这个软件包的描述文件，包含了该功能包的名称、版本号、维护人员等信息。<ul><li>[[xml|xml基本用法]]</li></ul></li></ul><h3 id="urdf文件"><a href="#urdf文件" class="headerlink" title="urdf文件"></a>urdf文件</h3><ul><li><a href="https://blog.csdn.net/lc1852109/article/details/125916104">标签详解</a></li><li><a href="https://wiki.ros.org/urdf/XML">标签官网详解</a><br>使用命令：urdf_to_graphiz var_strc_uav.urdf可以看节点关系<br>![[Pasted image 20231110124855.png]]</li></ul><h4 id="添加robot标签"><a href="#添加robot标签" class="headerlink" title="添加robot标签"></a>添加robot标签</h4><ul><li>robot标签是用以描述整个机器人的。这里要注意的是xml语言中标签是要闭合的，要是不闭合的话后面是会报错误的<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;mbot&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>这里第一行是对xml语言的版本号进行描述，声明以下代码是使用xml语言进行编写的；mbot是所创建机器人模型的名称，在两个robot标签之间就可以添加模型配置参数了。</li></ul><h4 id="使用link标签创建模型"><a href="#使用link标签创建模型" class="headerlink" title="使用link标签创建模型"></a>使用link标签创建模型</h4><ul><li>link标签是用以描述机器人某个刚体部分的外观和物理属性的，其参数包括连杆尺寸（size）、颜色（color）、形状（shape）、惯性矩阵（inertial matrix）、碰撞参数（collision properties）等。</li><li><code>&lt;inertial&gt;</code>：描述了惯性信息，包括质量、质心位置和惯性矩阵。<ul><li><code>&lt;origin&gt;</code>：描述质心的位置和姿态。xyz属性是质心的位置，rpy是质心的姿态</li><li><code>&lt;mass&gt;</code>：描述链接的质量。</li><li><code>&lt;inertia&gt;</code>：描述链接的惯性矩阵。</li></ul></li><li><code>&lt;visual&gt;</code>：描述了链接的可视化外观。<ul><li><code>&lt;origin&gt;</code>：描述可视化外观的位置和姿态。</li><li><code>&lt;geometry&gt;</code>：描述可视化外观的几何形状。<ul><li><code>&lt;mesh&gt;</code>：描述链接的网格形状，其中”filename”属性指定了网格文件的路径。</li></ul></li><li><code>&lt;material&gt;</code>：描述了材质的外观属性。<ul><li>name属性：指定了材质的名称。</li><li><code>&lt;color&gt;</code>：描述了材质的颜色属性。</li><li>rgba属性：RGBA（红、绿、蓝、透明度）值通常在0到1之间取值。每个通道的取值范围是从0到1，其中0表示最小的颜色强度或透明度</li></ul></li></ul></li><li><code>&lt;collision&gt;</code>：描述链接的碰撞检测外观，用于物理交互模拟。<ul><li><code>&lt;origin&gt;</code>：描述碰撞检测外观的位置和姿态。</li><li><code>&lt;geometry&gt;</code>：描述碰撞检测外观的几何形状。<ul><li><code>&lt;mesh&gt;</code>：描述链接的网格形状，其中”filename”属性指定了网格文件的路径。</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;1.72914627334106E-06 1.14526384273527E-11 0.125972978720317&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mass</span></span></span><br><span class="line"><span class="tag">      <span class="attr">value</span>=<span class="string">&quot;1.30165543679935&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inertia</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ixx</span>=<span class="string">&quot;0.00224695292268191&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ixy</span>=<span class="string">&quot;-2.79132144572356E-11&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ixz</span>=<span class="string">&quot;1.31602008096035E-19&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">iyy</span>=<span class="string">&quot;0.00631415383644451&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">iyz</span>=<span class="string">&quot;-8.06503412892502E-20&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">izz</span>=<span class="string">&quot;0.00750920095649338&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">        <span class="attr">filename</span>=<span class="string">&quot;package://var_strc_uav/meshes/base_link.STL&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">material</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">color</span></span></span><br><span class="line"><span class="tag">        <span class="attr">rgba</span>=<span class="string">&quot;1 1 1 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mesh</span></span></span><br><span class="line"><span class="tag">        <span class="attr">filename</span>=<span class="string">&quot;package://var_strc_uav/meshes/base_link.STL&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="joint标签连接模型"><a href="#joint标签连接模型" class="headerlink" title="joint标签连接模型"></a>joint标签连接模型</h4><ul><li><code>&lt;joint&gt;</code>：描述了一个关节。<ul><li>name属性：指定了关节的名称，这里是”right_hind_joint5”。</li><li>type属性：指定了关节的类型，这里是”continuous”，表示关节可以无限制地旋转。</li></ul></li><li><code>&lt;origin&gt;</code>：描述了关节原点的位置和姿态。<ul><li>xyz属性：指定了关节原点的位置</li><li>rpy属性：指定了关节原点的姿态</li></ul></li><li><code>&lt;parent&gt;</code>：描述了该关节的父链接（parent link）。<ul><li>link属性：指定了父链接的名称，这里是”right_hind_link4”</li></ul></li><li><code>&lt;child&gt;</code>：描述了该关节的子链接（child link）<ul><li>link属性：指定了子链接的名称，这里是”right_hind_link5”</li></ul></li><li><code>&lt;axis&gt;</code>：描述了关节的旋转轴<ul><li>xyz属性：指定了旋转轴的方向，这里是(0, 0, -1)，表示绕Z轴逆时针旋转。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- continuous无限制角度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;right_hind_joint5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0.0682997475619318 -0.0101500000000048 0.0110000000000001&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">&quot;-1.5707963267949 -0.594899552273233 -1.5707963267949&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">&quot;right_hind_link4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">&quot;right_hind_link5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0 0 -1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">&lt;!-- revolute限制角度，与上面类似，只是多个下面的东西 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;right_front_joint1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;revolute&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">limit</span> <span class="attr">effort</span>=<span class="string">&quot;30&quot;</span> <span class="attr">velocity</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">lower</span>=<span class="string">&quot;-1.2&quot;</span> <span class="attr">upper</span>=<span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>对于齿轮连接可，就用<code>&lt;mimic&gt;</code>标签实现</p><ul><li>例子<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://ros.org/wiki/xacro&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my_robot&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;right_front_link2&quot;</span>&gt;</span></span><br><span class="line">    .....</span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;right_front_link5&quot;</span>&gt;</span></span><br><span class="line">    .....</span><br><span class="line">  <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;right_front_joint4&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0.184 0 0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">&quot;right_front_link2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">&quot;right_front_link4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加minic标签后，其实这里就直接通过right_front_joint3直接控制right_front_joint5了，在也就是..._joint3转一圈，...joint5转2圈 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于他们之间关系，如果这里的父节点是right_front_link3,那么right_front_link5会绕着right_front_link3中心旋转，应该绕着我们之前设置的坐标旋转，即...link5在...link2设置的轴线 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">joint</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;right_front_joint5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">origin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0.184 0 0&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">&quot;right_front_link2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span></span></span><br><span class="line"><span class="tag">      <span class="attr">link</span>=<span class="string">&quot;right_front_link5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">axis</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xyz</span>=<span class="string">&quot;0 0 -1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mimic</span> <span class="attr">joint</span>=<span class="string">&quot;right_front_joint3&quot;</span> <span class="attr">multiplier</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- multiplier论径比例 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="sdf文件和urdf和xacro文件的区别"><a href="#sdf文件和urdf和xacro文件的区别" class="headerlink" title="sdf文件和urdf和xacro文件的区别"></a>sdf文件和urdf和xacro文件的区别</h3><ul><li>SDF文件用于描述仿真环境，URDF文件用于描述机器人模型，而Xacro则是一种用于简化URDF文件编写的工具</li><li>sdf文件、urdf文件和xacro文件都是模型文件。</li><li>xacro文件是urdf文件的改进版，urdf文件只能在rviz等中显示，不能在仿真器中显示出来。</li><li>xacro文件可以在gazebo仿真器中显示出来，相对urdf文件，xacro文件增加了更多的属性设置标签。</li><li>sdf文件和urdf文件、xacro文件都可以加载dae等三维模型文件。</li><li>sdf和urdf、xacro的<strong>区别</strong><ul><li>ros和gazebo 不能使得sdf模型动起来、sdf模型有自己的行为</li><li>ros和gazebo能使得urdf、xacro模型动起来、urdf、xacro模型有自己的行为</li></ul></li><li>当前，sdf文件和urdf、xacro文件之间还不能自动转换，只能根据实体手动转换。</li></ul><h3 id="gazebo标签"><a href="#gazebo标签" class="headerlink" title="gazebo标签"></a>gazebo标签</h3><ul><li>在gazebo仿真，有自己的标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- gazebo自己的颜色信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gazebo</span> <span class="attr">reference</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">material</span>&gt;</span>Gazebo/Red<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><a href="https://blog.csdn.net/qq_42226250/article/details/110881207">gazebo颜色</a></li></ul><h2 id="gazebo设置"><a href="#gazebo设置" class="headerlink" title="gazebo设置"></a>gazebo设置</h2><ul><li>将生成好的文件夹复制到catkin_ws&#x2F;src下，接着<code>catkin_make</code>编译</li><li>在终端输入命令<code>roslaunch var_strc_uav display.launch</code>，弹出rvia界面\</li><li>在Fixed Frame中选择base_link作为底盘坐标系</li><li>点击<code>Add---rviz----Robotmodel</code>显现模型<ul><li>保存配置项:File—save config as</li><li>rviz：左键旋转，中键平移拖动，中键滚轮缩放</li></ul></li><li>关闭rviz后，修改display.launch中，没有这行代码就添加，有则修改成下面的代码形式；终端输入上述命令，会弹出一个窗口，通过移动滑条（Joint State Publish工具）来控制关节的旋转，判断是否正确旋转<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在原来display.launch代码中后面修改 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加该代码后就不用手动添加，但要提前保存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find var_strc_uav)/urdf/config.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把下面的注释调 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;node</span></span><br><span class="line"><span class="comment">  name=&quot;rviz&quot;</span></span><br><span class="line"><span class="comment">  pkg=&quot;rviz&quot;</span></span><br><span class="line"><span class="comment">  type=&quot;rviz&quot;</span></span><br><span class="line"><span class="comment">  args=&quot;-d $(find var_strc_uav)/urdf.rviz&quot; /&gt; --&gt;</span></span><br></pre></td></tr></table></figure>其中，我们需要对旋转方向进行判断和规定</li><li>对于舵机1来说，从下向上旋转，从机身向外为正<br>![[Pasted image 20231103195306.png]]</li><li>对于舵机2来说，朝机身向外旋转为正</li></ul><p>![[Pasted image 20231103195420.png]]</p><ul><li>对于电机3来说，看螺旋桨旋转方向<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 1&quot;</span> /&gt;</span>  <span class="comment">&lt;!--需要在joint标签改写， 对z轴来说，1是逆时针（右手定则），-1是顺时针--&gt;</span></span><br></pre></td></tr></table></figure></li><li>判断没什么问题后，一般将之转为xacro文件进而添加控制驱动等进行控制</li><li><code>使用check_urdf var_strc_uav.urdf</code>可检查urdf文件</li></ul><h1 id="xacro编写"><a href="#xacro编写" class="headerlink" title="xacro编写"></a>xacro编写</h1><ul><li>[[xml#xacro语法|xacro语法]]</li><li><a href="https://blog.csdn.net/chishuideyu/article/details/53695392">官方解释</a></li><li>而xacro中可以包含urdf文件中的joint和link标签等</li></ul><h2 id="将urdf模型文件变更为xacro文件"><a href="#将urdf模型文件变更为xacro文件" class="headerlink" title="将urdf模型文件变更为xacro文件"></a>将urdf模型文件变更为xacro文件</h2><ul><li>首先，在urdf文件夹下的urdf文件复制并改后缀为.xacro</li><li>将开头文件进行更改<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;var_strc_uav&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--将上面的语句改为下面的语句,--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;var_strc_uav&quot;</span>  <span class="attr">xmlns:xacro</span>=<span class="string">&quot;http://ros.org/wiki/xacro&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="在xacro文件中进行相关配置"><a href="#在xacro文件中进行相关配置" class="headerlink" title="在xacro文件中进行相关配置"></a>在xacro文件中进行相关配置</h3><ul><li><a href="http://www.autolabor.com.cn/book/ROSTutorials/di-6-zhang-ji-qi-ren-xi-tong-fang-zhen/67/671-ji-qi-ren-yun-dong-kong-zhi-yi-ji-li-cheng-ji-xin-xi-xian-shi.html">教程</a></li><li><a href="https://blog.csdn.net/u011017694/article/details/122357808">运动控制教程</a><br><strong>步骤</strong></li></ul><ol><li>在创建完毕上的机器人模型，编写一个单独的xacro文件，为机器人模型添加传动装置以及控制器</li><li>将此文件集成进xacro文件</li><li>启动Gazebo并发布&#x2F;cmd+vel消息控制机器人运动</li></ol><h4 id="为joint添加传动装置"><a href="#为joint添加传动装置" class="headerlink" title="为joint添加传动装置"></a>为joint添加传动装置</h4><ul><li>[[ros_control#transmission标签|transmission标签]]<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xacro:macro</span> <span class="attr">name</span>=<span class="string">&quot;joint_trans&quot;</span> <span class="attr">params</span>=<span class="string">&quot;joint_name&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Transmission is important to link the joints and the controller --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transmission</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_trans&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">actuator</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;joint_name&#125;_motor&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">hardwareInterface</span>&gt;</span>hardware_interface/PositionJointInterface<span class="tag">&lt;/<span class="name">hardwareInterface</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mechanicalReduction</span>&gt;</span>1<span class="tag">&lt;/<span class="name">mechanicalReduction</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">actuator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transmission</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xacro:macro</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 每一个驱动轮都需要配置传动装置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;left_wheel2base_link&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xacro:joint_trans</span> <span class="attr">joint_name</span>=<span class="string">&quot;right_wheel2base_link&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>注意这里的硬件控制接口需要和yaml文件中的控制接口对应</li><li>对于机械臂来说，一般用的位置控制</li><li>车轮这种的应该是用的速度控制</li></ul><h4 id="添加gazebo控制器插件"><a href="#添加gazebo控制器插件" class="headerlink" title="添加gazebo控制器插件"></a>添加gazebo控制器插件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">gazebo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">name</span>=<span class="string">&quot;gazebo_ros_control&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;libgazebo_ros_control.so&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">robotNamespace</span>&gt;</span>/var_strc_uav<span class="tag">&lt;/<span class="name">robotNamespace</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">robotSimType</span>&gt;</span>gazebo_ros_control/DefaultRobotHWSim<span class="tag">&lt;/<span class="name">robotSimType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legacyModeNS</span>&gt;</span>true<span class="tag">&lt;/<span class="name">legacyModeNS</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gazebo</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;plugin&gt;</code>:插件元素，用于在Gazebo中加载指定的插件。<ul><li>name&#x3D;”gazebo_ros_control”: 插件的名称，这里是”gazebo_ros_control”。</li><li>filename&#x3D;”libgazebo_ros_control.so”: 插件的文件名，这里是”libgazebo_ros_control.so”。这表示Gazebo将加载名为”libgazebo_ros_control.so”的共享库文件作为该插件。</li><li><strong>插件的名称可以是任意的，但需要确保插件名称与加载的插件文件名匹配</strong>。在上述代码中，插件的名称是”gazebo_ros_control”，并且加载的插件文件名是”libgazebo_ros_control.so”。这是因为在加载插件时，Gazebo会查找与插件名称匹配的共享库文件。</li></ul></li><li><code>&lt;robotNamespace&gt;/var_strc_uav&lt;/robotNamespace&gt;</code>: 机器人命名空间。这表示该插件将在名为”&#x2F;var_strc_uav”的命名空间下加载。也就是文件第二行机器人的命名名称：<code>robot name=&quot;var_strc_uav&quot;</code>，也就是后面话题会用到</li><li><code>&lt;robotSimType&gt;gazebo_ros_control/DefaultRobotHWSim&lt;/robotSimType&gt;</code>: 机器人仿真类型。这表示Gazebo将使用”gazebo_ros_control&#x2F;DefaultRobotHWSim”作为机器人的仿真类型。</li><li><legacyModeNS>true</legacyModeNS>: 是否启用遗留模式的命名空间。这里设置为”true”，表示启用遗留模式命名空间。</li></ul><h4 id="修改display-launch及gazebo-launch文件"><a href="#修改display-launch及gazebo-launch文件" class="headerlink" title="修改display.launch及gazebo.launch文件"></a>修改display.launch及gazebo.launch文件</h4><p>按照</p><blockquote><p>命名空间</p><ul><li>控制器<br>– 控制器参数<br>这样的格式写好配置，<a href="https://wiki.ros.org/robot_mechanism_controllers">具体参数配置</a></li></ul></blockquote><ul><li>在config文件夹创建var_strc_uav_control.yaml<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var_strc_uav:</span>     <span class="comment">#命名空间</span></span><br><span class="line">  <span class="comment"># Publish all joint states -----------------------------------</span></span><br><span class="line">  <span class="attr">joint_state_controller:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">joint_state_controller/JointPositionController</span></span><br><span class="line">    <span class="attr">publish_rate:</span> <span class="number">50</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment"># Position Controllers ---------------------------------------</span></span><br><span class="line">  <span class="attr">right_front_joint1_control:</span>            <span class="comment">#控制器名称，后续会在launch使用</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">position_controllers/JointPositionController</span></span><br><span class="line">    <span class="attr">joint:</span> <span class="string">right_front_joint1</span>            <span class="comment">#控制关节名称</span></span><br><span class="line">    <span class="comment"># pid: &#123;p: 12.0, i: 0.01, d: 0.0&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">var_strc_uav/gazebo_ros_control/pid_gains:</span></span><br><span class="line">  <span class="attr">right_front_joint1:</span> &#123;<span class="attr">p:</span> <span class="number">10.0</span>, <span class="attr">i:</span> <span class="number">0.0</span>, <span class="attr">d:</span> <span class="number">0.0</span>&#125;</span><br></pre></td></tr></table></figure>在launch文件夹中创建gazebo_test.launch<br>模板说明<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find 包名)/urdf/文件名&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动 gazebo --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find var_strc_uav)/worlds/hello.world&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find var_strc_uav)/urdf/config.rviz&quot; required=&quot;true&quot;&gt;&lt;/node&gt;      --&gt;</span>    <span class="comment">&lt;!-- 加载rviz --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find 包名)/config/文件名.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span>/&gt;</span>    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;controller_spawner&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;controller_manager&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawner&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;/命名空间&quot;</span> <span class="attr">args</span>=<span class="string">&quot;控制器名1 控制器名1...&quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 在 gazebo 中显示机器人模型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model 模型名字 -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 关节以及机器人状态发布节点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>在launch文件中node开头的，可以用rosnode list查看<br><strong>实例</strong><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 将 Urdf 文件的内容加载到参数服务器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(find var_strc_uav)/urdf/var_strc_uav.urdf.xacro&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动 gazebo --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find var_strc_uav)/worlds/hello.world&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find var_strc_uav)/urdf/config.rviz&quot; required=&quot;true&quot;&gt;&lt;/node&gt;      --&gt;</span>    <span class="comment">&lt;!-- 加载rviz --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find var_strc_uav)/config/var_strc_uav_control.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;controller_spawner&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;controller_manager&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawner&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;/var_strc_uav&quot;</span> <span class="attr">args</span>=<span class="string">&quot;right_front_joint1_control right_front_joint2_control right_front_joint3_control right_front_joint4_control</span></span></span><br><span class="line"><span class="string"><span class="tag">                                                                                                                                      right_hind_joint1_control right_hind_joint2_control right_hind_joint3_control right_hind_joint4_control</span></span></span><br><span class="line"><span class="string"><span class="tag">                                                                                                                                      left_hind_joint1_control left_hind_joint2_control left_hind_joint3_control left_hind_joint4_control  </span></span></span><br><span class="line"><span class="string"><span class="tag">                                                                                                                                      left_front_joint1_control left_front_joint2_control left_front_joint3_control left_front_joint4_control &quot;</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 在 gazebo 中显示机器人模型 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-urdf -model my_uav -param robot_description&quot;</span>  /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 关节以及机器人状态发布节点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>后续</p><ul><li>catkin_make编译</li><li>使用<code>roslaunch var_strc_uav display.launch</code>打开rviz并打开模型另存为到&#x2F;urdf&#x2F;config.rviz中</li><li><code>roslaunch var_strc_uav gazebo_test.launch开启gazebo,</code>新终端输入<code>rostopic pub -1 /var_strc_uav/right_front_joint1_control/command std_msgs/Float64 &quot;data: 1.2&quot;</code>控制的一个电机旋转</li><li>接着就是自己慢慢细化模型就行</li><li>[[变结构无人机仿真教程]]</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.c++_模板</title>
      <link href="/data.github.io/post/2f83c309.html"/>
      <url>/data.github.io/post/2f83c309.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><ul><li>函数模板是通用的函数描述，使用任意类型（泛型）来描述函数。</li><li>编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。</li><li>生成函数定义的过程被称为实例化</li><li>在C++98添加关键字typename之前，C++使用关键字class来创建模板。</li><li>如果考虑向后兼容，函数模板应使用typename，而不是class</li><li>函数模板实例化可以让编译器自动推导，也可以在调用的代码中显式的指定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//T可以为其他别名，一般为T，函数前必须添加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span><span class="comment">//交换两个变量值的函数模板,T代表其他类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="type">float</span> a1=<span class="number">9.230</span>,b1=<span class="number">8.23</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(a1,b1);</span><br><span class="line">    cout&lt;&lt;a1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>可以为类的成员函数创建模板，但不能是虚函数和析构函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">CGirl</span>(T a)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CGirl <span class="title">g</span><span class="params">(<span class="string">&quot;西施&quot;</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">show</span>(<span class="number">345</span>);</span><br><span class="line">    g.<span class="built_in">show</span>(<span class="string">&quot;sdjfh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用函数模板时，必须明确数据类型，确保实参与函数模板能匹配上——针对无参数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">()</span><span class="comment">//无参数时</span></span></span><br><span class="line"><span class="function"><span class="title">Swap</span><span class="params">()</span></span>;<span class="comment">//直接调用会报错</span></span><br><span class="line"><span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//这样无问题</span></span><br></pre></td></tr></table></figure></li><li>使用函数模板时，推导的数据类型必须适应函数模板中的代码。</li><li>使用函数模板时，如果是自动类型推导，不会发生隐式类型转换，如果显式指定了函数模板的数据类型，可以发生隐式类型转换。</li><li>函数模板支持多个通用数据类型的参数</li><li>函数模板支持重载，可以有非通用数据类型的参数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T1 b,T2 B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;b&lt;&lt;B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数模板的具体化"><a href="#函数模板的具体化" class="headerlink" title="函数模板的具体化"></a>函数模板的具体化</h2><ul><li><strong>可以提供一个具体化的函数定义</strong>，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> 函数模板名&lt;数据类型&gt;(参数列表)</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> 函数模板名(参数列表)&#123;&#125;</span><br></pre></td></tr></table></figure>示例1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">                      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>            <span class="comment">// 超女类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_bh;              <span class="comment">// 编号。</span></span><br><span class="line">string m_name;   <span class="comment">// 姓名。</span></span><br><span class="line"><span class="type">int</span> m_rank;          <span class="comment">// 排名。</span></span><br><span class="line">&#125;;</span><br><span class="line">              </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span>;      <span class="comment">// 交换两个变量的值函数模板。</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="type">void</span> <span class="built_in">Swap</span>&lt;CGirl&gt;(CGirl&amp; g1, CGirl&amp; g2);      <span class="comment">// 交换两个超女对象的排名。</span></span><br><span class="line"><span class="comment">// template&lt;&gt; </span></span><br><span class="line"><span class="comment">// void Swap(CGirl&amp; g1, CGirl&amp; g2);      // 交换两个超女对象的排名。</span></span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">Swap</span>(a, b);           <span class="comment">// 使用了函数模板。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">CGirl g1, g2;</span><br><span class="line">g1.m_rank = <span class="number">1</span>; g2.m_rank = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">Swap</span>(g1, g2);     <span class="comment">// 使用了超女类的具体化函数。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;g1.m_rank=&quot;</span> &lt;&lt; g1.m_rank &lt;&lt; <span class="string">&quot;,g2.m_rank=&quot;</span> &lt;&lt; g2.m_rank &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span>      <span class="comment">// 交换两个变量的值函数模板。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了Swap(T&amp; a, T&amp; b)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="type">void</span> <span class="built_in">Swap</span>&lt;CGirl&gt;(CGirl&amp; g1, CGirl&amp; g2)      <span class="comment">// 交换两个超女对象的排名。</span></span><br><span class="line"><span class="comment">// template&lt;&gt; </span></span><br><span class="line"><span class="comment">// void Swap(CGirl&amp; g1, CGirl&amp; g2)      // 交换两个超女对象的排名。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = g1.m_rank;</span><br><span class="line">g1.m_rank = g2.m_rank;</span><br><span class="line">g2.m_rank = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了Swap(CGirl&amp; g1, CGirl&amp; g2)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>规则</strong></li><li>如果主函数调用的函数都能用，优先级：<strong>普通函数&gt;具体化&gt;常规模板</strong></li><li>如果希望使用函数模板，可以用空模板参数强制使用函数模板。</li><li>如果函数模板能产生更好的匹配，将优先于普通函数。例如普通为传参为 int 型，到那时传参为字符时会优先模板而不是 int 型（字符可传参 int 型）</li></ul><h3 id="函数模板分文件编写"><a href="#函数模板分文件编写" class="headerlink" title="函数模板分文件编写"></a>函数模板分文件编写</h3><ul><li>函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中</li><li>函数模板的具体化有实体，编译的原理和普通函数一样，所以，声明放在头文件中，定义放在源文件中<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// public.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;      <span class="comment">// 普通函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T a, T b)</span>         <span class="comment">// 函数模板。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;使用了函数模板。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;    <span class="comment">// 函数模板的具体化版本。</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// public.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>      <span class="comment">// 普通函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;使用了普通函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>     <span class="comment">// 函数模板的具体化版本。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;使用了具体化的函数模板。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// demo01.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Swap</span>(<span class="number">1</span>,<span class="number">2</span>);         <span class="comment">// 将使用普通函数。</span></span><br><span class="line"><span class="built_in">Swap</span>(<span class="number">1.3</span>, <span class="number">3.5</span>);  <span class="comment">// 将使用具体化的函数模板。</span></span><br><span class="line"><span class="built_in">Swap</span>(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>);    <span class="comment">// 将使用函数模板。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="函数模板高级"><a href="#函数模板高级" class="headerlink" title="函数模板高级"></a>函数模板高级</h2><h3 id="decltype-关键字"><a href="#decltype-关键字" class="headerlink" title="decltype 关键字"></a>decltype 关键字</h3><ul><li>用于查询表达式的数据类型 ,不会执行表达式和函数</li><li>语法：<code>decltype(expression) var;</code></li><li><a href="https://blog.csdn.net/qq_38196982/article/details/118578967?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169080608216800197085132%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169080608216800197085132&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118578967-null-null.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&utm_term=decltype&spm=1018.2226.3001.4187">decltype用法详解</a></li><li>decltype分析表达式并得到它的类型，不会计算执行表达式。函数调用也一种表达式，因此不必担心在使用decltype时执行了函数。</li></ul><p><strong>推导规则</strong></p><ul><li>如果 expression 是没有用括号括起来的标识符，则 var 的类型与该标识符的类型相同，包括 const 等限定符。</li><li>如果 expression 是函数调用，则 var 的类型与函数的返回值类型相同 (函数不能返回 void, 但可以返回 void*)</li><li>如果 expression 是左值（能取地址）、或者用括号括起来的标识符，那么 var 的类型是 expression 的引用。</li><li>如果上面的条件都不满足，则 var 的类型与 expressionl 的类型相同：如果需要多次使用decltype，可以结合typedef和using。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(a) var = a;  <span class="comment">// var 的类型为 int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(pi) var2 = pi;  <span class="comment">// var2 的类型为 const float</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>)) var3 = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// var3 的类型为 int</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp; var4 = x;  <span class="comment">// var4 的类型为 int&amp;</span></span><br><span class="line">    var4 = <span class="number">20</span>;  <span class="comment">// 修改 var4 的值也会修改 x 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line">    <span class="keyword">decltype</span>(*ptr)&amp; var5 = *ptr;  <span class="comment">// var5 的类型为 int&amp;</span></span><br><span class="line">    var5 = <span class="number">30</span>;  <span class="comment">// 修改 var5 的值也会修改 x 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> var6 = <span class="number">3.14</span>;  <span class="comment">// var6 的类型为 double</span></span><br><span class="line">    <span class="keyword">auto</span> var7 = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// var7 的类型为 const char*</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var: &quot;</span> &lt;&lt; var &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var2: &quot;</span> &lt;&lt; var2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var3: &quot;</span> &lt;&lt; var3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var4: &quot;</span> &lt;&lt; var4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var5: &quot;</span> &lt;&lt; var5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var6: &quot;</span> &lt;&lt; var6 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;var7: &quot;</span> &lt;&lt; var7 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>函数后置返回类型</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> y)</span></span>;</span><br><span class="line"><span class="comment">//等同：</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> y)</span> -&gt; <span class="type">int</span></span>;</span><br><span class="line"><span class="comment">//将返回类型移到了函数声明的后面。</span></span><br><span class="line"><span class="comment">//auto是一个占位符（C++11给auto新增的角色）, 为函数返回值占了一个位置。</span></span><br><span class="line"><span class="comment">//这种语法也可以用于函数定义：</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> y)</span> -&gt; <span class="type">int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>示例1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//有返回值形式写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="comment">//auto func(T1 x,T2 y)这么写也可以</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T1 x,T2 y)</span> -&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> tem=x+y;</span><br><span class="line">cout&lt;&lt;tem&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.2</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><ul><li>使用类模板时，指定具体的数据类型，让编译器生成该类型的类定义</li><li>使用类模板时，数据类型必须适应类模板中的代码。</li><li>类模板可以为通用数据类型指定缺省的数据类型</li><li>类的成员函数可以在类外实现</li><li>可以用 new 创建模板对象</li><li>函数模板建议用typename描述通用数据类型，类模板建议用class<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>=string&gt;<span class="comment">//这样在主函数中创建时可以不写第二个参数</span></span><br></pre></td></tr></table></figure><strong>注意</strong><br>1）在创建对象的时候，必须指明具体的数据类型。<br>2）使用类模板时，数据类型必须适应类模板中的代码。<br>3）类模板可以为通用数据类型指定缺省的数据类型（C++11标准的函数模板也可以）。<br>4）模板类的成员函数可以在类外实现。<br>5）可以用new创建模板类对象。<br>6）在程序中，模板类的成员函数使用了才会创建。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">          </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>=string&gt;</span><br><span class="line"><span class="keyword">class</span> AA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_a;      <span class="comment">// 通用类型用于成员变量。</span></span><br><span class="line">T2 m_b;      <span class="comment">// 通用类型用于成员变量。</span></span><br><span class="line">          </span><br><span class="line"><span class="built_in">AA</span>() &#123;  &#125;        <span class="comment">// 默认构造函数是空的。</span></span><br><span class="line"><span class="comment">// 通用类型用于成员函数的参数。</span></span><br><span class="line"><span class="built_in">AA</span>(T1 a,T2 b):<span class="built_in">m_a</span>(a),<span class="built_in">m_b</span>(b) &#123;  &#125;</span><br><span class="line"><span class="comment">// 通用类型用于成员函数的返回值。</span></span><br><span class="line"><span class="function">T1 <span class="title">geta</span><span class="params">()</span>            <span class="comment">// 获取成员m_a的值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T1 a = <span class="number">2</span>;        <span class="comment">// 通用类型用于成员函数的代码中。</span></span><br><span class="line"><span class="keyword">return</span> m_a + a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T2 <span class="title">getb</span><span class="params">()</span></span>;            <span class="comment">// 获取成员m_b的值。</span></span><br><span class="line">&#125;;</span><br><span class="line">           </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">T2 AA&lt;T1,T2&gt;::<span class="built_in">getb</span>()            <span class="comment">// 获取成员m_b的值。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_b;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AA&lt;<span class="type">int</span>, string&gt;* a = <span class="keyword">new</span> <span class="built_in">AA</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;西施&quot;</span>);     <span class="comment">// 用模板类AA创建对象a。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a-&gt;geta()=&quot;</span> &lt;&lt; a-&gt;<span class="built_in">geta</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a-&gt;getb()=&quot;</span> &lt;&lt; a-&gt;<span class="built_in">getb</span>() &lt;&lt; endl;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="嵌套和递归使用模板类"><a href="#嵌套和递归使用模板类" class="headerlink" title="嵌套和递归使用模板类"></a>嵌套和递归使用模板类</h2><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130732817?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169080788416782425130693%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169080788416782425130693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130732817-null-null.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&utm_term=%E5%B5%8C%E5%A5%97%E5%92%8C%E9%80%92%E5%BD%92%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB&spm=1018.2226.3001.4187">C++类模板嵌套使用</a><br>现在有 vector 类容器和 stack 容器模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Vector容器，容器元素用Stack,</span></span><br><span class="line">Vector&lt;Stack&lt;string&gt;&gt; vs;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//栈类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;<span class="comment">//在类声明前加上模板的头部标签</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//3个成员变量</span></span><br><span class="line">DataType *items;<span class="comment">//栈数组，栈的元素用整数数组存放，动态分配一块数组空间</span></span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//栈大小，栈的大小用成员变量表示</span></span><br><span class="line"><span class="type">int</span> top;<span class="comment">//栈顶指针，栈顶指针用整数表示，不是C++的指针</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//成员函数 </span></span><br><span class="line"><span class="comment">//构造函数：1）分配栈数组空间；2）把栈顶指针初始化为0</span></span><br><span class="line"><span class="built_in">Stack</span>(<span class="type">int</span> size=<span class="number">3</span>):<span class="built_in">stacksize</span>(size),<span class="built_in">top</span>(<span class="number">0</span>)<span class="comment">//需要一个参数（栈的大小），采用初始化列表对成员赋值</span></span><br><span class="line">&#123;</span><br><span class="line">items=<span class="keyword">new</span> DataType [stacksize];<span class="comment">//在构造函数中，给栈数组分配内存</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Stack</span>()<span class="comment">//析构函数，释放数组空间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []items;<span class="comment">//释放数组空间</span></span><br><span class="line">items=<span class="literal">NULL</span>;<span class="comment">//指针置为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">return</span> top==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="comment">//判断栈是否为满</span></span><br><span class="line"><span class="keyword">return</span> top==stacksize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> DataType&amp; item)</span></span>&#123;<span class="comment">//元素入栈</span></span><br><span class="line"><span class="keyword">if</span>(top&lt;stacksize)<span class="comment">//如果还没有在栈顶</span></span><br><span class="line">&#123;</span><br><span class="line">items[top++]=item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(DataType&amp; item)</span></span>&#123;<span class="comment">//元素出栈</span></span><br><span class="line"><span class="keyword">if</span>(top&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">item=items[--top];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//数组容器类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> len;<span class="comment">//数组大小用成员变量表示</span></span><br><span class="line">T *items;<span class="comment">//数组元素用指针，动态分配</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">int</span> size=<span class="number">2</span>):<span class="built_in">len</span>(size)&#123;    <span class="comment">//构造函数，把数组大小传入，分配内存</span></span><br><span class="line">    items=<span class="keyword">new</span> T[len];</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Vector</span>()&#123;                        <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[]items;items=<span class="literal">NULL</span>;        <span class="comment">//释放数组空间，指针置为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;            <span class="comment">//扩展数组的内存空间</span></span><br><span class="line"><span class="keyword">if</span>(size&lt;=len)<span class="keyword">return</span>;            <span class="comment">//只能往更大的扩展</span></span><br><span class="line">T*tmp=<span class="keyword">new</span> T[size];                <span class="comment">//分配更大的目标数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;len;ii++)        <span class="comment">//将原来的数组赋给目标数组</span></span><br><span class="line">tmp[ii]=items[ii];</span><br><span class="line"><span class="keyword">delete</span>[]items;                <span class="comment">//释放原来的数组</span></span><br><span class="line">items=tmp;                    <span class="comment">//让数组指向新的目标数组</span></span><br><span class="line">len=size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;                <span class="comment">//获取数组长度</span></span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> ii)&#123;            <span class="comment">//重载操作符[]，形参是数组下标，可以修改数组中的元素</span></span><br><span class="line">    <span class="keyword">if</span>(ii&gt;=len)<span class="built_in">resize</span>(ii+<span class="number">10</span>);            <span class="comment">//扩展数组空间</span></span><br><span class="line">    <span class="keyword">return</span> items[ii];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> ii)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[ii];    <span class="comment">//重载操作符[]，形参是数组下标，不可以修改数组中的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Vector大小为2，Stack大小为3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个对象Vector</span></span><br><span class="line">Vector&lt;Stack&lt;string&gt; &gt;v;<span class="comment">//C++11之前，&gt;&gt;要加空格</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//手工地往容器Vector插入数据</span></span><br><span class="line">v[<span class="number">0</span>].<span class="built_in">push</span>(<span class="string">&quot;西施1&quot;</span>);v[<span class="number">0</span>].<span class="built_in">push</span>(<span class="string">&quot;西施2&quot;</span>);v[<span class="number">0</span>].<span class="built_in">push</span>(<span class="string">&quot;西施3&quot;</span>);</span><br><span class="line">v[<span class="number">1</span>].<span class="built_in">push</span>(<span class="string">&quot;西1&quot;</span>);v[<span class="number">1</span>].<span class="built_in">push</span>(<span class="string">&quot;西2&quot;</span>);v[<span class="number">1</span>].<span class="built_in">push</span>(<span class="string">&quot;西3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用for循环嵌套，把v容器中的数据显示出来</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)<span class="comment">//遍历Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!v[i].<span class="built_in">isempty</span>())<span class="comment">//遍历Stack</span></span><br><span class="line">&#123;</span><br><span class="line">string item;</span><br><span class="line">v[i].<span class="built_in">pop</span>(item);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;item= &quot;</span>&lt;&lt;item&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板类具体化"><a href="#模板类具体化" class="headerlink" title="模板类具体化"></a>模板类具体化</h3><ul><li>分为完全具体化和部分具体化</li><li>优先级：<strong>具体化程度高的类优先于具体化程度低的类</strong>，具体化的类优先没有具体化的类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">T1 a;</span><br><span class="line">T2 b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//部分具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">T1 a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;string,<span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模板类与继承"><a href="#模板类与继承" class="headerlink" title="模板类与继承"></a>模板类与继承</h2><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130753545?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169080917716800222832776%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169080917716800222832776&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130753545-null-null.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&utm_term=%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF&spm=1018.2226.3001.4187">c++ 模板类继承</a></li><li>模板类继承普通类（常见）</li><li>普通类继承模板类的<strong>实例版本</strong></li><li>普通类继承模板类（常见）</li><li>模板类继承模板类</li><li>模板类继承模板参数给出的基类（不能是模板类）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//模板类继承普通类，常见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>:<span class="keyword">public</span> A&#123;&#125;;<span class="comment">//继承普通类</span></span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//普通类继承模板类的实例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> BB&lt;<span class="type">int</span>,string&gt;;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//普通类继承模板类,常见</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> BB&lt;T1,T2&gt;;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//模板类继承模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>:<span class="keyword">public</span> BB&lt;T1,T2&gt;;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//模板类继承模板参树给出的基类(不能是模板类)</span></span><br><span class="line"><span class="comment">//普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:<span class="keyword">public</span> T&#123;&#125;<span class="comment">//模板类继承模板参数给出的基类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EE&lt;AA&gt; ea1;<span class="comment">//AA作为基类</span></span><br><span class="line">EE&lt;BB&gt; eb1;<span class="comment">//BB作为基类</span></span><br><span class="line">EE&lt;CC&gt; ec1;<span class="comment">//CC作为基类</span></span><br><span class="line">EE&lt;DD&lt;<span class="type">int</span>&gt;&gt; ed1; <span class="comment">//DD&lt;int&gt;作为基类,模板类作为基类时，必须明确指出模板类型参数</span></span><br><span class="line"><span class="comment">//EE&lt;DD&gt;ed1;   //DD作为基类，错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="模板类与函数"><a href="#模板类与函数" class="headerlink" title="模板类与函数"></a>模板类与函数</h2><p>模板类可以用于函数的参数和返回值</p><ol><li>普通函数，参数和返回值是模板类的实例化版本<ol><li><strong>友元函数不是模板函数</strong>，而是利用模板类参数生成的函数，只能在类内实现。</li><li>该方法生成的友元函数只能用于该模板类，不能用于其他模板类</li></ol></li><li>函数模板，参数和返回值是某种的模板类</li><li>函数模板，参数和返回值是任意类型（支持普通类和模板类和其它类型）, 这种较为规范</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//采用普通函数，参数和返回值是模板类的实例化版本</span></span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>,string&gt; <span class="title">func</span><span class="params">(A&lt;<span class="type">int</span>,string&gt; a)</span></span>&#123; <span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板，参数和返回值是模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">A&lt;T1,T2&gt; <span class="title">func</span><span class="params">(A&lt;T1,T2&gt; a)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板，参数和返回值是任意类型d</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T &amp;a)</span></span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>    <span class="comment">// 模板类AA。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y) : <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;show()  x = &quot;</span> &lt;&lt; m_x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; m_y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用普通函数，参数和返回值是模板类AA的实例化版本。</span></span><br><span class="line"><span class="function">AA&lt;<span class="type">int</span>, string&gt; <span class="title">func</span><span class="params">(AA&lt;<span class="type">int</span>, string&gt;&amp; aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用了func(AA&lt;int, string&gt; &amp;aa)函数。\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板，参数和返回值是的模板类AA。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">AA&lt;T1, T2&gt; <span class="title">func</span><span class="params">(AA&lt;T1, T2&gt;&amp; aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用了func(AA&lt;T1, T2&gt; &amp;aa)函数。\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板，参数和返回值是任意类型。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T &amp;aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// aa.show();</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用了func(AA&lt;T&gt; &amp;aa)函数。\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;函数模板。\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AA&lt;<span class="type">int</span>, string&gt; <span class="title">aa</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">func</span>(aa);</span><br><span class="line">    <span class="built_in">func</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="模板类与有元"><a href="#模板类与有元" class="headerlink" title="模板类与有元"></a>模板类与有元</h2><p>有三种形式</p><ol><li>非模板友元：<strong>友元函数不是模板函数</strong>，而是利用模板类参数生成的函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">T1 a;</span><br><span class="line">T2 b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">a</span>(x),<span class="built_in">b</span>(y)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;T1,T2&gt; &amp;c)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;c.a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>,string&gt; <span class="title">p</span><span class="params">(<span class="number">32</span>,<span class="string">&quot;我的世界&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">show</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数 (常用)。<br> 步骤<ol><li><strong>在模板类定义的前面</strong>，<strong>声明友元函数</strong>，为了让模板类知道友元函数模板的存在</li><li><strong>在模板类中</strong>，<strong>再次声明友元函数模板</strong>，让编译器知道需要实例化的友元函数模板</li><li>友元函数模板的定义，<strong>具体化版本</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//约束模板友元：模板实例化时，每个实例化的类对应一个友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T&amp;a)</span></span>;<span class="comment">//第一步：在模板类定义的前面，声明友元函数，为了让模板类知道友元函数模板的存在</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span><span class="comment">//AA是类模板，是类的通用描述，改变不存在叫AA的类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;<span class="comment">//第二步：在模板类中，再次声明友元函数模板，让编译器知道需要实例化的友元函数模板</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(AA&lt;T1,T2&gt;&amp;a);<span class="comment">//这行代码让类模板和函数模板扯上关系</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span><span class="comment">//AA是类模板，是类的通用描述，改变不存在叫AA的类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;<span class="comment">//第二步：在模板类中，再次声明友元函数模板，让编译器知道需要实例化的友元函数模板</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(BB&lt;T1,T2&gt;&amp;a);<span class="comment">//这行代码让类模板和函数模板扯上关系</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BB</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译器在实例化某种数据类型的模板类时，也会实例化这种数据类型的模板函数</span></span><br><span class="line"><span class="comment">//通用版本友元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//第三步：友元函数模板的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T&amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;通用：x=&quot;</span>&lt;&lt;a.m_x&lt;&lt;<span class="string">&quot;，y=&quot;</span>&lt;&lt;a.m_y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为友元函数是函数模板，所以可以有具体化版本</span></span><br><span class="line"><span class="comment">//具体化版本友元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(AA&lt;<span class="type">int</span>,string&gt;&amp;a)</span><span class="comment">//第四步：具体化版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;具体：x=&quot;</span>&lt;&lt;a.m_x&lt;&lt;<span class="string">&quot;，y=&quot;</span>&lt;&lt;a.m_y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//是类名AA&lt;int,string&gt;</span></span><br><span class="line">AA&lt;<span class="type">int</span>,string&gt;<span class="built_in">aa</span>(<span class="number">88</span>,<span class="string">&quot;我是一只小猫咪&quot;</span>);</span><br><span class="line"><span class="built_in">show</span>(aa);<span class="comment">//使用具体化的版本</span></span><br><span class="line">BB&lt;<span class="type">char</span>,string&gt;<span class="built_in">bb</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;我是一只小猫咪&quot;</span>);</span><br><span class="line"><span class="built_in">show</span>(bb);<span class="comment">//使用通用的版本，友元函数适应多种函数模板</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>非约束模板友元：模板类实例化时，如果实例化了 n 个类，也会实例化个友元函数，每个实例化的类都拥有 n 个友元函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非类模板约束的友元函数，实例化后，每个函数都是每个每个类的友元。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(T&amp; a)</span></span>;     <span class="comment">// 把函数模板设置为友元。</span></span><br><span class="line">    T1 m_x;</span><br><span class="line">    T2 m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">const</span> T1 x, <span class="type">const</span> T2 y) : <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T&amp; a)</span>                     <span class="comment">// 通用的函数模板。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通用：x = &quot;</span> &lt;&lt; a.m_x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; a.m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(AA&lt;<span class="type">int</span>, string&gt;&amp; a)</span>                 <span class="comment">// 函数模板的具体版本。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;具体&lt;int, string&gt;：x = &quot;</span> &lt;&lt; a.m_x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; a.m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AA&lt;<span class="type">int</span>, string&gt; <span class="title">a</span><span class="params">(<span class="number">88</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">show</span>(a);         <span class="comment">// 将使用具体化的版本。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">AA&lt;<span class="type">char</span>, string&gt; <span class="title">b</span><span class="params">(<span class="number">88</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">show</span>(b);        <span class="comment">// 将使用通用的版本。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130785787?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E6%9C%89%E5%85%83&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-130785787.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&spm=1018.2226.3001.4187">模板类与友元</a></li></ul><h2 id="模板类成员模板"><a href="#模板类成员模板" class="headerlink" title="模板类成员模板"></a>模板类成员模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;m_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;m_y&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line">T1 b;</span><br><span class="line"><span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;测试&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">B&lt;string&gt; m_b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//这里的T和上面的T无关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T tt)</span></span>&#123;</span><br><span class="line">m_b.<span class="built_in">show</span>();</span><br><span class="line">cout&lt;&lt;m_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;m_y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">AA&lt;<span class="type">int</span>,string&gt; <span class="title">a</span><span class="params">(<span class="number">88</span>,<span class="string">&quot;我的世界&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">show</span>();</span><br><span class="line">a.<span class="built_in">show</span>(<span class="string">&quot;你是谁&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在外面的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板类AA中模板类B中show方法在外写法</span></span><br><span class="line"><span class="comment">//在B类中void show();</span></span><br><span class="line"><span class="comment">//在类外</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> AA&lt;T1,T2&gt;::B&lt;T&gt;::<span class="built_in">show</span>()&#123;cout&lt;&lt;<span class="string">&quot;测试&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">------------------------</span><br><span class="line"><span class="comment">//模板类AAshow方法在外写法</span></span><br><span class="line"><span class="comment">//在A类中void show(T tt);</span></span><br><span class="line"><span class="comment">//在类外</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> AA&lt;T1,T2&gt;::<span class="built_in">show</span>(T tt)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="模板类用作参数"><a href="#模板类用作参数" class="headerlink" title="模板类用作参数"></a>模板类用作参数</h2><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130787396?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%B0%86%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-130787396.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&spm=1018.2226.3001.4187">将类模板用于参数</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> len&gt;<span class="comment">//实际上链表没有链表长度的说法，假设他需要</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 *m_head;</span><br><span class="line"><span class="type">int</span> m_len=len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向链表中插入了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleted</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向链表中删除了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向链表中更新了一条记录。\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> len&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1*m_data;</span><br><span class="line"><span class="type">int</span> m_len=len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向数组中插入了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleted</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向数组中删除了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向数组中更新了一条记录。\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//线性表模板类:tabletype(T1)线性表类型,datatype(T2)线性表的数据类型</span></span><br><span class="line"><span class="comment">//与普通的类模板是一样的,唯一的区别就是参数不一样,模板头部标签的模板参数不一样</span></span><br><span class="line"><span class="comment">//template&lt;class,int&gt;表示tabletype（class位置）不是一个普通的参数(不要填int等具体类型),而是一个类模板(填模板名),并且数据类型对的上</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>,<span class="type">int</span>&gt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="type">int</span> len&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//tabletype&lt;datatype,len&gt;m_table;//创建线性表对象</span></span><br><span class="line">T1&lt;T2,len&gt; m_table;<span class="comment">//创建线性表对象</span></span><br><span class="line"><span class="comment">//T1只是一个模板名,用T1创建对象的时候,要需要指定具体的数据类型</span></span><br><span class="line"><span class="comment">//T1的参数最常见的做法是,用LinearList类模板参数传递进来</span></span><br><span class="line"><span class="comment">//T1&lt;Array,10&gt;m_table;//创建线性表对象</span></span><br><span class="line"><span class="comment">//这么做也可以,但是没有体现类模板的价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;m_table.<span class="built_in">insert</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleted</span><span class="params">()</span></span>&#123;m_table.<span class="built_in">deleted</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;m_table.<span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oper</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;len=&quot;</span>&lt;&lt;m_table.m_len&lt;&lt;endl;</span><br><span class="line">m_table.<span class="built_in">insert</span>();</span><br><span class="line">m_table.<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建线性表对象,容器类型为链表,链表的数据类型为int,表长为20</span></span><br><span class="line">LinearList&lt;LinkList,<span class="type">int</span>,<span class="number">20</span>&gt;a;</span><br><span class="line">a.<span class="built_in">insert</span>();</span><br><span class="line">a.<span class="built_in">deleted</span>();</span><br><span class="line">a.<span class="built_in">update</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线性表对象,容器类型为链表,链表的数据类型为int,表长为20</span></span><br><span class="line">LinearList&lt;Array,string,<span class="number">20</span>&gt;b;</span><br><span class="line">b.<span class="built_in">insert</span>();</span><br><span class="line">b.<span class="built_in">deleted</span>();</span><br><span class="line">b.<span class="built_in">update</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h1 id="C-编译，链接，命名空间"><a href="#C-编译，链接，命名空间" class="headerlink" title="C++编译，链接，命名空间"></a>C++编译，链接，命名空间</h1><h2 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h2><ul><li>C++程序编译的过程：预处理 -&gt; 编译（优化、汇编）-&gt; 链接<br>预处理指令主要有以下三种：</li><li>包含头文件：<code>#include</code></li><li>宏定义：<code>#define（定义宏）、#undef（删除宏</code>）。</li><li>条件编译：<code>#ifdef、#ifndef</code></li></ul><h3 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h3><p><code>#include</code> 包含头文件有两种方式：</p><ul><li><code>#include &lt;文件名&gt;</code>：<strong>直接从编译器自带的函数库目录中寻找文件</strong></li><li><code>#include &quot;文件名&quot;</code>：<strong>先从自定义的目录中寻找文件</strong>，如果找不到，再从编译器自带的函数库目录中寻找</li><li><code>#include也包含其它的文件，如：*.h、*.cpp</code>或其它的文件</li></ul><p>C++98标准后的头文件：</p><ul><li>C的标准库：老版本的有.h后缀；新版本没有.h的后缀，增加了字符c的前缀。例如：老版本是<code>&lt;stdio.h&gt;</code>，新版本是<code>&lt;cstdio&gt;</code>，新老版本库中的内容是一样的。在程序中，不指定std命名空间也能使用库中的内容。</li><li>C++的标准库：老版本的有.h后缀；新版本没有.h的后缀。例如：老版本是<code>&lt;iostream.h&gt;</code>，**新版本是<code>&lt;iostream&gt;</code>**，老版本已弃用，只能用新版本。在程序中，必须指定std命名空间才能使用库中的内容</li><li>注意：用户自定义的头文件还是用.h为后缀。</li></ul><h3 id="宏定义指令"><a href="#宏定义指令" class="headerlink" title="宏定义指令"></a>宏定义指令</h3><ul><li>无参数的宏：<code>#define 宏名  宏内容</code></li><li>有参数的宏：<code>#define MAX(x,y)  ((x)&gt;(y) ? (x) : (y))    MAX(3,5)  ((3)&gt;(5) ? (3) : (5))</code></li><li>编译的时候，编译器把程序中的宏名用宏内容替换，是为宏展开（宏替换）</li><li>宏可以只有宏名，没有宏内容</li><li>在C++中，内联函数可代替有参数的宏，效果更好</li></ul><p>C++中常用的宏：</p><ul><li>当前源代码文件名：<strong>FILE</strong></li><li>当前源代码函数名：<strong>FUNCTION</strong></li><li>当前源代码行号：<strong>LINE</strong></li><li>编译的日期：<strong>DATE</strong></li><li>编译的时间：<strong>TIME</strong></li><li>编译的时间戳：<strong>TIMESTAMP</strong></li><li>当用C++编译程序时，宏__cplusplus就会被定义。</li></ul><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>最常用的两种：<code>#ifdef、#ifndef    if #define  if not #define</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//含义：如果#ifdef后面的宏名已存在，则使用程序段一，否则使用程序段二</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line">  程序段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  程序段二</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//含义：如果#ifndef后面的宏名不存在，则使用程序段一，否则使用序段二</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line">  程序段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  程序段二 </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="头文件中代买重复包含"><a href="#头文件中代买重复包含" class="headerlink" title="头文件中代买重复包含"></a>头文件中代买重复包含</h4><ul><li>在C&#x2F;C++中，在使用预编译指令#include的时候，为了防止头文件被重复包含，有两种方式。</li><li>第一种：用<code>#ifndef</code>指令<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GIRL_</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _GIRL_</span></span><br><span class="line">    <span class="comment">//代码内容。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure></li><li>第二种：把#pragma once指令放在文件的开头。<ul><li><code>#ifndef方式受C/C++</code>语言标准的支持，不受编译器的任何限制；而<code>#pragma once</code>方式有些编译器不支持。</li><li><code>#ifndef可以针对文件中的部分代码；而</code>#pragma once只能针对整个文件。</li><li><code>#ifndef更加灵活，兼容性好；</code>#pragma once操作简单，效率高。</li></ul></li></ul><h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><p><strong>源代码的组织</strong></p><ul><li>头文件<code>（*.h）</code>：<code>#include</code>头文件、函数的声明、结构体的声明、类的声明、模板的声明、内联函数、<code>#define</code>和const定义的常量等。</li><li>源文件<code>（*.cpp）</code>：函数的定义、类的定义、模板具体化的定义。</li><li>主程序（main函数所在的程序）：主程序负责实现框架和核心流程，把需要用到的头文件用<code>#include</code>包含进来。</li></ul><p><strong>编译预处理</strong><br>预处理的包括以下方面：<br>1）处理<code>#include</code>头文件包含指令。<br>2）处理<code>#ifdef #else #endif、#ifndef #else #endif条件编译指令。</code><br>3）处理<code>#define</code>宏定义。<br>4）为代码添加行号、文件名和函数名。<br>5）删除注释。<br>6）保留部分<code>#pragma</code>编译指令（编译的时候会用到）</p><p><strong>编译</strong></p><ul><li>将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化和汇编后，编译成若干个目标文件（二进制文件）</li></ul><p><strong>链接</strong></p><ul><li>将编译后的目标文件，以及它们所需要的库文件链接在一起，形成一个体整。</li></ul><p><strong>更多细节</strong></p><ul><li>分开编译的好处：每次只编译修改过的源文件，然后再链接，效率最高</li><li>编译单个<code>*.cpp</code>文件的时候，<strong>必须要让编译器知道名称的存在</strong>，否则会出现找不到标识符的错误</li><li>编译单个<code>*.cpp</code>文件的时候，编译器只需要知道名称的存在，不会把它们的定义一起编译</li><li>如果函数和类的定义不存在，编译不会报错，<strong>但链接会出现无法解析的外部命令</strong></li><li>链接的时候，变量、函数和类的定义只能有一个，否则会出现重定义的错误。（如果把变量、函数和类的定义放在<code>*.h</code>文件中，<code>*.h</code>会被多次包含，链接前可能存在多个副本；如果放在<code>*.cpp</code>文件中，<code>*.cpp</code>文件不会被包含，只会被编译一次，链接前只存在一个版本）</li><li>把<strong>变量、函数和类的定义</strong>放在<code>*.h</code>中是不规范的做法，如果<code>*.h</code>被多个<code>*.cpp</code>包含，会出现重定义。</li><li>用<code>#include</code>包含<code>*.cpp</code>也是不规范的做法，原理同上。</li><li>尽可能不使用全局变量，如果一定要用，要在<code>*.h</code>文件中声明（<strong>需要加extern关键字</strong>），在<code>*.cpp</code>文件中定义。</li><li>全局的const常量在头文件中定义（const常量仅在单个文件内有效）。</li><li><code>*.h</code>文件重复包含的处理方法只对单个的<code>*.cpp</code>文件有效，不是整个项目。</li><li>函数模板和类模板的声明和定义可以分开书写，但它们的定义并不是真实的定义，只能放在<code>*.h</code>文件中；函数模板和类模板的具体化版本的代码是真实的定义，所以放在<code>*.cpp</code>文件中。</li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li>较大型的项目会使用大量的全局名字，如类、函数、模板、变量等，很容易出现名字冲突的情况。</li><li>命名空间分割了全局空间，<strong>每个命名空间是一个作用域</strong>，防止名字冲突。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名字&#123;&#125;<span class="comment">//常见命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> 别名=原名<span class="comment">//创建命名空间的别名</span></span><br></pre></td></tr></table></figure><p><strong>使用命名空间</strong></p><ul><li>在同一命名空间内的名字可以直接访问，该命名空间之外的代码则必须明确指出命名空间。</li></ul><ol><li>运算符::<ul><li>语法：<strong>命名空间::名字</strong></li><li>简单明了，且不会造成任何冲突，但使用起来比较繁琐。</li></ul></li><li>using声明<ul><li>语法：<strong>using 命名空间::名字</strong></li><li>用using声明名后，就可以进行直接使用名称。</li><li>如果该声明区域有相同的名字，则会报错。</li></ul></li><li>using编译指令<ul><li>语法：using namespace 命名空间</li><li>using编译指令将使整个命名空间中的名字可用。如果声明区域有相同的名字，局部版本将隐藏命名空间中的名字，不过，可以使用域名解析符使用命名空间中的名称。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> aa&#123;</span><br><span class="line"><span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> d=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">cout&lt;&lt;aa::b&lt;&lt;endl;</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">using</span> aa::c;<span class="comment">//这样aa命名空间中的c可以直接用</span></span><br><span class="line">cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> aa;<span class="comment">//这样aa命名空间的所有代码都能用，最好不这样用</span></span><br><span class="line">cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b=<span class="number">3</span>;<span class="comment">//这里的b将屏蔽aa中的b,将和方式2发生冲突,和方式1，3不冲突</span></span><br><span class="line">cout&lt;&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><ul><li>命名空间是全局的，可以分布在多个文件中。</li><li>命名空间可以嵌套。</li><li>在命名空间中声明变量，而不是使用外部全局变量和静态全局变量。</li><li>对于 using 声明，首选将其作用域设置为局部而不是全局。</li><li>不要在<strong>头文件中使用 using 编译指令</strong>，如果非要使用，应将它放在所有的 <code>#include之后</code></li><li>匿名的命名空间，从创建的位置到文件结束有效<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo01.cpp ///////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public2.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> aa;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bb;</span><br><span class="line"><span class="keyword">using</span> bb::ab;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aa::ab=&quot;</span> &lt;&lt; aa::ab &lt;&lt; endl;</span><br><span class="line">aa::<span class="built_in">func1</span>();</span><br><span class="line">aa::A1 a;</span><br><span class="line">a.<span class="built_in">show</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bb::ab=&quot;</span> &lt;&lt; bb::ab &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// public2.cpp ///////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> aa</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>    ab = <span class="number">1</span>;        <span class="comment">// 全局变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bb</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>    ab = <span class="number">2</span>;        <span class="comment">// 全局变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;          <span class="comment">// 全局函数的定义。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了bb::func1()函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A1::show</span><span class="params">()</span> </span>&#123;    <span class="comment">// 类成员函数的类外实现。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了bb::A1::show()函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// public1.cpp ///////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> aa</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;          <span class="comment">// 全局函数的定义。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了aa::func1()函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A1::show</span><span class="params">()</span> </span>&#123;    <span class="comment">// 类成员函数的类外实现。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了aa::A1::show()函数。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// public2.h ///////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> aa</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span>    ab;        <span class="comment">// 全局变量。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bb</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span>    ab ;        <span class="comment">// 全局变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;       <span class="comment">// 全局函数的声明。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span>              <span class="comment">// 类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;    <span class="comment">// 类的成员函数。</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// public1.h ///////////////////////////////////////</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> aa</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;       <span class="comment">// 全局函数的声明。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span>              <span class="comment">// 类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;    <span class="comment">// 类的成员函数。</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="c-类型转换static-cast"><a href="#c-类型转换static-cast" class="headerlink" title="c++类型转换static_cast"></a>c++类型转换static_cast</h1><ul><li>C风格的类型转换很容易理解：</li><li>语法：(<strong>目标类型)表达式或目标类型(表达式);</strong></li><li>C++认为C风格的类型转换过于松散，可能会带来隐患，不够安全</li><li>C++推出了新的类型转换来替代C风格的类型转换，采用更严格的语法检查，降低使用风险</li><li>C++新增了四个关键字<strong>static_cast、const_cast、reinterpret_cast和dynamic_cast</strong>，用于支持C++风格的类型转换。</li><li>C++的类型转换只是语法上的解释，本质上与C风格的类型转换没什么不同，C语言做不到事情的C++也做不到。<br>语法：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;目标类型&gt;(表达式);</span><br><span class="line"><span class="built_in">const_cast</span>&lt;目标类型&gt;(表达式);</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;目标类型&gt;(表达式);</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;目标类型&gt;(表达式);</span><br></pre></td></tr></table></figure><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p><strong>用于内置数据类型之间的转换</strong></p><ul><li>除了语法不同，C和C++没有区别</li><li>用于基本类型之间的转换，如整数类型之间的转换、浮点数类型之间的转换等。</li><li>用于显式转换对象的类型，如将基类指针或引用转换为派生类指针或引用，但在转换时需要注意安全性。</li><li>可以用于指针之间的转换，但在进行指针类型转换时需要注意类型的兼容性。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>    ii = <span class="number">3</span>;</span><br><span class="line">    <span class="type">long</span> ll = ii;                     <span class="comment">// 绝对安全，可以隐式转换，不会出现警告。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> dd = <span class="number">1.23</span>;</span><br><span class="line">    <span class="type">long</span> ll1 = dd;                  <span class="comment">// 可以隐式转换，但是，会出现可能丢失数据的警告。</span></span><br><span class="line">    <span class="type">long</span> ll2 = (<span class="type">long</span>)dd;              <span class="comment">// C风格：显式转换，不会出现警告。</span></span><br><span class="line">    <span class="type">long</span> ll3 = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(dd);    <span class="comment">// C++风格：显式转换，不会出现警告。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ll1=&quot;</span> &lt;&lt; ll1 &lt;&lt; <span class="string">&quot;,ll2=&quot;</span> &lt;&lt; ll2 &lt;&lt; <span class="string">&quot;,ll3=&quot;</span> &lt;&lt; ll3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>用于指针之间的转换</strong></li><li>C风格可以把不同类型的指针进行转换</li><li>C++不可以，需要借助<code>void *</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;   <span class="comment">// 其它类型指针 -&gt; void *指针 -&gt; 其它类型指针</span></span><br><span class="line">    <span class="type">double</span>* pp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ii = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//double* pd1 = &amp;ii;                      // 错误，不能隐式转换。</span></span><br><span class="line">    <span class="type">double</span>* pd2 = (<span class="type">double</span>*) &amp;ii;      <span class="comment">// C风格，强制转换。</span></span><br><span class="line">    <span class="comment">//double* pd3 = static_cast&lt;double*&gt;(&amp;ii);    // 错误，static_cast不支持不同类型指针的转换。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* pv = &amp;ii;                               <span class="comment">// 任何类型的指针都可以隐式转换成void*。</span></span><br><span class="line">    <span class="type">double</span>* pd4 = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(pv);  <span class="comment">// static_cast可以把void *转换成其它类型的指针。</span></span><br><span class="line">    <span class="built_in">func</span>(&amp;ii);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul><li><p>static_cast<strong>不能丢掉指针（引用）的const和volitale属性</strong>，const_cast可以：const 和 volatile 是 C++ 中的限定符，用于修饰变量的属性</p></li><li><p>使用 const_cast 可能会改变变量的属性，因此需要谨慎使用。下面是一个使用 const_cast 去除 const 限定符的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;num);</span><br><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 此时修改 num 变量的值是未定义行为</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 输出原始的 num 的值，即 10</span></span><br></pre></td></tr></table></figure></li><li><p>在上面的示例中，num 是一个 const 类型的变量，其值为 10。我们使用 const_cast 将 num 的地址转换为一个非 const 的指针 ptr。然后，我们试图通过 ptr 修改 num 的值。然而，这是一种未定义行为，因为我们试图修改一个被声明为 const 的变量。因此，最好避免在代码中使用 const_cast 来修改 const 变量的值。</p></li><li><p>可以用于改变指针的常量性，如将指向常量对象的指针转换为指向非常量对象的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *ii)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *aa=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> *bb = (<span class="type">int</span> *)aa;                          <span class="comment">// C风格，强制转换，丢掉const限定符。</span></span><br><span class="line"><span class="type">int</span>* cc = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(aa);      <span class="comment">// C++风格，强制转换，丢掉const限定符。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(aa));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul><li>static_cast不能用于转换不同类型的指针（引用）（不考虑有继承关系的情况），reinterpret_cast可以。</li><li>reinterpret_cast的意思是重新解释，能够将一种对象类型转换为另一种，不管它们是否有关系。</li><li>语法：<code>reinterpret_cast&lt;目标类型&gt;(表达式);</code></li><li><code>&lt;目标类型&gt;</code>和(表达式)中必须有一个是指针（引用）类型。</li><li>reinterpret_cast不能丢掉(表达式)的const或volitale属性。</li></ul><p><strong>应用场景</strong></p><ul><li>reinterpret_cast的第一种用途是<strong>改变指针（引用）的类型</strong></li><li>reinterpret_cast的第二种用途是<strong>将指针（引用）转换成整型变量</strong>。整型与指针占用的字节数必须一致，否则会出现警告，转换可能损失精度</li><li>reinterpret_cast的第三种用途是<strong>将一个整型变量转换成指针（引用）</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ii = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(ptr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ii = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(ii));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ul><li>用于在运行时进行多态类型的转换。</li><li>用于将基类指针或引用转换为派生类指针或引用，在转换过程中会进行运行时的类型检查。</li><li>可以在多态类型的继承体系中进行安全的向下转型，避免出现类型错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a square.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Circle* circlePtr = <span class="built_in">dynamic_cast</span>&lt;Circle*&gt;(shapePtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (circlePtr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        circlePtr-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to cast shapePtr to Circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.c++类_继承</title>
      <link href="/data.github.io/post/9ceaa80f.html"/>
      <url>/data.github.io/post/9ceaa80f.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h1><h2 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h2><ul><li>在C语言中，数据和处理数据的操作（函数）是分开的。也就是说，C语言本身没有支持数据和函数之间的关联性</li><li>C++用类描述抽象数据类型（abstract data type，ADT），在类中定义了数据和函数，把数据和函数关联起来</li><li>对象中维护了多个指针表，表中放了成员与地址的对应关系</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>    m_name[<span class="number">10</span>];              <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>      m_age;                   <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="comment">// 默认构造函数和析构函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; <span class="built_in">memset</span>(m_name, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_name)); m_age = <span class="number">0</span>;  &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>() &#123;  &#125;</span><br><span class="line">    <span class="comment">// 显示超女的姓名。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 显示超女的年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showage</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>![[Pasted image 20231224170251.png]]</p><ul><li>C++类中有两种数据成员：nonstatic、static，三种函数成员：nonstatic、static、virtual。</li><li>对象内存的大小包括：<ul><li>所有非静态数据成员的大小</li><li>由内存对齐而填补的内存大小</li><li>为了支持virtual成员而产生的额外负担</li></ul></li><li>静态成员变量属于类，<strong>不计算在对象的大小之内</strong>。</li><li>成员函数是分开存储的，不论对象是否存在都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内。</li><li>用空指针可以调用没有用到this指针的非静态成员函数。</li><li>对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。</li></ul><h2 id="有元"><a href="#有元" class="headerlink" title="有元"></a>有元</h2><ul><li>有元提供了另一类访问类的私有成员</li><li>关键字 friend</li></ul><p><strong>友元全局函数</strong></p><ul><li>在友元全局函数中，可以访问另一个类的所有成员。</li></ul><p><strong>友元类</strong></p><ul><li>在友元类所有成员函数中，都可以访问另一个类的所有成员。</li><li>友元类的注意事项：<ul><li>友元关系不能被继承。</li><li>友元关系是单向的，不具备交换性。</li></ul></li><li>若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。</li></ul><p><strong>友元成员函数</strong></p><ul><li>在友元成员函数中，可以访问另一个类的所有成员</li><li>如果要把男朋友类CBoy的某成员函数声明为超女类CGirl的友元，声明和定义的顺序如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>;            <span class="comment">// 前置声明。   </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span> &#123; ...... &#125;;      <span class="comment">// CBoy的定义。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span> &#123; ...... &#125;;      <span class="comment">// CGirl的定义。</span></span><br><span class="line">                                      </span><br><span class="line"><span class="comment">// 友元成员函数的定义。               </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBoy::func</span><span class="params">(CGirl &amp;g)</span> </span>&#123; ...... &#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>示例1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 这行代码将 int main() 声明为 CGirl 类的友元函数。</span></span><br><span class="line"><span class="comment">// 这意味着 main() 函数可以直接访问 CGirl 类的私有成员和保护成员。</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//func函数可以访问类的所有信息</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;   <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_name = <span class="string">&quot;西施&quot;</span>;  m_xw = <span class="number">87</span>; &#125;</span><br><span class="line">    <span class="comment">// 显示姓名的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>         m_xw;        <span class="comment">// 胸围。</span></span><br><span class="line">    <span class="comment">// 显示胸围的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showxw</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;胸围：&quot;</span> &lt;&lt; m_xw &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGirl g;</span><br><span class="line">    g.<span class="built_in">showname</span>();</span><br><span class="line">    g.<span class="built_in">showxw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>示例2<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CBoy</span>;<span class="comment">//在CBoy类中可以访问CGirl的所有函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;   <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_name = <span class="string">&quot;西施&quot;</span>;  m_xw = <span class="number">87</span>; &#125;</span><br><span class="line">    <span class="comment">// 显示姓名的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>         m_xw;        <span class="comment">// 胸围。</span></span><br><span class="line">    <span class="comment">// 显示胸围的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showxw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;胸围：&quot;</span> &lt;&lt; m_xw &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span>    <span class="comment">// 超女的男朋友类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我女朋友的姓名是：&quot;</span> &lt;&lt; g.m_name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我女朋友的胸围是：&quot;</span> &lt;&lt; g.m_xw &lt;&lt; endl;</span><br><span class="line">        g.<span class="built_in">showxw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGirl g;</span><br><span class="line">    CBoy b;</span><br><span class="line">    b.<span class="built_in">func</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>示例3<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>;      <span class="comment">// 把超女类的声明前置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span>    <span class="comment">// 超女的男朋友类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CBoy::func1</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span></span>;<span class="comment">//只有 CBoy 类中的 func1 函数可以访问 CGirl 类的所有信息。</span></span><br><span class="line">    <span class="comment">// friend void CBoy::func2(const CGirl&amp; g);</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;   <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_name = <span class="string">&quot;西施&quot;</span>;  m_xw = <span class="number">87</span>; &#125;</span><br><span class="line">    <span class="comment">// 显示姓名的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showname</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>         m_xw;        <span class="comment">// 胸围。</span></span><br><span class="line">    <span class="comment">// 显示胸围的成员函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showxw</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;胸围：&quot;</span> &lt;&lt; m_xw &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBoy::func1</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;func1()我女朋友的胸围是：&quot;</span> &lt;&lt; g.m_xw &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBoy::func2</span><span class="params">(<span class="type">const</span> CGirl&amp; g)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;func2()我女朋友的姓名是：&quot;</span> &lt;&lt; g.m_name &lt;&lt; endl; &#125;<span class="comment">//将g.m_name改为g.m_xw将会报错应为m_xw是private</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGirl g;</span><br><span class="line">    CBoy b;</span><br><span class="line">    b.<span class="built_in">func2</span>(g);</span><br><span class="line">    b.<span class="built_in">func1</span>(g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="运算符重载基础"><a href="#运算符重载基础" class="headerlink" title="运算符重载基础"></a>运算符重载基础</h3><ul><li>C++将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观。</li><li>例如字符串string用加号（+）拼接、cout用两个左尖括号（&lt;&lt;）输出。</li><li>运算符重载函数的语法：<strong>返回值 operator运算符(参数列表);</strong></li><li>运算符重载函数的返回值类型要与运算符本身的含义一致。</li><li>非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；</li><li>成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个<strong>操作数隐式传递了调用对象</strong>。</li><li>如果同时重载了非成员函数和成员函数版本，会出现二义性。</li></ul><p><strong>注意</strong></p><ol><li>返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）</li><li>重载函数参数列表中的顺序决定了操作数的位置。</li><li>重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符。</li><li>如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷。</li><li>重载函数不能违背运算符原来的含义和优先级。</li><li>不能创建新的运算符。</li><li>以下运算符不可重载：</li></ol><table><thead><tr><th align="left">sizeof</th><th align="left">sizeof运算符</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">成员运算符</td></tr><tr><td align="left">.*</td><td align="left">成员运算符</td></tr><tr><td align="left">::</td><td align="left">作用域解析运算符</td></tr><tr><td align="left">?:</td><td align="left">条件运算符</td></tr><tr><td align="left">typeid</td><td align="left">一个RTTI运算符</td></tr><tr><td align="left">const_cast</td><td align="left">强制类型转换运算符</td></tr><tr><td align="left">dynamic_cast</td><td align="left">强制类型转换运算符</td></tr><tr><td align="left">reinterpret_cast</td><td align="left">强制类型转换运算符</td></tr><tr><td align="left">static_cast</td><td align="left">强制类型转换运算符</td></tr></tbody></table><ul><li>以下运算符只能通过成员函数进行重载</li></ul><p>![[Pasted image 20231224190921.png]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> CGirl &amp;<span class="keyword">operator</span>+(CGirl&amp; g, <span class="type">int</span> score);</span><br><span class="line">    <span class="keyword">friend</span> CGirl&amp; <span class="keyword">operator</span>+(<span class="type">int</span> score, CGirl&amp; g);</span><br><span class="line">    <span class="keyword">friend</span> CGirl&amp; <span class="keyword">operator</span>+(CGirl&amp; g1, CGirl&amp; g2);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>         m_xw;        <span class="comment">// 胸围。</span></span><br><span class="line">    <span class="type">int</span>         m_score;    <span class="comment">// 分数。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;   <span class="comment">// 姓名。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_name = <span class="string">&quot;西施&quot;</span>;  m_xw = <span class="number">87</span>;  m_score = <span class="number">30</span>; &#125;</span><br><span class="line">    <span class="comment">// 自我介绍的方法。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，胸围：&quot;</span> &lt;&lt; m_xw &lt;&lt; <span class="string">&quot;，评分：&quot;</span> &lt;&lt; m_score &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数相对于非成员函数少了自生CGirl&amp; g</span></span><br><span class="line">    CGirl&amp; <span class="keyword">operator</span>-(<span class="type">int</span> score)    <span class="comment">// 给超女减分的函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">       m_score = m_score - score;</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CGirl&amp; <span class="keyword">operator</span>+(CGirl&amp; g, <span class="type">int</span> score)    <span class="comment">// 给超女加分的函数。</span></span><br><span class="line">&#123;</span><br><span class="line">    g.m_score = g.m_score + score;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">CGirl&amp; <span class="keyword">operator</span>+(<span class="type">int</span> score,CGirl&amp; g)    <span class="comment">// 给超女加分的函数。</span></span><br><span class="line">&#123;</span><br><span class="line">    g.m_score = g.m_score + score;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">CGirl&amp; <span class="keyword">operator</span>+(CGirl&amp; g1, CGirl&amp; g2)    <span class="comment">// 给超女加分的函数。</span></span><br><span class="line">&#123;</span><br><span class="line">    g1.m_score = g1.m_score + g2.m_score;</span><br><span class="line">    <span class="keyword">return</span> g1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 导演的要求：每轮表演之后，给超女加上她的得分。</span></span><br><span class="line">    CGirl g;</span><br><span class="line">    g =  g+g;</span><br><span class="line">    g.<span class="built_in">show</span>();</span><br><span class="line">g=g+<span class="number">4</span>;</span><br><span class="line">g.<span class="built_in">show</span>();</span><br><span class="line">g=g<span class="number">-2</span>;</span><br><span class="line">g.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CGirl &amp;<span class="keyword">operator</span>-(CGirl &amp;g,<span class="type">int</span> age)&#123;  </span><br><span class="line">    g.m_age-=age;  </span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">CGirl &amp;<span class="keyword">operator</span>-(<span class="type">int</span> age,CGirl &amp;g)&#123;  </span><br><span class="line">    g.m_age-=age;  </span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g=<span class="number">3</span>-g<span class="number">-10</span><span class="number">-1</span>;<span class="comment">//这样可以有上面两个函数才能执行，只有第一个函数无法执行</span></span><br><span class="line"><span class="comment">//g=3-10-g-1;//相当于3-（10-（1-1））,要从g.m_age=1开始执行</span></span><br></pre></td></tr></table></figure><h3 id="重载关系运算符"><a href="#重载关系运算符" class="headerlink" title="重载关系运算符"></a>重载关系运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重载关系运算符（==、!=、&gt;、&gt;=、&lt;、&lt;=）用于比较两个自定义数据类型的大小。</span><br><span class="line">可以使用非成员函数和成员函数两种版本，建议采用成员函数版本。</span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line">    string    m_name;     <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">int</span>         m_yz;           <span class="comment">// 颜值：1-千年美人；2-百年美人；3-绝代美人；4-极漂亮；5-漂亮；6-一般；7-歪瓜裂枣。</span></span><br><span class="line">    <span class="type">int</span>         m_sc;           <span class="comment">// 身材：1-火辣；2-...；3-...；4-...；5-...；6-...；7-膘肥体壮。</span></span><br><span class="line">    <span class="type">int</span>         m_acting;    <span class="comment">// 演技：1-完美；2-...；3-...；4-...；5-...；6-...；7-四不像。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 四个参数的构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>(string name, <span class="type">int</span> yz, <span class="type">int</span> sc, <span class="type">int</span> acting) &#123; m_name = name;  m_yz = yz;  m_sc = sc; m_acting = acting; &#125;</span><br><span class="line">    <span class="comment">// 比较两个超女的商业价值。</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CGirl&amp; g1)      <span class="comment">// 相等==</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m_yz + m_sc + m_acting) == (g1.m_yz + g1.m_sc + g1.m_acting)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> CGirl&amp; g1)      <span class="comment">// 大于&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m_yz + m_sc + m_acting) &lt; (g1.m_yz + g1.m_sc + g1.m_acting)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> CGirl&amp; g1)      <span class="comment">// 小于&lt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m_yz + m_sc + m_acting) &gt; (g1.m_yz + g1.m_sc + g1.m_acting)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CGirl  <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span>, <span class="title">g2</span><span class="params">(<span class="string">&quot;冰冰&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (g1==g2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;西施和冰冰的商业价值相同。\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (g1&gt;g2)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;西施商业价值相同比冰冰大。\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;冰冰商业价值相同比西施大。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>![[Pasted image 20230729214456.png]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> CGirl&amp;g)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_age&lt;g.m_age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相等==,小于&lt;,大于&gt;等等</span></span><br></pre></td></tr></table></figure><h3 id="重载左移运算符"><a href="#重载左移运算符" class="headerlink" title="重载左移运算符"></a>重载左移运算符</h3><ul><li><strong>只能使用非成员函数版本</strong>。</li><li>重载左移运算符（&lt;&lt;）<strong>用于输出自定义对象的成员变量</strong>，在实际开发中很有价值（调试和日志）</li><li>如果要输出对象的私有成员，可以配合友元一起使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非成员函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="type">const</span> CGirl &amp;g)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;姓名：&quot;</span>&lt;&lt;m_name;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;g&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li></ul><h3 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h3><ul><li>如果对象中有数组，<code>重载下标运算符[]</code>，操作对象中的数组将像操作普通数组一样方便。</li><li><strong>下标运算符必须以成员函数的形式进行重载</strong>。</li></ul><p>下标运算符重载函数的语法：</p><ul><li>方式一：<code>返回值类型 &amp;perator[](参数);</code></li><li>方式二：<code>const 返回值类型 &amp;operator[](参数) const;</code><ul><li>使用第一种声明方式，<code>[]</code>不仅可以<strong>访问</strong>数组元素，可以<strong>修改</strong>数组元素。</li><li>使用第二种声明方式，<code>[]</code><strong>只能访问而不能修改数组元素</strong>。</li></ul></li><li>在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应const对象，因为通过const 对象只能调用const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何数组元素。</li><li>在重载函数中，可以对下标做合法性检查，防止数组越界。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string    m_boys[<span class="number">3</span>];       <span class="comment">// 超女的男朋友</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;          <span class="comment">// 姓名。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_boys[<span class="number">0</span>] = <span class="string">&quot;子都&quot;</span>; m_boys[<span class="number">1</span>] = <span class="string">&quot;潘安&quot;</span>; m_boys[<span class="number">2</span>] = <span class="string">&quot;宋玉&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// 显示全部男朋友的姓名。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; m_boys[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;、&quot;</span> &lt;&lt; m_boys[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;、&quot;</span> &lt;&lt; m_boys[<span class="number">2</span>] &lt;&lt; endl; &#125;</span><br><span class="line">    string&amp; <span class="keyword">operator</span>[](<span class="type">int</span> ii)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_boys[ii];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> string&amp; <span class="keyword">operator</span>[](<span class="type">int</span> ii) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_boys[ii];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGirl g;          <span class="comment">// 创建超女对象。</span></span><br><span class="line">    g[<span class="number">1</span>] = <span class="string">&quot;王麻子&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第1任男朋友：&quot;</span> &lt;&lt; g[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    g.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> CGirl g1 = g;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第1任男朋友：&quot;</span> &lt;&lt; g1[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h3><ul><li>C++编译器可能会给类添加四个函数：<ul><li>默认构造函数，空实现。</li><li>默认析构函数，空实现。</li><li>默认拷贝构造函数，对成员变量进行浅拷贝。</li><li>默认赋值函数, 对成员变量进行浅拷贝。</li></ul></li><li>对象的赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值。</li><li>如果类的定义中没有重载赋值函数，编译器就会提供一个默认赋值函数。</li><li>如果类中重载了赋值函数，编译器将不提供默认赋值函数。</li><li>重载赋值函数的语法：<code>类名 &amp; operator=(const 类名 &amp; 源对象);</code><br><strong>注意</strong></li><li>编译器提供的默认赋值函数，<strong>是浅拷贝</strong>。</li><li><strong>如果对象中不存在堆区内存空间</strong>，默认赋值函数可以满足需求，否则需要深拷贝。</li><li>赋值运算和拷贝构造不同：拷贝构造是指原来的对象不存在，用已存在的对象进行构造；赋值运算是指已经存在了两个对象，把其中一个对象的成员变量的值赋给另一个对象的成员变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">                     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>         m_bh;               <span class="comment">// 编号。</span></span><br><span class="line">    string    m_name;          <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">int</span>*        m_ptr;              <span class="comment">// 计划使用堆区内存。</span></span><br><span class="line">                        </span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_ptr = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>() &#123; <span class="keyword">if</span> (m_ptr)  <span class="keyword">delete</span> m_ptr;  &#125;</span><br><span class="line">    <span class="comment">// 显示全部成员变量。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;编号：&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;，姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，m_ptr=&quot;</span> &lt;&lt; m_ptr &lt;&lt;/* <span class="string">&quot;，*m_ptr=&quot;</span> &lt;&lt; *m_ptr&lt;&lt; */endl; &#125;</span><br><span class="line">    CGirl&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CGirl&amp; g)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;g) <span class="keyword">return</span> *<span class="keyword">this</span>;          <span class="comment">// 如果是自己给自己赋值。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (g.m_ptr == <span class="literal">nullptr</span>)    <span class="comment">// 如果源对象的指针为空，则清空目标对象的内存和指针。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_ptr != <span class="literal">nullptr</span>) &#123; <span class="keyword">delete</span> m_ptr; m_ptr = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 如果源对象的指针不为空。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果目标对象的指针为空，先分配内存。</span></span><br><span class="line">            <span class="keyword">if</span> (m_ptr == <span class="literal">nullptr</span>) m_ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">            <span class="comment">// 然后，把源对象内存中的数据复制到目标对象的内存中。</span></span><br><span class="line">            <span class="built_in">memcpy</span>(m_ptr, g.m_ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">                  </span><br><span class="line">        m_bh = g.m_bh; m_name = g.m_name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了重载赋值函数。\n&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">                         </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGirl g1, g2;          <span class="comment">// 创建超女对象。</span></span><br><span class="line">    g1.m_bh = <span class="number">8</span>; g1.m_name = <span class="string">&quot;西施&quot;</span>; g1.m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">    g2.<span class="built_in">show</span>();</span><br><span class="line">              </span><br><span class="line">    g2 = g1;  </span><br><span class="line">    g2.<span class="built_in">show</span>(); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*g1.m_ptr=&quot;</span> &lt;&lt; *g1.m_ptr &lt;&lt; <span class="string">&quot;，*g2.m_ptr=&quot;</span> &lt;&lt; *g2.m_ptr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重载-new-delete"><a href="#重载-new-delete" class="headerlink" title="重载 new&amp;delete"></a>重载 new&amp;delete</h3><ul><li>重载new和delete运算符的目是为了自定义内存分配的细节。（内存池：快速分配和归还，无碎片）</li></ul><p>在C++中，使用new时，编译器做了两件事情：</p><ul><li>调用标准库函数operator new()分配内存；</li><li>调用构造函数初始化内存；</li></ul><p>使用delete时，也做了两件事情：</p><ol><li>调用析构函数；</li><li>调用标准库函数operator delete()释放内存</li></ol><ul><li>构造函数和析构函数由编译器调用，我们无法控制。</li><li>但是，可以重载内存分配函数operator new()和释放函数operator delete()。<ul><li>重载内存分配函数的语法：<code>void* operator new(size_t size);</code>   <ul><li>参数必须是size_t，返回值必须是<code>void*</code>。</li></ul></li><li>重载内存释放函数的语法：<code>void operator delete(void* ptr)</code>   <ul><li>参数必须是<code>void *</code>（指向由operator new()分配的内存），返回值必须是void。</li></ul></li></ul></li><li>重载的new和delete可以是全局函数，也可以是类的成员函数。</li><li>为一个类重载new和delete时，尽管不必显式地使用static，但实际上仍在创建static成员函数。</li><li>编译器看到使用new创建自定义的类的对象时，它选择成员版本的operator new()而不是全局版本的new()。</li><li><code>new[]和delete[]</code>也可以重载。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">                   </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span>   <span class="comment">// 参数必须是size_t（unsigned long long），返回值必须是void*。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了全局重载的new：&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节。\n&quot;</span>;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);        <span class="comment">// 申请内存。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;申请到的内存的地址是：&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span>   <span class="comment">// 参数必须是void *，返回值必须是void。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了全局重载的delete。\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="number">0</span>) <span class="keyword">return</span>;       <span class="comment">// 对空指针delete是安全的。</span></span><br><span class="line"><span class="built_in">free</span>(ptr);      <span class="comment">// 释放内存。</span></span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span>        m_bh;               <span class="comment">// 编号。</span></span><br><span class="line"><span class="type">int</span>        m_xw;               <span class="comment">// 胸围。</span></span><br><span class="line">                               </span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">int</span> bh, <span class="type">int</span> xw) &#123; m_bh = bh, m_xw = xw;  cout &lt;&lt; <span class="string">&quot;调用了构造函数CGirl()\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">CGirl</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~CGirl()\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span>   <span class="comment">// 参数必须是size_t（unsigned long long），返回值必须是void*。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了类的重载的new：&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;字节。\n&quot;</span>;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);        <span class="comment">// 申请内存。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;申请到的内存的地址是：&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span>   <span class="comment">// 参数必须是void *，返回值必须是void。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用了类的重载的delete。\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="number">0</span>) <span class="keyword">return</span>;       <span class="comment">// 对空指针delete是安全的。</span></span><br><span class="line"><span class="built_in">free</span>(ptr);      <span class="comment">// 释放内存。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;    </span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);<span class="comment">//这里调用了全局变量的new</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1=&quot;</span> &lt;&lt; (<span class="type">void</span> *)p1 &lt;&lt;<span class="string">&quot;，*p1=&quot;</span> &lt;&lt;*p1&lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line">             </span><br><span class="line">CGirl* p2 = <span class="keyword">new</span> <span class="built_in">CGirl</span>(<span class="number">3</span>, <span class="number">8</span>);<span class="comment">//这里调用了类中的new</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的地址是：&quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot;编号：&quot;</span> &lt;&lt; p2-&gt;m_bh &lt;&lt; <span class="string">&quot;，胸围：&quot;</span> &lt;&lt; p2-&gt;m_xw &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重载括号运算符"><a href="#重载括号运算符" class="headerlink" title="重载括号运算符"></a>重载括号运算符</h3><ul><li>括号运算符()也可以重载，对象名可以当成函数来使用（函数对象、仿函数）。</li><li>语法：<strong>返回值类型 operator()(参数列表);</strong></li></ul><p><strong>注意</strong></p><ul><li><strong>括号运算符必须以成员函数的形式进行重载</strong>。</li><li>括号运算符重载函数具备普通函数全部的特征。</li><li>如果函数对象与全局函数同名，按作用域规则选择调用的函数。</li></ul><p><strong>函数对象的用途</strong></p><ol><li>表面像函数，部分场景中可以代替函数，在STL中得到广泛的应用；</li><li>函数对象本质是类，可以用成员变量存放更多的信息；</li><li>函数对象有自己的数据类型；</li><li>可以提供继承体系。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;普通函数：&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;重载函数：&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CGirl girl;</span><br><span class="line">    <span class="built_in">girl</span>(<span class="string">&quot;我的&quot;</span>);</span><br><span class="line">    <span class="comment">//对于第4点</span></span><br><span class="line">    CGirl show;</span><br><span class="line">    ::<span class="built_in">show</span>(<span class="string">&quot;哈HA&quot;</span>);<span class="comment">//函数名重了，这样才能调用全局函数</span></span><br><span class="line">    <span class="built_in">show</span>(<span class="string">&quot;哈HA&quot;</span>);<span class="comment">//调用的重载函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载一元运算符"><a href="#重载一元运算符" class="headerlink" title="重载一元运算符"></a>重载一元运算符</h3><p>![[Pasted image 20230730170313.png]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">成员函数版：CGirl &amp;<span class="keyword">operator</span>++();             <span class="comment">// ++前置</span></span><br><span class="line">成员函数版：CGirl <span class="keyword">operator</span>++(<span class="type">int</span>);            <span class="comment">// 后置++</span></span><br><span class="line">非成员函数版：CGirl &amp;<span class="keyword">operator</span>++(CGirl &amp;);   <span class="comment">// ++前置</span></span><br><span class="line">非成员函数版：CGirl <span class="keyword">operator</span>++(CGirl &amp;,<span class="type">int</span>);  <span class="comment">// 后置++</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里对后置++需要有一定理解<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;重载函数：&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CGirl</span>()&#123;a=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">// void operator++()&#123;</span></span><br><span class="line"><span class="comment">// a++;</span></span><br><span class="line"><span class="comment">// &#125;//这是前置，只能实现++g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的形式针对++(++g),++g;</span></span><br><span class="line">CGirl &amp;<span class="keyword">operator</span>++()&#123;</span><br><span class="line">a++;<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//前置</span></span><br><span class="line">CGirl <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">a++;<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//这是后置</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CGirl g;</span><br><span class="line">    ++g;</span><br><span class="line">    g++;</span><br><span class="line">    cout&lt;&lt;g.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><ul><li>对于内置类型，如果两种数据类型是兼容的，C++可以自动转换，如果从更大的数转换为更小的数，可能会被截断或损失精度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> count = <span class="number">8</span>;        <span class="comment">// int转换为long</span></span><br><span class="line"><span class="type">double</span> time = <span class="number">11</span>;      <span class="comment">// int转换为double</span></span><br><span class="line"><span class="type">int</span> side = <span class="number">3.33</span>;         <span class="comment">// double转换为int的3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++不自动转换不兼容的类型，下面语句是非法的：</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能自动转换时，可以使用强制类型转换：</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="number">8</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果某种类型与类相关，从某种类型转换为类类型是有意义的</span></span><br><span class="line">string str = <span class="string">&quot;我是一只傻傻鸟&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++中，将一个参数的构造函数用作自动类型转换函数，它是自动进行的，不需要显式的转换</span></span><br><span class="line"><span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="number">8</span>)</span></span>;           <span class="comment">// 常规的写法</span></span><br><span class="line">CGirl g1 = <span class="built_in">CGirl</span>(<span class="number">8</span>);   <span class="comment">// 显式转换</span></span><br><span class="line">CGirl g1 = <span class="number">8</span>;          <span class="comment">// 隐式转换</span></span><br><span class="line">CGirl g1;              <span class="comment">// 创建对象</span></span><br><span class="line">g1 = <span class="number">8</span>;                <span class="comment">// 隐式转换，用CGirl(8)创建临时对象，再赋值给g</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong></p><ul><li>一个类可以有多个转换函数</li><li>多个参数的构造函数，除第一个参数外，如果其它参数都有缺省值，也可以作为转换函数</li><li>CGirl(int)的隐式转换的场景：<ul><li>将CGirl对象初始化为int值时： CGirl g1 &#x3D; 8;</li><li>将int值赋给CGirl对象时：CGirl g1; g1 &#x3D; 8;</li><li>将int值传递给接受CGirl参数的函数时</li><li>返回值被声明为CGirl的函数试图返回int值时</li><li>在上述任意一种情况下，使用可转换为int类型的内置类型时。</li></ul></li><li>如果自动类型转换有二义性，编译将报错</li><li>将构造函数用作自动类型转换函数似乎是一项不错的特性，但有时候会导致意外的类型转换。<strong>explicit关键字用于关闭这种自动特性，但仍允许显式转换</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CGirl</span><span class="params">(<span class="type">int</span> bh)</span></span>;</span><br><span class="line">CGirl g=<span class="number">8</span>;        <span class="comment">// 错误。</span></span><br><span class="line">CGirl g=<span class="built_in">CGirl</span>(<span class="number">8</span>);  <span class="comment">// 显式转换，可以。</span></span><br><span class="line">CGirl g=(CGirl)<span class="number">8</span>;  <span class="comment">// 显式转换，可以。</span></span><br></pre></td></tr></table></figure><ul><li>在实际开发中，如果强调的是构造，建议使用explicit，如果强调的是类型转换，则不使用explicit。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>       <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;           </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>         m_bh;           <span class="comment">// 编号。</span></span><br><span class="line">    string    m_name;     <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">double</span>  m_weight;   <span class="comment">// 体重，单位：kg。</span></span><br><span class="line">                </span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_bh = <span class="number">0</span>;  m_name.<span class="built_in">clear</span>();  m_weight = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;调用了CGirl()\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// 自我介绍的方法。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;bh=&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;,weight=&quot;</span> &lt;&lt; m_weight &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CGirl</span><span class="params">(<span class="type">int</span> bh)</span> </span>&#123; m_bh = bh;  m_name.<span class="built_in">clear</span>();  m_weight = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;调用了CGirl(int bh)\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">//CGirl(double weight) &#123; m_bh = 0;  m_name.clear();  m_weight = weight; cout &lt;&lt; &quot;调用了CGirl(double weight)\n&quot;; &#125;</span></span><br><span class="line">&#125;;     </span><br><span class="line">          </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="comment">//CGirl g1(8);                // 常规的写法。</span></span><br><span class="line">    <span class="comment">//CGirl g1 = CGirl(8);   // 显式转换。</span></span><br><span class="line">    <span class="comment">//CGirl g1 = 8;             // 隐式转换。有explicit会报错，去掉则不会</span></span><br><span class="line">    CGirl g1;                    <span class="comment">// 创建对象。</span></span><br><span class="line">    g1 = (CGirl)<span class="number">8</span>;                      <span class="comment">// 隐式转换，用CGirl(8)创建临时对象，再赋值给g。</span></span><br><span class="line">    <span class="comment">//CGirl g1 = 8.7;             // 隐式转换。</span></span><br><span class="line">    <span class="comment">//g1.show();</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><ul><li>构造函数只用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数——转换函数</li><li>语法：<strong>operator 数据类型 ();</strong></li><li>注意：<strong>转换函数必须是类的成员函数：不能指定返回值类型；不能有参数。</strong></li><li>关键字 <a href="https://blog.csdn.net/qq_35524916/article/details/58178072">explicit</a> 不能用于转换函数，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ii=girl;       <span class="comment">// 隐式转换。</span></span><br><span class="line"><span class="type">int</span> ii=(<span class="type">int</span>) girl;  <span class="comment">// 显式转换。</span></span><br><span class="line"><span class="type">int</span> ii=<span class="built_in">int</span>(girl);   <span class="comment">// 显式转换。</span></span><br></pre></td></tr></table></figure></li><li>谨慎使用隐式转换函数，最好选择仅被显式调用地调用时才会执行的成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">string b;</span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line"><span class="built_in">CGirl</span>()&#123;</span><br><span class="line">a=<span class="number">1</span>;b=<span class="string">&quot;haha&quot;</span>;c=<span class="number">43.34</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> string name = <span class="string">&quot;西施&quot;</span>;                 <span class="comment">// char * 转换成 string</span></span><br><span class="line">    <span class="comment">//  const char* ptr = name;             // string 转换成 char *，错误</span></span><br><span class="line">     <span class="type">const</span> <span class="type">char</span>* ptr = name.<span class="built_in">c_str</span>();  <span class="comment">// 返回char *，正确</span></span><br><span class="line"></span><br><span class="line">    CGirl g;</span><br><span class="line">    <span class="type">int</span> a=g;<span class="comment">//这是隐式表达，explicit要用于显示表达，会报错，就像下面字符串的表达式才能正确的表达；如果有double函数，则会执行double这个而不是int</span></span><br><span class="line">    <span class="comment">// int a=int(g);//显示表达式</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    string b=<span class="built_in">string</span>(g);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>继承可以理解为一个类从另一个类获取成员变量和成员函数的过程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:［继承方式］基类名</span><br><span class="line">&#123;</span><br><span class="line">    派生类新增加的成员</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>被继承的类称为基类或父类</li><li>继承的类称为派生类或子类，派生类除了拥有基类的成员，还可以定义新的成员</li><li>派生类除了拥有基类的成员，还可以定义新的成员，以增强其功能</li></ul><p><strong>使用继承的场景：</strong></p><ul><li>如果新创建的类与现有的类相似，<strong>只是多出若干成员变量或成员函数时</strong>，可以使用继承</li><li>当需要创建多个类时，如果它们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAllComers</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line">string m_tel;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CAllComers</span>()&#123;m_name=<span class="string">&quot;女&quot;</span>;m_tel=<span class="string">&quot;不详&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(<span class="type">const</span> string &amp;name)</span></span>&#123;m_name=name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承形式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>:<span class="keyword">public</span> CAllComers</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_br;</span><br><span class="line"><span class="built_in">CGirl</span>()&#123;m_br=<span class="number">4</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;m_br&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CGirl g;</span><br><span class="line">g.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><ul><li>类成员的访问权限由高到低依次为：<code>public &gt; protected &gt; private</code>, public 成员在类外可以访问，private 成员只能在类的成员函数中访问。</li><li>如果不考虑继承关系，protected 成员和 private 成员一样，类外不能访问。但是，当存在继承关系时，protected 和 private 就不一样了。</li><li>基类中的 <strong>protected 成员可以在派生类中访问</strong>，而基类中的Private 成员不能在派生类中访问。</li><li>继承方式有三种：public（公有的）、protected（受保护的）和 private（私有的）。它是可选的。</li></ul><p>关系图<br>![[Pasted image 20230726144942.png]]</p><ul><li><p><strong>基类成员在派生类中的访问权限不得高于继承方式中指定的权限</strong>。例如，当继承方式为protected时，那么基类成员在派生类中的访问权限最高也为protected，高于protected的会降级为protected，但低于protected不会升级。</p><ul><li>继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。</li></ul></li><li><p>不管继承方式如何，<strong>基类中的private成员在派生类中始终不能使用</strong></p></li><li><p>如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为public 或protected；只有那些不希望在派生类中使用的成员才声明为private</p></li><li><p>如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 <strong>protected</strong></p></li><li><p>由于private和protected继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，一般使用public</p></li><li><p>在派生类中，可以通过<strong>基类的公有成员函数间接访问基类的私有成员</strong></p></li><li><p>使用 using 关键字可以改变基类成员在派生类中的访问权限。</p><ul><li>注意：<strong>using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限</strong>，因为基类中 private 成员在派生类中是不可见的，根本不能使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> A::b;<span class="comment">//将b的权限改为共有</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">using</span> A::a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="继承的对象模型"><a href="#继承的对象模型" class="headerlink" title="继承的对象模型"></a>继承的对象模型</h2><ul><li>创建派生类对象时，<strong>先调用基类的构造函数，再调用派生类的构造函数</strong>。</li><li>销毁派生类对象时，<strong>先调用派生类的析构函数，再调用基类的析构函数</strong>。</li><li>创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this 指针相同</li><li>创建派生类对象时，先初始化基类对象，再初始化派生类对象。</li><li>可以通过指针方法来对类的私有成员进行访问</li><li>对派生类对象用sizeof得到的是基类所有成员（包括私有成员）+派生类对象所有成员的大小</li></ul><h3 id="构造基类"><a href="#构造基类" class="headerlink" title="构造基类"></a>构造基类</h3><p>派生类构造函数的要点</p><ul><li>创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数</li><li>如果没以指定基类构造函数，将使用基类的默认构造函数</li><li>可以用初始化列表指明要使用的基类构造函数</li><li>基类构造函数负责初始化被继承的数据成员；派生类构造函数主要用于初始化新增的数据成员</li><li>派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用了基类的构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> p):<span class="built_in">a</span>(<span class="number">0</span>)&#123;</span><br><span class="line">b=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这样可以根据需求调用基类不同的构造函数</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="built_in">B</span>():<span class="built_in">c</span>(<span class="number">3</span>),<span class="built_in">A</span>()&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用了派生类的默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意写法</span></span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> p,<span class="type">int</span> j):<span class="built_in">c</span>(p),<span class="built_in">A</span>(j)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用了派生类的默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;,c:&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    b1.<span class="built_in">show</span>();</span><br><span class="line">    b2.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="名字遮蔽与类作用域"><a href="#名字遮蔽与类作用域" class="headerlink" title="名字遮蔽与类作用域"></a>名字遮蔽与类作用域</h3><p><strong>名字遮蔽</strong>：如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，<strong>将使用派生类新增的成员</strong>，而不是基类的。</p><ul><li>基类的成员函数和派生类的成员函数不会构成重载，如果<strong>派生类有同名函数，那么就会遮蔽基类中的所有同名函数</strong>。</li><li>但是可以利用下面的类作用域避免覆盖</li></ul><p><strong>作用域</strong></p><ul><li>类是一种作用域，每个类都有它自己的作用域，在这个作用域之内定义成员。</li><li>在类的作用域之外，普通的成员只能通过对象 (可以是对象本身，也可以是对象指针或对象引用)</li><li>在成员名前面加类名和域解析符可以访问对象的成员。</li><li>如果不存在继承关系，类名和域解析符可以省略不写</li><li>当存在继承关系时，基类的作用域嵌套在派生类的作用域中。如果成员在派生类的作用域中已经找到，就不会在基类作用域中继续查找；如果没有找到，则继续在基类作用域中查找<br>如果在成员的前面加上类名和域解析符，就可以直接使用该作用域的成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//这样可以区分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">A::a=a;</span><br><span class="line">cout&lt;&lt;A::a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   A a1;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;a1.a;//等价下面</span></span><br><span class="line">   cout&lt;&lt;a1.A::a&lt;&lt;endl;</span><br><span class="line">   a1.<span class="built_in">func</span>(<span class="number">65</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![[Pasted image 20230731163409.png]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   B b1;</span><br><span class="line">   cout&lt;&lt;b1.B::a&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;b1.A::a&lt;&lt;endl;<span class="comment">//这样就避免了派生类覆盖基类相同的值</span></span><br><span class="line">   cout&lt;&lt;b1.B::A::a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承特殊关系"><a href="#继承特殊关系" class="headerlink" title="继承特殊关系"></a>继承特殊关系</h3><ul><li>如果继承方式是公有的，派生类对象可以使用基类成员。</li><li>可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。</li><li>基类指针可以在不进行显式转换的情况下指向派生类对象。</li><li>基类引用可以在不进行显式转换的情况下引用派生类对象。</li><li><strong>基类指针或引用只能调用基类的方法</strong>，不能调用派生类的方法。可以用派生类构造基类。</li><li>如果函数的形参是基类，实参可以用派生类</li></ul><p><strong>注意</strong></p><ul><li><strong>基类指针或引用只能调用基类的方法</strong>，不能调用派生类的方法</li><li>可以用派生类构造基类</li><li>如果函数的形参是基类，实参可以用派生类</li><li>C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外。但是，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针（没有价值，没有讨论的必要）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;        <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 显示基类A全部的成员。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::show() m_a=&quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot;,m_b=&quot;</span> &lt;&lt; m_b &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 设置成员m_b的值。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setb</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123; m_b = b;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A        <span class="comment">// 派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_c=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 显示派生类B全部的成员。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::show() m_a=&quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot;m_c=&quot;</span> &lt;&lt; m_c &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;                   <span class="comment">// 创建一个B类的对象</span></span><br><span class="line">A* a = &amp;b;             <span class="comment">// 用A类的指针指向B类的对象</span></span><br><span class="line"></span><br><span class="line">b.m_a = <span class="number">10</span>;            <span class="comment">// 在B类中设置成员m_a的值为10</span></span><br><span class="line">b.<span class="built_in">setb</span>(<span class="number">20</span>);            <span class="comment">// 在B类中调用setb()函数设置成员m_b的值为20</span></span><br><span class="line">b.m_c = <span class="number">30</span>;            <span class="comment">// 在B类中设置成员m_c的值为30</span></span><br><span class="line">b.<span class="built_in">show</span>();              <span class="comment">// 调用B类的show()函数，输出结果可能是 &quot;m_a: 10, m_b: 20, m_c: 30&quot;</span></span><br><span class="line"></span><br><span class="line">a-&gt;m_a = <span class="number">11</span>;           <span class="comment">// 通过A类的指针设置B类对象的成员m_a的值为11（因为B是A的子类，所以可以通过A类的指针访问到B类的公共成员）</span></span><br><span class="line">a-&gt;<span class="built_in">setb</span>(<span class="number">22</span>);           <span class="comment">// 通过A类的指针调用B类对象的setb()函数设置成员m_b的值为22</span></span><br><span class="line"><span class="comment">// a-&gt;m_c = 30;        // 无法通过A类的指针直接访问B类对象的私有成员m_c</span></span><br><span class="line"></span><br><span class="line">a-&gt;<span class="built_in">show</span>();             <span class="comment">// 调用A类的show()函数，输出结果可能是 &quot;m_a: 11&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多继承与虚继承"><a href="#多继承与虚继承" class="headerlink" title="多继承与虚继承"></a>多继承与虚继承</h1><p><strong>多继承语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:继承方式<span class="number">1</span> 基类名,继承方式<span class="number">2</span> 基类名<span class="number">2.</span>..</span><br><span class="line">&#123;派生类新增成员&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> c=<span class="number">6</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>菱形继承</strong></p><ul><li>用上述多继承方式，则下面 D 类中会存在两个 a 变量，存在数据冗余；<strong>可利用类作用域实现分别访问，利用虚继承解决</strong></li><li><strong>虚继承可以解决菱形继承的二义性和数据冗余的问题</strong></li><li>不提倡使用多继承，只有在比较简单和不出现二义性的情况时才使用多继承，能用单一继承解决的问题就不要使用多继承</li><li>如果继承的层次很多、关系很复杂，程序的编写、调试和维护工作都会变得更加困难，由于这个原因，C++之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承</li></ul><p>![[Pasted image 20230731170149.png]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DD d;</span><br><span class="line">    <span class="comment">// d.B::m_a = 30;</span></span><br><span class="line">    <span class="comment">// d.C::m_a = 80;</span></span><br><span class="line">    d.m_a = <span class="number">80</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B::m_a的地址是：&quot;</span> &lt;&lt; &amp;d.B::m_a &lt;&lt; <span class="string">&quot;，值是：&quot;</span> &lt;&lt; d.B::m_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C::m_a的地址是：&quot;</span> &lt;&lt; &amp;d.C::m_a &lt;&lt; <span class="string">&quot;，值是：&quot;</span> &lt;&lt; d.C::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li><strong>基类指针只能调用基类的成员函数，不能调用派生类的成员函数</strong></li><li><strong>如果在基类的成员函数前加virtual</strong> 关键字，把它声明为虚函数，<strong>基类指针就可以调用派生类中同名的成员函数</strong>，通过派生类中同名的成员函数，就可以访问派生对象的成员变量</li><li>有了虚函数，<strong>基类指针指向基类对象时就使用基类的成员函数和数据，指向派生类对象时就使用派生类的成员函数和数据</strong>，基类指针表现出了多种形式，这种现象称为多态</li><li>基类引用也可以使用多态。</li></ul><p><strong>注意</strong></p><ol><li><strong>只需要在基类的函数声明中加上virtual关键字</strong>，函数定义时不能加。</li><li>在派生类中重定义虚函数时，函数特征要相同。</li><li>当在基类中定义了虚函数时，如果派生类没有重定义该函数，那么将使用基类的虚函数。</li><li>在派生类中重定义了虚函数的情况下，如果想使用基类的虚函数，可以加类名和域解析符。</li><li>如果要在派生类中重新定义基类的函数，则将它设置为虚函数；否则，不要设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAllComers</span> &#123;        <span class="comment">// 报名者类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>  m_bh = <span class="number">0</span>;             <span class="comment">// 编号。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CAllComers::show()：我是&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;号。 &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CAllComers::show(int a)：我是&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;号。 &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">             </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span> :<span class="keyword">public</span> CAllComers &#123;        <span class="comment">// 超女类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age = <span class="number">0</span>;           <span class="comment">// 年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CGirl::show()：我是&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;号， &quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;岁。&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CGirl::show(int a)：我是&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;号， &quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;岁。&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    CAllComers a;  a.m_bh = <span class="number">3</span>;                             <span class="comment">// 创建基类对象并对成员赋值。</span></span><br><span class="line">    CGirl g;             g.m_bh = <span class="number">8</span>; g.m_age = <span class="number">23</span>;    <span class="comment">// 创建派生类对象并对成员赋值。</span></span><br><span class="line">            </span><br><span class="line">    CAllComers* p;            <span class="comment">// 声明基类指针。</span></span><br><span class="line">    <span class="comment">//p = &amp;a;   p-&gt;show();   // 让基类指针指向基类对象，并调用虚函数。</span></span><br><span class="line">    p = &amp;g;   p-&gt;<span class="built_in">show</span>();   <span class="comment">// 让基类指针指向派生类对象，并调用虚函数。</span></span><br><span class="line">    p-&gt;<span class="built_in">show</span>(<span class="number">5</span>); </span><br><span class="line">    p-&gt;CAllComers::<span class="built_in">show</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多态的对象模型"><a href="#多态的对象模型" class="headerlink" title="多态的对象模型"></a>多态的对象模型</h3><ul><li><p>类的普通成员函数的地址是静态的，在编译阶段已指定。</p></li><li><p>如果基类中有虚函数，对象的内存模型中有一个虚函数表，表中存放了基类的函数名和地址。</p></li><li><p><strong>如果派生类中重定义了基类的虚函数</strong>，创建派生类对象时，将用派生类的函数取代虚函数表中基类的函数。</p></li><li><p>C++中的多态分为两种：<strong>静态多态与动态多态</strong>。</p></li><li><p>静态多态：也成为编译时的多态；在编译时期就已经确定要执行了的函数地址了；主要有函数重载和函数模板。</p></li><li><p>动态多态：即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，一般用于解决基类指针或引用派生类对象调用类中重写的方法（函数）时出现的问题。</p></li></ul><h2 id="析构派生类"><a href="#析构派生类" class="headerlink" title="析构派生类"></a>析构派生类</h2><ul><li><strong>构造函数不能继承</strong>，创建派生类对象时，先执行基类构造函数，再执行派生类构造函数。</li><li><strong>析构函数不能继承</strong>，而销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数。</li><li>派生类的析构函数在执行完后，会自动执行基类的析构函数。</li></ul><p><strong>析构派生类的要点如下</strong>：</p><ul><li>析构派生类对象时，会自动调用基类的析构函数。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数</li><li>用基类指针指向派生类对象时，delete 基类指针调用的是基类的析构函数，不是派生类的，如果希望调用派生类的析构函数，就要把基类的析构函数设置为虚函数。</li><li><strong>赋值运算符函数不能继承</strong>，派生类继承的函数的特征标与基类完全相同，但赋值运算符函数的特征标随类而异，它包含了一个类型为其所属类的形参</li><li>友元函数不是类成员，不能继承。</li><li>析构函数可以手工调用，如果对象中有堆内存，析构函数中以下代码是必要的 <code>delete ptr;ptr=nullptr;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">          </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;                    <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了基类的构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;调用了基类的func()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="comment">// virtual ~AA() &#123; cout &lt;&lt; &quot;调用了基类的析构函数~AA()。\n&quot;; &#125;</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AA</span>() &#123;cout&lt;&lt;<span class="string">&quot;调用了基类的析构函数AA()&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>:<span class="keyword">public</span> AA  &#123;  <span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了派生类的构造函数BB()。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;调用了派生类的func()。\n&quot;</span>; &#125;</span><br><span class="line">~<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了派生类的析构函数~BB()。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">         </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AA *a=<span class="keyword">new</span> BB;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><ul><li><strong>基类中不能对虚函数给出有意义的实现</strong>，把它声明为纯虚函数。</li><li>纯虚函数只有函数名、参数和返回值类型，<strong>没有函数体</strong>，具体实现留给该派生类去做</li><li>语法：<code>virtual 返回值类型 函数名（参数列表）=0;</code></li><li>纯虚函数在基类中为派生类保留一个函数的名字，以便派生类它进行重定义。如果在基类中没有保留函数名字，则无法支持多态性。</li><li><strong>含有纯虚函数的类被称为抽象类</strong>，不能实例化对象，<strong>可以创建指针和引用</strong></li><li>派生类必须重定义抽象类中的纯虚函数，否则也属于抽象类</li><li>基类中的纯虚析构函数也需要实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;基类构造A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//&#123;cout&lt;&lt;&quot;调用&quot;;&#125;</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;调用基类析构函数\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;派生构造B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;调用派生类&quot;</span>;&#125;</span><br><span class="line">~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;调用派生函数\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   B b1;</span><br><span class="line">   A *p=&amp;b1;</span><br><span class="line">   p-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行阶段类型识别dynamic-cast"><a href="#运行阶段类型识别dynamic-cast" class="headerlink" title="运行阶段类型识别dynamic_cast"></a>运行阶段类型识别dynamic_cast</h1><ul><li>运行阶段类型识别（RTTI RunTime Type Identification）为程序在运行阶段确定对象的类型，<strong>只适用于包含虚函数的类</strong>。</li><li>基类指针可以指向派生类对象，如何知道基类指针指向的是哪种派生类的对象呢？（想调用派生类中的非虚函数）。</li><li><strong>dynamic_cast运算符用指向基类的指针来生成派生类的指针</strong>，它不能回答“指针指向的是什么类的对象”的问题，但能回答“是否可以安全的将对象的地址赋给特定类的指针”的问题。</li><li>语法：<code>派生类指针 = dynamic_cast&lt;派生类类型 *&gt;(基类指针);</code></li><li>如果转换成功，dynamic_cast返回对象的地址，如果失败，返回nullptr。</li></ul><p><strong>注意</strong></p><ol><li>dynamic_cast只适用于包含虚函数的类。</li><li>dynamic_cast可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。</li><li>dynamic_cast可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现bad_cast异常。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>                        <span class="comment">// 英雄基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> viability;      <span class="comment">// 生存能力。</span></span><br><span class="line"><span class="type">int</span> attack;         <span class="comment">// 攻击伤害。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">skill1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;英雄释放了一技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">skill2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;英雄释放了二技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">uskill</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;英雄释放了大绝招。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XS</span> :<span class="keyword">public</span> Hero       <span class="comment">// 西施派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">skill1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;西施释放了一技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">skill2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;西施释放了二技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uskill</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;西施释放了大招。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;我是天下第一美女。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HX</span> :<span class="keyword">public</span> Hero       <span class="comment">// 韩信派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">skill1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;韩信释放了一技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">skill2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;韩信释放了二技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uskill</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;韩信释放了大招。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LB</span> :<span class="keyword">public</span> Hero       <span class="comment">// 李白派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">skill1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;李白释放了一技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">skill2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;李白释放了二技能。\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uskill</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;李白释放了大招。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 根据用户选择的英雄，施展一技能、二技能和大招。</span></span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>;     <span class="comment">// 英雄的id。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入英雄（1-西施；2-韩信；3-李白。）：&quot;</span>;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基类指针，让它指向派生类对象，用基类指针调用派生类的成员函数。</span></span><br><span class="line">Hero* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>) &#123;             <span class="comment">// 1-西施</span></span><br><span class="line">ptr = <span class="keyword">new</span> XS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;      <span class="comment">// 2-韩信</span></span><br><span class="line">ptr = <span class="keyword">new</span> HX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">3</span>) &#123;      <span class="comment">// 3-李白</span></span><br><span class="line">ptr = <span class="keyword">new</span> LB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">ptr-&gt;<span class="built_in">skill1</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">skill2</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">uskill</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果基类指针指向的对象是西施，那么就调用西施的show()函数。</span></span><br><span class="line"><span class="comment">//if (id == 1) &#123;</span></span><br><span class="line"><span class="comment">//XS* pxs = (XS *)ptr;        // C风格强制转换的方法，程序员必须保证目标类型正确。</span></span><br><span class="line"><span class="comment">//pxs-&gt;show();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">XS* xsptr = <span class="built_in">dynamic_cast</span>&lt;XS*&gt;(ptr);         <span class="comment">// 把基类指针转换为派生类。</span></span><br><span class="line"><span class="keyword">if</span> (xsptr != <span class="literal">nullptr</span>) xsptr-&gt;<span class="built_in">show</span>();              <span class="comment">// 如果转换成功，调用派生类西施的非虚函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码演示把基类引用转换为派生类引用时发生异常的情况。</span></span><br><span class="line"><span class="comment">/*HX hx;</span></span><br><span class="line"><span class="comment">Hero&amp; rh = hx;</span></span><br><span class="line"><span class="comment">try&#123;</span></span><br><span class="line"><span class="comment">XS &amp; rxs= dynamic_cast&lt;XS &amp;&gt;(rh);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">catch (bad_cast) &#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;出现了bad_cast异常。\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="typeid运算符和type-info类"><a href="#typeid运算符和type-info类" class="headerlink" title="typeid运算符和type_info类"></a>typeid运算符和type_info类</h2><ul><li>typeid运算符用于获取数据类型的信息<ul><li>语法一：<strong>typeid(数据类型);</strong></li><li>语法二：<strong>typeid(变量名或表达式);</strong></li></ul></li><li>typeid运算符返回type_info类（在头文件<code>&lt;typeinfo&gt;</code>中定义）的对象的引用。</li><li>type_info类的实现随编译器而异，但至少有name()成员函数，该函数返回一个字符串，通常是类名。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==和!=运算符，用于对类型进行比较。</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong><br>1）type_info类的构造函数是private属性，也没有拷贝构造函数，所以不能直接实例化，只能由编译器在内部实例化。<br>2）不建议用name()成员函数返回的字符串作为判断数据类型的依据。（编译器可能会转换类型名）<br>3）typeid运算符可以用于多态的场景，在运行阶段识别对象的数据类型。<br>4）假设有表达式<code>typeid(*ptr)</code>，当ptr是空指针时，如果ptr是多态的类型，将引发bad_typeid异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> &#123;   <span class="comment">// 定义一个类。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BBB</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBB aa;</span><br><span class="line">    BBB* paa = &amp;aa;</span><br><span class="line">    BBB&amp; raa = aa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用typeid获取类型信息并打印类型名称</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid(BBB)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(BBB).<span class="built_in">name</span>() &lt;&lt; endl;     <span class="comment">// 输出类型BBB的名称,结果为3BB，3应该是类型名字符个数吧</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid(aa)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(aa).<span class="built_in">name</span>() &lt;&lt; endl;     <span class="comment">// 输出aa对象的类型名称</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid(BBB*)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(BBB*).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">// 输出指针类型BBB*的名称</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid(paa)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(paa).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">// 输出paa指针的类型名称</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid(BBB&amp;)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(BBB&amp;).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">// 输出引用类型BBB&amp;的名称</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid(raa)=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(raa).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">// 输出raa引用的类型名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用typeid进行类型比较</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(BBB) == <span class="built_in">typeid</span>(aa))      <span class="comment">// 比较类型BBB和aa的类型是否相同</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(BBB) == <span class="built_in">typeid</span>(*paa))    <span class="comment">// 比较类型BBB和paa指针指向对象的类型是否相同</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok2\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(BBB) == <span class="built_in">typeid</span>(raa))     <span class="comment">// 比较类型BBB和raa引用的类型是否相同</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok3\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(BBB*) == <span class="built_in">typeid</span>(paa))    <span class="comment">// 比较类型BBB*和paa指针的类型是否相同</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ok4\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="自动推导类型auto"><a href="#自动推导类型auto" class="headerlink" title="自动推导类型auto"></a>自动推导类型auto</h1><ul><li>在C语言和C++98中，auto关键字用于修饰变量（自动存储的局部变量）。</li><li>在C++11中，赋予了auto全新的含义，不再用于修饰变量，而是作为一个类型指示符，<strong>指示编译器在编译时推导auto声明的变量的数据类型</strong>。<br>语法：<strong>auto 变量名 &#x3D; 初始值;</strong><br><strong>注意</strong></li><li>auto声明的变量必须在定义时初始化。</li><li>初始化的右值可以是具体的数值，也可以是表达式和函数的返回值等。</li><li><strong>auto不能作为函数的形参类型</strong>。</li><li>auto不能直接声明数组。</li><li>auto不能定义类的非静态成员变量。</li></ul><p>auto在编程时真正的用途如下：</p><ul><li>代替冗长复杂的变量声明。</li><li>在模板中，用于声明依赖模板参数的变量。</li><li>函数模板依赖模板参数的返回值。</li><li>用于lambda表达式中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line">          </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">double</span> b, <span class="type">const</span> <span class="type">char</span>* c, <span class="type">float</span> d, <span class="type">short</span> e, <span class="type">long</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;,c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,d=&quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;,e=&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;,f=&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5.5</span>;</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">double</span> (*pf)( <span class="type">double</span> , <span class="type">const</span> <span class="type">char</span>* , <span class="type">float</span> , <span class="type">short</span> , <span class="type">long</span> );    <span class="comment">// 声明函数指针pf。</span></span><br><span class="line">pf = func;</span><br><span class="line"><span class="built_in">pf</span>( <span class="number">2</span>, <span class="string">&quot;西施&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">auto</span> pf1 = func;</span><br><span class="line"><span class="built_in">pf1</span>(<span class="number">2</span>, <span class="string">&quot;西施&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mavros</title>
      <link href="/data.github.io/post/93b2f74a.html"/>
      <url>/data.github.io/post/93b2f74a.html</url>
      
        <content type="html"><![CDATA[<p>![[Pasted image 20230904154632.png]]</p><blockquote><p>MAVROS相当于PX4飞控中的MAVLINK模块。MAVROS将话题转为MAVLINK格式消息发送给飞控，飞控中的MAVLINK模块将MAVLINK格式消息转化为uORB消息给PX4各模块间传递消息使用，也可以反过来从uORB消息一直到ROS话题。</p></blockquote><ul><li><a href="https://blog.csdn.net/qq_42680785/article/details/118853000?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169253464816800227498528%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169253464816800227498528&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-118853000-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=px4%E5%92%8Cmavros%20gazebo&spm=1018.2226.3001.4187">仿真</a></li><li><a href="https://www.cnblogs.com/cporoske/p/11641477.html">仿真</a></li><li><a href="https://docs.px4.io/main/zh/ros/mavros_offboard_cpp.html">官方实例仿真</a><ul><li><a href="https://blog.csdn.net/private_Jack/article/details/128466062?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-128466062-blog-124301786.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-128466062-blog-124301786.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=2">官方实例报错情况解决</a>:出现多个offboard enable时</li></ul></li><li><a href="https://blog.csdn.net/qq_35598561/article/details/131284168?ops_request_misc=&request_id=&biz_id=102&utm_term=mavros%E4%B8%AD%E8%AE%A2%E9%98%85%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-131284168.142%5Ev93%5EchatsearchT3_2&spm=1018.2226.3001.4187">mavros常用话题</a></li><li><a href="http://wiki.ros.org/mavros#Overview">mavros话题wiki</a></li></ul><h1 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h1><p><strong>实现offboard模式sin路线飞行控制</strong></p><ol><li>找到ROS工作空间，创建功能包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg offboard_pkg roscpp std_msgs geometry_msgs mavros_msgs</span><br></pre></td></tr></table></figure></li><li>在功能包的src路径下创建offboard_node.cpp文件写入如下代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span>  <span class="comment">//发布的消息体对应的头文件，该消息体的类型为geometry_msgs：：PoseStamped</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/CommandBool.h&gt;</span>  <span class="comment">//CommandBool服务的头文件，该服务的类型为mavros_msgs：：CommandBool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/SetMode.h&gt;</span>     <span class="comment">//SetMode服务的头文件，该服务的类型为mavros_msgs：：SetMode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/State.h&gt;</span>  <span class="comment">//订阅的消息体的头文件，该消息体的类型为mavros_msgs：：State</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//建立一个订阅消息体类型的变量，用于存储订阅的信息</span></span><br><span class="line">mavros_msgs::State current_state;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//订阅时的回调函数，接受到该消息体的内容时执行里面的内容，这里面的内容就是赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">    current_state = *msg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;offb_node&quot;</span>); <span class="comment">//ros系统的初始化，最后一个参数为节点名称</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//订阅。&lt;&gt;里面为模板参数，传入的是订阅的消息体类型，（）里面传入三个参数，分别是该消息体的位置、缓存大小（通常为1000）、回调函数；</span></span><br><span class="line">    <span class="comment">//这里就是订阅飞控中的当前无人机的状态，在后面的代码中使用</span></span><br><span class="line">    ros::Subscriber state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;mavros/state&quot;</span>, <span class="number">10</span>, state_cb);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//发布之前需要公告，并获取句柄，发布的消息体的类型为：geometry_msgs::PoseStamped；</span></span><br><span class="line">    <span class="comment">//方便后面将位置信息到飞控中</span></span><br><span class="line">    ros::Publisher local_pos_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;mavros/setpoint_position/local&quot;</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//启动服务1，设置客户端（Client）名称为arming_client，客户端的类型为ros::ServiceClient，</span></span><br><span class="line">    <span class="comment">//启动服务用的函数为nh下的serviceClient&lt;&gt;()函数，&lt;&gt;里面是该服务的类型，（）里面是该服务的路径，解锁指令</span></span><br><span class="line">    ros::ServiceClient arming_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::CommandBool&gt;(<span class="string">&quot;mavros/cmd/arming&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//启动服务2，设置客户端（Client）名称为set_mode_client，客户端的类型为ros::ServiceClient，</span></span><br><span class="line">    <span class="comment">//启动服务用的函数为nh下的serviceClient&lt;&gt;()函数，&lt;&gt;里面是该服务的类型，（）里面是该服务的路径</span></span><br><span class="line">    ros::ServiceClient set_mode_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::SetMode&gt;(<span class="string">&quot;mavros/set_mode&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//the setpoint publishing rate MUST be faster than 2Hz</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 等待飞控连接mavros，current_state是我们订阅的mavros的状态，连接成功在跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>() &amp;&amp; !current_state.connected)&#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//先实例化一个geometry_msgs::PoseStamped类型的对象，并对其赋值，最后将其发布出去</span></span><br><span class="line">    geometry_msgs::PoseStamped pose;</span><br><span class="line">    pose.pose.position.x = <span class="number">1</span>;</span><br><span class="line">    pose.pose.position.y = <span class="number">1</span>;</span><br><span class="line">    pose.pose.position.z = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建立一个类型为SetMode的服务端offb_set_mode，并将其中的模式mode设为&quot;OFFBOARD&quot;，作用便是用于后面的</span></span><br><span class="line">    <span class="comment">//客户端与服务端之间的通信（服务）</span></span><br><span class="line">    mavros_msgs::SetMode offb_set_mode;</span><br><span class="line">    offb_set_mode.request.custom_mode = <span class="string">&quot;OFFBOARD&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建立一个类型为CommandBool的服务端arm_cmd，并将其中的是否解锁设为&quot;true&quot;，作用便是用于后面的</span></span><br><span class="line">    <span class="comment">//客户端与服务端之间的通信（服务）</span></span><br><span class="line">    mavros_msgs::CommandBool arm_cmd;</span><br><span class="line">    arm_cmd.request.value = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    ros::Time last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())<span class="comment">//进入大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先判断当前模式是否为offboard模式，如果不是，则客户端set_mode_client向服务端offb_set_mode发起请求call，</span></span><br><span class="line">        <span class="comment">//然后服务端回应response将模式返回，这就打开了offboard模式</span></span><br><span class="line">        <span class="keyword">if</span>( current_state.mode != <span class="string">&quot;OFFBOARD&quot;</span> &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set_mode_client.<span class="built_in">call</span>(offb_set_mode) &amp;&amp; offb_set_mode.response.mode_sent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Offboard enabled&quot;</span>);<span class="comment">//打开模式后打印信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//else指已经为offboard模式，然后进去判断是否解锁，如果没有解锁，则客户端arming_client向服务端arm_cmd发起请求call</span></span><br><span class="line">            <span class="comment">//然后服务端回应response成功解锁，这就解锁了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !current_state.armed &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( arming_client.<span class="built_in">call</span>(arm_cmd) &amp;&amp; arm_cmd.response.success)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Vehicle armed&quot;</span>);<span class="comment">//解锁后打印信息</span></span><br><span class="line">                &#125;</span><br><span class="line">                last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        local_pos_pub.<span class="built_in">publish</span>(pose); </span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li>其中通过订阅mavros发布的的<strong>mavros&#x2F;local_position&#x2F;pose</strong>话题得到当前无人机的位置反馈</li></ul><ol start="3"><li>修改CMakeLists.txt文件，在最后加入下面两行：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(offboard_node src/offboard_node.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(offboard_node <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li><li>编译<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws</span><br><span class="line">catkin build</span><br></pre></td></tr></table></figure></li></ol><ul><li>使用上述命令报错<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The build space at &#x27;/home/wjl/catkin_ws/build&#x27; was previously built by &#x27;catkin_make&#x27;. Please remove the build space or pick a different build space.</span><br></pre></td></tr></table></figure>这个错误通常表示之前使用catkin_make命令编译过ROS工作空间，而现在又尝试使用catkin build命令进行编译，导致冲突。</li><li>解决——删除旧的编译空间：在终端中运行以下命令，删除先前使用catkin_make生成的旧的编译空间。</li><li>遇到devel文件夹报错的，删除对应文件夹即可<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/catkin_ws/build</span><br></pre></td></tr></table></figure></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li>找到PX4的安装路径，打开gazebo仿真并启动PX4：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make px4_sitl gazebo_iris</span><br></pre></td></tr></table></figure></li><li>打开QGC地面站</li><li>建立mavros与PX4的连接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch mavros px4.launch fcu_url:=&quot;udp://:14540@127.0.0.1:14557&quot;</span><br></pre></td></tr></table></figure></li><li>使用命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun offboard_pkg offboard_node</span><br></pre></td></tr></table></figure></li></ol><h1 id="常用话题"><a href="#常用话题" class="headerlink" title="常用话题"></a>常用话题</h1><ul><li><a href="http://wiki.ros.org/mavros#Overview">mavros话题wiki</a>：具体信息见wiki</li><li><a href="https://zhuanlan.zhihu.com/p/364872655">话题知户</a></li><li>一般订阅位置信息用<code>geometry_msgs::PoseStamped</code>，可以得到x,y,z信息。具体内容则是看消息体的位置<ul><li><code>mavros/local_position/pose</code>：表示当前无人机的位置</li><li><code>mavros/setpoint_position/local</code>：表示我们需要设立的期望点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅。&lt;&gt;里面为模板参数，传入的是订阅的消息体类型，（）里面传入三个参数，分别是该消息体的位置、缓存大小（通常为1000）、回调函数；</span></span><br><span class="line">ros::Subscriber local_pos_sub = nh.<span class="built_in">subscribe</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;mavros/local_position/pose&quot;</span>, <span class="number">10</span>,pos_sub_cb);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span>  <span class="comment">//发布的消息体对应的头文件，该消息体的类型为geometry_msgs：：PoseStamped</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/CommandBool.h&gt;</span>  <span class="comment">//CommandBool服务的头文件，该服务的类型为mavros_msgs：：CommandBool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/SetMode.h&gt;</span>     <span class="comment">//SetMode服务的头文件，该服务的类型为mavros_msgs：：SetMode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/State.h&gt;</span>  <span class="comment">//订阅的消息体的头文件，该消息体的类型为mavros_msgs：：State</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//建立一个订阅消息体类型的变量，用于存储订阅的信息</span></span><br><span class="line">mavros_msgs::State current_state;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//订阅时的回调函数，接受到该消息体的内容时执行里面的内容，这里面的内容就是赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">    current_state = *msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uav_info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ros::Subscriber state_sub;<span class="comment">//订阅飞控中的当前无人机的状态，在后面的代码中使用</span></span><br><span class="line">    ros::Publisher local_pos_pub;<span class="comment">//发布信息位置</span></span><br><span class="line">    ros::ServiceClient arming_client;<span class="comment">//启动服务，</span></span><br><span class="line">    ros::ServiceClient set_mode_client;<span class="comment">//启动服务，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立一个订阅消息体类型的变量，用于存储当前状态的信息</span></span><br><span class="line">    mavros_msgs::State current_state;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Uav_info</span>(ros::NodeHandle nh,std::string model_name)&#123;</span><br><span class="line">        state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/mavros/state&quot;</span>, <span class="number">10</span>, state_cb);</span><br><span class="line">        local_pos_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/mavros/setpoint_position/local&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        arming_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::CommandBool&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/mavros/cmd/arming&quot;</span>);</span><br><span class="line">        set_mode_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::SetMode&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;mavros/set_mode&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;offboard&quot;</span>); </span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="function">Uav_info <span class="title">iris_0</span><span class="params">(nh,<span class="string">&quot;iris_0&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Uav_info <span class="title">iris_1</span><span class="params">(nh,<span class="string">&quot;iris_1&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;2333&quot;</span>);</span><br><span class="line">    <span class="comment">// 等待飞控连接mavros，current_state是我们订阅的mavros的状态，连接成功在跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>() &amp;&amp; !iris_0.current_state.connected)&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%d&quot;</span>,iris_0.current_state.connected);</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">    <span class="comment">//先实例化一个geometry_msgs::PoseStamped类型的对象，并对其赋值，最后将其发布出去</span></span><br><span class="line">    geometry_msgs::PoseStamped pose;</span><br><span class="line">    pose.pose.position.x = <span class="number">1</span>;</span><br><span class="line">    pose.pose.position.y = <span class="number">1</span>;</span><br><span class="line">    pose.pose.position.z = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建立一个类型为SetMode的服务端offb_set_mode，并将其中的模式mode设为&quot;OFFBOARD&quot;，作用便是用于后面的</span></span><br><span class="line">    <span class="comment">//客户端与服务端之间的通信（服务）</span></span><br><span class="line">    mavros_msgs::SetMode offb_set_mode;</span><br><span class="line">    offb_set_mode.request.custom_mode = <span class="string">&quot;OFFBOARD&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建立一个类型为CommandBool的服务端arm_cmd，并将其中的是否解锁设为&quot;true&quot;，作用便是用于后面的</span></span><br><span class="line">    <span class="comment">//客户端与服务端之间的通信（服务）</span></span><br><span class="line">    mavros_msgs::CommandBool arm_cmd;</span><br><span class="line">    arm_cmd.request.value = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    ros::Time last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())<span class="comment">//进入大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先判断当前模式是否为offboard模式，如果不是，则客户端set_mode_client向服务端offb_set_mode发起请求call，</span></span><br><span class="line">        <span class="comment">//然后服务端回应response将模式返回，这就打开了offboard模式</span></span><br><span class="line">        <span class="keyword">if</span>( iris_0.current_state.mode != <span class="string">&quot;OFFBOARD&quot;</span> &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( iris_0.set_mode_client.<span class="built_in">call</span>(offb_set_mode) &amp;&amp; offb_set_mode.response.mode_sent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Offboard enabled&quot;</span>);<span class="comment">//打开模式后打印信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//else指已经为offboard模式，然后进去判断是否解锁，如果没有解锁，则客户端arming_client向服务端arm_cmd发起请求call</span></span><br><span class="line">            <span class="comment">//然后服务端回应response成功解锁，这就解锁了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !iris_0.current_state.armed &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( iris_0.arming_client.<span class="built_in">call</span>(arm_cmd) &amp;&amp; arm_cmd.response.success)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Vehicle armed&quot;</span>);<span class="comment">//解锁后打印信息</span></span><br><span class="line">                &#125;</span><br><span class="line">                last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用时间差，超过8秒跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">6.0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        iris_0.local_pos_pub.<span class="built_in">publish</span>(pose); </span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        iris_0.local_pos_pub.<span class="built_in">publish</span>(pose);</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现两个位置来回移动"><a href="#实现两个位置来回移动" class="headerlink" title="实现两个位置来回移动"></a>实现两个位置来回移动</h2><p><strong>关键信息</strong></p><ul><li>在设定模式的环节利用时间差退出循环</li><li>实现一个功能后，利用时间差来退出循环<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span>  <span class="comment">//发布的消息体对应的头文件，该消息体的类型为geometry_msgs：：PoseStamped</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/CommandBool.h&gt;</span>  <span class="comment">//CommandBool服务的头文件，该服务的类型为mavros_msgs：：CommandBool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/SetMode.h&gt;</span>     <span class="comment">//SetMode服务的头文件，该服务的类型为mavros_msgs：：SetMode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/State.h&gt;</span>  <span class="comment">//订阅的消息体的头文件，该消息体的类型为mavros_msgs：：State</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//建立一个订阅消息体类型的变量，用于存储订阅的信息</span></span><br><span class="line">mavros_msgs::State current_state;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//订阅时的回调函数，接受到该消息体的内容时执行里面的内容，这里面的内容就是赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">    current_state = *msg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;offb_node&quot;</span>); <span class="comment">//ros系统的初始化，最后一个参数为节点名称</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//订阅。&lt;&gt;里面为模板参数，传入的是订阅的消息体类型，（）里面传入三个参数，分别是该消息体的位置、缓存大小（通常为1000）、回调函数；</span></span><br><span class="line">    <span class="comment">//这里就是订阅飞控中的当前无人机的状态，在后面的代码中使用</span></span><br><span class="line">    ros::Subscriber state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;mavros/state&quot;</span>, <span class="number">10</span>, state_cb);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//发布之前需要公告，并获取句柄，发布的消息体的类型为：geometry_msgs::PoseStamped；</span></span><br><span class="line">    <span class="comment">//方便后面将位置信息到飞控中</span></span><br><span class="line">    ros::Publisher local_pos_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;mavros/setpoint_position/local&quot;</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//启动服务1，设置客户端（Client）名称为arming_client，客户端的类型为ros::ServiceClient，</span></span><br><span class="line">    <span class="comment">//启动服务用的函数为nh下的serviceClient&lt;&gt;()函数，&lt;&gt;里面是该服务的类型，（）里面是该服务的路径，解锁指令</span></span><br><span class="line">    ros::ServiceClient arming_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::CommandBool&gt;(<span class="string">&quot;mavros/cmd/arming&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//启动服务2，设置客户端（Client）名称为set_mode_client，客户端的类型为ros::ServiceClient，</span></span><br><span class="line">    <span class="comment">//启动服务用的函数为nh下的serviceClient&lt;&gt;()函数，&lt;&gt;里面是该服务的类型，（）里面是该服务的路径</span></span><br><span class="line">    ros::ServiceClient set_mode_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::SetMode&gt;(<span class="string">&quot;mavros/set_mode&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//the setpoint publishing rate MUST be faster than 2Hz</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 等待飞控连接mavros，current_state是我们订阅的mavros的状态，连接成功在跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>() &amp;&amp; !current_state.connected)&#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//先实例化一个geometry_msgs::PoseStamped类型的对象，并对其赋值，最后将其发布出去</span></span><br><span class="line">    geometry_msgs::PoseStamped pose;</span><br><span class="line">    pose.pose.position.x = <span class="number">1</span>;</span><br><span class="line">    pose.pose.position.y = <span class="number">1</span>;</span><br><span class="line">    pose.pose.position.z = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建立一个类型为SetMode的服务端offb_set_mode，并将其中的模式mode设为&quot;OFFBOARD&quot;，作用便是用于后面的</span></span><br><span class="line">    <span class="comment">//客户端与服务端之间的通信（服务）</span></span><br><span class="line">    mavros_msgs::SetMode offb_set_mode;</span><br><span class="line">    offb_set_mode.request.custom_mode = <span class="string">&quot;OFFBOARD&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//建立一个类型为CommandBool的服务端arm_cmd，并将其中的是否解锁设为&quot;true&quot;，作用便是用于后面的</span></span><br><span class="line">    <span class="comment">//客户端与服务端之间的通信（服务）</span></span><br><span class="line">    mavros_msgs::CommandBool arm_cmd;</span><br><span class="line">    arm_cmd.request.value = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    ros::Time last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())<span class="comment">//进入大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先判断当前模式是否为offboard模式，如果不是，则客户端set_mode_client向服务端offb_set_mode发起请求call，</span></span><br><span class="line">        <span class="comment">//然后服务端回应response将模式返回，这就打开了offboard模式</span></span><br><span class="line">        <span class="keyword">if</span>( current_state.mode != <span class="string">&quot;OFFBOARD&quot;</span> &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set_mode_client.<span class="built_in">call</span>(offb_set_mode) &amp;&amp; offb_set_mode.response.mode_sent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Offboard enabled&quot;</span>);<span class="comment">//打开模式后打印信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//else指已经为offboard模式，然后进去判断是否解锁，如果没有解锁，则客户端arming_client向服务端arm_cmd发起请求call</span></span><br><span class="line">            <span class="comment">//然后服务端回应response成功解锁，这就解锁了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !current_state.armed &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( arming_client.<span class="built_in">call</span>(arm_cmd) &amp;&amp; arm_cmd.response.success)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Vehicle armed&quot;</span>);<span class="comment">//解锁后打印信息</span></span><br><span class="line">                &#125;</span><br><span class="line">                last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用时间差，超过8秒跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">6.0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        local_pos_pub.<span class="built_in">publish</span>(pose); </span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> state=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(state--)&#123;</span><br><span class="line">        last_request=ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">            pose.pose.position.x = <span class="number">2</span>;</span><br><span class="line">            pose.pose.position.y = <span class="number">2</span>;</span><br><span class="line">            pose.pose.position.z = <span class="number">5</span>;</span><br><span class="line">            local_pos_pub.<span class="built_in">publish</span>(pose); </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;state-----&quot;</span>);</span><br><span class="line">            ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">            rate.<span class="built_in">sleep</span>();</span><br><span class="line">            <span class="keyword">if</span>(ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last_request=ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">            pose.pose.position.x = <span class="number">-2</span>;</span><br><span class="line">            pose.pose.position.y = <span class="number">-2</span>;</span><br><span class="line">            pose.pose.position.z = <span class="number">2</span>;</span><br><span class="line">            local_pos_pub.<span class="built_in">publish</span>(pose); </span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;state+++++&quot;</span>);</span><br><span class="line">            ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">            rate.<span class="built_in">sleep</span>();</span><br><span class="line">            <span class="keyword">if</span>(ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="用类的形式实现无人机起飞"><a href="#用类的形式实现无人机起飞" class="headerlink" title="用类的形式实现无人机起飞"></a>用类的形式实现无人机起飞</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span>  <span class="comment">//发布的消息体对应的头文件，该消息体的类型为geometry_msgs：：PoseStamped</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/CommandBool.h&gt;</span>  <span class="comment">//CommandBool服务的头文件，该服务的类型为mavros_msgs：：CommandBool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/SetMode.h&gt;</span>     <span class="comment">//SetMode服务的头文件，该服务的类型为mavros_msgs：：SetMode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/State.h&gt;</span>  <span class="comment">//订阅的消息体的头文件，该消息体的类型为mavros_msgs：：State</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag_fly;<span class="comment">//判断第一架飞机是否起飞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uav_info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string model_name;</span><br><span class="line">    ros::Subscriber state_sub;<span class="comment">//订阅飞控中的当前无人机的状态，在后面的代码中使用</span></span><br><span class="line"></span><br><span class="line">    mavros_msgs::SetMode set_mode;<span class="comment">//设置模式</span></span><br><span class="line">    mavros_msgs::CommandBool arm_cmd;<span class="comment">//建立</span></span><br><span class="line"></span><br><span class="line">    ros::ServiceClient arming_client;<span class="comment">//启动服务，</span></span><br><span class="line">    ros::ServiceClient set_mode_client;<span class="comment">//启动服务，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立一个订阅消息体类型的变量，用于存储当前状态的信息</span></span><br><span class="line">    mavros_msgs::State current_state;</span><br><span class="line">    ros::Publisher local_pos_pub;<span class="comment">//发布信息位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为期望位置信息储存</span></span><br><span class="line">    geometry_msgs::PoseStamped setpoint_pose;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Uav_info</span>(ros::NodeHandle nh,std::string model_name)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;model_name=model_name;</span><br><span class="line">        arm_cmd.request.value=<span class="literal">true</span>;</span><br><span class="line">        state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;/&quot;</span> + model_name + <span class="string">&quot;/mavros/state&quot;</span>, <span class="number">10</span>, boost::<span class="built_in">bind</span>(&amp;Uav_info::state_cb, <span class="keyword">this</span>, _1, boost::<span class="built_in">ref</span>(current_state)));</span><br><span class="line">        local_pos_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/mavros/setpoint_position/local&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        arming_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::CommandBool&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/mavros/cmd/arming&quot;</span>);</span><br><span class="line">        set_mode_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::SetMode&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/mavros/set_mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 等待飞控连接mavros，current_state是我们订阅的mavros的状态，连接成功在跳出循环</span></span><br><span class="line">        <span class="keyword">while</span>(ros::<span class="built_in">ok</span>() &amp;&amp; <span class="keyword">this</span>-&gt;current_state.connected)&#123;</span><br><span class="line">            ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">            rate.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg, mavros_msgs::State&amp; current_state)</span> </span>&#123;</span><br><span class="line">        current_state = *msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pub_pos</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y,<span class="type">double</span> z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setpoint_pose.pose.position.x=x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setpoint_pose.pose.position.y=y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;setpoint_pose.pose.position.z=z;</span><br><span class="line">        <span class="keyword">this</span>-&gt;local_pos_pub.<span class="built_in">publish</span>(setpoint_pose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set_offboard</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y,<span class="type">double</span> z)</span></span>&#123;</span><br><span class="line">        <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line">        ros::Time last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;set_mode.request.custom_mode = <span class="string">&quot;OFFBOARD&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())<span class="comment">//进入大循环</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;iris:%s,mode:%s&quot;</span>,<span class="keyword">this</span>-&gt;model_name.<span class="built_in">c_str</span>(),<span class="keyword">this</span>-&gt;current_state.mode.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="comment">//首先判断当前模式是否为offboard模式，如果不是，则客户端set_mode_client向服务端offb_set_mode发起请求call，</span></span><br><span class="line">            <span class="comment">//然后服务端回应response将模式返回，这就打开了offboard模式</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="keyword">this</span>-&gt;current_state.mode != <span class="string">&quot;OFFBOARD&quot;</span> &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>( <span class="keyword">this</span>-&gt;set_mode_client.<span class="built_in">call</span>(<span class="keyword">this</span>-&gt;set_mode) &amp;&amp; <span class="keyword">this</span>-&gt;set_mode.response.mode_sent)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Offboard enabled&quot;</span>);<span class="comment">//打开模式后打印信息</span></span><br><span class="line">                &#125;</span><br><span class="line">                last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//else指已经为offboard模式，然后进去判断是否解锁，如果没有解锁，则客户端arming_client向服务端arm_cmd发起请求call</span></span><br><span class="line">            <span class="comment">//然后服务端回应response成功解锁，这就解锁了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( !<span class="keyword">this</span>-&gt;current_state.armed &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( <span class="keyword">this</span>-&gt;arming_client.<span class="built_in">call</span>(arm_cmd) &amp;&amp; arm_cmd.response.success)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Vehicle armed&quot;</span>);<span class="comment">//解锁后打印信息</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//利用时间差，超过8秒跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">6.0</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Pub_pos</span>(x,y,z);<span class="comment">//这里不能少，否则会失败</span></span><br><span class="line">            ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">            rate.<span class="built_in">sleep</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;offboard&quot;</span>); </span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="function">Uav_info <span class="title">iris_0</span><span class="params">(nh,<span class="string">&quot;iris_0&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Uav_info <span class="title">iris_1</span><span class="params">(nh,<span class="string">&quot;iris_1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    iris_0.<span class="built_in">Set_offboard</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 延时2秒</span></span><br><span class="line">    <span class="comment">// ros::Duration(5.0).sleep();</span></span><br><span class="line">    <span class="comment">// iris_1.Set_offboard(3,0,1);</span></span><br><span class="line"></span><br><span class="line">    ros::Time last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        iris_0.<span class="built_in">Pub_pos</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// iris_1.Pub_pos(3,0,1);</span></span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现摄像头跟踪"><a href="#实现摄像头跟踪" class="headerlink" title="实现摄像头跟踪"></a>实现摄像头跟踪</h2><ul><li>首先切换到bash终端,打开qgc</li><li><a href="https://blog.csdn.net/qq_44939973/article/details/120965458?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-5-120965458-blog-122326291.235%5Ev38%5Epc_relevant_anti_t3&spm=1001.2101.3001.4242.4&utm_relevant_index=8">gazebo仿真添加摄像头</a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec bash <span class="comment">//切换到bash终端</span></span><br><span class="line">roslaunch px4 mavros_posix_sitl_cp.launch   <span class="comment">//只有这个命令是在bash终端中运行，其他命令可在zsh</span></span><br><span class="line">rosrun offboard_pkg offboard_node    </span><br><span class="line"><span class="comment">//对于roslaunch启动的直接运行上面两个命令即可</span></span><br><span class="line"><span class="comment">//对于make px4_sitl gazebo启动的，上面命令之间需要roslaunch mavros px4.launch fcu_url:=&quot;udp://:14540@127.0.0.1:14557&quot;,这就是区别</span></span><br></pre></td></tr></table></figure>offboard模式控制飞行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/CommandBool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/SetMode.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/State.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/Altitude.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sensor_msgs/Image.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cv_bridge/cv_bridge.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// 一些全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 悬空高度（追踪小车的高度）</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> h = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 调整高度的速度（上升或下降）</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> hv = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制无人机的速度</span></span><br><span class="line">geometry_msgs::Twist velocity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无人机当前的高度</span></span><br><span class="line"><span class="type">double</span> curH;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无人机是否已经稳定在空中的标志</span></span><br><span class="line"><span class="type">bool</span> start = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doImg</span><span class="params">(<span class="type">const</span> sensor_msgs::Image::ConstPtr &amp;msg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!start) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将无人机发布的图像先转化为灰度图，再进行二值化，就能得到黑白图像，若小车出现，那么在图像内有黑色的像素，否则图像全是白色像素，这也是我将小车改成黑色的原因，若改成其它颜色就不好进行分离</span></span><br><span class="line">    cv_bridge::CvImagePtr cv_ptr = cv_bridge::<span class="built_in">toCvCopy</span>(msg, sensor_msgs::image_encodings::BGR8);</span><br><span class="line">cv::Mat img = cv_ptr -&gt; image;</span><br><span class="line">    cv::Mat gray, bin;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(img, gray, cv::COLOR_BGR2GRAY);</span><br><span class="line">    cv::<span class="built_in">threshold</span>(gray, bin, <span class="number">127</span>, <span class="number">255</span>, cv::THRESH_BINARY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得图像的宽和高</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> row = bin.rows, col = bin.cols;</span><br><span class="line">    <span class="comment">// 图像中心点的位置，我们假设图像中心点的位置就是无人机的位置，这样就能很方便的发布速度来控制无人机</span></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> centX = row / <span class="number">2</span>, centY = col / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x y用来记录小车在该帧图像出现的位置</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="comment">// 是否找到小车的标记</span></span><br><span class="line">    <span class="type">bool</span> findCar = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历图像，若图像内有黑色像素则代表发现了小车，记录下此时的x y位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            uchar point = bin.<span class="built_in">at</span>&lt;uchar&gt;(i, j);</span><br><span class="line">            <span class="keyword">if</span>(point == <span class="number">0</span>) &#123;</span><br><span class="line">                findCar = <span class="literal">true</span>;</span><br><span class="line">                x = i, y = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(findCar) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录最后一次找到小车的时间</span></span><br><span class="line">    <span class="type">static</span> ros::Time last_find_time = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">if</span>(findCar) &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;找到目标位置, x = %d, y = %d&quot;</span>, x, y);</span><br><span class="line">        <span class="comment">// 将小车（所在像素点）相对无人机（图像中心像素点）的位置归一化到0 ~ 1之间，并以此作为控制无人机的速度，小车离无人机越远，则无人机的速度越大，否则无人机的速度越小</span></span><br><span class="line">        <span class="type">double</span> vx = <span class="built_in">abs</span>(centX - x) / centX;</span><br><span class="line">        <span class="type">double</span> vy = <span class="built_in">abs</span>(centY - y) / centY;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 经测试，无人机发送的图像的垂直方向是无人机的x方向，图像的水平方向是无人机的y方向</span></span><br><span class="line">        <span class="comment">// 因此，若小车（像素位置）在无人机（像素位置）上方，需要发送一个正的x方向速度，否则要发送一个负方向的速度</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; centX) velocity.linear.x = vx;</span><br><span class="line">        <span class="keyword">else</span> velocity.linear.x = -vx;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// y方向同理</span></span><br><span class="line">        <span class="keyword">if</span>(y &lt; centY) velocity.linear.y = vy;</span><br><span class="line">        <span class="keyword">else</span> velocity.linear.y = -vy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若不给无人机发送z方向的速度，无人机会时上时下，因此通过下面这个代码控制无人机高度，若低于一定高度，就发布z方向的速度，若高于某个高度，就发送一个-z方向的速度，让无人机下降</span></span><br><span class="line">        <span class="keyword">if</span>(curH &lt; h - <span class="number">0.5</span>) velocity.linear.z = hv;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(curH &lt; h + <span class="number">0.5</span>) velocity.linear.z = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> velocity.linear.z = (curH - h) * -hv;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发布速度 x : %f, y : %f, z : %f&quot;</span>, velocity.linear.x, velocity.linear.y, velocity.linear.z);</span><br><span class="line">        <span class="comment">// 记录无人机最后一次发现小车的时间，后面有用</span></span><br><span class="line">        last_find_time = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ros::Time now = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        velocity.linear.x = <span class="number">0</span>;</span><br><span class="line">        velocity.linear.y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 无人机丢失目标五秒内，什么都不操作</span></span><br><span class="line">        <span class="keyword">if</span>(now - last_find_time &lt; ros::<span class="built_in">Duration</span>(<span class="number">5</span>)) &#123;</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;没有找到目标...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无人机丢失目标五秒后，开始向上飞行（扩大视野）来搜寻小车，搜寻的最高高度是无人机跟踪小车高度的两倍，这也是前面代码中控制无人机下降的原因，若无人机在升空过程中发现目标小车，会立刻下降跟踪小车</span></span><br><span class="line">            <span class="keyword">if</span>(curH &lt; <span class="number">2</span> * h - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;上升高度寻找，当前高度为：%.2f&quot;</span>, curH);</span><br><span class="line">                velocity.linear.z = hv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(curH &gt; <span class="number">2</span> * h + <span class="number">1</span>) velocity.linear.z = -hv;</span><br><span class="line">                <span class="keyword">else</span> velocity.linear.z = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;目标丢失。。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_H</span><span class="params">(<span class="type">const</span> mavros_msgs::Altitude::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">    curH = msg-&gt;local;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavros_msgs::State current_state;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">    current_state = *msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;offb_node&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::Subscriber state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;</span><br><span class="line">            (<span class="string">&quot;mavros/state&quot;</span>, <span class="number">10</span>, state_cb);</span><br><span class="line">    ros::Publisher local_pos_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::PoseStamped&gt;</span><br><span class="line">            (<span class="string">&quot;mavros/setpoint_position/local&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    ros::Publisher local_vec_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;</span><br><span class="line">            (<span class="string">&quot;/mavros/setpoint_velocity/cmd_vel_unstamped&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    ros::ServiceClient arming_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::CommandBool&gt;</span><br><span class="line">            (<span class="string">&quot;mavros/cmd/arming&quot;</span>);</span><br><span class="line">    ros::ServiceClient set_mode_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::SetMode&gt;</span><br><span class="line">            (<span class="string">&quot;mavros/set_mode&quot;</span>);</span><br><span class="line">    ros::Subscriber img_sub = nh.<span class="built_in">subscribe</span>&lt;sensor_msgs::Image&gt;(<span class="string">&quot;/camera/rgb/image_raw&quot;</span>, <span class="number">10</span>, doImg);</span><br><span class="line"></span><br><span class="line">    ros::Subscriber height_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::Altitude&gt;</span><br><span class="line">            (<span class="string">&quot;/mavros/altitude&quot;</span>, <span class="number">10</span>, do_H);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//the setpoint publishing rate MUST be faster than 2Hz</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for FCU connection</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>() &amp;&amp; !current_state.connected)&#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    geometry_msgs::PoseStamped pose;</span><br><span class="line">    pose.pose.position.x = <span class="number">0</span>;</span><br><span class="line">    pose.pose.position.y = <span class="number">0</span>;</span><br><span class="line">    pose.pose.position.z = h;</span><br><span class="line"></span><br><span class="line">    velocity.linear.x = <span class="number">0</span>;</span><br><span class="line">    velocity.linear.y = <span class="number">0</span>;</span><br><span class="line">    velocity.linear.z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mavros_msgs::SetMode offb_set_mode;</span><br><span class="line">    offb_set_mode.request.custom_mode = <span class="string">&quot;OFFBOARD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    mavros_msgs::CommandBool arm_cmd;</span><br><span class="line">    arm_cmd.request.value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ros::Time last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> takeoff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!takeoff) &#123;</span><br><span class="line">            <span class="keyword">if</span>( current_state.mode != <span class="string">&quot;OFFBOARD&quot;</span> &amp;&amp;</span><br><span class="line">                (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">2.0</span>)))&#123;</span><br><span class="line">                <span class="keyword">if</span>( set_mode_client.<span class="built_in">call</span>(offb_set_mode) &amp;&amp;</span><br><span class="line">                    offb_set_mode.response.mode_sent)&#123;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Offboard enabled&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( !current_state.armed &amp;&amp;</span><br><span class="line">                (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">2.0</span>)))&#123;</span><br><span class="line">                <span class="keyword">if</span>( arming_client.<span class="built_in">call</span>(arm_cmd) &amp;&amp;</span><br><span class="line">                    arm_cmd.response.success)&#123;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Vehicle armed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( current_state.armed &amp;&amp; </span><br><span class="line">                (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>))) &#123;</span><br><span class="line">                    takeoff = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Vehicle stabled&quot;</span>);</span><br><span class="line">                    start = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;开始追踪...&quot;</span>);</span><br><span class="line">                    last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            local_pos_pub.<span class="built_in">publish</span>(pose);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            local_vec_pub.<span class="built_in">publish</span>(velocity);</span><br><span class="line">        &#125;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="位置定点飞行"><a href="#位置定点飞行" class="headerlink" title="位置定点飞行"></a>位置定点飞行</h2><ul><li>到达指定三个点的位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/PoseStamped.h&gt;</span>  <span class="comment">//发布的消息体对应的头文件，该消息体的类型为geometry_msgs：：PoseStamped</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/CommandBool.h&gt;</span>  <span class="comment">//CommandBool服务的头文件，该服务的类型为mavros_msgs：：CommandBool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/SetMode.h&gt;</span>     <span class="comment">//SetMode服务的头文件，该服务的类型为mavros_msgs：：SetMode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mavros_msgs/State.h&gt;</span>  <span class="comment">//订阅的消息体的头文件，该消息体的类型为mavros_msgs：：State</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建立一个订阅消息体类型的变量，用于存储订阅的信息</span></span><br><span class="line">mavros_msgs::State current_state;</span><br><span class="line">geometry_msgs::PoseStamped current_pose;<span class="comment">//这个作为接受订阅者的信息，在回调函数中赋值</span></span><br><span class="line">geometry_msgs::PoseStamped pose;   <span class="comment">//作为发送位置信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">    current_state = *msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pos_sub_cb</span><span class="params">(<span class="type">const</span> geometry_msgs::PoseStamped msg)</span></span>&#123;</span><br><span class="line">    current_pose = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pos</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y,<span class="type">double</span> z)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;offb_node&quot;</span>); <span class="comment">//ros系统的初始化，最后一个参数为节点名称</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//订阅</span></span><br><span class="line">    ros::Subscriber state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;mavros/state&quot;</span>, <span class="number">10</span>, state_cb);</span><br><span class="line">    <span class="comment">//订阅当前无人机的位置</span></span><br><span class="line">    ros::Subscriber local_pos_sub = nh.<span class="built_in">subscribe</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;mavros/local_position/pose&quot;</span>, <span class="number">10</span>,pos_sub_cb);</span><br><span class="line">    <span class="comment">//发布期望位置</span></span><br><span class="line">    ros::Publisher local_pos_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;mavros/setpoint_position/local&quot;</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    ros::ServiceClient arming_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::CommandBool&gt;(<span class="string">&quot;mavros/cmd/arming&quot;</span>);</span><br><span class="line">    ros::ServiceClient set_mode_client = nh.<span class="built_in">serviceClient</span>&lt;mavros_msgs::SetMode&gt;(<span class="string">&quot;mavros/set_mode&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//the setpoint publishing rate MUST be faster than 2Hz</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">20.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 等待飞控连接mavros，current_state是我们订阅的mavros的状态，连接成功在跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>() &amp;&amp; !current_state.connected)&#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">set_pos</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    mavros_msgs::SetMode offb_set_mode;</span><br><span class="line">    offb_set_mode.request.custom_mode = <span class="string">&quot;OFFBOARD&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    mavros_msgs::CommandBool arm_cmd;</span><br><span class="line">    arm_cmd.request.value = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    ros::Time last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())<span class="comment">//进入大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( current_state.mode != <span class="string">&quot;OFFBOARD&quot;</span> &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set_mode_client.<span class="built_in">call</span>(offb_set_mode) &amp;&amp; offb_set_mode.response.mode_sent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Offboard enabled&quot;</span>);<span class="comment">//打开模式后打印信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//else指已经为offboard模式，然后进去判断是否解锁，如果没有解锁，则客户端arming_client向服务端arm_cmd发起请求call</span></span><br><span class="line">            <span class="comment">//然后服务端回应response成功解锁，这就解锁了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !current_state.armed &amp;&amp; (ros::Time::<span class="built_in">now</span>() - last_request &gt; ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( arming_client.<span class="built_in">call</span>(arm_cmd) &amp;&amp; arm_cmd.response.success)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Vehicle armed&quot;</span>);<span class="comment">//解锁后打印信息</span></span><br><span class="line">                &#125;</span><br><span class="line">                last_request = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ros::Time::<span class="built_in">now</span>()-last_request&gt;ros::<span class="built_in">Duration</span>(<span class="number">5.0</span>)) <span class="keyword">break</span>;</span><br><span class="line">        local_pos_pub.<span class="built_in">publish</span>(pose); </span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pos_flag=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//利用pos_flag和x位置来确定位置状态</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(current_pose.pose.position.x&lt;<span class="number">1.009</span> &amp;&amp; current_pose.pose.position.x&gt;<span class="number">0.991</span> &amp;&amp; pos_flag==<span class="number">1</span>)&#123;</span><br><span class="line">            pos_flag=<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">set_pos</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current_pose.pose.position.x&lt;<span class="number">0.009</span> &amp;&amp; current_pose.pose.position.x&gt;<span class="number">-0.991</span> &amp;&amp; pos_flag==<span class="number">2</span>)&#123;</span><br><span class="line">            pos_flag=<span class="number">3</span>;</span><br><span class="line">            <span class="built_in">set_pos</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current_pose.pose.position.x&lt;<span class="number">2.009</span> &amp;&amp; current_pose.pose.position.x&gt;<span class="number">1.991</span> &amp;&amp; pos_flag==<span class="number">3</span>)&#123;</span><br><span class="line">            pos_flag=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">set_pos</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;go to position%d&quot;</span>,pos_flag);</span><br><span class="line">        local_pos_pub.<span class="built_in">publish</span>(pose); </span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_pos</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y,<span class="type">double</span> z)</span></span>&#123;</span><br><span class="line">    pose.pose.position.x = x;</span><br><span class="line">    pose.pose.position.y = y;</span><br><span class="line">    pose.pose.position.z = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="/data.github.io/post/15fa7048.html"/>
      <url>/data.github.io/post/15fa7048.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://blog.csdn.net/qq_42257666/article/details/119209599?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169103195516800211577632%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169103195516800211577632&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119209599-null-null.142%5Ev92%5Econtrol&utm_term=ros%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">第一章 ROS的概述与环境搭建</a></li><li><a href="https://blog.csdn.net/weixin_43455581/article/details/96306977?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169227833916800180633932%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169227833916800180633932&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-96306977-null-null.142%5Ev93%5EchatgptT3_2&utm_term=%E5%8F%A4%E6%9C%88%E5%B1%85ros%E5%85%A5%E9%97%A821%E8%AE%B2%E7%AC%94%E8%AE%B0&spm=1018.2226.3001.4187#t7">古月21讲笔记</a></li><li><a href="https://blog.csdn.net/qq_37680545/article/details/123243313">无人机仿真</a></li><li><a href="https://www.guyuehome.com/372">ros</a></li><li><a href="https://wiki.ros.org/cn">ros wiki中文版</a></li><li><a href="https://docs.ros.org/en/api/">ros_api包</a>：可在上面查看软件包及消息类型</li></ul><h1 id="ROS-概念"><a href="#ROS-概念" class="headerlink" title="ROS 概念"></a>ROS 概念</h1><ul><li><a href="http://www.autolabor.com.cn/book/ROSTutorials/di-2-zhang-ros-jia-gou-she-ji.html">ros教程完整</a><br><strong>节点（Node）— 执行单元</strong></li><li>节点是具体的执行单元，执行具体任务的进程，独立运行的可执行文件</li><li>不同的节点可以使用不同的编程语言，可分布式运行在不同的主机</li><li>节点在系统中的名称必须是唯一的，重名ros系统会找不到</li></ul><p><strong>节点管理器（ROS Master) — 控制中心</strong></p><ul><li>节点的管理。命名、注册、建立通讯</li><li>提供参数服务器，节点使用此服务器存储和检索运行时的参数</li></ul><p><strong>话题通信（异步）<br>话题 topic</strong></p><ul><li>分为发布者和订阅者</li><li>单向数据传输，从驱动端传到订阅段，发布者到订阅者</li><li>通道被定义为话题时,数据传输的总线</li></ul><p><strong>消息 message</strong></p><ul><li>具有一定的类型和数据结构（有 ros 提供的标准类型和用户自定义的类型）</li><li>使用与编程语言无关的 .msg 文件定义类型和数据结构</li></ul><p><strong>服务通信（同步）<br>服务 service</strong></p><ul><li>使用服务端&#x2F;客服端（service&#x2F;client) 模型，客户端发送请求数据，服务器完成处理后返回应答数据</li><li>使用与编程语言无关的, .srv 文件定义请求和应答的数据结构</li><li>一般是一次，发出一个配置指令，完成配置内容，返回一个反馈</li></ul><p>![[Pasted image 20230818085619.png]]<br>![[Pasted image 20230818085629.png]]<br><strong>参数 parameter</strong></p><ul><li>适合存储静态、非二进制的配置参数，不适合动态配置的数据</li><li>节点使用服务器来存储和检测运行时的参数</li></ul><p><strong>文件系统</strong></p><ul><li>功能包 package：ros软件的基本单元，包含源码、配置文件、数据定义</li><li>功能包清单 package manifest：记录功能包的基本信息，包含作者信息、许可信息等等信息</li><li>元功能包 meta packages：组织多个用于同一目的的功能</li></ul><h2 id="ROS-搞懂多话题回调机制以及消息队列"><a href="#ROS-搞懂多话题回调机制以及消息队列" class="headerlink" title="ROS 搞懂多话题回调机制以及消息队列"></a>ROS 搞懂多话题回调机制以及消息队列</h2><ul><li><a href="https://blog.csdn.net/m0_67392931/article/details/123498349?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-123498349-blog-113934774.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-123498349-blog-113934774.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=16">来源</a></li><li>ROS话题的通信是<strong>异步</strong>的，publisher只管不停的发但不管是否被接收，publisher的消息队列就是publisher发布信息的地方</li><li>publisher向消息队列发布信息然后通知subscriber过来读取， 而并不是publisher直接push给subscriber，publisher不停将消息发布到消息队列上，直到队列占满，然后新到的消息把最老的消息挤出队列，每个subscriber会通过一个位置指针使其在正确的消息队列位置上进行读取</li><li>publisher消息队列的作用就是，缓存一定数量的历史信息，让不能及时订阅的subscriber能读取到之前发布的信息</li><li>subscriber读取到数据后就会将它放置与自己的消息队列中，等待回调函数读取，这个消息队列的作用是，将回调函数来不及处理的信息及时的缓存，这样不至于因为回调函数执行或调用过慢，导致数据的丢失。</li><li><a href="https://www.cnblogs.com/liu-fa/p/5925381.html">ROS处理回调函数</a></li><li>接受订阅的消息，但是<strong>所接到的消息并不是立刻就被处理，而是必须要等到ros::spin()或ros::spinOnce()执行的时候才被调用</strong>，这就是消息回到函数的原理</li></ul><p><strong>区别</strong></p><ul><li>ros::spin()：调用后不会执行后面的程序，一般在程序结束末尾</li><li>ros::spinOnce()：调用<strong>后还可以继续执行之后的程序</strong><ul><li>ros::spinOnce()的用法相对来说很灵活，但往往需要考虑调用消息的时机，调用频率，以及消息池的大小，这些都要根据现实情况协调好，不然会造成数据丢包或者延迟的错误。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅时的回调函数，接受到该消息体的内容时执行里面的内容，这里面的内容就是赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">    current_state = *msg;</span><br><span class="line">&#125;</span><br><span class="line">ros::Subscriber state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;mavros/state&quot;</span>, <span class="number">100</span>, state_cb);</span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">15.0</span>)</span></span>;<span class="comment">//利用rate.sleep()控制while循环的每秒运行15次</span></span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())<span class="comment">//进入大循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">         local_pos_pub.<span class="built_in">publish</span>(pose); <span class="comment">//发布位置信息，所以综上飞机只有先打开offboard模式然后解锁才能飞起来</span></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;spinOnce&quot;</span>);</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//对于上述测试的代码</span></span><br></pre></td></tr></table></figure><h2 id="ROS时间概念"><a href="#ROS时间概念" class="headerlink" title="ROS时间概念"></a>ROS时间概念</h2><ul><li><a href="https://blog.csdn.net/u014453443/article/details/104636566">概念总结</a><br><strong>基本用法</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">ros::Time begin=ros::Time::<span class="built_in">now</span>();   </span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义类对象</span></span><br><span class="line">ros::Time::<span class="built_in">Time</span>(<span class="type">uint32_t</span> sec, <span class="type">uint32_t</span> nsec)</span><br><span class="line">ros::Time::<span class="built_in">Time</span>(<span class="type">double</span> t)</span><br><span class="line"> </span><br><span class="line">ros::Duration::<span class="built_in">Duration</span>(<span class="type">uint32_t</span> sec, <span class="type">uint32_t</span> nsec)</span><br><span class="line">ros::Duration::<span class="built_in">Duration</span>(<span class="type">double</span> t)</span><br><span class="line"><span class="comment">//_sec是秒，_nsec是纳秒</span></span><br><span class="line"><span class="comment">//故ros::Time a_little_after_the_beginning(0, 1000000);等价于ros::Time a_little_after_the_beginning(0.001);</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//实列</span></span><br><span class="line"><span class="function">ros::Time <span class="title">at_some_time1</span><span class="params">(<span class="number">5</span>,<span class="number">20000000</span>)</span></span>;    <span class="comment">//逗号之前表示 second，逗号之后表示 nanosecond</span></span><br><span class="line"><span class="function">ros::Time <span class="title">at_some_time2</span><span class="params">(<span class="number">5.2</span>)</span>    <span class="comment">//同上,重载了float类型和两个uint类型的构造函数</span></span></span><br><span class="line"><span class="function">ros::Duration <span class="title">one_hour</span><span class="params">(<span class="number">60</span>*<span class="number">60</span>,<span class="number">0</span>)</span></span>; <span class="comment">//1h</span></span><br><span class="line"><span class="type">double</span> secs1=at_some_time1.<span class="built_in">toSec</span>();<span class="comment">//将 Time 转为 double 型时间</span></span><br><span class="line"><span class="type">double</span> secs2=one_hour.<span class="built_in">toSec</span>();<span class="comment">//将 Duration 转为 double 型时间</span></span><br></pre></td></tr></table></figure></li><li>Time 指的是某个时刻，而 Duration 指的是某个时段，尽管他们的数据结构都相同，但是应该用在不同的场景下</li><li>ROS为我们重载了 Time、Duration 类型之间的加减运算，避免了转换的麻烦。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ros::Time t1=ros::Time::now()-ros::Duration(<span class="number">5.5</span>);<span class="comment">//t1是5.5s前的时刻,Time加减Duration返回Time</span></span><br><span class="line">ros::Time t2=ros::Time::now()+ros::Duration(<span class="number">3.3</span>);<span class="comment">//t2是当前时刻往后推3.3s的时刻</span></span><br><span class="line">ros::Duration d1=t2-t1;<span class="comment">//从t1到t2的时长，两个Time相减返回Duration类型</span></span><br><span class="line">ros::Duration d2=d1-ros::Duration(<span class="number">0</span>,<span class="number">300</span>);<span class="comment">//两个Duration相减，返回Duration</span></span><br></pre></td></tr></table></figure><h1 id="ROS-命令行工具的使用（操作集）"><a href="#ROS-命令行工具的使用（操作集）" class="headerlink" title="ROS 命令行工具的使用（操作集）"></a>ROS 命令行工具的使用（操作集）</h1><p>这需要新建多个终端并输入命令</p><ul><li>启动 rosmaster：<code>roscore</code></li><li>启动小海龟仿真器：<code>rosrun turtlesim turtlesim_node</code></li><li>启动海龟控制节点：<code>rosrun turtlesim turtle_teleop_key</code>，点击该终端可以通过键盘运行小海龟</li><li><code>rosrun  [包名] [可执行文件]</code><ul><li>可执行文件一般是src文件下的cpp文件处理后的，需要在CMakeLists中去设置好可执行文件</li></ul></li></ul><h2 id="ros文件系统"><a href="#ros文件系统" class="headerlink" title="ros文件系统"></a>ros文件系统</h2><p><strong>catkin结构</strong></p><p>![[Pasted image 20231112120357.png]]</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">​&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!-- 格式: 以前是 1，推荐使用格式 2 --&gt;</span><br><span class="line">&lt;package format=&quot;2&quot;&gt;</span><br><span class="line">  &lt;!-- 包名 --&gt;</span><br><span class="line">  &lt;name&gt;demo01_hello_vscode&lt;/name&gt;</span><br><span class="line">  &lt;!-- 版本 --&gt;</span><br><span class="line">  &lt;version&gt;0.0.0&lt;/version&gt;</span><br><span class="line">  &lt;!-- 描述信息 --&gt;</span><br><span class="line">  &lt;description&gt;The demo01_hello_vscode package&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- One maintainer tag required, multiple allowed, one person per tag --&gt;</span><br><span class="line">  &lt;!-- Example:  --&gt;</span><br><span class="line">  &lt;!-- &lt;maintainer email=&quot;jane.doe@example.com&quot;&gt;Jane Doe&lt;/maintainer&gt; --&gt;</span><br><span class="line">  &lt;!-- 维护人员 --&gt;</span><br><span class="line">  &lt;maintainer email=&quot;xuzuo@todo.todo&quot;&gt;xuzuo&lt;/maintainer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- One license tag required, multiple allowed, one license per tag --&gt;</span><br><span class="line">  &lt;!-- Commonly used license strings: --&gt;</span><br><span class="line">  &lt;!--   BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1, LGPLv3 --&gt;</span><br><span class="line">  &lt;!-- 许可证信息，ROS核心组件默认 BSD --&gt;</span><br><span class="line">  &lt;license&gt;TODO&lt;/license&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- Url tags are optional, but multiple are allowed, one per tag --&gt;</span><br><span class="line">  &lt;!-- Optional attribute type can be: website, bugtracker, or repository --&gt;</span><br><span class="line">  &lt;!-- Example: --&gt;</span><br><span class="line">  &lt;!-- &lt;url type=&quot;website&quot;&gt;http://wiki.ros.org/demo01_hello_vscode&lt;/url&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- Author tags are optional, multiple are allowed, one per tag --&gt;</span><br><span class="line">  &lt;!-- Authors do not have to be maintainers, but could be --&gt;</span><br><span class="line">  &lt;!-- Example: --&gt;</span><br><span class="line">  &lt;!-- &lt;author email=&quot;jane.doe@example.com&quot;&gt;Jane Doe&lt;/author&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- The *depend tags are used to specify dependencies --&gt;</span><br><span class="line">  &lt;!-- Dependencies can be catkin packages or system dependencies --&gt;</span><br><span class="line">  &lt;!-- Examples: --&gt;</span><br><span class="line">  &lt;!-- Use depend as a shortcut for packages that are both build and exec dependencies --&gt;</span><br><span class="line">  &lt;!--   &lt;depend&gt;roscpp&lt;/depend&gt; --&gt;</span><br><span class="line">  &lt;!--   Note that this is equivalent to the following: --&gt;</span><br><span class="line">  &lt;!--   &lt;build_depend&gt;roscpp&lt;/build_depend&gt; --&gt;</span><br><span class="line">  &lt;!--   &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt; --&gt;</span><br><span class="line">  &lt;!-- Use build_depend for packages you need at compile time: --&gt;</span><br><span class="line">  &lt;!--   &lt;build_depend&gt;message_generation&lt;/build_depend&gt; --&gt;</span><br><span class="line">  &lt;!-- Use build_export_depend for packages you need in order to build against this package: --&gt;</span><br><span class="line">  &lt;!--   &lt;build_export_depend&gt;message_generation&lt;/build_export_depend&gt; --&gt;</span><br><span class="line">  &lt;!-- Use buildtool_depend for build tool packages: --&gt;</span><br><span class="line">  &lt;!--   &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; --&gt;</span><br><span class="line">  &lt;!-- Use exec_depend for packages you need at runtime: --&gt;</span><br><span class="line">  &lt;!--   &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; --&gt;</span><br><span class="line">  &lt;!-- Use test_depend for packages you need only for testing: --&gt;</span><br><span class="line">  &lt;!--   &lt;test_depend&gt;gtest&lt;/test_depend&gt; --&gt;</span><br><span class="line">  &lt;!-- Use doc_depend for packages you need only for building documentation: --&gt;</span><br><span class="line">  &lt;!--   &lt;doc_depend&gt;doxygen&lt;/doc_depend&gt; --&gt;</span><br><span class="line">  &lt;!-- 依赖的构建工具，这是必须的 --&gt;</span><br><span class="line">  &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 指定构建此软件包所需的软件包 --&gt;</span><br><span class="line">  &lt;build_depend&gt;roscpp&lt;/build_depend&gt;</span><br><span class="line">  &lt;build_depend&gt;rospy&lt;/build_depend&gt;</span><br><span class="line">  &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 指定根据这个包构建库所需要的包 --&gt;</span><br><span class="line">  &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;</span><br><span class="line">  &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;</span><br><span class="line">  &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 运行该程序包中的代码所需的程序包 --&gt;  </span><br><span class="line">  &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;</span><br><span class="line">  &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;</span><br><span class="line">  &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;!-- The export tag contains other, unspecified, tags --&gt;</span><br><span class="line">  &lt;export&gt;</span><br><span class="line">    &lt;!-- Other tools can request additional information be placed here --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/export&gt;</span><br><span class="line">&lt;/package&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>![[Pasted image 20231213092328.png]]<br><strong>package是catkin工作空间的基本单元</strong></p><ul><li>其中定义package的是 CMakeLists.txt 和 package.xml ,这两个文件是package中必不可少<br>![[Pasted image 20231031195234.png]]<br>• scripts (python 可执行文件)<br>• src (C++ source files)<br>• msg (for custom message definitions)<br>• srv (for service message definitions)<br>• include -&gt; 需要作为依赖项的头&#x2F;库<br>• config -&gt; 配置文件<br>• launch -&gt; 提供更自动化的启动节点方式<br>• urdf (通用机器人描述文件)<br>• meshes (CAD文件.dae (Collada)或.stl (STereoLithography)格式)<br>• worlds (用于Gazebo模拟环境的类似XML的文件)</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph  <span class="comment">//用来显示系统计算图的工具</span></span><br></pre></td></tr></table></figure><h3 id="rosnode"><a href="#rosnode" class="headerlink" title="rosnode"></a>rosnode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosnode  <span class="comment">//显示所有系统节点相关信息的指令</span></span><br><span class="line">rosnode <span class="built_in">list</span> <span class="comment">//列出系统所有节点</span></span><br><span class="line">rosnode info 节点 <span class="comment">//查看节点信息，查看某个节点的信息，发布和订阅的信息</span></span><br></pre></td></tr></table></figure><h3 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic"></a>rostopic</h3><ul><li><a href="http://www.autolabor.com.cn/book/ROSTutorials/di-2-zhang-ros-jia-gou-she-ji/24-chang-yong-ming-ling/242-rostopic.html">简单说明</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rostopic bw     显示主题使用的带宽</span><br><span class="line">rostopic delay  显示带有 header 的主题延迟</span><br><span class="line">rostopic echo   打印消息到屏幕</span><br><span class="line">rostopic find   根据类型查找主题</span><br><span class="line">rostopic hz     显示主题的发布频率</span><br><span class="line">rostopic info   显示主题相关信息</span><br><span class="line">rostopic list   显示所有活动状态下的主题</span><br><span class="line">rostopic pub    将数据发布到主题</span><br><span class="line">rostopic type   打印主题类型</span><br></pre></td></tr></table></figure></li></ul><p><strong>rostopic list</strong></p><ul><li>直接调用即可，控制台将打印当前运行状态下的主题名称</li><li>rostopic list -v : 获取话题详情(比如列出：发布者和订阅者个数…)</li></ul><p><strong>rostopic pub</strong></p><ul><li>可以直接调用命令向订阅者发布消息</li><li>为roboware 自动生成的 发布&#x2F;订阅 模型案例中的 订阅者 发布一条字符串<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub /主题名称 消息类型 消息内容</span><br><span class="line">rostopic pub /chatter std_msgs gagaxixi</span><br></pre></td></tr></table></figure></li></ul><p><strong>rostpic echo</strong>  主题名称</p><ul><li>获取指定话题当前发布的消息</li></ul><p><strong>rostopic info</strong>  主题名称</p><ul><li>获取当前话题的相关信息</li><li>消息类型</li><li>发布者信息</li><li>订阅者信息<br><strong>rostopic type</strong></li><li>列出话题的消息类型<br><strong>rostopic find 消息类型</strong></li><li>根据消息类型查找话题</li></ul><p><strong>rostopic delay</strong></p><ul><li>列出消息头信息</li></ul><p><strong>rostopic hz</strong></p><ul><li>列出消息发布频率</li></ul><p><strong>rostopic bw</strong></p><ul><li>列出消息发布带宽</li></ul><p>![[Pasted image 20230818095944.png]]<br>学会使用tab, 这里输入消息类型的时候还要连按两次tab（通过两次tab键来补全命令）</p><ul><li>用pub发布数据给某一个topic</li><li>后面跟话题名</li><li>再后面跟消息结构（类型）</li><li>再跟消息结构里的具体数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是发布线速度和角速度的命令，这样只运行一次</span></span><br><span class="line"><span class="comment">//rostopic pub 话题名称  消息类型 消息内容</span></span><br><span class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist <span class="string">&quot;linear:</span></span><br><span class="line"><span class="string">  x: 1.0</span></span><br><span class="line"><span class="string">  y: 0.0</span></span><br><span class="line"><span class="string">  z: 4.0</span></span><br><span class="line"><span class="string">angular:</span></span><br><span class="line"><span class="string">  x: 54.0</span></span><br><span class="line"><span class="string">  y: 0.0</span></span><br><span class="line"><span class="string">  z: 0.0&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//一秒钟发布2次</span></span><br><span class="line">rostopic pub -r <span class="number">2</span> /turtle1/cmd_vel geometry_msgs/Twist <span class="string">&quot;linear:</span></span><br><span class="line"><span class="string">  x: 1.0</span></span><br><span class="line"><span class="string">  y: 0.0</span></span><br><span class="line"><span class="string">  z: 4.0</span></span><br><span class="line"><span class="string">angular:</span></span><br><span class="line"><span class="string">  x: 54.0</span></span><br><span class="line"><span class="string">  y: 0.0</span></span><br><span class="line"><span class="string">  z: 0.0&quot;</span> </span><br></pre></td></tr></table></figure><h3 id="rosmsg"><a href="#rosmsg" class="headerlink" title="rosmsg"></a>rosmsg</h3><ul><li>rosmsg show显示消息的数据结构<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosmsg</span><br><span class="line">rosmsg show geometry_msgs/Twist</span><br></pre></td></tr></table></figure></li></ul><h3 id="rosservice"><a href="#rosservice" class="headerlink" title="rosservice"></a>rosservice</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice   <span class="comment">//查看相关服务端相关指令</span></span><br><span class="line">rosservice list</span><br></pre></td></tr></table></figure><p>rosservice call 召唤新海龟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /spawn <span class="string">&quot;x: 2.0</span></span><br><span class="line"><span class="string">y: 2.0</span></span><br><span class="line"><span class="string">theta: 0.0</span></span><br><span class="line"><span class="string">name: &#x27;turtle2&#x27;&quot;</span> </span><br></pre></td></tr></table></figure><h3 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -a -O cmd_record    <span class="comment">//话题记录,将记录cmd_record.bag并保存到当前目录</span></span><br><span class="line">rosbag play cmd_record.bag        <span class="comment">//对上面的记录的话题，进行话题复现</span></span><br></pre></td></tr></table></figure><h1 id="创建工作空间与功能包"><a href="#创建工作空间与功能包" class="headerlink" title="创建工作空间与功能包"></a>创建工作空间与功能包</h1><p><strong>概念</strong></p><ul><li>工作空间（workspace)是一个存放工程开发相关文件的文件夹。所有的源码、配置文件、可执行文件都是放置在里面的。主要分为四个文件夹：</li></ul><ol><li>src: 代码空间 (source space)：放置功能包（里面的代码、配置文件、launch文件</li><li>build:编译空间 (build space)：编译过程中的中间文件（不太用关心</li><li>devel:开发空间 (development space)：编译生成的一些可执行文件、库、脚本</li><li>install:安装空间 (install space)：install命令的结果就放在里面<br>![[Pasted image 20230818165821.png]]<br><strong>创建工作空间</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src   <span class="comment">//-p是连续创建，catkin_ws可以是其他名字，src必须有</span></span><br><span class="line">cd ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure></li></ol><p><strong>编译工作空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/</span><br><span class="line">catkin_make </span><br><span class="line">catkin_make install   <span class="comment">//使install空间出现</span></span><br></pre></td></tr></table></figure><p><strong>创建功能包</strong></p><ul><li>功能包是放置ROS源码的最小单元</li><li>同一个工作空间下不允许存在同名功能包</li><li>要在src里面<br><img src="https://img-blog.csdnimg.cn/23227ad21b774a298d8e3eb2431345a4.png" alt="在这里插入图片描述"><br>命令 功能包名 依赖1 依赖2 依赖3 … 依赖n：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建功能包,功能包名可自定义</span></span><br><span class="line">cd ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_pkg std_msgs rospy roscpp  <span class="comment">//有cpp，python依赖</span></span><br><span class="line"><span class="comment">//编译功能包</span></span><br><span class="line">cd ~/catkin_ws</span><br><span class="line">catkin_make </span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>设置环境变量</strong></li><li>在catkin_ws的文件下设置：<code>source devel/setup.bash</code></li></ul><p><strong>检查环境变量</strong></p><ul><li>用echo命令把环境变量打开:<code>echo $ROS_PACKAGE_PATH</code>,（ROS_PACKAGE_PATH 是ROS本身的一个环境变量，通过这个环境变量查找所有功能包的路径）</li></ul><h4 id="catkin-make和catkin-build区别"><a href="#catkin-make和catkin-build区别" class="headerlink" title="catkin_make和catkin build区别"></a>catkin_make和catkin build区别</h4><ul><li>catkin_make会编译全部ros包</li><li>而catkin_build可以选择部分ros包编译<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只编译uav_arm包</span></span><br><span class="line">catkin build uav_arm</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布实现"><a href="#发布实现" class="headerlink" title="发布实现"></a>发布实现</h2><p><a href="https://blog.csdn.net/qq_46980810/article/details/133691753?ops_request_misc=&request_id=&biz_id=102&utm_term=ros%E8%AE%A2%E9%98%85%E8%AF%9D%E9%A2%98%E6%A1%88%E4%BE%8B%E3%80%91&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-133691753.nonecase&spm=1018.2226.3001.4187">订阅与发布讲解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在src下创建包,并编译</span></span><br><span class="line">cd ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br><span class="line">cd ~/catkin_ws/</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>![[Pasted image 20230818141307.png]]<br>在<code>src/learning_topic/src</code>下创建文件<code>velocity_publisher.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ROS节点初始化</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">ros::Publisher turtle_vel_pub = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>src/learning_topic/CMakeLists.txt</code>中的camke文件添加信息</p><h3 id="cmake文件"><a href="#cmake文件" class="headerlink" title="cmake文件"></a>cmake文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在build注释后面添加</span></span><br><span class="line"><span class="keyword">add_executable</span>(velocity_publisher src/velocity_publisher.cpp)<span class="comment">#描述将cpp变成velocity_publisher可执行文件,这里添加编译文件名的名称</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(velocity_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#指定库以链接库或可执行目标</span></span><br></pre></td></tr></table></figure><p>接着返回根目录编译</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catkin_make</span><br><span class="line">source devel/setup.bash  <span class="comment">#设置环境变量</span></span><br></pre></td></tr></table></figure><p>运行发布</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore </span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic velocity_publisher</span><br></pre></td></tr></table></figure><ul><li>注意<code>source devel/setup.bash</code>和<code>rosrun learning_topic velocity_publisher</code>要在同一个终端才不会报错，<a href="https://blog.csdn.net/qq_33973712/article/details/108226729?ops_request_misc=&request_id=&biz_id=102&utm_term=%5Brospack%5D%20Error:%20package%20%27lear&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-108226729.142%5Ev93%5EchatgptT3_2&spm=1018.2226.3001.4187">解决报错办法</a></li></ul><h2 id="订阅者实现"><a href="#订阅者实现" class="headerlink" title="订阅者实现"></a>订阅者实现</h2><ul><li>对于已经创建的环境包中实现，在<code>src/learning_topic/src</code>下创建文件<code>pose_subscriber.cpp</code></li><li>同一个回调函数可以在多个订阅话题中使用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数，订阅消息的操作需要在回调函数中去写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span></span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>&lt;turtlesim::Pose::ConstPtr&gt;(<span class="string">&quot;/turtle1/pose&quot;</span>, <span class="number">10</span>, poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ros::spin() 将会进入循环， 一直调用回调函数poseCallback(),每次调用10个数据。</span></span><br><span class="line"><span class="comment">     * 当用户输入Ctrl+C或者ROS主进程关闭时退出，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="回调函数传入多个参数"><a href="#回调函数传入多个参数" class="headerlink" title="回调函数传入多个参数"></a>回调函数传入多个参数</h4><ul><li><a href="https://www.cnblogs.com/tiderfang/p/8968124.html#:~:text=ROS%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E4%B8%8D%E5%B0%91%E9%9C%80%E8%A6%81%E7%BB%99%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%BC%A0%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%20%E4%B8%80%E3%80%81%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%BB%85%E5%90%AB%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%20void%20chatterCallback%28const%20std_msgs%3A%3AString%3A%3AConstPtr%26%20msg%29%20%7B%20ROS_INFO,%7B....%20ros%3A%3ASubscriber%20sub%20%3D%20n.subscribe%20%28%22chatter%22%2C%201000%2C%20chatterCallback%29%3B.">解释</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/Float64.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/Float32.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback1</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">const</span> std_msgs::Float64&gt;&amp; msg, std::string joint_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s的angle_position:%0.6f&quot;</span>, joint_name.<span class="built_in">c_str</span>(), msg-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">const</span> std_msgs::Float32&gt;&amp; msg, Four_motor&amp; four_motor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// four_motor.Pub(msg-&gt;data);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Four_motor</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;real_position_sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    std::string joint_name=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    ros::Subscriber arm_joint1_sub = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float64&gt;(<span class="string">&quot;iris0/arm_joint1/real_position&quot;</span>, <span class="number">10</span>, boost::<span class="built_in">bind</span>(&amp;poseCallback1, _1, <span class="string">&quot;arm1&quot;</span>));</span><br><span class="line">    ros::Subscriber arm_joint2_sub = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float64&gt;(<span class="string">&quot;iris0/arm_joint2/real_position&quot;</span>, <span class="number">10</span>, boost::<span class="built_in">bind</span>(&amp;poseCallback1, _1, <span class="string">&quot;arm2&quot;</span>));</span><br><span class="line">    ros::Subscriber arm_joint3_sub = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float64&gt;(<span class="string">&quot;iris0/arm_joint3/real_position&quot;</span>, <span class="number">10</span>, boost::<span class="built_in">bind</span>(&amp;poseCallback1, _1, <span class="string">&quot;arm3&quot;</span>));</span><br><span class="line">    ros::Subscriber arm_joint4_sub = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float64&gt;(<span class="string">&quot;iris0/arm_joint4/real_position&quot;</span>, <span class="number">10</span>, boost::<span class="built_in">bind</span>(&amp;poseCallback1, _1, <span class="string">&quot;arm4&quot;</span>));</span><br><span class="line">    Four_motor four_motor;</span><br><span class="line">    <span class="comment">// 对于定义的类,对于下面的poseCallback的第二个参数是类</span></span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float32&gt;(<span class="string">&quot;/var_strc_uav/four_motor_pos_sub&quot;</span>, <span class="number">10</span>,</span><br><span class="line">                                                              boost::<span class="built_in">bind</span>(&amp;poseCallback, _1, boost::<span class="built_in">ref</span>(four_motor)));</span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float32&gt;(<span class="string">&quot;/var_strc_uav/four_motor_pos_sub&quot;</span>, <span class="number">10</span>,</span><br><span class="line">                                                              boost::<span class="built_in">bind</span>(&amp;poseCallback, _1, four_motor));</span><br><span class="line">    <span class="comment">// 两个区别：在第一个代码片段中，使用了boost::ref(four_motor)，它将four_motor对象作为引用传递给回调函数。这意味着在回调函数中可以修改four_motor对象的状态，并且这些修改将在回调函数返回后保持有效。</span></span><br><span class="line">    <span class="comment">// 而在第二个代码片段中，使用了four_motor（而不是boost::ref(four_motor)），它将four_motor对象作为值传递给回调函数。这意味着在回调函数中对four_motor对象的修改只会在回调函数内部有效，不会影响到原始的four_motor对象。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>添加cmake文件中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(pose_subscriber src/pose_subscriber.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(pose_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><p>运行发布</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roscore </span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic pose_subscriber</span><br></pre></td></tr></table></figure><h3 id="订阅和发布混用"><a href="#订阅和发布混用" class="headerlink" title="订阅和发布混用"></a>订阅和发布混用</h3><ul><li>订阅一个话题，在回调函数中通过一个类来进行信息发布(发布到4个电机中)</li><li>测试在rqt_gui中进行发布，也可以自己写<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/Float32.h&quot;</span> </span></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数，订阅消息的操作需要在回调函数中去写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Joint_info</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std_msgs::Float32 joint_info;<span class="comment">//作为关节信息的发布内容</span></span><br><span class="line">    std::string topic_path;</span><br><span class="line">    std::string joint_name;</span><br><span class="line">    ros::Publisher joint_pub;</span><br><span class="line">    ros::Subscriber position_sub;</span><br><span class="line">    std_msgs::Float32 current_position;</span><br><span class="line">    <span class="built_in">Joint_info</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init_Info</span><span class="params">(std::string joint_name,ros::NodeHandle nh)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_name=joint_name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;topic_path=<span class="string">&quot;/var_strc_uav/&quot;</span>+joint_name+<span class="string">&quot;/pos_cmd&quot;</span>;<span class="comment">//设置话题路径</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub=nh.<span class="built_in">advertise</span>&lt;std_msgs::Float32&gt;(topic_path,<span class="number">10</span>);<span class="comment">//设置节点发布</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pub</span><span class="params">(<span class="type">double</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;current_position.data=data;</span><br><span class="line">        <span class="keyword">this</span>-&gt;joint_pub.<span class="built_in">publish</span>(<span class="keyword">this</span>-&gt;current_position);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Four_motor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Joint_info motor1;</span><br><span class="line">    Joint_info motor2;</span><br><span class="line">    Joint_info motor3;</span><br><span class="line">    Joint_info motor4;</span><br><span class="line">    <span class="built_in">Four_motor</span>(std::string joint_name1,std::string joint_name2,std::string joint_name3,std::string joint_name4,ros::NodeHandle nh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;motor1.<span class="built_in">Init_Info</span>(joint_name1,nh);</span><br><span class="line">        <span class="keyword">this</span>-&gt;motor2.<span class="built_in">Init_Info</span>(joint_name2,nh);</span><br><span class="line">        <span class="keyword">this</span>-&gt;motor3.<span class="built_in">Init_Info</span>(joint_name3,nh);</span><br><span class="line">        <span class="keyword">this</span>-&gt;motor4.<span class="built_in">Init_Info</span>(joint_name4,nh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Pub</span><span class="params">(<span class="type">double</span> data)</span></span>&#123;</span><br><span class="line">        motor1.<span class="built_in">Pub</span>(data);</span><br><span class="line">        motor2.<span class="built_in">Pub</span>(data);</span><br><span class="line">        motor3.<span class="built_in">Pub</span>(data);</span><br><span class="line">        motor4.<span class="built_in">Pub</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">const</span> std_msgs::Float32&gt;&amp; msg, Four_motor&amp; four_motor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    four_motor.<span class="built_in">Pub</span>(msg-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;info_sub&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="function">Four_motor <span class="title">four_motor1</span><span class="params">(<span class="string">&quot;left_front_joint1&quot;</span>,<span class="string">&quot;left_hind_joint1&quot;</span>,<span class="string">&quot;right_front_joint1&quot;</span>,<span class="string">&quot;right_hind_joint1&quot;</span>,n)</span></span>;</span><br><span class="line">    <span class="function">Four_motor <span class="title">four_motor2</span><span class="params">(<span class="string">&quot;left_front_joint2&quot;</span>,<span class="string">&quot;left_hind_joint2&quot;</span>,<span class="string">&quot;right_front_joint2&quot;</span>,<span class="string">&quot;right_hind_joint2&quot;</span>,n)</span></span>;</span><br><span class="line">    <span class="comment">//对电机1的4个电机进行发布</span></span><br><span class="line">    ros::Subscriber pose_sub1 = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float32&gt;(<span class="string">&quot;/var_strc_uav/four_motor1_pos_sub&quot;</span>, <span class="number">10</span>,</span><br><span class="line">                                                              boost::<span class="built_in">bind</span>(&amp;poseCallback, _1, boost::<span class="built_in">ref</span>(four_motor1)));</span><br><span class="line">    <span class="comment">//对电机2的4个电机进行发布</span></span><br><span class="line">    ros::Subscriber pose_sub2 = n.<span class="built_in">subscribe</span>&lt;std_msgs::Float32&gt;(<span class="string">&quot;/var_strc_uav/four_motor2_pos_sub&quot;</span>, <span class="number">10</span>,</span><br><span class="line">                                                              boost::<span class="built_in">bind</span>(&amp;poseCallback, _1, boost::<span class="built_in">ref</span>(four_motor2)));</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><p><strong>流程</strong></p><ul><li>编写发布方实现；</li><li>编写订阅方实现；</li><li>为python文件添加可执行权限；</li><li>编辑配置文件；</li><li>编译并执行。</li></ul><p><strong>发布</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    需求: 实现基本的话题通信，一方发布数据，一方接收数据，</span></span><br><span class="line"><span class="string">         实现的关键点:</span></span><br><span class="line"><span class="string">         1.发送方</span></span><br><span class="line"><span class="string">         2.接收方</span></span><br><span class="line"><span class="string">         3.数据(此处为普通文本)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         PS: 二者需要设置相同的话题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    消息发布方:</span></span><br><span class="line"><span class="string">        循环发布信息:HelloWorld 后缀数字编号</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    实现流程:</span></span><br><span class="line"><span class="string">        1.导包 </span></span><br><span class="line"><span class="string">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="string">        3.实例化 发布者 对象</span></span><br><span class="line"><span class="string">        4.组织被发布的数据，并编写逻辑发布数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#1.导包 </span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;talker_p&quot;</span>)</span><br><span class="line">    <span class="comment">#3.实例化 发布者 对象</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;chatter&quot;</span>,String,queue_size=<span class="number">10</span>)</span><br><span class="line">    <span class="comment">#4.组织被发布的数据，并编写逻辑发布数据</span></span><br><span class="line">    msg = String()  <span class="comment">#创建 msg 对象</span></span><br><span class="line">    msg_front = <span class="string">&quot;hello 你好&quot;</span></span><br><span class="line">    count = <span class="number">0</span>  <span class="comment">#计数器 </span></span><br><span class="line">    <span class="comment"># 设置循环频率</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line"></span><br><span class="line">        <span class="comment">#拼接字符串</span></span><br><span class="line">        msg.data = msg_front + <span class="built_in">str</span>(count)</span><br><span class="line"></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;写出的数据:%s&quot;</span>,msg.data)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>订阅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    需求: 实现基本的话题通信，一方发布数据，一方接收数据，</span></span><br><span class="line"><span class="string">         实现的关键点:</span></span><br><span class="line"><span class="string">         1.发送方</span></span><br><span class="line"><span class="string">         2.接收方</span></span><br><span class="line"><span class="string">         3.数据(此处为普通文本)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    消息订阅方:</span></span><br><span class="line"><span class="string">        订阅话题并打印接收到的消息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    实现流程:</span></span><br><span class="line"><span class="string">        1.导包 </span></span><br><span class="line"><span class="string">        2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line"><span class="string">        3.实例化 订阅者 对象</span></span><br><span class="line"><span class="string">        4.处理订阅的消息(回调函数)</span></span><br><span class="line"><span class="string">        5.设置循环调用回调函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#1.导包 </span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">doMsg</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;I heard:%s&quot;</span>,msg.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#2.初始化 ROS 节点:命名(唯一)</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;listener_p&quot;</span>)</span><br><span class="line">    <span class="comment">#3.实例化 订阅者 对象</span></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;chatter&quot;</span>,String,doMsg,queue_size=<span class="number">10</span>)</span><br><span class="line">    <span class="comment">#4.处理订阅的消息(回调函数)</span></span><br><span class="line">    <span class="comment">#5.设置循环调用回调函数</span></span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>终端下进入 scripts 执行:<code>chmod +x ***.py</code>，编译catkin_make</li><li>配置CmakeLists.txt<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_install_python(PROGRAMS</span><br><span class="line">  scripts/talker_p.py</span><br><span class="line">  scripts/listener_p.py</span><br><span class="line">  DESTINATION <span class="variable">$&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>roscore运行，最好scripts文件下运行<code>rosrun 功能包 talker_p.py</code></li></ul><h1 id="话题消息的定义与使用"><a href="#话题消息的定义与使用" class="headerlink" title="话题消息的定义与使用"></a>话题消息的定义与使用</h1><ol><li>定义msg文件<br>在功能包learning_topic文件夹下新建msg文件夹,在msg下新建Person.msg文件中写入<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age</span><br><span class="line"></span><br><span class="line">uint8 unknown=0</span><br><span class="line">uint8 male=1</span><br><span class="line">uint8 female=2</span><br></pre></td></tr></table></figure></li></ol><ul><li>其中在cpp使用的类型和msg定义的类型如下</li><li>订阅的时候接受要用cpp对应的类型，发布时，发布的信息和发布要用msg的类型(赋值还是cpp)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅</span></span><br><span class="line">std::string current_flag;</span><br><span class="line">flag_sub=nh.<span class="built_in">subscribe</span>&lt;uav_arm::Flag&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/arm_flag&quot;</span>, <span class="number">10</span>,boost::<span class="built_in">bind</span>(&amp;Flag_judge::Flag_cb, <span class="keyword">this</span>,_1));;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Flag_cb</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">const</span> uav_arm::Flag&gt;&amp; msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        uav_arm::Flag a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;current_flag=msg-&gt;flag;<span class="comment">//msg-&gt;flag</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布</span></span><br><span class="line">ros::Publisher flag_pub;</span><br><span class="line">flag_pub=nh.<span class="built_in">advertise</span>&lt;uav_arm::Flag&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/arm_flag&quot;</span>,<span class="number">10</span>); </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pub</span><span class="params">(std::string a)</span></span>&#123;</span><br><span class="line">        uav_arm::Flag b;</span><br><span class="line">        b.flag=a;</span><br><span class="line">        flag_pub.<span class="built_in">publish</span>(b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="left">msg中类型</th><th align="left">cpp对应类型</th></tr></thead><tbody><tr><td align="left">float32</td><td align="left">float</td></tr><tr><td align="left">float64</td><td align="left">double</td></tr><tr><td align="left">uint8</td><td align="left">unsigned char</td></tr><tr><td align="left">uint32</td><td align="left">unsigned int</td></tr><tr><td align="left">int32</td><td align="left">int</td></tr><tr><td align="left">string</td><td align="left">string</td></tr><tr><td align="left">string</td><td align="left">char</td></tr><tr><td align="left">bool</td><td align="left">bool</td></tr></tbody></table><ol><li>在功能包下package.xml中添加功能包依赖<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt; <span class="comment">//编译依赖</span></span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;   <span class="comment">//运行依赖</span></span><br></pre></td></tr></table></figure></li><li>在CMakeLists.txt添加编译选项<br> 这三部分添加，第一和第三找到对应函数添加，第二个在<code>Declare ROS messages, services and actions</code> 下方添加</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(... message_generation) </span><br><span class="line"></span><br><span class="line">add_message_files(FILES Person.msg)</span><br><span class="line">generate_messages(DEPENDENCIES std_msgs)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line"><span class="comment">#  INCLUDE_DIRS include</span></span><br><span class="line"><span class="comment">#  LIBRARIES learning_topic</span></span><br><span class="line"> CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime <span class="comment">#设置好的依赖放在这个位置</span></span><br><span class="line"><span class="comment">#  DEPENDS system_lib</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在编写文件后添加依赖，以发布为例,注意第三项</span></span><br><span class="line"><span class="keyword">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_publisher <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)<span class="comment"># 与动态生成的头文件作连接</span></span><br></pre></td></tr></table></figure><ol start="4"><li>编译<code>catkin_make</code>生成语言相关文件：在<code>devel/include/learning_topic/Person.h</code>可以查看编译后的代码<ol><li>对于编译的时候，最好在CmakeLists.txt将要编译的cpp文件注释下，然后再编译，因为可能cpp有之前.h消息头文件，而删除devel，导致后面编译不过</li></ol></li><li>编写发布和订阅更上面内容类似</li><li>对于要使用这个类型消息的话，生成.h文件，然后直接将这个文件复制相应位置就行了<br>对于直接文件</li></ol><ul><li>如果rqt添加没有反映，就source一下</li></ul><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    需求: 循环发布人的信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;demo02_talker_listener/Person.h&quot;</span></span></span><br><span class="line"><span class="comment">//头文件说明</span></span><br><span class="line"><span class="comment">//#include &quot;demo02_talker_listener/Person.h&quot;说明是在demo02_talker_listener功能包的路径</span></span><br><span class="line"><span class="comment">//复制.h文件到相应位置</span></span><br><span class="line"><span class="comment">//#include &quot;include/Person.h&quot;说明是1.cpp与include同一级目录,.h文件在include下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.初始化 ROS 节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;talker_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建 ROS 句柄</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建发布者对象</span></span><br><span class="line">    <span class="comment">//demo02_talker_listener是生成的命名空间，需要看生成的.h文件</span></span><br><span class="line">    ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;demo02_talker_listener::Person&gt;(<span class="string">&quot;chatter_person&quot;</span>,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.组织被发布的消息，编写发布逻辑并发布消息；</span></span><br><span class="line">    demo02_talker_listener::Person p;</span><br><span class="line">    p.name = <span class="string">&quot;sunwukong&quot;</span>;</span><br><span class="line">    p.age = <span class="number">2000</span>;</span><br><span class="line">    p.height = <span class="number">1.45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pub.<span class="built_in">publish</span>(p);</span><br><span class="line">        p.age += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;我叫:%s,今年%d岁,高%.2f米&quot;</span>, p.name.<span class="built_in">c_str</span>(), p.age, p.height);</span><br><span class="line"></span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h1><p>流程</p><ul><li>初始化ROS节点</li><li>创建一个Client实例</li><li>发布服务请求数据</li><li>等待Server处理后的应答结果</li></ul><p> 创建功能包<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg learning_service roscpp std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><br> 新建cpp<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//该例程将请求/spawn服务，服务数据类型为turtlesim::Spawn</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv)</span></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line">    ros::NodeHandle node;<span class="comment">//创建节点语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发现/spawn服务后，创建一个服务客户端，连接名/spawn的service</span></span><br><span class="line">    ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">    ros::ServiceClient add_turtle=node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">    turtlesim::Spawn srv;</span><br><span class="line">    srv.request.x=<span class="number">2.4</span>;</span><br><span class="line">    srv.request.y=<span class="number">2.6</span>;</span><br><span class="line">    srv.request.name=<span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//请求服务调用</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;call service to spwan turtle[x:%0.6f,y:%0.6f,name:%s]&quot;</span>,</span><br><span class="line">        srv.request.x,srv.request.y,srv.request.name);</span><br><span class="line">    add_turtle.<span class="built_in">call</span>(srv);<span class="comment">//类似publisher</span></span><br><span class="line">    <span class="comment">//显示服务调用结果</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spawn turtle successfully [name:%s]&quot;</span>,srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>按上面流程添加cmake文件，编译</li></ul><h1 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;std_srvs/Trigger.h&gt;</span></span></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="type">bool</span> pubCommand=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//service回调函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request &amp;req,std_srvs::Trigger::Response &amp;res)</span></span>&#123;</span><br><span class="line">    pubCommand=!pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;publish turtle velocity command [%s]&quot;</span>,pubCommand==<span class="literal">true</span>? <span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="comment">//设置反馈数据</span></span><br><span class="line">    res.success=<span class="literal">true</span>;</span><br><span class="line">    res.message=<span class="string">&quot;Change turtle command state&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="comment">//创建一个/turtle_command的server,注册回调函数commanderCallback</span></span><br><span class="line">    ros::ServiceServer command_service=n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>,commandCallback);</span><br><span class="line">    <span class="comment">//创建一个Publisher,发布一个名为/turtle1/cmd_vel的topic,消息类型为geometry_msgs::Twist,队列长度为10</span></span><br><span class="line">    turtle_vel_pub=n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive&quot;</span>);</span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();<span class="comment">//查看一次回调函数队列</span></span><br><span class="line">        <span class="comment">//如果标志为true,则发布速度指令</span></span><br><span class="line">        <span class="keyword">if</span>(pubCommand)&#123;</span><br><span class="line">            geometry_msgs::Twist vel_msg;</span><br><span class="line">            vel_msg.linear.x=<span class="number">0.2</span>;</span><br><span class="line">            vel_msg.angular.z=<span class="number">0.2</span>;</span><br><span class="line">            turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();<span class="comment">//按照循环频率延时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启服务后：用<code>rosservice call /turtle_command</code>可以来控制海龟运动</p><h2 id="服务数据的定义与使用"><a href="#服务数据的定义与使用" class="headerlink" title="服务数据的定义与使用"></a>服务数据的定义与使用</h2><p>定义自定义服务数据</p><ol><li>首先在功能包文件夹下创建srv文件夹，接着创建Person.srv<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name</span><br><span class="line">uint8 age</span><br><span class="line">uint8 sex</span><br><span class="line"></span><br><span class="line">uint8 unknown=<span class="number">0</span></span><br><span class="line">uint8 male=<span class="number">1</span></span><br><span class="line">uint8 female=<span class="number">2</span></span><br><span class="line">---</span><br><span class="line"><span class="built_in">string</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">//横线上方是request请求，横线下方是回应response</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>下面的操作与[[ROS#话题消息的定义与使用]]类似<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(FILES Person.srv)<span class="comment">#与上面操作不同的地方注意，文件名和函数名不同</span></span><br></pre></td></tr></table></figure></li><li>接着编译生成相关文件</li></ul><h2 id="参数使用与编程方法"><a href="#参数使用与编程方法" class="headerlink" title="参数使用与编程方法"></a>参数使用与编程方法</h2><ul><li><a href="https://blog.csdn.net/LacyExsale/article/details/117092499?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169268961516800225541999%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169268961516800225541999&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-117092499-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=ros%E5%8F%82%E6%95%B0&spm=1018.2226.3001.4187">使用方法</a></li></ul><ol><li>先创建一个功能包<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg learning_parameter roscpp rospy std_srvs</span><br></pre></td></tr></table></figure>参数命令行使用<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rosparam <span class="built_in">list</span>  <span class="comment">//列出当前多有参数</span></span><br><span class="line">rosparam get param_key  <span class="comment">//显示某个参数值</span></span><br><span class="line">rosparam <span class="built_in">set</span> param_key param_value  <span class="comment">//设置某个参数值</span></span><br><span class="line">rosparam dump file_name <span class="comment">//保存参数到文件</span></span><br><span class="line">rosparam load file_name  <span class="comment">//从文件加载参数（文件修改后）</span></span><br><span class="line">rosparam delet param_key  <span class="comment">//删除参数</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>ros::Subscriber：用于订阅话题消息。通过创建 ros::Subscriber 对象，你可以接收其他节点发布的话题消息，并在回调函数中处理这些消息。</li><li>ros::Publisher：用于发布话题消息。通过创建 ros::Publisher 对象，你可以向话题发布消息，供其他节点订阅和接收。<br>![[Pasted image 20230907161013.png]]</li><li>ros::ServiceClient：<strong>用于调用服务</strong>。通过创建 ros::ServiceClient 对象，你可以向其他节点发送服务请求，<strong>并等待并接收服务响应</strong>。</li></ul><p>这三个类的区别在于它们的用途和通信方式</p><ul><li>ros::Subscriber 和 ros::Publisher 用于发布&#x2F;订阅模式的通信。在发布&#x2F;订阅模式中，消息的发布者（发布者）将消息发布到一个特定的话题，而订阅者（消费者）订阅了这个话题并接收消息。发布者和订阅者之间<strong>通过话题进行异步通信</strong>，发布者和订阅者之间<strong>没有直接的请求-响应关系</strong>。</li><li>ros::ServiceClient <strong>用于请求-响应模式的通信</strong>。在请求-响应模式中，服务的客户端向服务的服务器发送请求，并等待服务器完成处理并返回响应。客户端和服务器之间通过服务进行同步通信，客户端发送请求并等待响应。<br>![[Pasted image 20230907155557.png]]</li><li>因此，<strong>ros::Subscriber 和 ros::Publisher 适用于一对多的消息通信，而 ros::ServiceClient 适用于一对一的请求-响应通信</strong>。</li><li>ros::Publisher和ros::ServiceClient 可理解成一个类型</li><li>ros::Subscriber 和ros::ServiceServer理解成一个类型<br>![[Pasted image 20230907160056.png]]</li></ul><h1 id="坐标系管理系统"><a href="#坐标系管理系统" class="headerlink" title="坐标系管理系统"></a>坐标系管理系统</h1><ul><li><a href="https://blog.csdn.net/weixin_53475254/article/details/118658041?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169269014116800184112173%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169269014116800184112173&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-118658041-null-null.142%5Ev93%5EchatsearchT3_2&utm_term=ros%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F&spm=1018.2226.3001.4187">坐标系管理系统</a><br><strong>TF功能包的作用</strong>是一种树状数据结构，根据时间缓冲并维护多个参考系之间的坐标变换关系，可以帮助程序员在任意时间，将点、向量等数据的坐标，在两个参考系中完成坐标变换,默认记录10S内的坐标。</li></ul><p><strong>TF坐标变换的实现方式</strong></p><ul><li>广播TF变换</li><li>监听TF变换</li></ul><ol><li>创建功能包：<code>catkin_create_pkg learning_tf roscpp rospy tf turtlesim</code><br>广播器编写turtle_tf_broadcaster.cpp<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建tf的广播器</span></span><br><span class="line"><span class="type">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化tf数据</span></span><br><span class="line">tf::Transform transform;</span><br><span class="line">transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );</span><br><span class="line">tf::Quaternion q;</span><br><span class="line">q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);</span><br><span class="line">transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line">ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>监听器编写turtle_tf_listener.cpp<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求产生turtle2</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">ros::Publisher turtle_vel = node.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tf的监听器</span></span><br><span class="line">tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">tf::StampedTransform transform;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查询是否有这两个坐标系，查询当前时间，如果超过3s则报错</span></span><br><span class="line">listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line"></span><br><span class="line">listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (tf::TransformException &amp;ex) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>接着编写[[ROS#cmake文件|cmake文件]]文件并编译</li><li>运行<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1   <span class="comment">//name后面的turtle1替代my_tf_broadcaster</span></span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2</span><br><span class="line">rosrun learning_tf turtle_tf_listener</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure></li></ul><h1 id="launch启动文件"><a href="#launch启动文件" class="headerlink" title="launch启动文件"></a>launch启动文件</h1><ul><li>rosrun是启动单个节点,roslaunch可以同时启动多个节点</li><li><a href="https://wiki.ros.org/roslaunch/XML">官方说明</a></li><li><a href="https://blog.csdn.net/weixin_45590473/article/details/122647788">详解1</a></li><li><a href="https://blog.csdn.net/zcw_jszs/article/details/131876383?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-131876383-blog-123661717.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-131876383-blog-123661717.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=5">语法说明</a></li><li><a href="https://blog.csdn.net/CH_monsy/article/details/107664893">详解2</a></li></ul><h2 id="launch元素"><a href="#launch元素" class="headerlink" title="launch元素"></a>launch元素</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Launch file content goes here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;launch&gt;</code>元素是roslaunch文件的根元素，表示一个启动配置的开始。所有其他元素都必须包含在<code>&lt;launch&gt;</code>元素的内部。一个roslaunch文件只能包含一个<code>&lt;launch&gt;</code>元素。</li></ul><h2 id="node元素"><a href="#node元素" class="headerlink" title="node元素"></a>node元素</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node_name&quot;</span> <span class="attr">args</span>=<span class="string">&quot;arguments&quot;</span> <span class="attr">output</span>=<span class="string">&quot;output_option&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;node&gt;</code>元素用于定义一个要启动的ROS节点。它包含以下属性：</p><ul><li><strong>pkg:</strong> 节点所在的包名。</li><li><strong>type</strong>: 节点的类型，即<strong>节点可执行文件</strong>的名称。</li><li><strong>name</strong>: 节点重映射的名称，相当于在系统中给节点所在源文件改了个名字；</li><li><strong>args</strong>: 可选属性，用于传递给节点的命令行参数。（对于spawn_model执行文件来说还有很多属性）<ul><li>-s：通常用于指定一个设置（setting），比如传递一个配置文件路径或者其他设置文件的参数。</li><li>-file：用于指定一个文件，可能是一个数据文件或者配置文件的路径。</li><li>-model：用于指定模型名</li><li>-param：用于指定一个ROS参数，这个参数将会传递给节点作为参数之一。</li></ul></li><li><strong>output</strong>: 可选属性，用于定义节点的输出选项，可以是”screen”（输出到屏幕），”log”（输出到日志文件），或”none”（无输出）。<br>其他重要的</li><li>respawn： 如果节点意外关闭是否重新启动。</li><li>Respawn_delay&#x3D;”delay_time”：表示节点延迟启动delay_time秒。</li><li>required&#x3D;true|false一般用在非常重要的节点（一旦这个节点停止运行则整个系统都会受影响）上。一旦这个节点进程结束（这个节点被杀死了），整个系统的所有节点都会停止运行</li><li>ns： &#x3D;namespace可以为每个待启动节点自定义一个<strong>命名空间</strong>，来避免使用时命名冲突的问题。</li><li>args： 可在启动节点时为每个节点添加参数，如在新建Ros工作空间时可以添加roscpp、rospy、tf等参数表示新建工作空间的依赖项。</li><li>machine： 可以设置运行该节点的PC的名称、address、ros-root和ros-package-path。</li><li>remap： 可以<strong>更改节点名称</strong>、话题名称等等，在节点中用到的ROS变量的名称。例如：。</li><li>include： 可以加载属于同一个功能包或不同的功能包的另一个launch,并将其作为一个launch文件来运行。</li><li>group： 用于分组正在运行的节点。</li><li>test： 用于测试节点。类似于，但是有可以用于测试的选项。</li></ul><h2 id="param元素"><a href="#param元素" class="headerlink" title="param元素"></a>param元素</h2><param name="parameter_name" value="parameter_value" /><param name="parameter_name" value="parameter_value" /><param name="parameter_name" value="parameter_value" /><param name="parameter_name" value="parameter_value" /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;parameter_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parameter_value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>用于在参数服务器中设置参数。它包含以下属性：- name: 参数的名称- value: 参数的值- 参数服务器是ROS中用于存储参数的一个全局数据库，节点可以在运行时从参数服务器获取参数的值。使用`<param>`元素可以在**节点启动前设定节点需要使用的参数**。## arg元素<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;argument_name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;default_value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>`<arg>`元素用于定义参数化的参数，可以在启动时传入不同的参数值。它包含以下属性：- name: 参数的名称。- default: 参数的默认值，可选属性。如果没有在启动命令中传入该参数，则会使用默认值。- 使用<`arg>`元素可以使启动配置更具灵活性，可以根据不同的场景传入不同的参数值。### 参数设置语法**上面的方式算一种****< rosparam >**`<rosparam file="$(find var_strc_uav)/config/params.yaml" command="load" ns=“params"/>`- 从参数文件params.yaml中加载所有参数，上传到Ros的参数服务器中，定义命名空间为params，其中：- file：参数文件名称- command：当前操作- ns：命名空间名称<p><strong>&lt; arg &gt;标签</strong><br>实现功能：<br>arg标签中的参数仅限于在launch文件之间进行参数传递，该语句表示在当前launch文件下定义一个名为“arg-name”的参数，其默认参数值为“arg-value”，其中：<br><code>&lt;arg name=&quot;arg-name&quot; default=&quot;arg-value&quot; /&gt;</code></p><ul><li>name：在当前launch文件中定义一个参数的参数名称</li><li>default：该参数的默认参数值<param name="foo" value="$(arg arg-name)" /></li></ul><p><strong>&lt; arg &gt;定义参数调用方法1</strong><br>实现功能：</p><ul><li>launc文件中找到名为arg-name的参数，取出参数值，将参数值赋值给名为foo的参数，其中：<br><code>&lt;param name=&quot;foo&quot; value=&quot;$(arg arg-name)&quot; /&gt;</code></li><li>name：取出参数值后赋值给参数的参数名</li><li>value&#x3D;”$(arg xxx)”：在launch文件内部找到名为 “xxx”的参数，取出参数值，注意不能漏掉 $和前面的arg前缀</li></ul><p><strong>&lt; arg &gt;定义参数调用方法2</strong><br><code>&lt;node name=&quot;node&quot; pkg=&quot;package&quot; type=&quot;type &quot; args=&quot;$(arg arg-name)&quot; /&gt;</code></p><ul><li>实现功能：在启动节点时，取出launch文件中的arg-name参数作为节点的输入参数参与节点运行。</li></ul><h3 id="例子讲解"><a href="#例子讲解" class="headerlink" title="例子讲解"></a>例子讲解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;verbose&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 使用&lt;include&gt;标签来引用另一个launch文件，即gazebo_ros软件包中的empty_world.launch文件。这个launch文件会启动Gazebo仿真，并加载一个空白的世界模型。在引用时，通过&lt;arg&gt;标签将参数传递给被引用的launch文件，也就是上面的参数，如果没有的话，就会按照之前的原定参数去实现，继承了empty_world.launch的大部分必要功能，其他参数只需设置为其默认值--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg world)&quot;</span>/&gt;</span><span class="comment">&lt;!-- 这里的world_name是empty_world.launch定义的，传入参数是这个文件定义的 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg debug)&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;verbose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg verbose)&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="group元素"><a href="#group元素" class="headerlink" title="group元素"></a>group元素</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Grouped nodes and other elements go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;group&gt;</code>元素用于将多个节点组织在一个组内，方便统一管理。</li><li>包含多个<code>&lt;node&gt;、&lt;param&gt;、&lt;arg&gt;</code>等其他元素。</li><li>使用<code>&lt;group&gt;</code>元素可以使启动配置更加结构化，将相关的节点组织在一起，提高配置的可读性和维护性。</li></ul><h2 id="include元素"><a href="#include元素" class="headerlink" title="include元素"></a>include元素</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;path_to_launch_file&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;include&gt;</code>元素允许将其他roslaunch文件包含在当前文件中，实现模块化配置。它包含一个file属性，用于指定要包含的roslaunch文件的路径。</li><li>通过使用<code>&lt;include&gt;</code>元素，将大型的启动配置拆分为多个小文件，使配置更加清晰和易于管理。</li><li>通过灵活地组合这些元素，构建出复杂的启动配置，</li></ul><h2 id="roslaunch中的高级配置选项"><a href="#roslaunch中的高级配置选项" class="headerlink" title="roslaunch中的高级配置选项"></a>roslaunch中的高级配置选项</h2><h3 id="使用remap标签进行话题重映射"><a href="#使用remap标签进行话题重映射" class="headerlink" title="使用remap标签进行话题重映射"></a>使用remap标签进行话题重映射</h3><p>在roslaunch中，<code>&lt;remap&gt;</code>标签允许您在启动文件中对话题进行<strong>重映射</strong>，从而解决节点之间的通信问题。通常在启动文件中，节点的话题名称已经预先定义，但在某些情况下，可能希望在启动时动态地更改节点之间的通信话题。这就是<code>&lt;remap&gt;</code>标签的作用。<strong>也就是重命名</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Node with original topic --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node1&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Node with remapped topic --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;original_topic&quot;</span> <span class="attr">to</span>=<span class="string">&quot;remapped_topic&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，启动了两个节点node1和node2，它们来自同一个包package_name并具有相同的类型node_type。通过<code>&lt;remap&gt;</code>标签，将node2中的话题original_topic重映射为remapped_topic。这样，在node2内部，它会接收来自original_topic的数据，但实际上与node1通信的话题是remapped_topic。</p></blockquote><p>使用&lt;<code>remap&gt;</code>标签可以方便地解决节点之间话题名称的冲突问题，从而实现灵活的通信。<br><strong>例子</strong></p><ul><li>作用：将Ros中某些计算图的资源进行重新命名，如：<br><code>&lt;remap from=&quot;/turtlebot/cmd_vel&quot; to=&quot;/cmd_vel&quot;/&gt;</code><br><strong>实现功能</strong><br>将Ros中的Topic：”&#x2F;turtlebot&#x2F;cmd_vel”进行映射，重命名为”&#x2F;cmd_vel”，其中：</li><li>from：原命名</li><li>to：映射之后的命名</li></ul><h3 id="引入参数并使用arg标签"><a href="#引入参数并使用arg标签" class="headerlink" title="引入参数并使用arg标签"></a>引入参数并使用arg标签</h3><p>在实际项目中，可能需要根据不同的运行环境或需求来调整节点的参数。为了使启动配置更加灵活，可以使用<code>&lt;arg&gt;</code>标签定义参数，并在roslaunch文件中引入和使用这些参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define an argument with default value --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;my_param&quot;</span> <span class="attr">default</span>=<span class="string">&quot;default_value&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- Start the node with the specified parameter value --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my_node&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg my_param)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>&lt;arg&gt;</code>标签定义了一个参数my_param，并给它设置了默认值default_value。在启动节点my_node时，使用<code>&lt;param&gt;</code>标签将参数param_name设置为(arg my_param)，这里的(arg my_param)表示使用之前定义的参数my_param的值。</li><li>使用&lt;<code>arg&gt;</code>标签，我们可以在启动时动态地传入参数值，从而灵活地配置节点。</li></ul><h3 id="条件启动节点：使用if和unless语句"><a href="#条件启动节点：使用if和unless语句" class="headerlink" title="条件启动节点：使用if和unless语句"></a>条件启动节点：使用if和unless语句</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Start node1 only if the condition is true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">condition</span> <span class="attr">value</span>=<span class="string">&quot;$(arg condition_variable)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- Start node2 only if the condition is false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">unless</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">condition</span> <span class="attr">value</span>=<span class="string">&quot;$(arg condition_variable)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;package_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;node_type&quot;</span> <span class="attr">name</span>=<span class="string">&quot;node2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">unless</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在上面的例子中，使用<code>&lt;if&gt;</code>和<code>&lt;unless&gt;</code>标签分别对node1和node2进行条件判断。<code>&lt;condition&gt;</code>标签用于定义条件判断的值，它的值来自之前定义的参数condition_variable。如果condition_variable的值为true，则node1会被启动；如果为false，则node2会被启动。</p></blockquote><ul><li>使用条件语句，可以根据不同的情况来启动不同的节点，使得启动配置更加灵活和智能。</li><li>为了更具体地说明roslaunch文件的高级配置选项和调试策略，假设有一个简单的ROS项目，其中包含两个节点，一个发布者节点（publisher_node）和一个订阅者节点（subscriber_node）。发布者节点发布一个名为&#x2F;chatter的话题，订阅者节点接收并显示收到的消息。</li><li>我们将创建一个roslaunch文件来启动这两个节点，并演示如何使用<code>&lt;remap&gt;</code>标签进行话题重映射，引入参数，以及使用调试选项和调试策略。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Define an argument for message rate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;message_rate&quot;</span> <span class="attr">default</span>=<span class="string">&quot;1.0&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- Start the publisher_node with a remapped topic and custom message rate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;my_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;publisher_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;chatter&quot;</span> <span class="attr">to</span>=<span class="string">&quot;custom_chatter_topic&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;message_rate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg message_rate)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- Start the subscriber_node --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;my_package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;subscriber_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscriber&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>说明：</li><li>我们在roslaunch文件中使用<code>&lt;arg&gt;</code>标签定义了一个参数message_rate，并设置了默认值为1.0。这个参数用于控制消息发布的频率。</li><li>在publisher_node节点中，我们使用<code>&lt;remap&gt;</code>标签将发布的话题<code>/chatter</code>重映射为<code>/custom_chatter_topic</code>。这样，在其他节点中订阅的话题名就是<code>/custom_chatter_topic</code>。</li><li>同时，使用<code>&lt;param&gt;</code>标签将参数message_rate设置为我们之前定义的message_rate参数的值，这样我们可以在启动时传入不同的频率。</li></ul><p><strong>参数设置</strong><br>![[Pasted image 20230822191024.png]]</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li>首先创建功能包：<code>catkin_create_pkg learning_launch</code>,接着在功能包创建launch文件夹</li><li>在launch文件夹中新建simple.launch并写入<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_subscriber&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>使用命令编译</li><li>启动文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch learning_launch simple.launch</span><br></pre></td></tr></table></figure></li></ol><p><strong>对于世界文件</strong></p><ul><li>对于px4的世界文件在<code>Tools/sitl_gazebo/worlds/</code>中</li><li>接着在launch文件中添加文件路径即可<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find mavlink_sitl_gazebo)/worlds/ego_simple.world&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这句先找到mavlink_sitl_gazebo功能包，然后在他的路径下找到ego_simple.world --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="sh脚本文件启动"><a href="#sh脚本文件启动" class="headerlink" title=".sh脚本文件启动"></a>.sh脚本文件启动</h1><p>这是在bash终端和terminate中实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash  #注释用#， 使用Bash解释器</span><br><span class="line"># 修改/dev/ttyACM0文件的权限为<span class="number">777</span>，即可读、可写、可执行权限。</span><br><span class="line">sudo chmod <span class="number">777</span> /dev/ttyACM0</span><br><span class="line">sudo chmod <span class="number">777</span> /dev/ttyUSB0</span><br><span class="line">sudo chmod <span class="number">777</span> /dev/ttyUSB1</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br><span class="line"># 在当前Shell中执行.bashrc文件，即加载.bashrc文件中定义的环境变量和别名配置。</span><br><span class="line"></span><br><span class="line"># 打开新的终端窗口，并在其中执行roscore命令，然后进入交互式Shell。</span><br><span class="line">gnome-terminal --window -e <span class="string">&#x27;bash -c &quot;roscore; exec bash&quot;&#x27;</span> \</span><br><span class="line"></span><br><span class="line"># 打开新的终端窗口，并在其中等待<span class="number">3</span>秒后执行roslaunch mavros px4.launch命令，然后进入交互式Shell。</span><br><span class="line">gnome-terminal --window -e <span class="string">&#x27;bash -c &quot;sleep 3; roslaunch mavros px4.launch; exec bash&quot;&#x27;</span> \</span><br><span class="line"></span><br><span class="line"># 在前一个终端窗口中新建一个选项卡，在该选项卡中等待<span class="number">3</span>秒后执行cd nooploop_ws &amp;&amp; source ./devel/setup.bash &amp;&amp;roslaunch serial serial.launch命令，然后进入交互式Shell</span><br><span class="line">--tab -e <span class="string">&#x27;bash -c &quot;sleep 3; cd nooploop_ws &amp;&amp; source ./devel/setup.bash &amp;&amp;roslaunch serial serial.launch; exec bash&quot;&#x27;</span> \</span><br><span class="line">--tab -e <span class="string">&#x27;bash -c &quot;sleep 5; source ~/CODE/PROJECT/plane_ws/devel/setup.bash &amp;&amp; roslaunch px4_realsense_bridge bridge.launch; exec bash&quot;&#x27;</span> \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gnome-terminal --window -e <span class="string">&#x27;bash -c &quot;sleep 5; rostopic echo /mavros/local_position/pose; exec bash&quot;&#x27;</span> \</span><br><span class="line"></span><br><span class="line"># 每个命令的执行顺序是按照脚本中的顺序依次执行的</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><ul><li>注释：用于给脚本添加注解，提高可读性。注释以<code>#开头</code>，可以是单行注释或多行注释。</li><li>变量：使用变量来存储和操作数据。变量名通常以字母或下划线开头，不能以数字开头。变量赋值使用等号(&#x3D;)进行，注意等号两边不能有空格。</li><li>命令执行：可以在.sh文件中执行各种命令，包括系统命令、自定义命令和其他脚本文件。</li><li>控制结构：可以使用条件判断和循环结构来控制脚本的执行流程。常见的控制结构有if-else、for、while等。</li><li>函数：可以定义和调用函数，将一系列指令封装成可重复使用的代码块。</li><li>输入输出：可以使用echo命令输出内容到终端，使用read命令接收用户输入。</li><li><strong>运行.sh文件</strong>：在终端中通过.&#x2F;filename.sh命令来运行.sh文件，**需要给.sh文件添加可执行权限(chmod +x filename.sh)**。</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><strong>1.新建.sh文件</strong></p><ul><li>这里新建的.sh文件名为：test.sh</li></ul><p><strong>2.输入内容</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># !/bin/zsh</span><br><span class="line">cd /test2</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><strong>3.赋予.sh文件执行权限</strong></p><ul><li>赋予.sh文件可执行权限，可以使用 <code>chmod 777 test.sh</code></li><li>这里是在bash文件中使用，但是我的是zsh终端，然后执行zsh test.sh即可<br><strong>4.运行</strong></li><li><code>./test.sh</code></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>这是在zsh终端和terminator使用</li><li>新建terminator终端才能用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># !/bin/zsh</span><br><span class="line"># 水平分割要在terminator终端执行才行，不要默认端口</span><br><span class="line"># 模拟按下Ctrl+Shift+E键盘快捷键</span><br><span class="line">xdotool key Ctrl+Shift+e</span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"># 等待一段时间以确保水平分割完成</span><br><span class="line">sleep <span class="number">1</span></span><br><span class="line"># 模拟按下Alt+Tab键盘快捷键以切换到新创建的终端窗格</span><br><span class="line">xdotool key Alt+Tab</span><br><span class="line">roslaunch px4 indoor_test1.launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#但是这个水平分割后不能在新的终端用，还是在原始终端执行命令，待解决</span><br><span class="line"># # 垂直分割</span><br><span class="line"><span class="meta"># xdotool key Ctrl+Shift+v</span></span><br></pre></td></tr></table></figure>实例2</li><li>这个用的zsh主题，用terminate和terminator终端都可以<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># !/bin/zsh</span><br><span class="line"># 对于直接用下个命令会卡住，所以要新建终端使用</span><br><span class="line"><span class="meta"># roslaunch px4 indoor1_test.launch</span></span><br><span class="line">gnome-terminal --window -e <span class="string">&#x27;zsh -c &quot;roslaunch px4 indoor1_test.launch; exec zsh&quot;&#x27;</span> \</span><br><span class="line">sleep <span class="number">2</span></span><br><span class="line"></span><br><span class="line"># # 打开新的终端窗口，并在其中执行ls命令，然后进入交互式Shell。</span><br><span class="line">gnome-terminal --window -e <span class="string">&#x27;zsh -c &quot;ls; exec zsh&quot;&#x27;</span> \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="ROS-INFO"><a href="#ROS-INFO" class="headerlink" title="ROS_INFO"></a>ROS_INFO</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ROS_INFO_STREAM</span>(“Hello ROS”),输出字符串</span><br><span class="line"><span class="built_in">ROS_INFO</span>(“%s”, msg.data.<span class="built_in">c_str</span>()),输出一个字符串变量,在变量名后面。<span class="built_in">c_str</span>()</span><br><span class="line"><span class="built_in">ROS_INFO</span>(“I heard: [%s]”, msg.data.<span class="built_in">c_str</span>()),输出一个字符串变量，这里的中括号不是必须的，输出时会直接显示这个中括号</span><br><span class="line"><span class="built_in">ROS_INFO</span>(“I heard: [%s]”, msg-&gt;data.<span class="built_in">c_str</span>()),输出一个指针变量</span><br><span class="line"><span class="built_in">ROS_INFO</span>(“Publish Person Info: name:%s age:%d sex:%d”,</span><br><span class="line">person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex)，按数据类型输出</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.c++模板</title>
      <link href="/data.github.io/post/c010a565.html"/>
      <url>/data.github.io/post/c010a565.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><ul><li>函数模板是通用的函数描述，使用任意类型（泛型）来描述函数。</li><li>编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。</li><li>生成函数定义的过程被称为实例化。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//T可以为其他别名，一般为T，函数前必须添加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span><span class="comment">//交换两个变量值的函数模板,T代表其他类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(a,b);</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="type">float</span> a1=<span class="number">9.230</span>,b1=<span class="number">8.23</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(a1,b1);</span><br><span class="line">    cout&lt;&lt;a1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>可以为类的成员函数创建模板，但不能是虚函数和析构函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">CGirl</span>(T a)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CGirl <span class="title">g</span><span class="params">(<span class="string">&quot;西施&quot;</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">show</span>(<span class="number">345</span>);</span><br><span class="line">    g.<span class="built_in">show</span>(<span class="string">&quot;sdjfh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用函数模板时，必须明确数据类型，确保实参与函数模板能匹配上——针对无参数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">()</span><span class="comment">//无参数时</span></span></span><br><span class="line"><span class="function"><span class="title">Swap</span><span class="params">()</span></span>;<span class="comment">//直接调用会报错</span></span><br><span class="line"><span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//这样无问题</span></span><br></pre></td></tr></table></figure></li><li>使用函数模板时，推导的数据类型必须适应函数模板中的代码。</li><li>使用函数模板时，如果是自动类型推导，不会发生隐式类型转换，如果显式指定了函数模板的数据类型，可以发生隐式类型转换。</li><li>函数模板支持多个通用数据类型的参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T1 b,T2 B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;b&lt;&lt;B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数模板的具体化"><a href="#函数模板的具体化" class="headerlink" title="函数模板的具体化"></a>函数模板的具体化</h2><ul><li>可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> 函数模板名&lt;数据类型&gt;(参数列表)</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="type">void</span> 函数模板名(参数列表)&#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_rank;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;swap&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(CGirl &amp;g1,CGirl &amp;g2)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> temp=g1.m_rank;</span><br><span class="line">g1.m_rank=g2.m_rank;</span><br><span class="line">g2.m_rank=temp;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用CGirl&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CGirl g1,g2;</span><br><span class="line">    g1.m_rank=<span class="number">1</span>;</span><br><span class="line">    g2.m_rank=<span class="number">2</span>;</span><br><span class="line">    g1.i=<span class="number">4</span>;</span><br><span class="line">    g2.i=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(g1,g2);<span class="comment">//这里使用了函数模板具体化</span></span><br><span class="line">    cout&lt;&lt;g1.m_rank&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;g2.m_rank&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>规则</strong></li><li>如果主函数调用的函数都能用，优先级：普通函数&gt;具体化&gt;常规模板</li><li>如果希望使用函数模板，可以用空模板参数强制使用函数模板。</li><li>如果函数模板能产生更好的匹配，将优先于普通函数。例如普通为传参为 int 型，到那时传参为字符时会优先模板而不是 int 型（字符可传参 int 型）</li></ul><h2 id="函数模板进阶"><a href="#函数模板进阶" class="headerlink" title="函数模板进阶"></a>函数模板进阶</h2><h3 id="decltype-关键字"><a href="#decltype-关键字" class="headerlink" title="decltype 关键字"></a>decltype 关键字</h3><ul><li>用于查询表达式的数据类型 ,不会执行表达式和函数</li><li>语法：<code>decltype(expression) var;</code></li><li><a href="https://blog.csdn.net/qq_38196982/article/details/118578967?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169080608216800197085132%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169080608216800197085132&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118578967-null-null.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&utm_term=decltype&spm=1018.2226.3001.4187">decltype用法详解</a></li></ul><p><strong>推导规则</strong></p><ul><li>如果 expression 是没有用括号括起来的标识符，则 var 的类型与该标识符的类型相同，包括 const 等限定符。</li><li>如果 expression 是函数调用，则 var 的类型与函数的返回值类型相同 (函数不能返回 void, 但可以返回 void*)</li><li>如果 expression 是左值（能取地址）、或者用括号括起来的标识符，那么 var 的类型是 expression 的引用。</li><li>如果上面的条件都不满足，则 var 的类型与 expressionl 的类型相同。</li></ul><p><strong>函数后置返回类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> y)</span></span>;<span class="comment">//等价于下面式子</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">double</span> y)</span> -&gt; <span class="type">int</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//有返回值形式写法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt; </span><br><span class="line"><span class="comment">//auto func(T1 x,T2 y)这么写也可以</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T1 x,T2 y)</span> -&gt;<span class="title">decltype</span><span class="params">(x+y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> tem=x+y;</span><br><span class="line">cout&lt;&lt;tem&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.2</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板分文件编写"><a href="#函数模板分文件编写" class="headerlink" title="函数模板分文件编写"></a>函数模板分文件编写</h3><ul><li>函数模板只是函数的描述，没有实体，<strong>创建函数模板的代码直接放在头文件中</strong>。</li><li><strong>函数模板的具体化</strong>有实体，编译的原理和普通函数一样，所以，<strong>声明放在头文件中，定义放在源文件中</strong>。</li><li><code>#pragma once</code> : <a href="https://blog.csdn.net/weixin_41055260/article/details/122994997">作用</a>，为了避免同一个头文件被包含 (include)多次</li></ul><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><ul><li>使用类模板时，指定具体的数据类型，让编译器生成该类型的类定义</li><li>使用类模板时，数据类型必须适应类模板中的代码。</li><li>类模板可以为通用数据类型指定缺省的数据类型</li><li>类的成员函数可以在类外实现。</li><li>可以用 new 创建模板对象。’<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>=string&gt;<span class="comment">//这样在主函数中创建时可以不写第二个参数</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_a;<span class="comment">//通用类用于成员变量</span></span><br><span class="line">T2 m_b;</span><br><span class="line"><span class="comment">//通用类型用于成员函数的参数</span></span><br><span class="line"><span class="built_in">AA</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">AA</span>(T1 a,T2 b):<span class="built_in">m_a</span>(a),<span class="built_in">m_b</span>(b)&#123;&#125;</span><br><span class="line"><span class="function">T1 <span class="title">geta</span><span class="params">()</span></span>&#123;          <span class="comment">//获取成员m_a的值</span></span><br><span class="line">T1 a=<span class="number">2</span>;         <span class="comment">//通用类型用于成员函数的代码中</span></span><br><span class="line"><span class="keyword">return</span> m_a+a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">AA&lt;<span class="type">int</span>,<span class="type">double</span>&gt; a;<span class="comment">//用模板类AA创建a</span></span><br><span class="line">a.m_a=<span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;a.<span class="built_in">geta</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template &lt;class T1,int len=19&gt;//这种定义式第二个参数可以不写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义函数</span></span><br><span class="line"><span class="comment">//template &lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="comment">//T2 AA&lt;T1,T2&gt;::geta()&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//AA&lt;int,string&gt; *a=new AA&lt;int,string&gt;(3,&quot;西施&quot;)//使用new创建</span></span><br></pre></td></tr></table></figure><h2 id="嵌套和递归使用模板类"><a href="#嵌套和递归使用模板类" class="headerlink" title="嵌套和递归使用模板类"></a>嵌套和递归使用模板类</h2><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130732817?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169080788416782425130693%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169080788416782425130693&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130732817-null-null.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&utm_term=%E5%B5%8C%E5%A5%97%E5%92%8C%E9%80%92%E5%BD%92%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB&spm=1018.2226.3001.4187">C++类模板嵌套使用</a><br>现在有 vector 类容器和 stack 容器模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Vector容器，容器元素用Stack,</span></span><br><span class="line">Vector&lt;Stack&lt;string&gt;&gt; vs;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//栈类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DataType</span>&gt;<span class="comment">//在类声明前加上模板的头部标签</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//3个成员变量</span></span><br><span class="line">DataType *items;<span class="comment">//栈数组，栈的元素用整数数组存放，动态分配一块数组空间</span></span><br><span class="line"><span class="type">int</span> stacksize;<span class="comment">//栈大小，栈的大小用成员变量表示</span></span><br><span class="line"><span class="type">int</span> top;<span class="comment">//栈顶指针，栈顶指针用整数表示，不是C++的指针</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//成员函数 </span></span><br><span class="line"><span class="comment">//构造函数：1）分配栈数组空间；2）把栈顶指针初始化为0</span></span><br><span class="line"><span class="built_in">Stack</span>(<span class="type">int</span> size=<span class="number">3</span>):<span class="built_in">stacksize</span>(size),<span class="built_in">top</span>(<span class="number">0</span>)<span class="comment">//需要一个参数（栈的大小），采用初始化列表对成员赋值</span></span><br><span class="line">&#123;</span><br><span class="line">items=<span class="keyword">new</span> DataType [stacksize];<span class="comment">//在构造函数中，给栈数组分配内存</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Stack</span>()<span class="comment">//析构函数，释放数组空间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []items;<span class="comment">//释放数组空间</span></span><br><span class="line">items=<span class="literal">NULL</span>;<span class="comment">//指针置为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isempty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">return</span> top==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isfull</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="comment">//判断栈是否为满</span></span><br><span class="line"><span class="keyword">return</span> top==stacksize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> DataType&amp; item)</span></span>&#123;<span class="comment">//元素入栈</span></span><br><span class="line"><span class="keyword">if</span>(top&lt;stacksize)<span class="comment">//如果还没有在栈顶</span></span><br><span class="line">&#123;</span><br><span class="line">items[top++]=item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(DataType&amp; item)</span></span>&#123;<span class="comment">//元素出栈</span></span><br><span class="line"><span class="keyword">if</span>(top&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">item=items[--top];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//数组容器类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> len;<span class="comment">//数组大小用成员变量表示</span></span><br><span class="line">T *items;<span class="comment">//数组元素用指针，动态分配</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">int</span> size=<span class="number">2</span>):<span class="built_in">len</span>(size)&#123;    <span class="comment">//构造函数，把数组大小传入，分配内存</span></span><br><span class="line">    items=<span class="keyword">new</span> T[len];</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Vector</span>()&#123;                        <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">delete</span>[]items;items=<span class="literal">NULL</span>;        <span class="comment">//释放数组空间，指针置为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;            <span class="comment">//扩展数组的内存空间</span></span><br><span class="line"><span class="keyword">if</span>(size&lt;=len)<span class="keyword">return</span>;            <span class="comment">//只能往更大的扩展</span></span><br><span class="line">T*tmp=<span class="keyword">new</span> T[size];                <span class="comment">//分配更大的目标数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;len;ii++)        <span class="comment">//将原来的数组赋给目标数组</span></span><br><span class="line">tmp[ii]=items[ii];</span><br><span class="line"><span class="keyword">delete</span>[]items;                <span class="comment">//释放原来的数组</span></span><br><span class="line">items=tmp;                    <span class="comment">//让数组指向新的目标数组</span></span><br><span class="line">len=size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span>&#123;                <span class="comment">//获取数组长度</span></span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> ii)&#123;            <span class="comment">//重载操作符[]，形参是数组下标，可以修改数组中的元素</span></span><br><span class="line">    <span class="keyword">if</span>(ii&gt;=len)<span class="built_in">resize</span>(ii+<span class="number">10</span>);            <span class="comment">//扩展数组空间</span></span><br><span class="line">    <span class="keyword">return</span> items[ii];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> ii)<span class="type">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[ii];    <span class="comment">//重载操作符[]，形参是数组下标，不可以修改数组中的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Vector大小为2，Stack大小为3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个对象Vector</span></span><br><span class="line">Vector&lt;Stack&lt;string&gt; &gt;v;<span class="comment">//C++11之前，&gt;&gt;要加空格</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//手工地往容器Vector插入数据</span></span><br><span class="line">v[<span class="number">0</span>].<span class="built_in">push</span>(<span class="string">&quot;西施1&quot;</span>);v[<span class="number">0</span>].<span class="built_in">push</span>(<span class="string">&quot;西施2&quot;</span>);v[<span class="number">0</span>].<span class="built_in">push</span>(<span class="string">&quot;西施3&quot;</span>);</span><br><span class="line">v[<span class="number">1</span>].<span class="built_in">push</span>(<span class="string">&quot;西1&quot;</span>);v[<span class="number">1</span>].<span class="built_in">push</span>(<span class="string">&quot;西2&quot;</span>);v[<span class="number">1</span>].<span class="built_in">push</span>(<span class="string">&quot;西3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用for循环嵌套，把v容器中的数据显示出来</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)<span class="comment">//遍历Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!v[i].<span class="built_in">isempty</span>())<span class="comment">//遍历Stack</span></span><br><span class="line">&#123;</span><br><span class="line">string item;</span><br><span class="line">v[i].<span class="built_in">pop</span>(item);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;item= &quot;</span>&lt;&lt;item&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板类具体化"><a href="#模板类具体化" class="headerlink" title="模板类具体化"></a>模板类具体化</h3><ul><li>分为完全具体化和部分具体化</li><li>优先级：具体化程度高的类优先于具体化程度低的类，具体化的类优先没有具体化的类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">T1 a;</span><br><span class="line">T2 b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//部分具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">T1 a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完全具体化</span></span><br><span class="line"><span class="keyword">template</span> &lt;string,<span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模板类与继承"><a href="#模板类与继承" class="headerlink" title="模板类与继承"></a>模板类与继承</h2><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130753545?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169080917716800222832776%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169080917716800222832776&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130753545-null-null.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&utm_term=%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF&spm=1018.2226.3001.4187">c++ 模板类继承</a></li><li>模板类继承普通类（常见）</li><li>普通类继承模板类的<strong>实例版本</strong></li><li>普通类继承模板类（常见）</li><li>模板类继承模板类</li><li>模板类继承模板参数给出的基类（不能是模板类）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//模板类继承普通类，常见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>:<span class="keyword">public</span> A&#123;&#125;;<span class="comment">//继承普通类</span></span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//普通类继承模板类的实例</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> BB&lt;<span class="type">int</span>,string&gt;;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//普通类继承模板类,常见</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> BB&lt;T1,T2&gt;;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//模板类继承模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>:<span class="keyword">public</span> BB&lt;T1,T2&gt;;</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment">//模板类继承模板参树给出的基类(不能是模板类)</span></span><br><span class="line"><span class="comment">//普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:<span class="keyword">public</span> T&#123;&#125;<span class="comment">//模板类继承模板参数给出的基类</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EE&lt;AA&gt; ea1;<span class="comment">//AA作为基类</span></span><br><span class="line">EE&lt;BB&gt; eb1;<span class="comment">//BB作为基类</span></span><br><span class="line">EE&lt;CC&gt; ec1;<span class="comment">//CC作为基类</span></span><br><span class="line">EE&lt;DD&lt;<span class="type">int</span>&gt;&gt; ed1; <span class="comment">//DD&lt;int&gt;作为基类,模板类作为基类时，必须明确指出模板类型参数</span></span><br><span class="line"><span class="comment">//EE&lt;DD&gt;ed1;   //DD作为基类，错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="模板类与函数"><a href="#模板类与函数" class="headerlink" title="模板类与函数"></a>模板类与函数</h2><p>模板类可以用于函数的参数和返回值</p><ol><li>普通函数，参数和返回值是模板类的实例化版本<ol><li>友元函数不是模板函数，而是利用模板类参数生成的函数，只能在类内实现。</li><li>该方法生成的友元函数只能用于该模板类，不能用于其他模板类</li></ol></li><li>函数模板，参数和返回值是某种的模板类</li><li>函数模板，参数和返回值是任意类型（支持普通类和模板类和其它类型）, 这种较为规范</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//采用普通函数，参数和返回值是模板类的实例化版本</span></span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>,string&gt; <span class="title">func</span><span class="params">(A&lt;<span class="type">int</span>,string&gt; a)</span></span>&#123; <span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板，参数和返回值是模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function">A&lt;T1,T2&gt; <span class="title">func</span><span class="params">(A&lt;T1,T2&gt; a)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板，参数和返回值是任意类型d</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T &amp;a)</span></span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模板类与有元"><a href="#模板类与有元" class="headerlink" title="模板类与有元"></a>模板类与有元</h2><p>有三种形式</p><ol><li>非模板友元：友元函数不是模板函数，而是利用模板类参数生成的函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">T1 a;</span><br><span class="line">T2 b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">a</span>(x),<span class="built_in">b</span>(y)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;T1,T2&gt; &amp;c)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;c.a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>,string&gt; <span class="title">p</span><span class="params">(<span class="number">32</span>,<span class="string">&quot;我的世界&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">show</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数 (常用)。<br> 步骤<ol><li>在模板类定义的前面，声明友元函数，为了让模板类知道友元函数模板的存在</li><li>在模板类中，再次声明友元函数模板，让编译器知道需要实例化的友元函数模板</li><li>友元函数模板的定义，具体化版本<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//约束模板友元：模板实例化时，每个实例化的类对应一个友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T&amp;a)</span></span>;<span class="comment">//第一步：在模板类定义的前面，声明友元函数，为了让模板类知道友元函数模板的存在</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span><span class="comment">//AA是类模板，是类的通用描述，改变不存在叫AA的类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;<span class="comment">//第二步：在模板类中，再次声明友元函数模板，让编译器知道需要实例化的友元函数模板</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(AA&lt;T1,T2&gt;&amp;a);<span class="comment">//这行代码让类模板和函数模板扯上关系</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span><span class="comment">//AA是类模板，是类的通用描述，改变不存在叫AA的类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;<span class="comment">//第二步：在模板类中，再次声明友元函数模板，让编译器知道需要实例化的友元函数模板</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(BB&lt;T1,T2&gt;&amp;a);<span class="comment">//这行代码让类模板和函数模板扯上关系</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BB</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//编译器在实例化某种数据类型的模板类时，也会实例化这种数据类型的模板函数</span></span><br><span class="line"><span class="comment">//通用版本友元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//第三步：友元函数模板的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T&amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;通用：x=&quot;</span>&lt;&lt;a.m_x&lt;&lt;<span class="string">&quot;，y=&quot;</span>&lt;&lt;a.m_y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为友元函数是函数模板，所以可以有具体化版本</span></span><br><span class="line"><span class="comment">//具体化版本友元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(AA&lt;<span class="type">int</span>,string&gt;&amp;a)</span><span class="comment">//第四步：具体化版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;具体：x=&quot;</span>&lt;&lt;a.m_x&lt;&lt;<span class="string">&quot;，y=&quot;</span>&lt;&lt;a.m_y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//是类名AA&lt;int,string&gt;</span></span><br><span class="line">AA&lt;<span class="type">int</span>,string&gt;<span class="built_in">aa</span>(<span class="number">88</span>,<span class="string">&quot;我是一只小猫咪&quot;</span>);</span><br><span class="line"><span class="built_in">show</span>(aa);<span class="comment">//使用具体化的版本</span></span><br><span class="line">BB&lt;<span class="type">char</span>,string&gt;<span class="built_in">bb</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;我是一只小猫咪&quot;</span>);</span><br><span class="line"><span class="built_in">show</span>(bb);<span class="comment">//使用通用的版本，友元函数适应多种函数模板</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>非约束模板友元：模板类实例化时，如果实例化了 n 个类，也会实例化个友元函数，每个实例化的类都拥有 n 个友元函数。</li></ol><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130785787?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E6%9C%89%E5%85%83&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-130785787.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&spm=1018.2226.3001.4187">模板类与友元</a></li></ul><h2 id="模板类成员模板"><a href="#模板类成员模板" class="headerlink" title="模板类成员模板"></a>模板类成员模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"><span class="built_in">AA</span>(<span class="type">const</span> T1 x,<span class="type">const</span> T2 y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;m_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;m_y&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line">T1 b;</span><br><span class="line"><span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;测试&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">B&lt;string&gt; m_b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//这里的T和上面的T无关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T tt)</span></span>&#123;</span><br><span class="line">m_b.<span class="built_in">show</span>();</span><br><span class="line">cout&lt;&lt;m_x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;m_y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">AA&lt;<span class="type">int</span>,string&gt; <span class="title">a</span><span class="params">(<span class="number">88</span>,<span class="string">&quot;我的世界&quot;</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">show</span>();</span><br><span class="line">a.<span class="built_in">show</span>(<span class="string">&quot;你是谁&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在外面的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板类AA中模板类B中show方法在外写法</span></span><br><span class="line"><span class="comment">//在B类中void show();</span></span><br><span class="line"><span class="comment">//在类外</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> AA&lt;T1,T2&gt;::B&lt;T&gt;::<span class="built_in">show</span>()&#123;cout&lt;&lt;<span class="string">&quot;测试&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">------------------------</span><br><span class="line"><span class="comment">//模板类AAshow方法在外写法</span></span><br><span class="line"><span class="comment">//在A类中void show(T tt);</span></span><br><span class="line"><span class="comment">//在类外</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> AA&lt;T1,T2&gt;::<span class="built_in">show</span>(T tt)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="模板类用作参数"><a href="#模板类用作参数" class="headerlink" title="模板类用作参数"></a>模板类用作参数</h2><ul><li><a href="https://blog.csdn.net/Crush_66/article/details/130787396?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%B0%86%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%94%A8%E4%BD%9C%E5%8F%82%E6%95%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-130787396.142%5Ev91%5Econtrol,239%5Ev12%5Econtrol2&spm=1018.2226.3001.4187">将类模板用于参数</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> len&gt;<span class="comment">//实际上链表没有链表长度的说法，假设他需要</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 *m_head;</span><br><span class="line"><span class="type">int</span> m_len=len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向链表中插入了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleted</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向链表中删除了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向链表中更新了一条记录。\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="type">int</span> len&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1*m_data;</span><br><span class="line"><span class="type">int</span> m_len=len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向数组中插入了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleted</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向数组中删除了一条记录。\n&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;向数组中更新了一条记录。\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//线性表模板类:tabletype(T1)线性表类型,datatype(T2)线性表的数据类型</span></span><br><span class="line"><span class="comment">//与普通的类模板是一样的,唯一的区别就是参数不一样,模板头部标签的模板参数不一样</span></span><br><span class="line"><span class="comment">//template&lt;class,int&gt;表示tabletype（class位置）不是一个普通的参数(不要填int等具体类型),而是一个类模板(填模板名),并且数据类型对的上</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>,<span class="type">int</span>&gt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="type">int</span> len&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//tabletype&lt;datatype,len&gt;m_table;//创建线性表对象</span></span><br><span class="line">T1&lt;T2,len&gt; m_table;<span class="comment">//创建线性表对象</span></span><br><span class="line"><span class="comment">//T1只是一个模板名,用T1创建对象的时候,要需要指定具体的数据类型</span></span><br><span class="line"><span class="comment">//T1的参数最常见的做法是,用LinearList类模板参数传递进来</span></span><br><span class="line"><span class="comment">//T1&lt;Array,10&gt;m_table;//创建线性表对象</span></span><br><span class="line"><span class="comment">//这么做也可以,但是没有体现类模板的价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;m_table.<span class="built_in">insert</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleted</span><span class="params">()</span></span>&#123;m_table.<span class="built_in">deleted</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;m_table.<span class="built_in">update</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oper</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;len=&quot;</span>&lt;&lt;m_table.m_len&lt;&lt;endl;</span><br><span class="line">m_table.<span class="built_in">insert</span>();</span><br><span class="line">m_table.<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建线性表对象,容器类型为链表,链表的数据类型为int,表长为20</span></span><br><span class="line">LinearList&lt;LinkList,<span class="type">int</span>,<span class="number">20</span>&gt;a;</span><br><span class="line">a.<span class="built_in">insert</span>();</span><br><span class="line">a.<span class="built_in">deleted</span>();</span><br><span class="line">a.<span class="built_in">update</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线性表对象,容器类型为链表,链表的数据类型为int,表长为20</span></span><br><span class="line">LinearList&lt;Array,string,<span class="number">20</span>&gt;b;</span><br><span class="line">b.<span class="built_in">insert</span>();</span><br><span class="line">b.<span class="built_in">deleted</span>();</span><br><span class="line">b.<span class="built_in">update</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><ul><li>命名空间分割了全局空间，每个命名空间是一个作用域，可防止命名冲突<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间名字&#123;&#125;<span class="comment">//常见命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> 别名=原名<span class="comment">//创建命名空间的别名</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> aa&#123;</span><br><span class="line"><span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> c=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> d=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">cout&lt;&lt;aa::b&lt;&lt;endl;</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">using</span> aa::c;<span class="comment">//这样aa命名空间中的c可以直接用</span></span><br><span class="line">cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> aa;<span class="comment">//这样aa命名空间的所有代码都能用，最好不这样用</span></span><br><span class="line">cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b=<span class="number">3</span>;<span class="comment">//这里的b将屏蔽aa中的b,将和方式2发生冲突,和方式1，3不冲突</span></span><br><span class="line">cout&lt;&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意</p><ul><li>命名空间是全局的，可以分布在多个文件中。</li><li>命名空间可以嵌套。</li><li>在命名空间中声明变量，而不是使用外部全局变量和静态全局变量。</li><li>对于 using 声明，首选将其作用域设置为局部而不是全局。</li><li>不要在头文件中使用 using 编译指令，如果非要使用，应将它放在所有的 <code>#include之后</code></li><li>匿名的命名空间，从创建的位置到文件结束有效。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.c++类2</title>
      <link href="/data.github.io/post/2bc4fa53.html"/>
      <url>/data.github.io/post/2bc4fa53.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h1><h2 id="有元"><a href="#有元" class="headerlink" title="有元"></a>有元</h2><ul><li>有元提供了另一类访问类的私有成员</li><li>关键字 friend</li></ul><p>三种</p><ul><li>有元全局函数：可访问另一个类的所有成员</li><li>有元类</li><li>有元成员函数</li></ul><p>注意</p><ul><li>有元关系不能继承</li><li>有元关系是单向的，不具备交换性</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>;<span class="comment">//把main函数(可以是其他函数)作为CGirl的有元函数，这样在mian函数中可以访问CGirl的所有成员</span></span><br><span class="line"><span class="comment">//friend class CBoy;//对类操作</span></span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_x</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;m_x:&quot;</span>&lt;&lt;m_x&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CGirl girl;</span><br><span class="line">  </span><br><span class="line">    girl.<span class="built_in">show_x</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul><li>在 C 语言中，运算符已经被重载 (表示乘法和解引用)</li><li>C++将运算符重载扩展到自定义的数据类型。<ul><li>字符串 string 用+拼接，cout 用&lt;&lt;表示输出</li></ul></li><li>语法：<code>返回值 operator符号(参数列表); void operator-(int a);</code> <ul><li>非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同</li><li>成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的操作数隐式调用了对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> <span class="keyword">operator</span>+(CGirl &amp;g,<span class="type">int</span> age);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> m_w;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name,<span class="type">int</span> age)<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    m_name=name;</span><br><span class="line">    m_age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员函数版本，利用this</span></span><br><span class="line">    CGirl &amp;<span class="keyword">operator</span>-(<span class="type">int</span> age)&#123;</span><br><span class="line">    m_age-=age;  </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄：&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//非成员函数版本</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+(CGirl &amp;g,<span class="type">int</span> age)&#123;  </span><br><span class="line">    g.m_age+=age;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CGirl <span class="title">g</span><span class="params">(<span class="string">&quot;xiao&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="comment">// operator+(g,30);</span></span><br><span class="line">    g+<span class="number">30</span>;<span class="comment">//等价上面的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// g=operator-(operator-(operator-(g,3),10),1);</span></span><br><span class="line">    g=g<span class="number">-3</span><span class="number">-10</span><span class="number">-1</span>;<span class="comment">//本质是函数的多次调用，等价下面的式子</span></span><br><span class="line">    g.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>注意</li></ul></li><li>返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）</li><li>重载函数参数列表中顺序决定了操作数的位置。</li><li>重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CGirl &amp;<span class="keyword">operator</span>-(CGirl &amp;g,<span class="type">int</span> age)&#123;  </span><br><span class="line">    g.m_age-=age;  </span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">CGirl &amp;<span class="keyword">operator</span>-(<span class="type">int</span> age,CGirl &amp;g)&#123;  </span><br><span class="line">    g.m_age-=age;  </span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g=<span class="number">3</span>-g<span class="number">-10</span><span class="number">-1</span>;<span class="comment">//这样可以有上面两个函数才能执行，只有第一个函数无法执行</span></span><br><span class="line"><span class="comment">//g=3-10-g-1;//相当于3-（10-（1-1））,要从g.m_age=1开始执行</span></span><br></pre></td></tr></table></figure></li><li>如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算</li><li>以下运算符不能重载：<code>sizeof , . , .* ,:: , ?:</code> 等</li></ul><h3 id="运算关系符重载"><a href="#运算关系符重载" class="headerlink" title="运算关系符重载"></a>运算关系符重载</h3><p>![[Pasted image 20230729214456.png]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> CGirl&amp;g)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_age&lt;g.m_age) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相等==,小于&lt;,大于&gt;等等</span></span><br></pre></td></tr></table></figure><h3 id="重载左移运算符"><a href="#重载左移运算符" class="headerlink" title="重载左移运算符"></a>重载左移运算符</h3><ul><li>只能使用非成员函数版本。</li><li>如果要输出对象的私有成员，可以配合友元一起使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非成员函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,<span class="type">const</span> CGirl &amp;g)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;姓名：&quot;</span>&lt;&lt;m_name;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;g&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;姓名：&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_name;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line">g&lt;&lt;cout&lt;&lt;endl;<span class="comment">//所以用成员函数好</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">返回类型 &amp;perator[](参数)；</span><br><span class="line"><span class="type">const</span>  返回类型 &amp;perator[](参数) <span class="type">const</span>；<span class="comment">//只能访问不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数，m_name是string型</span></span><br><span class="line">string&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i)&#123;</span><br><span class="line"><span class="keyword">return</span> m_name[i];</span><br><span class="line">&#125;</span><br><span class="line">CGirl g;</span><br><span class="line">cout&lt;&lt;g[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h3><ul><li>编译器提供的默认赋值函数是浅拷贝</li><li>对于有指针成员时，最好自己写赋值函数，深拷贝</li><li>赋值运算和拷贝构造不同：拷贝构造是指原来的对象不存在，用已存在的对象进行构造</li><li>赋值运算是指已经存在了两个对象，把其中一个对象的成员变量的值赋给另一个对象的成员变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CGirl g1,g2;</span><br><span class="line">g1=g2;<span class="comment">//这样g2的属性都赋值给g1,这是系统默认提供的，默认全部赋值</span></span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">类名 &amp;<span class="keyword">operator</span>=(<span class="type">const</span> 类名 &amp; 源对象)；</span><br><span class="line">CGirl &amp;<span class="keyword">operator</span>=(<span class="type">const</span> CGirl &amp;g)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;g) <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//如果给自己赋值</span></span><br><span class="line">    m_name=g.m_name;m_age=g.m_age;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="重载-new-delete"><a href="#重载-new-delete" class="headerlink" title="重载 new&amp;delete"></a>重载 new&amp;delete</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span><span class="comment">//参数必须是size_t,返回值必须是void *</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用了new&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="type">void</span>* ptr=<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ptr==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p1=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;*p1;</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载括号运算符"><a href="#重载括号运算符" class="headerlink" title="重载括号运算符"></a>重载括号运算符</h3><ul><li>返回值类型 operator (参数列表)；</li><li>括号运算符必须以成员函数的形式进行重载。</li><li>括号运算符重载函数具备普通函数全部的特征。</li><li>如果函数对象与全局函数同名，按作用域规则选择调用的函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;普通函数：&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;重载函数：&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CGirl girl;</span><br><span class="line">    <span class="built_in">girl</span>(<span class="string">&quot;我的&quot;</span>);</span><br><span class="line">    <span class="comment">//对于第4点</span></span><br><span class="line">    CGirl show;</span><br><span class="line">    ::<span class="built_in">show</span>(<span class="string">&quot;哈HA&quot;</span>);<span class="comment">//函数名重了，这样才能调用全局函数</span></span><br><span class="line">    <span class="built_in">show</span>(<span class="string">&quot;哈HA&quot;</span>);<span class="comment">//调用的重载函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载一元运算符"><a href="#重载一元运算符" class="headerlink" title="重载一元运算符"></a>重载一元运算符</h3><p>![[Pasted image 20230730170313.png]]</p><ul><li>这里对后置++需要有一定理解<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;重载函数：&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CGirl</span>()&#123;a=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">// void operator++()&#123;</span></span><br><span class="line"><span class="comment">// a++;</span></span><br><span class="line"><span class="comment">// &#125;//这是前置，只能实现++g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的形式针对++(++g),++g;</span></span><br><span class="line">CGirl &amp;<span class="keyword">operator</span>++()&#123;</span><br><span class="line">a++;<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//前置</span></span><br><span class="line">CGirl <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">a++;<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//这是后置</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CGirl g;</span><br><span class="line">    ++g;</span><br><span class="line">    g++;</span><br><span class="line">    cout&lt;&lt;g.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>自动类型转换没记录</li></ul><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><ul><li>构造函数只用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数——转换函数</li><li>语法：operator 数据类型 ();</li><li>注意：<strong>转换函数必须是类的成员函数：不能指定返回值类型；不能有参数。</strong></li><li>关键字 <a href="https://blog.csdn.net/qq_35524916/article/details/58178072">explicit</a> 不能用于转换函数，</li><li>谨慎使用隐式转换函数，最好选择仅被显式调用地调用时才会执行的成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">string b;</span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line"><span class="built_in">CGirl</span>()&#123;</span><br><span class="line">a=<span class="number">1</span>;b=<span class="string">&quot;haha&quot;</span>;c=<span class="number">43.34</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// operator double()&#123;</span></span><br><span class="line"><span class="comment">// return c;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CGirl g;</span><br><span class="line">    <span class="type">int</span> a=g;<span class="comment">//这是隐式表达，explicit要用于显示表达，会报错，就像下面字符串的表达式才能正确的表达；如果有double函数，则会执行double这个而不是int</span></span><br><span class="line">    <span class="comment">//int a=int(g);//显示表达式</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    string b=<span class="built_in">string</span>(g);</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>被继承的类称为基类或父类</li><li>继承的类称为派生类或子类，派生类除了拥有基类的成员，还可以定义新的成员<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAllComers</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line">string m_tel;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CAllComers</span>()&#123;m_name=<span class="string">&quot;女&quot;</span>;m_tel=<span class="string">&quot;不详&quot;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setname</span><span class="params">(<span class="type">const</span> string &amp;name)</span></span>&#123;m_name=name;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承形式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>:<span class="keyword">public</span> CAllComers</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_br;</span><br><span class="line"><span class="built_in">CGirl</span>()&#123;m_br=<span class="number">4</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;m_br&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CGirl g;</span><br><span class="line">g.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>使用继承的场景</strong></li><li>如果新创建的类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承。</li><li>当需要创建多个类时，如果它们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承。</li></ul><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><ul><li>类成员的访问权限由高到低依次为：public-&gt;protected-&gt;private, public 成员在类外可以访问，private 成员只能在类的成员函数中访问。</li><li>如果不考虑继承关系，protected 成员和 private 成员一样，类外不能访问。但是，当存在继承关系时，protected 和 private 就不一样了。</li><li>基类中的 protected 成员可以在派生类中访问，而基类中的Private 成员不能在派生类中访问。</li><li>继承方式有三种：public（公有的）、protected（受保护的）和 private（私有的）。它是可选的。</li></ul><p>关系图<br>![[Pasted image 20230726144942.png]]</p><ul><li>在派生类中，可以通过基类的公有成员函数间接访问基类的私有成员。</li><li>使用 using 关键字可以改变基类成员在派生类中的访问权限。<br>注意：using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> A::b;<span class="comment">//将b的权限改为共有</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">using</span> A::a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="继承的对象模型"><a href="#继承的对象模型" class="headerlink" title="继承的对象模型"></a>继承的对象模型</h2><ul><li>创建派生类对象时，先调用基类的构造函数，再调用派生类的构造函数。</li><li>销毁派生类对象时，先调用派生类的析构函数，再调用基类的析构函数。</li><li>创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this 指针相同</li><li>创建派生类对象时，先初始化基类对象，再初始化派生类对象。</li><li>可以通过指针方法来对类的私有成员进行访问</li></ul><h3 id="构造基类"><a href="#构造基类" class="headerlink" title="构造基类"></a>构造基类</h3><p>派生类构造函数的要点</p><ul><li>创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数</li><li>如果没以指定基类构造函数，将使用基类的默认构造函数</li><li>可以用初始化列表指明要使用的基类构造函数</li><li>基类构造函数负责初始化被继承的数据成员；派生类构造函数主要用于初始化新增的数据成员</li><li>派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用了基类的构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> p):<span class="built_in">a</span>(<span class="number">0</span>)&#123;</span><br><span class="line">b=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这样可以根据需求调用基类不同的构造函数</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="built_in">B</span>():<span class="built_in">c</span>(<span class="number">3</span>),<span class="built_in">A</span>()&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用了派生类的默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意写法</span></span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> p,<span class="type">int</span> j):<span class="built_in">c</span>(p),<span class="built_in">A</span>(j)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;调用了派生类的默认构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;b:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;,c:&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    b1.<span class="built_in">show</span>();</span><br><span class="line">    b2.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="名字遮蔽与类作用域"><a href="#名字遮蔽与类作用域" class="headerlink" title="名字遮蔽与类作用域"></a>名字遮蔽与类作用域</h3><p><strong>名字遮蔽</strong>：如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，<strong>将使用派生类新增的成员</strong>，而不是基类的。</p><ul><li>基类的成员函数和派生类的成员函数不会构成重载，如果<strong>派生类有同名函数，那么就会遮蔽基类中的所有同名函数</strong>。</li><li>但是可以利用下面的类作用域避免覆盖</li></ul><p><strong>作用域</strong></p><ul><li>类是一种作用域，每个类都有它自己的作用域，在这个作用域之内定义成员。</li><li>在类的作用域之外，普通的成员只能通过对象 (可以是对象本身，也可以是对象指针或对象引用)</li><li>在成员名前面加类名和域解析符可以访问对象的成员。</li><li>如果不存在继承关系，类名和域解析符可以省略不写。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//这样可以区分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">A::a=a;</span><br><span class="line">cout&lt;&lt;A::a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   A a1;</span><br><span class="line">   <span class="comment">// cout&lt;&lt;a1.a;//等价下面</span></span><br><span class="line">   cout&lt;&lt;a1.A::a&lt;&lt;endl;</span><br><span class="line">   a1.<span class="built_in">func</span>(<span class="number">65</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>![[Pasted image 20230731163409.png]]</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   B b1;</span><br><span class="line">   cout&lt;&lt;b1.B::a&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;b1.A::a&lt;&lt;endl;<span class="comment">//这样就避免了派生类覆盖基类相同的值</span></span><br><span class="line">   cout&lt;&lt;b1.B::A::a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承特殊关系"><a href="#继承特殊关系" class="headerlink" title="继承特殊关系"></a>继承特殊关系</h3><ul><li>如果继承方式是公有的，派生类对象可以使用基类成员。</li><li>可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。</li><li>基类指针可以在不进行显式转换的情况下指向派生类对象。</li><li>基类引用可以在不进行显式转换的情况下引用派生类对象。</li><li>基类指针或引用只能调用基类的方法，不能调用派生类的方法。可以用派生类构造基类。</li><li>如果函数的形参是基类，实参可以用派生类。</li></ul><h1 id="多继承与虚继承"><a href="#多继承与虚继承" class="headerlink" title="多继承与虚继承"></a>多继承与虚继承</h1><p><strong>多继承语法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:继承方式<span class="number">1</span> 基类名,继承方式<span class="number">2</span> 基类名<span class="number">2.</span>..</span><br><span class="line">&#123;派生类新增成员&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> c=<span class="number">6</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>菱形继承</strong></p><ul><li>用上述多继承方式，则下面 D 类中会存在两个 a 变量，存在数据冗余；可利用类作用域实现分别访问，利用虚继承解决<br>![[Pasted image 20230731170149.png]]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;;<span class="comment">//声明为虚函数，所以是同一个变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li>基类指针只能调用基类的成员函数，不能调用派生类的成员函数。</li><li>如果在基类的成员函数前加 virtual 关键字，把它声明为<strong>虚函数</strong>，基类指针就可以调用派生类的成员数，通过派生类的成员函数，还可以访问派生对象的成员变量。</li><li>有了<strong>虚函数，基类指针指向基类对象时就使用基类的成员函数，指向派生类对象时就使用派生类的成员函数</strong>，基类指针表现出了多种形式，这种现象称为多态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//去掉virtual则都输出A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a1;  a1.a=<span class="number">2</span>;</span><br><span class="line">B b1;  b1.b=<span class="number">4</span>;</span><br><span class="line">A *p;<span class="comment">//声明基类指针</span></span><br><span class="line">p=&amp;a1;p-&gt;<span class="built_in">show</span>();</span><br><span class="line">p=&amp;b1;p-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意</li><li>只需在基类的函数声明中加上 virtual 关键字，普通函数定义时不能加。</li><li>在派生类中重定义虚函数时，派生类中的函数名和参数一定要和基类中的虚函数相同</li><li>当在基类中定义了虚函数时，如果派生类没有重定义该函数，那么将使用基类的虚函数。</li><li>名字遮蔽和重载函数的规则也适用于虚函数。</li><li>在派生类中重定义了虚函数的情况下，如果想使用基类的函数，可以加类名和域解析符。</li><li>如果要在派生类中重新定义基类的函数，则将它设置为虚函数；否则，不要设置为虚函数</li><li>用虚函数的话，很多时候都是利用基函数指针来对派生类操作</li><li>虚函数不能对构造函数使用</li></ul><h2 id="析构派生类"><a href="#析构派生类" class="headerlink" title="析构派生类"></a>析构派生类</h2><ul><li>构造函数不能继承，创建派生类对象时，先执行基类构造函数，再执行派生类构造函数。</li><li>析构函数不能继承，而销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数。</li><li>派生类的析构函数在执行完后，会自动执行基类的析构函数。</li><li>如果手工的调用派生类的析构函数，也会自动调用基类的析构函数。</li></ul><p><strong>析构派生类的要点如下</strong>：</p><ul><li>析构派生类对象时，会自动调用基类的析构函数。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数</li><li>用基类指针指向派生类对象时，delete 基类指针调用的是基类的析构函数，不是派生类的，如果希望调用派生类的析构函数，就要把基类的析构函数设置为虚函数。</li><li><strong>赋值运算符函数不能继承</strong>，派生类继承的函数的特征标与基类完全相同，但赋值运算符函数的特征标随类而异，它包含了一个类型为其所属类的形参</li><li>友元函数不是类成员，不能继承。</li><li>析构函数可以手工调用，如果对象中有堆内存，析构函数中以下代码是必要的 <code>delete ptr;ptr=nullptr;</code></li></ul><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><ul><li>基类中不能对虚函数给出有意义的实现，把它声明为纯虚函数。</li><li>纯虚函数只有函数名、参数和返回值类型，没有函数体，具体实现留给该派生类去做</li><li>语法：<code>virtual 返回值类型 函数名（参数列表）=0;</code></li><li>纯虚函数在基类中为派生类保留一个函数的名字，以便派生类它进行重定义。如果在基类中没有保留函数名字，则无法支持多态性。</li><li>含有纯虚函数的类被称为抽象类，不能实例化对象，可以创建指针和引用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;基类构造A&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//&#123;cout&lt;&lt;&quot;调用&quot;;&#125;</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;调用基类析构函数\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;派生构造B&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;调用派生类&quot;</span>;&#125;</span><br><span class="line">~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;调用派生函数\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   B b1;</span><br><span class="line">   A *p=&amp;b1;</span><br><span class="line">   p-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dynamic_cast, typeid 运算符和 type_info 类</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.c++类_基础</title>
      <link href="/data.github.io/post/36e8e938.html"/>
      <url>/data.github.io/post/36e8e938.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/553387258">c++笔记来源</a></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="从结构体到类"><a href="#从结构体到类" class="headerlink" title="从结构体到类"></a>从结构体到类</h2><ul><li>对面向对象编程来说，一切都是对象，对象用类来描述</li><li>类把对象的数据和操作数据的方法作为一个整体考虑<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">成员一的数据类型  成员名一;</span><br><span class="line">成员二的数据类型  成员名二;</span><br><span class="line">成员三的数据类型  成员名三;</span><br><span class="line">......</span><br><span class="line">成员n的数据类型  成员名n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>类的成员可以是变量，也可以是函数。</li><li><strong>类的成员变量也叫属性</strong>。</li><li><strong>类的成员函数也叫方法</strong>&#x2F;行为，类的成员函数可以定义在类的外面。</li><li>用类定义一个类的变量叫创建（或实例化）一个对象。</li><li>对象的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGil</span>&#123;</span><br><span class="line">    string name;<span class="comment">//设置成员变量的值</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要声明，设置成员变量的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGil::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    name =name1;</span><br><span class="line">    age=age1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类.方法（）</span></span><br><span class="line"><span class="comment">//类.属性</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><ul><li>类的成员有三种访问权限：public、private 和 protected, 分别表示公有的、私有的和受保护的</li><li>在类的内部（类的成员函数中），无论成员被声明为 public 还是 private, 都可以访问</li><li>在类的外部（定义类的代码之外），只能访问 public 成员，不能访问 private、protected 成员</li><li>在一个类体的定义中，private 和 public 可以出现多次</li><li>结构体的成员缺省为 public，类的成员缺省为 private</li><li>private 的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为 public<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line"><span class="comment">//public可访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> speed=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        x += a * speed;</span><br><span class="line">        y += b * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x=<span class="number">5</span>;<span class="comment">//赋值</span></span><br><span class="line">    player.<span class="built_in">move</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//调用方法</span></span><br><span class="line">    cout&lt;&lt;player.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;player.y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="C-类与对象"><a href="#C-类与对象" class="headerlink" title="C++类与对象"></a>C++类与对象</h2><ul><li><a href="https://blog.csdn.net/u013921164/article/details/130929563?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=5">UML类图</a></li></ul><ol><li>类的成员函数可以直接访问该类其它的成员函数（可以递归）。</li><li>类的成员函数可以重载，可以使用默认参数。</li><li>类指针的用法与结构体指针用法相同。</li><li>类的成员可以是任意数据类型（类中枚举）。</li><li>可以为类的成员指定缺省值（C++11标准）。</li><li>类可以创建对象数组，就像结构体数组一样。</li><li>对象可以作为实参传递给函数，<strong>一般传引用</strong>。</li><li>可以用<strong>new动态创建对象，用delete释放对象</strong>。</li><li>在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。</li><li>对象一般不用memset()清空成员变量，可以写一个专用于清空成员变量的成员函数。</li><li>对类和对象用sizeof运算意义不大，一般不用。</li><li>用结构体描述纯粹的数据，用类描述对象。</li><li>在类的声明中定义的函数都将自动成为内联函数；在类的声明之外定义的函数如果使用了inline限定符，也是内联函数。</li><li>为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。</li><li>类的分文件编写。</li></ol><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul><li>构造函数：在创建对象时，自动进行初始化工作</li><li>析构函数：在销毁对象前，自动完成清理工作</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>语法：类名 (){…}</li><li>访问权限<strong>必须是 public</strong>.</li><li>函数名必须<strong>与类名相同</strong>。</li><li>没有返回值，也不写 void。</li><li>可以有参数，可以重载，可以有默认参数。</li><li>创建对象时会自动调用一次，不能手工调用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//创建构造函数，可以多个，但是需要有不同参数</span></span><br><span class="line">    <span class="comment">//CGirl() = default; 放在类的定义中的构造函数声明处，可以告诉编译器使用默认生成的方式来生成默认构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name,<span class="type">int</span> age=<span class="number">23</span>)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//CGirl();在这里使用这个函数，含义不是调用构造函数（无参数），是创建一个匿名对象，不能这么用</span></span><br><span class="line">        m_age=age;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数2个参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用析构函数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要生命，设置成员变量的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    CGirl girl;<span class="comment">//调用没有参数的构造函数,不用括号</span></span><br><span class="line">    <span class="comment">// const char* ch=&quot;23&quot;;//等价于string ch=&quot;23&quot;,不加const 传参会报错</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;,8);//调用有两个参数的构造函数</span></span><br><span class="line">    <span class="comment">// CGirl girl&#123;&quot;西施&quot;,8&#125;;//也可以这样写，用&#123;&#125;</span></span><br><span class="line">    <span class="comment">// CGirl girl;//隐式调用构造函数，无参数无括号，常用</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl();//显示调用构造函数，无参数有括号</span></span><br><span class="line">    girl.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// girl.~CGirl();//手动调用,一般自动就会调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGirl::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    m_name =name1;</span><br><span class="line">    m_age=age1;</span><br><span class="line">    <span class="built_in">show</span>();<span class="comment">//类内部调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul><li>语法：~类名 (){…}</li><li>访问权限必须是 public.</li><li>函数名必须在类名前加~。</li><li>没有返回值，也不写 void.</li><li>没有参数，不能重载。</li><li>销毁对象前只会自动调用一次，但是可以手工调用</li></ul><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul><li><p>如果没有提供构造&#x2F;析构函数，编译器将提供<strong>空实现</strong>的构造&#x2F;析构函数。</p></li><li><p>如果提供了构造&#x2F;析构函数，编译器将不提供空实现的构造&#x2F;析构函数。</p></li><li><p>创建对象的时候，如果重载了构造函数，编译器<strong>根据实参匹配</strong>相应的构造函数。</p></li><li><p>创建对象的时候<strong>不要在对象名后面加空的圆括号，编译器误认为是声明函数</strong>。(没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）</p></li><li><p>在构造函数名后面加括号和参数<strong>不是调用构造函数，是创建匿名对象</strong></p></li><li><p>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐 <code>CGirl girl=10</code></p></li><li><p>下面两行代码有本质区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGirl girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>)；<span class="comment">//显示创建对象,会调用一次构造函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CGirl girl;<span class="comment">//创建对象</span></span><br><span class="line">girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>);<span class="comment">//创建匿名对象，然后给现有对象赋值，会调用构造函数</span></span><br><span class="line"><span class="comment">//匿名对象是指在不给对象命名的情况下直接创建的对象。匿名对象通常用于临时的、一次性的操作，不需要对其进行命名和重复使用。</span></span><br></pre></td></tr></table></figure></li><li><p>用 new&#x2F;delete 创建&#x2F;销毁对象时，也会调用构造函数或者析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGirl *girl=<span class="keyword">new</span> <span class="built_in">CGirl</span>();<span class="comment">//显示写法用new,必须用指针形式</span></span><br><span class="line">girl-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">delete</span> girl;</span><br></pre></td></tr></table></figure></li><li><p>如果类成员有指针时，析构函数需要用这段代码 <code>delete ptr;ptr=nullptr;</code></p></li><li><p>如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构自身，再析构成员类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                                  <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                                     <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="type">char</span>      m_memo[<span class="number">301</span>];                        <span class="comment">// 备注。</span></span><br><span class="line">    <span class="built_in">CGirl</span>()                                        <span class="comment">// 没有参数的构造函数。  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl()构造函数。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name)                   <span class="comment">// 一个参数（姓名）的构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(name)构造函数。\n&quot;</span>;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">int</span> age)                           <span class="comment">// 一个参数（年龄）的构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(age)构造函数。\n&quot;</span>;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name, <span class="type">int</span> age)      <span class="comment">// 两个参数的构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(name,age)构造函数。\n&quot;</span>;</span><br><span class="line">        m_name = name; m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initdata</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>(); m_age = <span class="number">0</span>; <span class="built_in">memset</span>(m_memo, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>()                                     <span class="comment">// 析构函数。  </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了~CGirl()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span>                               <span class="comment">// 超女自我介绍的方法。</span></span></span><br><span class="line"><span class="function">    </span>&#123;  cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;，备注：&quot;</span> &lt;&lt; m_memo&lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CGirl girl;                     // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;);        // 创建超女对象，为成员姓名设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;,8);     // 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl();                   // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl(&quot;西施&quot;);        // 创建超女对象，为成员姓名设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl(&quot;西施&quot;,8);     // 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl =77;                         // 使用赋值语法初始化对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CGirl *girl=new CGirl;                   // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl *girl=new CGirl(&quot;西施&quot;);        // 创建超女对象，为成员姓名设置初始值。</span></span><br><span class="line">    CGirl *girl=<span class="keyword">new</span> <span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>);     <span class="comment">// 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    </span><br><span class="line">    girl-&gt;<span class="built_in">show</span>();    <span class="comment">// 显示超女的自我介绍。</span></span><br><span class="line">    <span class="keyword">delete</span> girl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li>用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。</li><li>如果类中没有定义拷贝构造函数，编译器<strong>将提供一个拷贝构造函数</strong>，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。</li></ul><p>用一个已存在的对象创建新的对象语法：</p><ul><li>类名  新对象名(已存在的对象名)；</li><li>类名  新对象名&#x3D;已存在的对象名；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//以无参数为例</span></span><br><span class="line">CGirl g1;</span><br><span class="line">g1.m_name=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line">g1.m_age=<span class="number">18</span>;</span><br><span class="line"><span class="comment">//写法1</span></span><br><span class="line"><span class="function">CGirl <span class="title">g2</span><span class="params">(g1)</span></span>;</span><br><span class="line">g2.<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line">CGirl g3=g1;</span><br><span class="line">g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>拷贝构造函数写法：</li></ul><ol><li>无参数： <code>类名（const 类名&amp; 对象名）&#123;&#125;</code>；</li><li>有参数： <code>类名（...，connst 类名&amp; 对象名，....）&#123;&#125;</code></li></ol><ul><li>访问权限必须 public</li><li>函数名必须与类名相同</li><li>以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。</li><li>函数以值的方式返回对象时，可能会调用拷贝构造函数（VS 会调用，Linux 不会）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                                  <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                                     <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="type">int</span>*       m_ptr;                                       <span class="comment">// 指针成员，计划使用堆内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有参数的普通构造函数。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_name.<span class="built_in">clear</span>(); m_age = <span class="number">0</span>;  m_ptr = <span class="literal">nullptr</span>;  cout &lt;&lt; <span class="string">&quot;调用了CGirl()构造函数。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有重载的拷贝构造函数（默认拷贝构造函数）。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg) </span><br><span class="line">    &#123; </span><br><span class="line">        m_name = gg.m_name; m_age = gg.m_age;  </span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="type">int</span>;         <span class="comment">// 分配内存。</span></span><br><span class="line">        <span class="comment">// *m_ptr = *gg.m_ptr;   // 拷贝数据。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_ptr, gg.m_ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 拷贝数据。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(const CGirl &amp;gg)拷贝构造函数。\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数。  </span></span><br><span class="line">    ~<span class="built_in">CGirl</span>() &#123; <span class="keyword">delete</span> m_ptr; m_ptr = <span class="literal">nullptr</span>; cout &lt;&lt; <span class="string">&quot;调用了~CGirl()\n&quot;</span>;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名和年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;，m_ptr=&quot;</span>&lt;&lt; m_ptr&lt;&lt;<span class="string">&quot;，*m_ptr=&quot;</span>&lt;&lt;*m_ptr&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGirl g1;</span><br><span class="line">    g1.m_name = <span class="string">&quot;西施&quot;</span>; g1.m_age = <span class="number">23</span>; g1.m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g2</span><span class="params">(g1)</span></span>;  *g2.m_ptr = <span class="number">8</span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">    g2.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p><a href="https://blog.csdn.net/qq_42174306/article/details/122882267?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169017884016800186546005%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169017884016800186546005&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-122882267-null-null.142%5Ev90%5Econtrol,239%5Ev3%5Econtrol&utm_term=%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9Dc++&spm=1018.2226.3001.4187">C++浅拷贝与深拷贝</a></p><ol><li>浅拷贝： 将原对象或原数组的引用直接赋给新对象，<strong>浅拷贝只复制指向某个对象的指针</strong>，而不复制对象本身，新旧对象还是共享同一块内存</li><li>对于浅拷贝，对象的地址是不同的。浅拷贝只是复制成员变量的值，而不是创建新的对象</li><li>深拷贝： <strong>创建</strong>一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”，新对象与原对象不共享内存，修改新对象不会改到元对象</li><li><strong>浅拷贝和深拷贝是对类对象和指针的</strong>，如果仅修改其中的一个int变量是不变的</li><li>编译器提供的拷贝函数是浅拷贝，所以，在<strong>对含有指针成员的对象进行拷贝</strong>时，必须自己定义<strong>拷贝构造函数</strong>，达到深拷贝的目的，才能必变内存重复释放<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value) : <span class="built_in">m_name</span>(name) &#123;</span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg) : <span class="built_in">m_name</span>(gg.m_name), <span class="built_in">m_ptr</span>(gg.m_ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用浅拷贝构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg, <span class="type">bool</span> deepCopy) : <span class="built_in">m_name</span>(<span class="string">&quot;漂亮的&quot;</span> + gg.m_name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deepCopy) &#123;</span><br><span class="line">            m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*(gg.m_ptr));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_ptr = gg.m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用深拷贝构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CGirl</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象 g1</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;小红&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝对象 g2</span></span><br><span class="line">    CGirl g2 = g1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝对象 g3</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g3</span><span class="params">(g1, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 g1、g2 和 g3 的指针成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;g1.m_ptr: &quot;</span> &lt;&lt; g1.m_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;g2.m_ptr: &quot;</span> &lt;&lt; g2.m_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;g3.m_ptr: &quot;</span> &lt;&lt; g3.m_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">// 调用浅拷贝构造函数</span></span><br><span class="line"><span class="comment">// 调用深拷贝构造函数</span></span><br><span class="line"><span class="comment">// &amp;g1.m_ptr: 0x1e1630</span></span><br><span class="line"><span class="comment">// &amp;g2.m_ptr: 0x1e1630</span></span><br><span class="line"><span class="comment">// &amp;g3.m_ptr: 0x1e1650</span></span><br><span class="line"><span class="comment">// 从输出结果中可以看出，浅拷贝的对象g2和原对象g1共享同一块内存，因此它们的指针成员变量的地址是相同的。</span></span><br><span class="line"><span class="comment">//而深拷贝的对象g3则创建了一个新的对象，并复制了原对象g1的指针成员变量所指向的对象的副本，因此它们的指针成员变量的地址是不同的</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><ul><li>构造函数的执行可以分成两个阶段：初始化阶段和计算阶段。初始化阶段先于计算阶段。</li><li>初始化阶段：全部的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。</li><li>计算阶段：一般是指用于执行构造函数体内的赋值操作。</li><li>构造函数除了参数列表和函数体外，还可以由初始化列表<br>初始化列表的语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类名(形参列表):成员<span class="number">1</span>（值<span class="number">1</span>）,...,成员<span class="built_in">n</span>(值n)&#123;...&#125;</span><br><span class="line"><span class="comment">//对无参数构造函数调用</span></span><br><span class="line"><span class="built_in">CGirl</span>():<span class="built_in">m_name</span>(<span class="string">&quot;西施&quot;</span>),<span class="built_in">m_age</span>(<span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGirl</span>(string name,<span class="type">int</span> age):<span class="built_in">m_name</span>(<span class="string">&quot;漂亮的&quot;</span>+name),<span class="built_in">m_age</span>(age)&#123;&#125;<span class="comment">//对于有参数的构造函数</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。</li><li>初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。</li><li>初始化列表与赋值有本质的区别，如果成员是类，使用<strong>初始化列表调用的是拷贝构造函数</strong>，而赋值则是先创建对象（调用普通构造函数），然后再赋值。</li><li>如果成员是类，初始化列表效率更高。</li><li>如果成员是<strong>常量和引用</strong>，必须使用初始列表，因为常量和引用只能在定义的时候初始化。 </li><li>如果成员是没有默认构造函数的类，则必须使用初始列表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span>                <span class="comment">// 男朋友类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_xm;                      <span class="comment">// 男朋友的姓名。</span></span><br><span class="line">    <span class="built_in">CBoy</span>()                                 <span class="comment">// 没有参数的普通构造函数，默认构造函数。  </span></span><br><span class="line">    &#123; m_xm.<span class="built_in">clear</span>();  cout &lt;&lt; <span class="string">&quot;调用了CBoy()构造函数。\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">CBoy</span>(string xm)                 <span class="comment">// 有一个参数的普通构造函数。  </span></span><br><span class="line">    &#123; m_xm = xm;  cout &lt;&lt; <span class="string">&quot;调用了CBoy(string xm)构造函数。\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">CBoy</span>(<span class="type">const</span> CBoy&amp; bb)     <span class="comment">// 默认拷贝构造函数。  </span></span><br><span class="line">    &#123; m_xm = bb.m_xm;  cout &lt;&lt; <span class="string">&quot;调用了CBoy(const CBoy &amp;bb)拷贝构造函数。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                     <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>         m_age;                         <span class="comment">// 年龄属性。</span></span><br><span class="line">    CBoy&amp;     m_boy;                         <span class="comment">// 男朋友的信息。</span></span><br><span class="line">    <span class="comment">//CGirl()                                       // 没有参数的普通构造函数，默认构造函数。  </span></span><br><span class="line">    <span class="comment">//&#123;  </span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;调用了CGirl()构造函数。\n&quot;; </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//CGirl(string name, int age,CBoy &amp;boy)     // 三个参数的普通构造函数。</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    m_name = name; m_age = age; m_boy.m_xm = boy.m_xm;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;调用了CGirl(name,age,boy)构造函数。\n&quot;;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">CGirl</span>(string name, <span class="type">int</span> age, CBoy&amp; boy) :<span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age),<span class="built_in">m_boy</span>(boy)      <span class="comment">// 三个参数的普通构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(name,age,boy)构造函数。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名、年龄、男朋友。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;，男朋友：&quot;</span> &lt;&lt; m_boy.m_xm &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CBoy <span class="title">boy</span><span class="params">(<span class="string">&quot;子都&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;冰冰&quot;</span>,<span class="number">18</span>,boy)</span></span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="类嵌套类定义"><a href="#类嵌套类定义" class="headerlink" title="类嵌套类定义"></a>类嵌套类定义</h3><ul><li>对于类中有初始化信息的定义，类的类成员要在类的构造函数中定义</li><li>如果是分文件编写程序，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PID</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> Kp;   <span class="comment">// 比例系数</span></span><br><span class="line">    <span class="type">double</span> Ki;   <span class="comment">// 积分系数</span></span><br><span class="line">    <span class="type">double</span> Kd;   <span class="comment">// 微分系数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PID</span>(<span class="type">double</span> kp, <span class="type">double</span> ki, <span class="type">double</span> kd) : <span class="built_in">Kp</span>(kp), <span class="built_in">Ki</span>(ki), <span class="built_in">Kd</span>(kd) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;测试&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PID a;  <span class="comment">// 成员变量a的声明</span></span><br><span class="line">    <span class="comment">// PID a(1,1,1);//错误写法，类成员变量的初始化必须在构造函数的成员初始化列表中完成。</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dfjgk&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    std::cout&lt;&lt; a.a.Kd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="分文件编写"><a href="#分文件编写" class="headerlink" title="分文件编写"></a>分文件编写</h4><p>Uav_info.h 文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UAV_INFO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UAV_INFO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PID.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uav_info</span> &#123;</span><br><span class="line">    PID base_pose; <span class="comment">// 成员对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Uav_info</span>(); <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UAV_INFO_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Uav_info.cpp </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uav_info.h&quot;</span></span></span><br><span class="line"><span class="comment">//PID构造函数：PID(double a,double b,double c)&#123;&#125;</span></span><br><span class="line">Uav_info::<span class="built_in">Uav_info</span>() : <span class="built_in">base_pose</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 成员变量 base_pose 的初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Uav_info::someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用成员对象 base_pose</span></span><br><span class="line">    <span class="type">double</span> controlSignal = base_pose.<span class="built_in">update</span>(currentPosition);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><ul><li>在类的成员函数后面加 const 关键字，表示在成员函数中保证不会修改调用对象的成员变量。</li><li>类中调用一般用解引用去传参<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> CGirl &amp;<span class="title function_">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span> <span class="type">const</span></span><br></pre></td></tr></table></figure></li><li>其中，第一个<code>const</code>表示返回值是一个常引用类型，第二个<code>const</code>表示该函数是一个成员常函数，而第三个<code>const</code>则表示该成员函数不会修改任何成员变量的值。<br><strong>注意：</strong></li><li>mutable 可以突破 const 的限制，被 mutable 修饰的成员变量，将永远处于可变的状态，在 const 修饰的函数中，mutable 成员也可以被修改。</li><li>非const对象可以调用const修饰的成员函数和非const修饰的成员函数。</li><li>const对象只能调用const修饰的成员函数，不能调用非cosnt修饰的成员函数</li></ul><blockquote><p>保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，<strong>通过用const关键字来避免在函数中错误的修改了类对象的状态</strong>。并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。而mutable则是为了能突破const的封锁线，<strong>让类的一些次要的或者是辅助性的成员变量随时可以被更改</strong>。没有使用const和mutable关键字当然没有错，const和mutable 关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对成员函数的const</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//m_name=&quot;woo&quot;;//修改m_name,有const会报错</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="const类型"><a href="#const类型" class="headerlink" title="const类型"></a>const类型</h4><ul><li><strong>修饰变量</strong><ul><li>const int NUM &#x3D; 10; &#x2F;&#x2F; 常量变量</li><li>const float PI &#x3D; 3.14f; &#x2F;&#x2F; 常量变量</li><li>const MyClass obj; &#x2F;&#x2F; 常量对象</li><li>const int* ptr; &#x2F;&#x2F; 指向常量的指针</li><li>int* const ptr; &#x2F;&#x2F; 常指针</li></ul></li><li><strong>修饰成员函数：</strong><ul><li>void func() const; &#x2F;&#x2F; const成员函数，不会修改类的成员变量</li></ul></li><li><strong>修饰函数参数：</strong><ul><li>void foo(const int param); &#x2F;&#x2F; 参数是常量</li><li>void bar(const MyClass&amp; obj); &#x2F;&#x2F; 参数是常量引用</li></ul></li><li><strong>修饰返回值：</strong><ul><li>const int func(); &#x2F;&#x2F; 返回常量值</li><li>const MyClass&amp; getObject(); &#x2F;&#x2F; 返回常量引用</li></ul></li><li><strong>修饰指针：</strong><ul><li>int* const ptr; &#x2F;&#x2F; 常指针，指针本身是常量</li><li>const int* ptr; &#x2F;&#x2F; 指向常量的指针，指针所指的值是常量</li><li>const int* const ptr; &#x2F;&#x2F; 常指针，指向常量的指针</li></ul></li><li><strong>修饰成员变量：</strong><ul><li>class MyClass { const int m_value; &#x2F;&#x2F; 常量成员变量 static const int s_value; &#x2F;&#x2F; 静态常量成员变量 };</li></ul></li></ul><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ul><li><p>如果类的成员函数中涉及多个对象，在这种情况下需要使用 this 指针。</p></li><li><p>this 指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。</p></li><li><p>每个成员函数（包括构造函数和析构函数）都有一个 this 指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）</p></li><li><p><code>*this</code> 可以表示整个对象。</p></li><li><p>如果在成员函数的括号后面使用 const, 那么将<strong>不能通过 this 指针</strong>修改成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规写法对比对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;gg1,<span class="type">const</span> CGirl &amp;gg2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(gg1.m_age&lt;gg2.m_age) <span class="keyword">return</span> gg2;</span><br><span class="line"><span class="keyword">return</span> gg1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=<span class="built_in">pk</span>(g1,g2);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类中定义</span></span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g.m_age&gt;m_age) <span class="keyword">return</span> g;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=g2.<span class="built_in">pk</span>(g1);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//对比5个</span></span><br><span class="line">    <span class="comment">// CGirl g1(&quot;西施&quot;,8),g2(&quot;西瓜1&quot;,9),g3(&quot;西瓜2&quot;,10),g4(&quot;西瓜3&quot;,11),g5(&quot;西瓜4&quot;,12);</span></span><br><span class="line">    <span class="comment">// const CGirl &amp;g=g1.pk(g2).pk(g3).pk(g4).pk(g5);</span></span><br><span class="line">    <span class="comment">// g.show();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类中存在<strong>成员变量和局部变量同名</strong>时，可以使用this关键字来访问成员变量。例如：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myVariable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVariable</span><span class="params">(<span class="type">int</span> myVariable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;myVariable = myVariable; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;myVariable: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;myVariable &lt;&lt; std::endl; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setVariable</span>(<span class="number">10</span>);</span><br><span class="line">    obj.<span class="built_in">printVariable</span>(); <span class="comment">// 输出: myVariable: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，setVariable函数中的形参myVariable和类的成员变量myVariable同名。为了区分它们，使用this-&gt;myVariable来访问成员变量。</p><ul><li>另外，也可以使用this指针来调用其他成员函数。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">function1</span>(); <span class="comment">// 使用this指针调用其他成员函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">function2</span>(); <span class="comment">// 输出: This is function1</span></span><br><span class="line">                     <span class="comment">//       This is function2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在上面的例子中，function2通过使用this-&gt;function1()调用了function1成员函数。</li></ul><h3 id="类的静态成员变量"><a href="#类的静态成员变量" class="headerlink" title="类的静态成员变量"></a>类的静态成员变量</h3><ul><li>类的静态成员包括静态成员变量和静态成员函数</li><li>用静态成员可以变量<strong>实现多个对象之间的数据共享</strong>，比全局变量更安全性</li><li>用 static 关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的</li><li>静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解运算符）</li><li>静态成员使用类名加范围解析运算符：就可以访问，不需要创建类对象</li><li><strong>如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）</strong></li><li>静态成员变量在程序中只有一份 (生命周期与程序运行期相同，存放在静态存储区的)，不论是否创建了类的对象，也不论创建了多少个类的对象</li><li>静态成员函数<strong>只能访问静态成员</strong>，不能访问非静态成员</li><li>静态成员函数中没有 this 指针</li><li>非静态成员函数可以访问静态成员</li><li>私有静态变量在类外无法访问</li></ul><p><strong>优势</strong></p><ol><li><strong>无需创建对象</strong>：static 成员函数可以直接通过类名调用，无需创建类的对象。这意味着我们可以在不创建对象的情况下使用该函数，方便快捷。</li><li><strong>访问静态成员</strong>：static 成员函数可以访问类的静态成员变量和静态成员函数。这是因为静态成员属于类本身，而不是类的实例化对象。通过静态成员函数，我们可以直接操作和访问这些静态成员，而不需要对象的实例。</li><li><strong>代码复用</strong>：<strong>static 成员函数可以在不创建对象的情况下重复使用</strong>。这使得我们可以将一些通用的功能封装在静态成员函数中，并在需要时直接调用，而无需重复编写相同的代码：<strong>见示例2</strong></li><li>避免访问实例相关数据：由于 static 成员函数不依赖于类的实例，它无法直接访问非静态成员变量和非静态成员函数。这可以防止对实例相关数据的误操作或错误访问。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_age;<span class="comment">//设置静态变量</span></span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;构造函数无参数&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> string name,<span class="type">int</span> age)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    m_name=name;</span><br><span class="line">    m_age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="comment">//静态函数,只能用静态变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CGirl::m_age=<span class="number">34</span>;<span class="comment">//初始化类的静态成员变量,没有或者在其他位置不行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CGirl::<span class="built_in">show</span>();<span class="comment">//静态函数</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;CGirl::m_age:&quot;</span>&lt;&lt;CGirl::m_age&lt;&lt;endl;<span class="comment">//可以在创建对象那个前访问</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>示例2</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">incrementCount</span><span class="params">()</span> </span>&#123;  <span class="comment">// 静态成员函数</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;  <span class="comment">// 静态成员函数</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">incrementCount</span>();  <span class="comment">// 调用静态成员函数</span></span><br><span class="line">    MyClass::<span class="built_in">incrementCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = MyClass::<span class="built_in">getCount</span>();  <span class="comment">// 调用静态成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="PX4-C-代码形式理解"><a href="#PX4-C-代码形式理解" class="headerlink" title="PX4_C++代码形式理解"></a>PX4_C++代码形式理解</h1><h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h3><p><a href="https://blog.csdn.net/qq_43533553/article/details/123257675?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168906554316800227449672%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168906554316800227449672&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-123257675-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E4%B8%ADnamespace%E7%9A%84%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187">C++命名空间namespace</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一定义</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间名字</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> model1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//当前变量i只对命名空间model1可见，它的作用域被限定在model1</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">namespace</span> 命名空间<span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2定义</span></span><br><span class="line"><span class="keyword">using</span> model1::i;</span><br><span class="line">i= <span class="number">0</span>;  <span class="comment">//使用model1定义的变量i</span></span><br><span class="line">model2::i= <span class="number">10</span>;  <span class="comment">//使用model2定义的变量i</span></span><br></pre></td></tr></table></figure><p>由于使用命名空间后，变量的<a href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>被限定，所以在使用变量时，就需要通过特定方式来完成。需要用到“::”操作符，“::”操作符是域解析操作符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model1::i = <span class="number">1</span>;</span><br><span class="line">model2::i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>命名空间成员使用方法总结</strong></p><blockquote><p>方法一 ：命名空间名:: 成员比如：spaceA:: a;<br>使用 using 可以使得命名空间中的成员暴露外部，以致可以使用该成员<br>方法二： using 命名空间名:: 成员 —-&gt; 把指定的成员暴露给外部<br>比如：using spaceA:: a;<br>方法三： using namespace 命名空间名 —&gt; 将其所有成员暴露给外部<br>比如： using namespace spaceA;</p></blockquote><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@brief  ：简介，简单介绍函数作用  </span><br><span class="line">@param  ：介绍函数参数  </span><br><span class="line">@<span class="keyword">return</span>：函数返回类型说明  </span><br><span class="line">@exception NSException 可能抛出的异常.  </span><br><span class="line">@author zhangsan：  作者  </span><br><span class="line">@date <span class="number">2011</span><span class="number">-07</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">30</span>:<span class="number">00</span> ：时间  </span><br><span class="line">@version <span class="number">1.0</span> ：版本    </span><br><span class="line">@property ：属性介绍</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过多行注释实现，如下</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param _name         The name of the topic.</span></span><br><span class="line"><span class="comment"> * @param _struct       The structure the topic provides.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>[[1、数据类型#宏定义|宏定义]]<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">orb_advert_t</span> <span class="title">orb_advertise</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> orb_metadata *meta, <span class="type">const</span> <span class="type">void</span> *data)</span> __EXPORT</span>;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li><code>extern</code>: 这是一个 C&#x2F;C++关键字，<strong>用于表明被声明的函数不在当前文件中，而在其他的源文件中实现</strong>。这样的话，其他的源文件就可以调用到这个函数   </li><li><code>orb_advert_t</code>: 这是返回值类型。<code>orb_advert_t</code>应该是定义在别的地方的一个类型，可能是一个结构体、枚举等。<ol start="3"><li><code>orb_advertise</code>: 这是函数名。</li><li><code>__EXPORT</code>: 这个通常是一个平台相关的宏，用于标记函数或变量，使其在链接时可被其他模块看见，就是说这个函数可以被其他的文件或模块调用</li></ol></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.c++类</title>
      <link href="/data.github.io/post/f145b64d.html"/>
      <url>/data.github.io/post/f145b64d.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/553387258">c++笔记来源</a></p><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/620328348">C++中函数重载</a><br>函数名相同，但是参数类型或者参数个数不同的两个函数叫做函数重载；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyFun</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    b = b+<span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my fun -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数重载　*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyFun</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a - <span class="number">6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my fun -2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MyFun</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">MyFun</span>(<span class="number">99.99</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数重载判断标准</strong></p><ul><li>函数的参数个数、参数类型、参数顺序不同三者中满足其中一个，就是函数重载了</li><li>如果只有函数返回值不同，不是函数重载；返回值不同，参数也不同的时候，可以作为函数<strong>重载</strong></li></ul><p><strong>函数重载调用准则</strong></p><ul><li>函数重载调用时，先去找名称相同的函数，然后进行参数个数和类型的匹配。</li><li>找不到匹配的函数就会编译失败，找到两个匹配的函数也会编译失败；</li><li>重载的的函数，本质是两个不同的函数，在静态链编的时候就编链成两个不同的函数；</li><li>类里面的函数重载发生在同一个类中；</li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li>类的成员变量叫属性</li><li>类的成员函数叫方法&#x2F;行为，类的成员函数可以定义在类的外面</li><li>用类定义一个类的变量叫做创建一个对象</li><li>类的成员变量和成员函数的作用域和生命周期与对象的作用域和生命名周期相同<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGil</span>&#123;</span><br><span class="line">    string name;<span class="comment">//设置成员变量的值</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要声明，设置成员变量的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGil::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    name =name1;</span><br><span class="line">    age=age1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类.方法（）</span></span><br><span class="line"><span class="comment">//类.属性</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><ul><li>类的成员有三种访问权限：public、private 和 protected, 分别表示公有的、私有的和受保护的</li><li>在类的内部（类的成员函数中），无论成员被声明为 public 还是 private, 都可以访问</li><li>在类的外部（定义类的代码之外），只能访问 public 成员，不能访问 private、protected 成员</li><li>在一个类体的定义中，private 和 public 可以出现多次</li><li>结构体的成员缺省为 public，类的成员缺省为 private</li><li>private 的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为 public<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line"><span class="comment">//public可访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> speed=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        x += a * speed;</span><br><span class="line">        y += b * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x=<span class="number">5</span>;<span class="comment">//赋值</span></span><br><span class="line">    player.<span class="built_in">move</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//调用方法</span></span><br><span class="line">    cout&lt;&lt;player.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;player.y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个日志系统观察类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelError=<span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelWarning=<span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelInfo=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_LogLevel=LogLevelInfo;<span class="comment">//默认日志</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">        m_LogLevel=level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_LogLevel&gt;=LogLevelError)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;[ERROR]: &quot;</span>&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_LogLevel&gt;=LogLevelError)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;[WARNING]: &quot;</span>&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_LogLevel&gt;=LogLevelInfo)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;[INFO]: &quot;</span>&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    <span class="comment">// log.SetLevel(log.LogLevelWarning);</span></span><br><span class="line">    log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Error</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Info</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-类与对象"><a href="#C-类与对象" class="headerlink" title="C++类与对象"></a>C++类与对象</h2><ul><li><a href="https://blog.csdn.net/u013921164/article/details/130929563?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=5">UML类图</a></li><li>类的成员函数可以直接访问该类其它的成员函数（可以递归）</li><li>类的成员函数可以重载，可以使用默认参数</li><li>类指针的用法与结构体指针用法相同</li><li>类的成员可以是任意数据类型，类中枚举</li><li>可以为类的成员指定缺省值</li></ul><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul><li>构造函数：在创建对象时，自动进行初始化工作</li><li>析构函数：在销毁对象前，自动完成清理工作</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>语法：类名 (){…}</li><li>访问权限<strong>必须是 public</strong>.</li><li>函数名必须<strong>与类名相同</strong>。</li><li>没有返回值，也不写 void。</li><li>可以有参数，可以重载，可以有默认参数。</li><li>创建对象时会自动调用一次，不能手工调用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//创建构造函数，可以多个，但是需要有不同参数</span></span><br><span class="line">    <span class="comment">//CGirl() = default; 放在类的定义中的构造函数声明处，可以告诉编译器使用默认生成的方式来生成默认构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name,<span class="type">int</span> age=<span class="number">23</span>)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//CGirl();在这里使用这个函数，含义不是调用构造函数（无参数），是创建一个匿名对象，不能这么用</span></span><br><span class="line">        m_age=age;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数2个参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;调用析构函数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要生命，设置成员变量的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    CGirl girl;<span class="comment">//调用没有参数的构造函数,不用括号</span></span><br><span class="line">    <span class="comment">// const char* ch=&quot;23&quot;;//等价于string ch=&quot;23&quot;,不加const 传参会报错</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;,8);//调用有两个参数的构造函数</span></span><br><span class="line">    <span class="comment">// CGirl girl&#123;&quot;西施&quot;,8&#125;;//也可以这样写，用&#123;&#125;</span></span><br><span class="line">    <span class="comment">// CGirl girl;//隐式调用构造函数，无参数无括号，常用</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl();//显示调用构造函数，无参数有括号</span></span><br><span class="line">    girl.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// girl.~CGirl();//手动调用,一般自动就会调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGirl::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    m_name =name1;</span><br><span class="line">    m_age=age1;</span><br><span class="line">    <span class="built_in">show</span>();<span class="comment">//类内部调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul><li>语法：~类名 (){…}</li><li>访问权限必须是 public.</li><li>函数名必须在类名前加~。</li><li>没有返回值，也不写 void.</li><li>没有参数，不能重载。</li><li>销毁对象前只会自动调用一次，但是可以手工调用</li></ul><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul><li><p>如果没有提供构造&#x2F;析构函数，编译器将提供<strong>空实现</strong>的构造&#x2F;析构函数。</p></li><li><p>如果提供了构造&#x2F;析构函数，编译器将不提供空实现的构造&#x2F;析构函数。</p></li><li><p>创建对象的时候，如果重载了构造函数，编译器<strong>根据实参匹配</strong>相应的构造函数。</p></li><li><p>创建对象的时候<strong>不要在对象名后面加空的圆括号，编译器误认为是声明函数</strong>。(没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）</p></li><li><p>在构造函数名后面加括号和参数<strong>不是调用构造函数，是创建匿名对象</strong>。</p></li><li><p>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐 <code>CGirl girl=10</code></p></li><li><p>下面两行代码有本质区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGirl girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>)；<span class="comment">//显示创建对象,会调用一次构造函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CGirl girl;<span class="comment">//创建对象</span></span><br><span class="line">girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>);<span class="comment">//创建匿名对象，然后给现有对象赋值，会调用构造函数</span></span><br></pre></td></tr></table></figure></li><li><p>用 new&#x2F;delete 创建&#x2F;销毁对象时，也会调用构造函数或者析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGirl *girl=<span class="keyword">new</span> <span class="built_in">CGirl</span>();<span class="comment">//显示写法用new,必须用指针形式</span></span><br><span class="line">girl-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">delete</span> girl;</span><br></pre></td></tr></table></figure></li><li><p>如果类成员有指针时，析构函数需要用这段代码 <code>delete ptr;ptr=nullptr;</code></p></li></ul><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li>用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。</li><li>如果类中没有定义拷贝构造函数，编译器<strong>将提供一个拷贝构造函数</strong>，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。</li></ul><p>用一个已存在的对象创建新的对象语法：</p><ul><li>类名  新对象名(已存在的对象名)；</li><li>类名  新对象名&#x3D;已存在的对象名；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//以无参数为例</span></span><br><span class="line">CGirl g1;</span><br><span class="line">g1.m_name=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line">g1.m_age=<span class="number">18</span>;</span><br><span class="line"><span class="comment">//写法1</span></span><br><span class="line"><span class="function">CGirl <span class="title">g2</span><span class="params">(g1)</span></span>;</span><br><span class="line">g2.<span class="built_in">show</span>();</span><br><span class="line"><span class="comment">//写法2</span></span><br><span class="line">CGirl g3=g1;</span><br><span class="line">g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>拷贝构造函数写法：</li></ul><ol><li>无参数： <code>类名（const 类名&amp; 对象名）&#123;&#125;</code>；</li><li>有参数： <code>类名（...，connst 类名&amp; 对象名，....）&#123;&#125;</code></li></ol><ul><li>访问权限必须 public</li><li>函数名必须与类名相同</li><li>以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。</li><li>函数以值的方式返回对象时，可能会调用拷贝构造函数（VS 会调用，Linux 不会）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数直接用</span></span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp;gg)<span class="comment">//没有重载的拷贝函数,针对的是无参数的构造函数，默认执行，先构造后拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name=<span class="string">&quot;漂亮的&quot;</span>+gg.m_name;</span><br><span class="line">        m_age=gg.m_age<span class="number">-1</span>;</span><br><span class="line">     </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//有参数是写法</span></span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp;gg,<span class="type">int</span> age)<span class="comment">//带有一个参数的拷贝函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name=<span class="string">&quot;漂亮的&quot;</span>+gg.m_name;</span><br><span class="line">        m_age=gg.m_age-age;</span><br><span class="line">     </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CGirl g1;</span><br><span class="line">g1.m_name=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line">g1.m_age=<span class="number">18</span>;</span><br><span class="line"><span class="function">CGirl <span class="title">g2</span><span class="params">(g1,<span class="number">3</span>)</span></span>;</span><br><span class="line">g2.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p><a href="https://blog.csdn.net/qq_42174306/article/details/122882267?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169017884016800186546005%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169017884016800186546005&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-122882267-null-null.142%5Ev90%5Econtrol,239%5Ev3%5Econtrol&utm_term=%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9Dc++&spm=1018.2226.3001.4187">C++浅拷贝与深拷贝</a></p><ol><li>浅拷贝： 将原对象或原数组的引用直接赋给新对象，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</li><li>深拷贝： <strong>创建</strong>一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”，新对象与原对象不共享内存，修改新对象不会改到元对象</li><li>编译器提供的拷贝函数是浅拷贝，所以，在<strong>对含有指针成员的对象进行拷贝</strong>时，必须自己定义<strong>拷贝构造函数</strong>，达到深拷贝的目的，才能必变内存重复释放<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp;gg)<span class="comment">//没有重载的拷贝函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name=<span class="string">&quot;漂亮的&quot;</span>+gg.m_name;</span><br><span class="line">        <span class="comment">//分配内存，赋值</span></span><br><span class="line">        m_prt=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//分配内存,</span></span><br><span class="line">        *m_ptr=<span class="number">3</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><ul><li>构造函数的执行可以分成两个阶段：初始化阶段和计算阶段。初始化阶段先于计算阶段。</li><li>初始化阶段：全部的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。</li><li>计算阶段：一般是指用于执行构造函数体内的赋值操作。</li><li>构造函数除了参数列表和函数体外，还可以由初始化列表<br>初始化列表的语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类名(形参列表):成员<span class="number">1</span>（值<span class="number">1</span>）,...,成员<span class="built_in">n</span>(值n)&#123;...&#125;</span><br><span class="line"><span class="comment">//对无参数构造函数调用</span></span><br><span class="line"><span class="built_in">CGirl</span>():<span class="built_in">m_name</span>(<span class="string">&quot;西施&quot;</span>),<span class="built_in">m_age</span>(<span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGirl</span>(string name,<span class="type">int</span> age):<span class="built_in">m_name</span>(<span class="string">&quot;漂亮的&quot;</span>+name),<span class="built_in">m_age</span>(age)&#123;&#125;<span class="comment">//对于有参数的构造函数</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。</li><li>初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。</li><li>初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是拷贝构造函数，而赋值则是先创建对象（调用普通构造函数），然后再赋值。</li><li>如果成员是类，初始化列表效率更高。</li><li>如果成员是<strong>常量和引用</strong>，必须使用初始列表，因为常量和引用只能在定义的时候初始化。 </li><li>如果成员是没有默认构造函数的类，则必须使用初始列表。</li></ol><h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><ul><li>在类的成员函数后面加 const 关键字，表示在成员函数中保证不会修改调用对象的成员变量。</li><li>类中调用一般用解引用去传参<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> CGirl &amp;<span class="title function_">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span> <span class="type">const</span></span><br></pre></td></tr></table></figure></li><li>其中，第一个<code>const</code>表示返回值是一个常引用类型，第二个<code>const</code>表示该函数是一个成员常函数，而第三个<code>const</code>则表示该成员函数不会修改任何成员变量的值。<br><strong>注意：</strong></li><li>mutable 可以突破 const 的限制，被 mutable 修饰的成员变量，将永远处于可变的状态，在 const 修饰的函数中，mutable 成员也可以被修改。</li><li>非 const 成员函数可以调用 const 成员函数和非 const 成员函数。</li><li>const 成员函数不能调用非 const 成员函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//m_name=&quot;woo&quot;;//修改m_name,有const会报错</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ul><li><p>如果类的成员函数中涉及多个对象，在这种情况下需要使用 this 指针。</p></li><li><p>this 指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。</p></li><li><p>每个成员函数（包括构造函数和析构函数）都有一个 this 指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）</p></li><li><p><code>*this</code> 可以表示整个对象。</p></li><li><p>如果在成员函数的括号后面使用 const, 那么将不能通过 this 指针修改成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规写法对比对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;gg1,<span class="type">const</span> CGirl &amp;gg2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(gg1.m_age&lt;gg2.m_age) <span class="keyword">return</span> gg2;</span><br><span class="line"><span class="keyword">return</span> gg1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=<span class="built_in">pk</span>(g1,g2);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类中定义</span></span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(g.m_age&gt;m_age) <span class="keyword">return</span> g;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=g2.<span class="built_in">pk</span>(g1);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//对比5个</span></span><br><span class="line">    <span class="comment">// CGirl g1(&quot;西施&quot;,8),g2(&quot;西瓜1&quot;,9),g3(&quot;西瓜2&quot;,10),g4(&quot;西瓜3&quot;,11),g5(&quot;西瓜4&quot;,12);</span></span><br><span class="line">    <span class="comment">// const CGirl &amp;g=g1.pk(g2).pk(g3).pk(g4).pk(g5);</span></span><br><span class="line">    <span class="comment">// g.show();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个类中存在<strong>成员变量和局部变量同名</strong>时，可以使用this关键字来访问成员变量。例如：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myVariable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVariable</span><span class="params">(<span class="type">int</span> myVariable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;myVariable = myVariable; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;myVariable: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;myVariable &lt;&lt; std::endl; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setVariable</span>(<span class="number">10</span>);</span><br><span class="line">    obj.<span class="built_in">printVariable</span>(); <span class="comment">// 输出: myVariable: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，setVariable函数中的形参myVariable和类的成员变量myVariable同名。为了区分它们，使用this-&gt;myVariable来访问成员变量。</p><ul><li>另外，也可以使用this指针来调用其他成员函数。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">function1</span>(); <span class="comment">// 使用this指针调用其他成员函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">function2</span>(); <span class="comment">// 输出: This is function1</span></span><br><span class="line">                     <span class="comment">//       This is function2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在上面的例子中，function2通过使用this-&gt;function1()调用了function1成员函数。</li></ul><h3 id="类的静态成员变量"><a href="#类的静态成员变量" class="headerlink" title="类的静态成员变量"></a>类的静态成员变量</h3><ul><li>类的静态成员包括静态成员变量和静态成员函数。</li><li>用静态成员可以变量<strong>实现多个对象之间的数据共享</strong>，比全局变量更安全性。</li><li>用 static 关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。</li><li>静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解运算符）。</li><li>静态成员使用类名加范围解析运算符：就可以访问，不需要创建类对象。</li><li><strong>如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）</strong>。</li><li>静态成员变量在程序中只有一份 (生命周期与程序运行期相同，存放在静态存储区的)，不论是否创建了类的对象，也不论创建了多少个类的对象。</li><li>静态成员函数<strong>只能访问静态成员</strong>，不能访问非静态成员。</li><li>静态成员函数中没有 this 指针。</li><li>非静态成员函数可以访问静态成员。</li><li>私有静态变量在类外无法访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_age;<span class="comment">//设置静态变量</span></span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;构造函数无参数&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> string name,<span class="type">int</span> age)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    m_name=name;</span><br><span class="line">    m_age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="comment">//静态函数,只能用静态变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CGirl::m_age=<span class="number">34</span>;<span class="comment">//初始化类的静态成员变量,没有或者在其他位置不行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CGirl::<span class="built_in">show</span>();<span class="comment">//静态函数</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;CGirl::m_age:&quot;</span>&lt;&lt;CGirl::m_age&lt;&lt;endl;<span class="comment">//可以在创建对象那个前访问</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构体与类的对比"><a href="#结构体与类的对比" class="headerlink" title="结构体与类的对比"></a>结构体与类的对比</h2><p>区别：</p><blockquote><p>作用上：class默认private，struct默认public。<br>使用上：引入 struct 是为了让 C++向后兼容 C</p></blockquote><p>推荐选用：</p><blockquote><p>若只包含一些变量结构或POD(plain old data)时，选用struct。例如数学中的向量类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span>&#123;</span><br><span class="line"> <span class="type">float</span> x, y;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Vec2&amp; other)</span></span>&#123;</span><br><span class="line">     x += other.x;</span><br><span class="line">     y += other.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若要实现很多功能的类，则选用class</p><h2 id="c-中的静态"><a href="#c-中的静态" class="headerlink" title="c++中的静态"></a>c++中的静态</h2><p>static 关键字两种用法</p><ul><li>在类或结构体外部使用 static 关键字</li></ul><blockquote><p>这意味着你定义的函数和变量只对它的声明所在的cpp文件（编译单元）是“可见”的。换句话说此时static修饰的符号,（在link的时候）它只对定义它的翻译单元(.obj)可见（internal linkage）。</p></blockquote><ul><li>在类或结构体内部使用static关键字</li></ul><blockquote><p>此时表示这部分内存（static变量）是这个类的<strong>所有实例共享</strong>的。即：该静态变量在类中创建的所有实例中，静态变量只有一个实例。<strong>一个改变就改变所有。</strong></p></blockquote><p>类中的静态方法也一样，静态方法中没有该实例的指针（this）。在类中没有实例会传递给该方法。</p><h2 id="C-类和结构体中的静态（static）"><a href="#C-类和结构体中的静态（static）" class="headerlink" title="C++类和结构体中的静态（static）"></a>C++类和结构体中的静态（static）</h2><ul><li><strong>静态方法</strong>不能访问<strong>非静态变量</strong></li><li><strong>静态方法没有类实例</strong></li><li>本质上你在类里写的每个<strong>非静态方法</strong>都会获得当前的类实例作为参数（this指针）</li><li>静态成员变量在编译时存储在静态存储区，即<strong>定义过程应该在编译时完成</strong>，因此<strong>一定要在类外进行定义</strong>，但可以不初始化。 <strong>静态成员变量是所有实例共享的</strong>，但是其<strong>只是在类中进行了声明，并未定义或初始化</strong>（分配内存），类或者类实例就无法访问静态成员变量，这显然是不对的，<strong>所以必须先在类外部定义</strong>，也就是分配内存。</li></ul><blockquote><p>在几乎所有面向对象的语言里，static在一个类中意味着特定的东西。<strong>如果是static变量，这意味着在类的所有实例中，这个变量只有一个实例。</strong>比如一个entity类，有很多个entity实例，若其中一个实例更改了这个static变量，它会在所有实例中反映这个变化。这是因为即使创建了很多实例，static的变量仍然只有一个。正因如此，<strong>通过类实例来引用静态变量是没有意义的</strong>。因为这就像类的全局实例。<br>静态方法也是一样，无法访问类的实例。静态方法可以被调用，不需要通过类的实例。而在静态方法内部，你不能写引用到类实例的代码，因为你不能引用到类的实例。</p></blockquote><p>比如一段最简单的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然编译不会报错，但是链接会报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.obj : error LNK2001: unresolved external symbol <span class="string">&quot;public: static int Entity::x&quot;</span></span><br></pre></td></tr></table></figure><p>于是我们需要给出定义，让链接器可以链接到合适的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再创建一个实例对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    e1.<span class="built_in">print</span>();</span><br><span class="line">    e2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为两个2，这是因为两个实例化对象共享的是同一个变量，正因如此，<strong>通过类实例来引用静态变量是没有意义的</strong>，最好写为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    Entity::x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    Entity::x= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    e1.<span class="built_in">print</span>();</span><br><span class="line">    e2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把print()函数改为static，仍然正常，<strong>因为它引用的x，y也是静态的变量</strong>，同样的，正确代调用方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    Entity::x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    Entity::x= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在这个例子里我们都用不到类的实例，因为这些全是静态的，故代码改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity::x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity::x= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但如果把x改为非静态的，则会报错，因为静态方法不能访问非静态变量，原因就是静态方法没有类实例，我们在编写类的时候，本质上我们在类里写的每个非静态方法都会获得当前的类实例作为参数（this指针）。</strong></p><p>因此静态方法和在类外部编写的方法是一样的。</p><p>如果在类外面写一个print()函数，则就会报错，这就能为什么说明不能访问到x；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 报错，不能访问到非静态变量x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外面写一个print()函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 报错，x是什么？没被定义。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    e1.<span class="built_in">print</span>();</span><br><span class="line">    e2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果这样就可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类外面写一个print()函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(Entity e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; e.x &lt;&lt; endl;  <span class="comment">// 成功运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚刚写的方法，<strong>本质上就是一个类的非静态方法在编译时的真正样子</strong></p><p>但如果我把<strong>Entity实例去掉</strong>，就是<strong>把static关键字加到类方法时所做的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类外面写一个print()函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span>       <span class="comment">//把Entity实例去掉</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; e.x &lt;&lt; endl;  <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是为什么会错，他不知道要怎么访问 Entity 的 x，y 因为你没有给他一个 Entity 的引用。</p><h1 id="PX4-C-代码形式理解"><a href="#PX4-C-代码形式理解" class="headerlink" title="PX4_C++代码形式理解"></a>PX4_C++代码形式理解</h1><h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h3><p><a href="https://blog.csdn.net/qq_43533553/article/details/123257675?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168906554316800227449672%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168906554316800227449672&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-123257675-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E4%B8%ADnamespace%E7%9A%84%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187">C++命名空间namespace</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一定义</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间名字</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> model1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//当前变量i只对命名空间model1可见，它的作用域被限定在model1</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">namespace</span> 命名空间<span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2定义</span></span><br><span class="line"><span class="keyword">using</span> model1::i;</span><br><span class="line">i= <span class="number">0</span>;  <span class="comment">//使用model1定义的变量i</span></span><br><span class="line">model2::i= <span class="number">10</span>;  <span class="comment">//使用model2定义的变量i</span></span><br></pre></td></tr></table></figure><p>由于使用命名空间后，变量的<a href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>被限定，所以在使用变量时，就需要通过特定方式来完成。需要用到“::”操作符，“::”操作符是域解析操作符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model1::i = <span class="number">1</span>;</span><br><span class="line">model2::i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>命名空间成员使用方法总结</strong></p><blockquote><p>方法一 ：命名空间名:: 成员比如：spaceA:: a;<br>使用 using 可以使得命名空间中的成员暴露外部，以致可以使用该成员<br>方法二： using 命名空间名:: 成员 —-&gt; 把指定的成员暴露给外部<br>比如：using spaceA:: a;<br>方法三： using namespace 命名空间名 —&gt; 将其所有成员暴露给外部<br>比如： using namespace spaceA;</p></blockquote><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@brief  ：简介，简单介绍函数作用  </span><br><span class="line">@param  ：介绍函数参数  </span><br><span class="line">@<span class="keyword">return</span>：函数返回类型说明  </span><br><span class="line">@exception NSException 可能抛出的异常.  </span><br><span class="line">@author zhangsan：  作者  </span><br><span class="line">@date <span class="number">2011</span><span class="number">-07</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">30</span>:<span class="number">00</span> ：时间  </span><br><span class="line">@version <span class="number">1.0</span> ：版本    </span><br><span class="line">@property ：属性介绍</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过多行注释实现，如下</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param _name         The name of the topic.</span></span><br><span class="line"><span class="comment"> * @param _struct       The structure the topic provides.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>[[1、数据类型#宏定义|宏定义]]<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">orb_advert_t</span> <span class="title">orb_advertise</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> orb_metadata *meta, <span class="type">const</span> <span class="type">void</span> *data)</span> __EXPORT</span>;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li><code>extern</code>: 这是一个 C&#x2F;C++关键字，<strong>用于表明被声明的函数不在当前文件中，而在其他的源文件中实现</strong>。这样的话，其他的源文件就可以调用到这个函数   </li><li><code>orb_advert_t</code>: 这是返回值类型。<code>orb_advert_t</code>应该是定义在别的地方的一个类型，可能是一个结构体、枚举等。<ol start="3"><li><code>orb_advertise</code>: 这是函数名。</li><li><code>__EXPORT</code>: 这个通常是一个平台相关的宏，用于标记函数或变量，使其在链接时可被其他模块看见，就是说这个函数可以被其他的文件或模块调用</li></ol></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.c++基础语法2</title>
      <link href="/data.github.io/post/7f157bf9.html"/>
      <url>/data.github.io/post/7f157bf9.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>数组是一组数据类型相同的变量，可以存放一组数据。<br><strong>创建数组</strong></li><li>声明数组的语法：<code>数据类型 数组名[数组长度];</code></li><li>注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。</li><li>C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量</li></ul><p><strong>数组的使用</strong></p><ul><li>可以通过下标访问数组中元素，数组下标从0开始。</li><li>数组中每个元素的特征和使用方法与单个变量完全相同。</li><li>语法：<code>数组名[数组下标]</code></li></ul><p><strong>注意</strong></p><ul><li>数组下标也必须是整数，可以是常量，也可以是变量。</li><li>合法的数组下标取值是：0~(数组长度-1)。</li></ul><p><strong>数组占用内存的情况</strong></p><ul><li>数组在内存中占用的空间是连续的。</li><li>用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。</li></ul><p><strong>数组的初始化</strong><br>声明的时候初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[数组长度] = &#123; 值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>, ...... , 值n&#125;;</span><br><span class="line">数据类型 数组名[ ] = &#123; 值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>, ...... , 值n&#125;;</span><br><span class="line">数据类型 数组名[数组长度] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 把全部的元素初始化为0。</span></span><br><span class="line">数据类型 数组名[数组长度] = &#123; &#125;;    <span class="comment">// 把全部的元素初始化为0。</span></span><br></pre></td></tr></table></figure><p>注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填</p><p><strong>清空数组</strong></p><ul><li>用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）</li><li>函数原型：<code>void *memset(void *s, int c, size_t n);</code></li><li>注意，在Linux下，使用memcpy()函数需要包含头文件<code>#include &lt;string.h&gt;</code></li></ul><p><strong>复制数组</strong><br>用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）<br>函数原型：<code>void *memcpy(void *dest, const void *src, size_t n);</code></p><h2 id="一维数组与指针"><a href="#一维数组与指针" class="headerlink" title="一维数组与指针"></a>一维数组与指针</h2><p><strong>指针的算术</strong></p><ul><li>将一个整型变量加1后，其值将增加1。</li><li>但是，将指针变量（地址的值）加1后，<strong>增加的量等于它指向的数据类型的字节数</strong>。</li></ul><p><strong>数组的地址</strong></p><ul><li>a）数组在内存中占用的空间是连续的。</li><li>b）C++<strong>将数组名解释为数组第0个元素的地址</strong>。</li><li>c）<strong>数组第0个元素的地址和数组首地址的取值是相同的</strong>。</li><li>d）数组第n个元素的地址是：数组首地址+n</li><li>e）C++编译器把   <code>数组名[下标]</code>  解释为  <code>*(数组首地址+下标)</code></li></ul><p><strong>数组的本质</strong></p><ul><li>数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的。</li></ul><p><strong>数组名不一定会被解释为地址</strong></p><ul><li>在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数。</li><li>可以修改指针的值，但数组名是常量，不可修改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> b;      cout &lt;&lt; <span class="string">&quot;sizeof(char)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;            <span class="comment">// 1字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span> *)&amp; b &lt;&lt; endl;<span class="comment">//c++形式取地址，(void*)是一种类型转换操作符，将&amp;d的返回类型转换为void类型的指针</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b的地址+1是：&quot;</span> &lt;&lt; (<span class="type">void</span>*)( &amp; b + <span class="number">1</span>) &lt;&lt; endl&lt;&lt;endl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b的地址：%p\n\n\n&quot;</span>,&amp;b);<span class="comment">//c语言形式取地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a[<span class="number">5</span>]=&#123; <span class="number">1.3</span> , <span class="number">6</span> , <span class="number">5</span> , <span class="number">8</span> , <span class="number">9</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a的值是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;a的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)&amp;a &lt;&lt; endl;<span class="comment">//longlong是把地址转为整型方便对比看</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a[0]的地址是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>) &amp;a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a[1]的地址是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>) &amp;a[<span class="number">1</span>] &lt;&lt; endl&lt;&lt;endl;</span><br><span class="line"><span class="type">double</span>* p = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+0的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)(p+  <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p+1的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)(p + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+0)的值是：&quot;</span> &lt;&lt; *(p+  <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+1)的值是：&quot;</span> &lt;&lt; *(p + <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维数组用于函数的参数"><a href="#一维数组用于函数的参数" class="headerlink" title="一维数组用于函数的参数"></a>一维数组用于函数的参数</h2><p><strong>指针的数组表示</strong></p><ul><li>在C++内部，用指针来处理数组。</li><li>C++编译器把   <code>数组名[下标]  解释为  *(数组首地址+下标)</code></li><li>C++编译器把   <code>地址[下标]  解释为  *(地址+下标)</code></li></ul><p><strong>一维数组用于函数的参数</strong></p><ul><li>一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。<br>书写方法有两种： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>在函数中，可以用数组表示法，也可以用指针表示法。</li><li>在函数中，不要对指针名用sizeof运算符，它不是数组名。<br>![[Pasted image 20231223144029.png]]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(int *arr,int len)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; len; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]的值是：&quot;</span> &lt;&lt; arr[ii] &lt;&lt; endl;              <span class="comment">// 用数组表示法操作指针。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(arr+&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;)的值是：&quot;</span> &lt;&lt; *(arr + ii) &lt;&lt; endl;   <span class="comment">// 地址[下标]  解释为  *(地址+下标)。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> b[<span class="number">20</span>];             <span class="comment">// 这是一个长度为20的字符型数组。</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span> *)b;        <span class="comment">// 让整型指针p指向数组a的内存。强制转换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">6</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">p[ii] = ii + <span class="number">300</span>;     <span class="comment">// 用数组表示法操作指针。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">6</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*(p+&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;)的值是：&quot;</span> &lt;&lt; *(p + ii) &lt;&lt; endl;    <span class="comment">// 地址[下标]  解释为  *(地址+下标)。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">func</span>(a, <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="new动态创建数组"><a href="#new动态创建数组" class="headerlink" title="new动态创建数组"></a>new动态创建数组</h2><ul><li>普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存</li><li>动态创建一维数组的语法：<code>数据类型 *指针=new 数据类型[数组长度];</code></li><li>释放一维数组的语法：<code>delete [] 指针;</code></li></ul><p><strong>注意</strong></p><ul><li>动态创建的数组没有数组名，不能用sizeof运算符。</li><li>可以用数组表示法和指针表示法两种方式使用动态创建的数组。</li><li>必须使用delete[]来释放动态数组的内存（不能只用delete）：这是因为动态数组是通过<code>new[]</code>来分配内存的，而不是通过普通的new操作符。使用delete[]来释放不是通过<code>new[]</code>分配的内存是不安全的，可能导致未定义行为。</li><li>不要用<code>delete[]</code>来释放不是new[]分配的内存。</li><li>不要用<code>delete[]</code>释放同一个内存块两次（否则等同于操作野指针）。</li><li>对空指针用<code>delete[]</code>是安全的（释放内存后，<strong>应该把指针置空nullptr</strong>）。</li><li>声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。</li><li>如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。</li><li>为什么用<code>delete[]</code>释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 注意区别</span></span><br><span class="line"><span class="comment">// int *ptr = new int; // 分配一个int大小的内存空间，并将地址赋给指针ptr</span></span><br><span class="line"><span class="comment">// int *arr = new int[10]; // 分配一个包含10个int类型元素的数组，并将地址赋给指针arr</span></span><br><span class="line"><span class="comment">// delete ptr; // 释放通过new分配的单个变量的内存</span></span><br><span class="line"><span class="comment">// delete[] arr; // 释放通过new[]分配的数组的内存</span></span><br><span class="line"><span class="type">int</span> *arr=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];          <span class="comment">// 创建8个元素的整型数组。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">arr[ii] = <span class="number">100</span> + ii;                                                                  <span class="comment">// 数组表示法。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; *(arr + ii) &lt;&lt; endl;        <span class="comment">// 指针表示法。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="一维数组的排序qsort"><a href="#一维数组的排序qsort" class="headerlink" title="一维数组的排序qsort"></a>一维数组的排序qsort</h2><ul><li>qsort()函数用于对各种数据类型的数组进行排序。</li><li>函数的原型：<code>void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</code></li><li>第一个参数：数组的起始地址。</li><li>第二个参数：数组元素的个数（数组长度）。</li><li>第三个参数：数组元素的大小（sizeof(数组的数据类型)）。</li><li>第四个参数：回调函数的地址,<strong>它是函数指针</strong></li></ul><p>回调函数决定了排序的顺序，声明如下：</p><ul><li><code>int compar(const void *p1, const void *p2);</code></li></ul><ol><li>如果函数的返回值&lt; 0 ，那么p1所指向元素会被排在p2所指向元素的前面。</li><li>如果函数的返回值等于0，那么p1所指向元素与p2所指向元素的顺序不确定。</li><li>如果函数的返回值&gt; 0 ，那么p1所指向元素会被排在p2所指向元素的后面。</li></ol><p>qsort()函数的其它细节：</p><ul><li>形参中的地址用void是为了支持任意数据类型，在回调函数中必须具体化。</li></ul><p>为什么需要第三个形参size_t size？</p><ul><li>size_t是C标准库中定义的，在64位系统中是8字节无符号整型（unsigned long long）。</li><li>typedef unsigned long long size_t</li><li>排序的需求除了升序和降序，还有很多不可预知的情况，只能用回调函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compasc</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span>         <span class="comment">// 升序的回调函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *((<span class="type">int</span>*)p1) - *((<span class="type">int</span>*)p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compdesc</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span>       <span class="comment">// 降序的回调函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//void指针p1和p2分别转换为int指针，然后取出其指向的值，即将指针所指向的整数值进行比较。</span></span><br><span class="line"><span class="comment">//这里使用了类型转换操作符*来获取指针所指向的整数值。然后将这两个整数值进行相减，得到的结果即为降序排列所需的比较值。</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;p2&lt;&lt;endl&lt;&lt;(int*)p2&lt;&lt;endl&lt;&lt;*((int*)p2)&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> *((<span class="type">int</span>*)p2) - *((<span class="type">int</span>*)p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">qsort</span>(a,<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="built_in">sizeof</span>(<span class="type">int</span>),compasc);                   <span class="comment">// 对数组a进行升序排序。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; a[ii] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">qsort</span>(a, <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="built_in">sizeof</span>(<span class="type">int</span>), compdesc);            <span class="comment">// 对数组a进行降序排序。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; a[ii] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>C语言约定：如果字符型（char）数组的<strong>末尾包含了空字符\0</strong>（也就是0），那么该数组中的内容就是一个<strong>字符串</strong>。<br>![[Pasted image 20231223194336.png]]</p><ul><li>因为字符串需要用0结尾，所以在声明字符数组的时候，要预留多一个字节用来存放0。</li><li><code>char name[21];</code>  &#x2F;&#x2F; 声明一个最多存放20个英文字符或十个中文的字符串。<br><strong>初始化方法</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">11</span>];                 <span class="comment">// 可以存放10个字符，没有初始化，里面是垃圾值。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">11</span>] = <span class="string">&quot;hello&quot;</span>;         <span class="comment">// 初始内容为hello，系统会自动添加0。</span></span><br><span class="line"><span class="type">char</span> name[]   = &#123; <span class="string">&quot;hello&quot;</span> &#125;;      <span class="comment">// 初始内容为hello，系统会自动添加0，数组长度是6。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">11</span>]   &#123; <span class="string">&quot;hello&quot;</span> &#125;;      <span class="comment">// 初始内容为hello，系统会自动添加0。C++11标准。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;          <span class="comment">// 把全部的元素初始化为0。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>清空字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));   <span class="comment">// 把全部的元素置为0。</span></span><br><span class="line">name[<span class="number">0</span>]=<span class="number">0</span>;       <span class="comment">// 不规范，有隐患，不推荐。</span></span><br></pre></td></tr></table></figure><p><strong>字符串复制或赋值strcpy()</strong></p><ul><li><code>char *strcpy(char* dest, const char* src);</code></li><li>功能: 将参数src字符串拷贝至参数dest所指的地址。</li><li>返回值: 返回参数dest的字符串起始地址。</li><li>复制完字符串后，会在dest后追加0。</li><li>如果参数dest所指的内存空间不够大，会导致数组的越界。</li></ul><p><strong>字符串复制或赋值strncpy()</strong></p><ul><li><code>char * strncpy(char* dest,const char* src, const size_t n);</code></li><li>功能：<strong>把src前n个字符的内容复制到dest中</strong>。</li><li>返回值：dest字符串起始地址。</li><li>如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。</li><li>如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。</li><li>如果参数dest所指的内存空间不够大，会导致数组的越界。</li></ul><p><strong>获取字符串的长度strlen()</strong></p><ul><li><code>size_t  strlen( const char*  str);</code></li><li>功能：计算字符串的有效长度，<strong>不包含0</strong>。</li><li>返回值：返回字符串的字符数。</li><li>strlen()函数计算的是字符串的实际长度，遇到0结束</li></ul><p><strong>字符串拼接strcat(）</strong></p><ul><li><code>char *strcat(char* dest,const char* src);</code></li><li>功能：将src字符串拼接到dest所指的字符串尾部</li><li>返回值：返回dest字符串起始地址</li><li>dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0</li><li>如果参数dest所指的内存空间不够大，会导致数组的越界</li></ul><p><strong>字符串拼接strncat()</strong></p><ul><li><code>char *strncat (char* dest,const char* src, const size_t n);</code></li><li>功能：将src字符串的前n个字符拼接到dest所指的字符串尾部</li><li>返回值：返回dest字符串的起始地址</li><li>如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n小于字符串src的长度，只追加src的前n个字符。</li><li>strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。</li><li>如果参数dest所指的内存空间不够大，会导致数组的越界</li></ul><p><strong>字符串比较strcmp()和strncmp()</strong></p><ul><li><code>int strcmp(const char *str1, const char *str2 );</code><ul><li>功能：比较str1和str2的大小。</li><li>返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</li></ul></li><li><code>int strncmp(const char *str1,const char *str2 ,const size_t n);</code><ul><li>功能：比较str1和str2前n个字符的大小。</li><li>返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</li><li>两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。</li></ul></li><li>在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。</li></ul><p><strong>查找字符strchr()和strrchr()</strong></p><ul><li><code>const char *strchr(const char *s, int c);</code><ul><li>返回在字符串s中第一次出现c的位置，如果找不到，返回0。</li></ul></li><li><code>const char *strrchr(const char *s, int c);</code><ul><li>返回在字符串s中最后一次出现c的位置，如果找不到，返回0。</li></ul></li></ul><p><strong>查找字符串strstr()</strong></p><ul><li><code>char *strstr(const char* str,const char* substr);</code></li><li>功能：检索子串在字符串中首次出现的位置。</li><li>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。</li></ul><p><strong>用于string的表达式</strong></p><ul><li>可以把C风格的字符串用于包含了string类型的赋值拼接等表达式中。</li></ul><p><strong>注意事项</strong></p><ul><li>字符串的结尾标志是0，按照约定，在处理字符串的时候，会从起始位置开始搜索0，一直找下去，找到为止（不会判断数组是否越界）。</li><li>结尾标志0后面的都是垃圾内容。</li><li><strong>字符串在每次使用前都要初始化</strong>，减少入坑的可能，是每次，不是第一次。</li><li>不要在子函数中对字符指针用sizeof运算，所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。</li></ul><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul><li>一维数组的数学概念是线性表，二维数组的数学概念是矩阵。<br><strong>创建二维数组</strong></li><li>声明二维数组的语法：<code>数据类型 数组名[行数][列数];</code></li><li>注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。</li></ul><p><strong>二维数组的使用</strong></p><ul><li>可以通过行下标和列下标访问二维数组中元素，下标从0开始。</li><li>二维数组中每个元素的特征和使用方法与单个变量完全相同。</li><li>语法：<code>数组名[行下标][列下标]</code></li></ul><p><strong>注意</strong></p><ul><li>二维数组下标也必须是整数，可以是常量，也可以是变量。</li><li>合法的行下标取值是：0~(行数-1)。</li><li>合法的列下标取值是：0~(列数-1)。</li></ul><p><strong>二维数组占用内存的情况</strong></p><ul><li>用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）</li><li>二维数组在内存中占用的空间是连续的</li></ul><p><strong>二维数组的初始化</strong><br>声明的时候初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[行数][列数] = &#123; &#123;数据<span class="number">1</span>，数据<span class="number">2</span> &#125; ，&#123;数据<span class="number">3</span>，数据<span class="number">4</span> &#125;,...... &#125;;</span><br><span class="line">数据类型 数组名[行数][列数] = &#123; 数据<span class="number">1</span>，数据<span class="number">2</span>，数据<span class="number">3</span>，数据<span class="number">4</span>, ......&#125;;</span><br><span class="line">数据类型 数组名[ ][列数] = &#123; 数据<span class="number">1</span>，数据<span class="number">2</span>，数据<span class="number">3</span>，数据<span class="number">4</span>,......&#125;;</span><br><span class="line">数据类型 数组名[行数][列数] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 把全部的元素初始化为0。</span></span><br><span class="line">数据类型 数组名[行数][列数] = &#123; &#125;;    <span class="comment">// 把全部的元素初始化为0。</span></span><br></pre></td></tr></table></figure><ul><li>注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中<strong>全部的元素初始化为0，可以在{}内只填一个0或什么也不填。</strong></li></ul><p><strong>清空二维数组</strong></p><ul><li>用memset()函数可以把二维数组中全部的元素清零。（只适用于C++基本数据类型）</li><li>函数原型：<code>void *memset(void *s, int c, size_t n);</code></li><li>注意，在Linux下，使用memcpy()函数需要包含头文件<code>#include &lt;string.h&gt;</code></li></ul><p><strong>复制二维数组</strong></p><ul><li>用memcpy()函数可以把二维数组中全部的元素复制到另一个相同大小的数组）。（只适用于C++基本数据类型）</li><li>函数原型：<code>void *memcpy(void *dest, const void *src, size_t n);</code></li><li>注意，在Linux下，使用memcpy()函数需要包含头文件#include &lt;string.h&gt;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// int bh[2][3] = &#123; &#123;11,12,13&#125;,&#123;21,22,23&#125; &#125;;                              // 声明一个两行三列的二维数组，存放超女的编号。</span></span><br><span class="line"><span class="comment">// int bh[2][3] = &#123; 11,12,13,21,22,23 &#125;;</span></span><br><span class="line"><span class="type">int</span> bh[][<span class="number">3</span>] = &#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*bh[0][0] = 11;bh[0][1] = 12;    bh[0][2] = 13;</span></span><br><span class="line"><span class="comment">bh[1][0] = 21; bh[1][1] = 22;    bh[1][2] = 23;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*cout &lt;&lt; &quot;bh[0][0] = &quot; &lt;&lt; bh[0][0] &lt;&lt; &quot;  bh[0][1] = &quot; &lt;&lt; bh[0][1] &lt;&lt; &quot;  bh[0][2] = &quot; &lt;&lt; bh[0][2] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;bh[1][0] = &quot; &lt;&lt; bh[1][0] &lt;&lt; &quot;  bh[1][1] = &quot; &lt;&lt; bh[1][1] &lt;&lt; &quot;  bh[1][2] = &quot; &lt;&lt; bh[1][2] &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++)                 <span class="comment">// 第一层循环表示行数，循环继续的条件是计数器小于行数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; <span class="number">3</span>; jj++)              <span class="comment">// 第二层循环表示列数，循环继续的条件是计数器小于列数。</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;bh[&quot;</span>&lt;&lt;ii&lt;&lt;<span class="string">&quot;][&quot;</span>&lt;&lt;jj&lt;&lt;<span class="string">&quot;] = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>) &amp; bh[ii][jj] &lt;&lt; <span class="string">&quot;  &quot;</span>;          <span class="comment">// 处理二维数组的每个元素。</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;          <span class="comment">// 每处理一行数据后，输出一个换行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span> *)bh;<span class="comment">//将一个二维数组bh强制类型转换为int指针p。这么写的主要目的可能是想要将二维数组以一维数组的形式进行处理或操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">6</span>; ii++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; p[ii] &lt;&lt; endl;     <span class="comment">// 一维数组的数组表示法。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="二维数组用于函数的参数"><a href="#二维数组用于函数的参数" class="headerlink" title="二维数组用于函数的参数"></a>二维数组用于函数的参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;      <span class="comment">// 整型指针。</span></span><br><span class="line"><span class="type">int</span>* p[<span class="number">3</span>];   <span class="comment">// 一维整型指针数组，元素是3个整型指针（p[0]、p[1]、p[2]）。</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">p</span><span class="params">()</span></span>;    <span class="comment">// 函数p的返回值类型是整型的地址。</span></span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span> ,<span class="type">int</span>);   <span class="comment">// p是函数指针，函数的返回值是整型。</span></span><br></pre></td></tr></table></figure><p><strong>行指针（数组指针）</strong></p><ul><li>声明行指针的语法：<code>数据类型 (*行指针名)[行的大小];</code>  &#x2F;&#x2F; 行的大小即数组长度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p1)[<span class="number">3</span>];  <span class="comment">// p1是行指针，用于指向数组长度为3的int型数组。</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">5</span>];  <span class="comment">// p2行指针，用于指向数组长度为5的int型数组。</span></span><br><span class="line"><span class="built_in">double</span> (*p3)[<span class="number">5</span>];  <span class="comment">// p3是行指针，用于指向数组长度为5的double型数组。</span></span><br></pre></td></tr></table></figure></li><li>一维数组名被解释为数组第0个元素的地址。</li><li>对一维数组名取地址得到的是数组的地址，是行地址。</li></ul><p><strong>二维数组名是行地址</strong><br><code>int bh[2][3] = &#123; &#123;11,12,13&#125;,&#123;21,22,23&#125; &#125;;</code></p><ul><li>bh是二维数组名，该数组有2元素，每一个元素本身又是一个数组长度为3的整型数组。</li><li>bh被解释为数组长度为3的整型数组类型的行地址。</li><li>如果存放bh的值，要用数组长度为3的整型数组类型的行指针：<code>int (*p)[3]=bh;</code></li></ul><p><code>int bh[4][2][3];</code></p><ul><li>bh是三维数组名，该数组有4元素，每一个元素本身又是一个2行3列的二维数组。</li><li>bh被解释为2行3列的二维数组类型的二维地址</li><li>如果存放bh的值，要用2行3列的二维数组类型的二维指针：<code>int (*p)[2][3]=bh;</code></li></ul><p><strong>把二维数组传递给函数</strong><br>如果要把bh传给函数，函数的声明如下：</p><ul><li><code>void func(int (*p)[3],int len);</code></li><li><code>void func(int p[][3],int len);</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="comment">// void func(int p[][2][3])等价于void func(int (*p)[2][3])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">2</span>][<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ii = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 遍历三维数组p，给它的每个元素赋值。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">4</span>; a++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">2</span>; b++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)</span><br><span class="line">p[a][b][c] = ii++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> bh[<span class="number">4</span>][<span class="number">2</span>][<span class="number">3</span>];        <span class="comment">// 假设有4个超女方阵，每个方阵有2行，每行有3个超女。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(bh, <span class="number">0</span>, <span class="built_in">sizeof</span>(bh));</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(bh);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">4</span>; a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">2</span>; b++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)</span><br><span class="line">cout &lt;&lt; bh[a][b][c] &lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;    <span class="comment">// 每显示一行后，输出一个换行符。</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl&lt;&lt;endl;    <span class="comment">// 每显示一个方阵后，输出两个换行符。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="结构体，共同体和枚举"><a href="#结构体，共同体和枚举" class="headerlink" title="结构体，共同体和枚举"></a>结构体，共同体和枚举</h1><ul><li>结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。<br>使用结构体有两个步骤：1）定义结构体描述（类型）；2）创建结构体变量。<br><strong>定义结构体描述</strong><br>定义结构体描述的语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名</span><br><span class="line">&#123;</span><br><span class="line">成员一的数据类型  成员名一;</span><br><span class="line">成员二的数据类型  成员名二;</span><br><span class="line">成员三的数据类型  成员名三;</span><br><span class="line">......</span><br><span class="line">成员n的数据类型  成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>结构体名是标识符。</li><li>结构体的成员可以是任意数据类型。</li><li>定义结构体描述的代码可以放在程序的任何地方，一般放在main函数的上面或头文件中。</li><li>结构体成员可以用C++的类（如string），但是不提倡：默认的访问控制权限是public，结构体更适合用于只包含数据成员而不包含函数成员的情况</li><li>在C++中，结构体中可以有函数，但是不提倡。</li><li>在C++11中，定义结构体的时候可以指定缺省值。</li></ul><p><strong>创建结构体变量</strong><br>创建结构体变量的语法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名 结构体变量名;</span><br><span class="line"><span class="keyword">struct</span> 结构体名 结构体变量名=&#123;成员一的值, 成员二的值,......, 成员n的值&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为0：<code>struct 结构体名 结构体变量名=&#123;0&#125;;</code></li></ul><p><strong>注意</strong></p><ul><li>在C++中，struct关键字可以不写</li><li>可以在定义结构体的时候创建结构体变量</li></ul><p><strong>使用结构体</strong></p><ul><li>用成员运算符（.）来访问结构体的每个成员。结构体中的每个成员具备普通变量的全部特征。<br>语法：<code>结构体变量名.结构体成员名;</code></li></ul><p><strong>占用内存的大小</strong></p><ul><li>用sizeof运算符可以得到整个结构体占用内存的大小。</li><li>注意：整个结构体占用内存的大小不一定等于全部成员占用内存之和：<strong>因为在内存布局中可能存在内存对齐的问题</strong></li><li>内存对齐：<code>#pragma pack(字节数)</code>，sizeof计算的与这个有关系</li><li>合理使用内存对齐规则，某些节省内存的做法可能毫无意义。</li></ul><p><strong>清空结构体</strong></p><ul><li>创建的结构体变量如果没有初始化，成员中有垃圾值。</li><li>用memset()函数可以把结构体中全部的成员清零。（只适用于C++基本数据类型）</li></ul><p><strong>复制结构体</strong></p><ul><li>用memcpy()函数把结构体中全部的元素复制到另一个相同类型的结构体（只适用于C++基本数据类型）。</li><li>也可以直接用等于号（只适用于C++基本数据类型）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)<span class="comment">//指定了结构体成员的对齐方式为8字节。这意味着结构体的成员在内存中的存储位置将会按照8字节对齐，即结构体成员的起始地址相对于结构体起始地址的偏移量必须是8的倍数</span></span></span><br><span class="line"><span class="comment">// 成员name是一个字符数组，占用21个字节，对齐后起始地址为0，偏移量为0。</span></span><br><span class="line"><span class="comment">// 成员age是一个int类型，占用4个字节，需要对齐到8的倍数，因此在name后补齐3个字节，偏移量为24。</span></span><br><span class="line"><span class="comment">// 成员weight是一个double类型，占用8个字节，对齐后起始地址为32，偏移量为32。</span></span><br><span class="line"><span class="comment">// 成员sex是一个char类型，占用1个字节，需要对齐到8的倍数，因此在weight后补齐7个字节，偏移量为40。</span></span><br><span class="line"><span class="comment">// 超女基本信息结构体st_girl，存放了超女全部的数据项。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];        <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">int</span> age;                     <span class="comment">// 年龄。</span></span><br><span class="line">    <span class="type">double</span> weight;        <span class="comment">// 体重（kg）。</span></span><br><span class="line">    <span class="type">char</span> sex;                   <span class="comment">// 性别：X-女；Y-男。</span></span><br><span class="line">    <span class="type">bool</span> yz;                    <span class="comment">// 颜值：true-漂亮；false-不漂亮。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st_girl stgirl&#123;<span class="string">&quot;西施&quot;</span>,<span class="number">26</span>,<span class="number">33.8</span>,<span class="string">&#x27;X&#x27;</span>,<span class="literal">true</span>&#125;;        <span class="comment">// 创建结构体变量。</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(st_girl)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(st_girl) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirl, <span class="number">0</span>, <span class="built_in">sizeof</span>(stgirl));<span class="comment">//与#pragma pack(4)有关系</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stgirl.name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; stgirl.age &lt;&lt; <span class="string">&quot;，体重：&quot;</span> &lt;&lt; stgirl.weight</span><br><span class="line">        &lt;&lt; <span class="string">&quot;，性别：&quot;</span> &lt;&lt; stgirl.sex &lt;&lt; <span class="string">&quot;，颜值：&quot;</span> &lt;&lt; stgirl.yz &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><ul><li><p>结构体是一种自定义的数据类型，用结构体可以创建结构体变量。</p></li><li><p>在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> girl;         <span class="comment">// 声明结构体变量girl。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst=&amp;girl;  <span class="comment">// 声明结构体指针，指向结构体变量girls。</span></span><br><span class="line"><span class="comment">//通过结构体指针访问结构体成员，有两种方法：</span></span><br><span class="line"> (*指针名).成员变量名    <span class="comment">// (*pst).name和(*pst).age </span></span><br><span class="line">指针名-&gt;成员变量名    <span class="comment">// pst-&gt;name和*pst-&gt;age </span></span><br></pre></td></tr></table></figure></li><li><p>在第一种方法中，圆点.的优先级<code>高于*</code>，<code>(*指针名)</code>两边的括号不能少。如果去掉括号写成<code>(*指针名)</code>.成员变量名，那么相当于<code>*(指针名.成员变量名</code>)，意义就完全不一样了</p></li><li><p>在第二种方法中，-&gt;是一个新的运算符</p></li><li><p>上面的两种方法是等效的，程序员通常采用第二种方法，更直观</p></li><li><p>注意：与数组不一样，结构体变量名没有被解释为地址</p></li></ul><p><strong>用于函数的参数</strong></p><ul><li>如果要把结构体传递给函数，实参取结构体变量的地址，函数的形参用结构体指针。</li><li>如果不希望在函数中修改结构体变量的值，<strong>可以对形参加const约束</strong>。</li></ul><p><strong>用于动态分配内存</strong></p><ul><li>用结构体指针指向动态分配的内存的地址</li></ul><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><ul><li><p>结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。</p></li><li><p>声明结构体数组的语法：<code>struct 结构体类型 数组名[数组长度];</code></p></li><li><p>初始化结构体数组，要结合使用初始化数组的规则和初始化结构体的规则。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">struct</span> <span class="title class_">st_girl</span> girls[<span class="number">2</span>]`=&#123;&#123;<span class="string">&quot;西施&quot;</span>,<span class="number">26</span>,<span class="number">43.8</span>,<span class="string">&#x27;X&#x27;</span>,<span class="literal">true</span>&#125;,&#123;<span class="string">&quot;西瓜&quot;</span>,<span class="number">25</span>,<span class="number">52.8</span>,<span class="string">&#x27;X&#x27;</span>,<span class="literal">false</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用结构体数组可以用数组表示法，也可以用指针表示法。</p></li></ul><h3 id="结构体指针-1"><a href="#结构体指针-1" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>如果结构体中的指针指向的是动态分配的内存地址：</p><ul><li>对结构体用sizeof运算可能没有意义。</li><li>对结构体用memset()函数可能会造成内存泄露。</li><li>C++的字符串string中有一个指针，指向了动态分配内存的地址<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *ptr;   <span class="comment">// 指向动态分配内存的地址。</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="共同体"><a href="#共同体" class="headerlink" title="共同体"></a>共同体</h2><p>共同体（共用体、联合体）是一种数据格式，它能存储不同的数据类型，但是，在同一时间只能存储其中的一种类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 共同体名</span><br><span class="line">&#123;</span><br><span class="line">成员一的数据类型  成员名一;</span><br><span class="line">成员二的数据类型  成员名二;</span><br><span class="line">成员三的数据类型  成员名三;</span><br><span class="line">......</span><br><span class="line">成员n的数据类型  成员名n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><strong>共同体占用内存的大小是它最大的成员占用内存的大小</strong>（内存对齐）。</li><li>全部的成员使用同一块内存。</li><li>共同体中的值为最后被赋值的那个成员的值。</li><li>匿名共同体没有名字，可以在定义的时候创建匿名共同体变量（VS和Linux有差别），也可以嵌入结构体中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>       <span class="comment">// 声明超女结构体。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> no;             <span class="comment">// 超女编号。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>              <span class="comment">// 声明匿名共同体。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>        a;</span><br><span class="line"><span class="type">double</span> b;</span><br><span class="line"><span class="type">char</span>     c[<span class="number">21</span>];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> girl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;girl.a的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) &amp;girl.a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;girl.b的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) &amp;girl.b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;girl.c的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) &amp;girl.c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">girl.a = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;girl.a=&quot;</span> &lt;&lt; girl.a &lt;&lt; endl;</span><br><span class="line">girl.b = <span class="number">8.8</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;girl.a=&quot;</span> &lt;&lt; girl.a &lt;&lt; endl;</span><br><span class="line"><span class="built_in">strcpy</span>(girl.c, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;girl.c=&quot;</span> &lt;&lt; girl.c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ul><li>应用：当某些量仅由有限个整型数据值组成时</li><li>枚举常量是整型常量，用于限制变量的取值范围</li><li>增强程序看可读性：定义标志变量</li><li>MON后面常量依次加1，相当于宏定义</li></ul><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义的第一个给定初值，后面依次累计;若不给定初值则默认从0开始</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    MON=<span class="number">1</span>,</span><br><span class="line">    TUE,<span class="comment">//等价于TUE=2</span></span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">&#125;Week;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    Week today;</span><br><span class="line">    today=FRI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,today);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum weeks =&#123;SUN=7,MON=1,TUE,WED,THU,FRI,SAT&#125;//枚举类型声明</span></span><br><span class="line"><span class="comment">// typedef enum weeks =&#123;SUN=7,MON=1,TUE,WED,THU,FRI,SAT&#125; WEEKS;//定义别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //定义变量</span></span><br><span class="line"><span class="comment">// enum weeks today;</span></span><br><span class="line"><span class="comment">// WEEKS today;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h3><ul><li>这是c++11引入的新特性</li><li>默认底层是int，可以修改成char型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//声明变量初始化</span></span><br><span class="line">Color myColor = Color::Red;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="keyword">if</span> (myColor == Color::Green) &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示类型转换</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">int</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> colorValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Color::Red);</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制底层类型，改为char型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Flag</span> : <span class="type">char</span> &#123; Increase, Decrease, Reached &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><strong>作用域</strong>：enum 中定义的枚举值在同一作用域下是全局可见的，而 enum class 中定义的枚举值是由该枚举类限定作用域的，需要通过类名进行访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 全局可见</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 通过 Animal:: 访问</span></span><br></pre></td></tr></table></figure></li><li><strong>默认底层类型</strong>：enum 的枚举值使用整数类型作为底层类型，默认为int，而 enum class 的枚举值也使用整数类型作为底层类型，默认为无符号整数int<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 默认底层类型为 int</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 默认底层类型为 int</span></span><br></pre></td></tr></table></figure></li><li><strong>类型安全性</strong>：enum class 提供了更强的类型安全性。枚举值之间不会进行隐式的整数转换，不会与其他类型进行隐式转换，需要显式地进行类型转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> color = Red; <span class="comment">// 合法，隐式转换为 int</span></span><br><span class="line"><span class="type">int</span> animal = Animal::Cat; <span class="comment">// 非法，需要显式转换为 int</span></span><br><span class="line"><span class="type">int</span> cat = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Animal::Cat); <span class="comment">// 合法，显式转换为 int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><strong>命名空间污染</strong>：enum 中的枚举值会污染全局命名空间，可能会导致命名冲突，而 enum class 中的枚举值是由该枚举类限定作用域的，不会污染全局命名空间。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 可能会与其他全局变量或枚举值冲突</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 限定作用域，不会与其他变量或枚举值冲突</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>引用变量是C++新增的复合类型。</li><li>引用是已定义的变量的别名。</li><li>引用的主要用途是用作函数的形参和返回值。<br>声明&#x2F;创建引用的语法：<strong>数据类型 &amp;引用名&#x3D;原变量名;</strong></li></ul><p><strong>注意</strong></p><ol><li>引用的数据类型要与原变量名的数据类型相同</li><li>引用名和原变量名可以互换，它们值和内存单元是相同的</li><li><strong>必须在声明引用的时候初始化</strong>，初始化后不可改变</li><li>C和C++用&amp;符号来指示&#x2F;取变量的地址，C++给&amp;符号赋予了另一种含义<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 / 创建引用的语法：数据类型 &amp; 引用名 = 原变量名;</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;          <span class="comment">// 声明普通的整型变量。</span></span><br><span class="line"><span class="type">int</span>&amp; ra = a;      <span class="comment">// 创建引用ra，ra是a的别名。</span></span><br><span class="line"><span class="comment">// 语法：数据类型 * const 变量名;</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> rb = &amp;a;         <span class="comment">//声明指针常量rb，让它指向变量a。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a  &lt;&lt; <span class="string">&quot;， a的值是：&quot;</span> &lt;&lt;  a  &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra的值是：&quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ra = <span class="number">5</span>;    </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;， a的值是：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra的值是：&quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h2><p><strong>引用是指针常量的伪装。</strong></p><ul><li>引用是编译器提供的一个有用且安全的工具，去除了指针的一些缺点，禁止了部分不安全的操作。</li><li>变量：变量就是一个在程序执行过程中可以改变的量。</li><li>换一个角度，变量是一块内存区域的名字，它代表了这块内存区域，当我们对变量进行修改的时候，会引起内存区域中内容的改变。</li><li>在计算机看来，内存区域根本就不存在什么名字，它仅有的标志就是它的地址，因此我们若想修改一块内存区域的内容，只有知道他的地址才能实现。</li><li>所谓的变量只不过是编译器给我们进行的一种抽象，让我们不必去了解更多的细节，降低我们的思维跨度而已。</li><li>程序员拥有引用，但编译器仅拥有指针（地址）。</li><li>引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，<strong>编译器还是会把引用解释为指针</strong>。</li><li>引用和指针本质上没有区别。</li></ul><h2 id="引用用于函数的参数"><a href="#引用用于函数的参数" class="headerlink" title="引用用于函数的参数"></a>引用用于函数的参数</h2><ul><li>把函数的形参声明为引用，调用函数的时候，形参将成为实参的别名。</li><li>这种方法也叫按引用传递或传引用。（传值、传地址、传引用只是说法不同，其实都是传值。）</li><li>引用的本质是指针，传递的是变量的地址，在函数中，修改形参会影响实参。<br>1）传引用的代码更简洁。<br>2）传引用不必使用二级指针。<br>3）引用的属性和特别之处。<br><strong>示例1</strong>：普通变量引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>      <span class="comment">// 定义超女结构体。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> no;            <span class="comment">// 超女编号。</span></span><br><span class="line">string str;      <span class="comment">// 表白内容。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func1(st_girl girl)    // 传值。</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// girl.no = 8;</span></span><br><span class="line"><span class="comment">// girl.str = &quot;我有一只小小鸟。&quot;;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; girl.no &lt;&lt; &quot;号：&quot; &lt;&lt; girl.str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void func2(st_girl *girl)    // 传地址。</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// girl-&gt;no = 8;</span></span><br><span class="line"><span class="comment">// girl-&gt;str = &quot;我有一只小小鸟。&quot;;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; girl-&gt;no &lt;&lt; &quot;号：&quot; &lt;&lt; girl-&gt;str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void func3(st_girl &amp; girl)    // 传引用。</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// girl.no = 8;</span></span><br><span class="line"><span class="comment">// girl.str = &quot;我有一只小小鸟。&quot;;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; girl.no &lt;&lt; &quot;号：&quot; &lt;&lt; girl.str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> no, string str)</span>    <span class="comment">// 传值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">no = <span class="number">8</span>; </span><br><span class="line">str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>* no, string* str)</span>    <span class="comment">// 传地址。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*no = <span class="number">8</span>;</span><br><span class="line">*str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; *no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> &amp;no, string &amp;str)</span>    <span class="comment">// 传引用。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">no = <span class="number">8</span>;</span><br><span class="line">str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> bh = <span class="number">3</span>;      <span class="comment">// 超女的编号。</span></span><br><span class="line">string message = <span class="string">&quot;我是一只傻傻鸟。&quot;</span>;          <span class="comment">// 向超女表白的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func1(bh, message);                  // 传值。</span></span><br><span class="line"><span class="comment">//func2(&amp;bh, &amp;message);            // 传地址。</span></span><br><span class="line"><span class="built_in">func3</span>(bh, message);                  <span class="comment">// 传引用。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>示例2</strong>：对二级指针的引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>** p)</span>      <span class="comment">// 传地址，实参是指针的地址，形参是二级指针。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);       <span class="comment">// p是二级指针，存放指针的地址。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func1内存的地址是：&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>*&amp; p)</span>     <span class="comment">// 传引用，实参是指针，形参是指针的别名。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);         <span class="comment">// p是指针的别名。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2内存的地址是：&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;    <span class="comment">// 存放在子函数中动态分配内存的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func1</span>(&amp;p);      <span class="comment">// 传地址，实参填指针p的地址。</span></span><br><span class="line"><span class="comment">//func2(p);      // 传引用，实参填指针p。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main 内存的地址是：&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="引用的形参与const"><a href="#引用的形参与const" class="headerlink" title="引用的形参与const"></a>引用的形参与const</h2><ul><li>如果引用的数据对象类型不匹配，当引用为const时，C++将创建临时变量，让引用指向临时变量</li></ul><p><strong>创建临时变量情况</strong></p><ul><li>引用是const</li><li>数据对象的类型是<strong>正确的，但不是左值</strong><ul><li>左值：左值（value）是一个表达式，可以出现在赋值运算符的左边或右边。通俗地讲，就是可以被赋值的表达式</li><li>在C++中，左值指的是具有存储地址的表达式，或者说是“可寻址”的表达式。比如，变量、数组元素、解引用指针等都是左值。简单地说，如果你能够取得一个表达式的地址，那么这个表达式就是左值</li></ul></li><li>数据对象的<strong>类型不正确，但可以转换为正确的类型</strong></li><li>结论：如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 引用是const，且实参不是左值</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">42</span>); <span class="comment">// 此时会创建一个临时变量int，值为42，然后const引用value指向这个临时变量；42不是左值。在C++中，42是一个整数常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 引用是const，且实参的类型不匹配，但可以转换</span></span><br><span class="line">    <span class="type">double</span> number = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(number); <span class="comment">// 此时会创建一个临时变量int，值为3，然后const引用value指向这个临时变量</span></span><br><span class="line">std::cout&lt;&lt;number;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>引用形参声明为const</strong>的理由有三个：</li></ul><ol><li>使用const可以避免无意中修改数据的编程错误</li><li>使用const使函数能够处理const和非const实参，否则将只能接受非const实参</li><li>使用const，函数能正确生成并使用临时变量</li></ol><ul><li>左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针</li><li>非左值包括字面常量（用双引号包含的字符串除外）和包含多项的表达式</li></ul><h2 id="引用用于函数的返回值"><a href="#引用用于函数的返回值" class="headerlink" title="引用用于函数的返回值"></a>引用用于函数的返回值</h2><ul><li>传统的函数返回机制与值传递类似</li><li>函数的返回值被拷贝到一个临时位置（寄存器或栈），然后调用者程序再使用这个值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m=<span class="built_in">sqrt</span>(<span class="number">36</span>);      <span class="comment">// sqrt()是求平方根函数。</span></span><br><span class="line"><span class="comment">//sqrt(36)的返回值6被拷贝到临时的位置，然后赋值给m。</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">25</span>);</span><br><span class="line"><span class="comment">//sqrt(25)的返回值5被拷贝到临时的位置，然后传递给cout。</span></span><br></pre></td></tr></table></figure></li><li>如果返回的是一个结构体，将把整个结构体拷贝到临时的位置</li><li>如果返回引用不会拷贝内存</li></ul><p><strong>语法</strong></p><ul><li><strong>返回值的数据类型&amp; 函数名(形参列表);</strong><br>注意：</li><li>如果<strong>返回局部变量的引用，其本质是野指针</strong>，后果不可预知。</li><li>可以返回<strong>函数的引用形参、类的成员、全局变量、静态变量</strong>。</li><li>返回引用的函数是被引用的变量的别名，将const用于引用的返回类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> &amp;<span class="title">func2</span><span class="params">(<span class="type">int</span> &amp;ra)</span>    <span class="comment">// 返回的是引用。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra=&quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b = <span class="built_in">func2</span>(a);      <span class="comment">// 返回的是引用。</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;， a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; b的地址是：&quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&quot;， b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="comment">// func2(a) = 10;             // 返回引有的函数是被引用的变量的别名。</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot; a的地址是：&quot; &lt;&lt; &amp;a &lt;&lt; &quot;， a=&quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot; b的地址是：&quot; &lt;&lt; &amp;b &lt;&lt; &quot;， b=&quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="各种形参的使用场景"><a href="#各种形参的使用场景" class="headerlink" title="各种形参的使用场景"></a>各种形参的使用场景</h2><p>如果<strong>不需要在函数中修改实参</strong></p><ul><li>如果实参很小，如C++内置的数据类型或小型结构体，则按值传递。</li><li>如果实参是数组，则使用const指针，因为这是唯一的选择（没有为数组建立引用的说法）。</li><li>如果实参是较大的结构，则使用const指针或const引用。</li><li>如果<strong>实参是类，则使用const引用</strong>，传递类的标准方式是按引用传递（类设计的语义经常要求使用引用）。</li></ul><p><strong>如果需要在函数中修改实参</strong></p><ul><li>实参是内置数据类型，则使用指针。只要看到func(&amp;x)的调用，表示函数将修改x。</li><li><strong>实参是数组</strong>，则只能使用指针。</li><li>实参是结构体，则使用指针或引用。</li><li>实参是类，则使用引用。</li></ul><h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><ul><li>默认参数是指调用函数的时候，如果不书写实参，<strong>那么将使用的一个缺省值</strong>。</li><li>语法：返回值 函数名(数据类型 参数&#x3D;值, 数据类型 参数&#x3D;值,……);<br>注意</li><li>如果函数的声明和定义是分开书写的，在函数声明中书写默认参数，函数的定义中不能书写默认参数。</li><li>函数必须从右到左设置默认参数。也就是说，如果要为某个参数设置默认值，则必须为它后面所有的参数设置默认值。</li><li>调用函数的时候，如果指定了某个参数的值，那么该参数前面所有的参数都必须指定。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="comment">// void func(int bh,string name=&quot;西施&quot;)  //按值传递，修改不会影响实参</span></span><br><span class="line"><span class="comment">// void func(int bh,const string&amp; name=&quot;西施&quot;)  //函数内部只能读取参数值而不能修改它。</span></span><br><span class="line"><span class="comment">// void func(int bh,string&amp; name=&quot;西施&quot;)   //这样会报错,在调用函数时传递一个非引用的字符串，例如string s = &quot;Hello&quot;; P(s);，会导致编译错误。因为非引用的字符串无法绑定到引用参数,所以需要修改为上面的代码</span></span><br><span class="line"><span class="comment">// const string&amp; name=&quot;西施&quot;中的西施相当于非引用字符串，用string&amp; name=&quot;西施&quot;会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh,<span class="type">const</span> string&amp; name=<span class="string">&quot;西施&quot;</span>, <span class="type">const</span> string&amp; message=<span class="string">&quot;我喜欢你。&quot;</span>)</span>    <span class="comment">// 向超女表白的函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;（&quot;</span>&lt;&lt;bh&lt;&lt;<span class="string">&quot;)：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(string&amp; name)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">3</span>,<span class="string">&quot;shdfj&quot;</span>,<span class="string">&quot;我是一只傻傻鸟。&quot;</span>); </span><br><span class="line"><span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string s=<span class="string">&quot;sdj&quot;</span>;</span><br><span class="line"><span class="comment">// func1(&quot;sd&quot;);//这种要报错，因为这是非引用字符串</span></span><br><span class="line"><span class="built_in">func1</span>(s);<span class="comment">//这种不会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul><li>函数重载（函数多态）<strong>是指设计一系列同名函数</strong>，让它们完成相同（似）的工作。</li><li>C++允许定义名称相同的函数，条件是它们的特征（<strong>形参的个数、数据类型和排列顺序）不同</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">short</span> a  ,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a    ,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a    ,string b, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(string b , <span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure></li><li>调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。</li><li>在实际开发中，视需求重载各种数据类型，不要重载功能不同的函数。</li></ul><p><strong>注意</strong></p><ul><li>使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错</li><li>引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征</li><li>如果重载函数有默认参数，调用函数时，可能导致匹配失败</li><li><strong>const不能作为函数重载的特征</strong></li><li>返回值的数据类型不同不能作为函数重载的特征<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>     <span class="comment">// 交换两个整型变量的值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(string&amp; a, string&amp; b)</span>     <span class="comment">// 交换两个字符串变量的值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">myswap</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string c = <span class="string">&quot;西施&quot;</span>, d = <span class="string">&quot;西瓜&quot;</span>;</span><br><span class="line"><span class="built_in">myswap</span>(c, d);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,d=&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul><li>C++<strong>将内联函数的代码组合到程序中</strong>，可以提高程序运行的速度。</li><li>语法：<strong>在函数声明和定义前加上关键字inline</strong>。</li><li>通常的做法是将函数声明和定义写在一起</li><li>相当于将函数以代码的形式写在主函数，避免函数函数调用<br>注意：</li><li>内联函数节省时间，但消耗内存。</li><li>如果函数过大，编译器可能不将其作为内联函数。</li><li>内联函数不能递归。</li></ul><p><strong>优点</strong></p><ul><li>通过避免函数调用所带来保存现场、变量弹栈压栈、跳转新函数、存储函数返回值、执行完返回原现场等开销，提高了程序的运行速度</li><li><strong>缺点</strong>：对程序执行性能有要求且函数不超过10行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> <span class="type">short</span> bh, <span class="type">const</span> string message)</span>   <span class="comment">// 表白函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//show(3, &quot;我是一只傻傻鸟。&quot;);等价下面的函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bh = <span class="number">3</span>;</span><br><span class="line">string message = <span class="string">&quot;我是一只傻傻鸟。&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// show(8, &quot;我有一只小小鸟。&quot;);</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bh = <span class="number">8</span>;</span><br><span class="line">string message = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// show(5, &quot;我是一只小小鸟。&quot;);</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bh = <span class="number">5</span>;</span><br><span class="line">string message = <span class="string">&quot;我是一只小小鸟。&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板1</title>
      <link href="/data.github.io/post/7148eefc.html"/>
      <url>/data.github.io/post/7148eefc.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序变量与常量"><a href="#程序变量与常量" class="headerlink" title="程序变量与常量"></a>程序变量与常量</h1><h2 id="C-输出"><a href="#C-输出" class="headerlink" title="C++输出"></a>C++输出</h2><p>数据是信息的载体，写程序的目的就是为了处理数据。<br><strong>数据的分类</strong><br>数据有数字、字符和字符串三种类型。</p><ul><li>数字：直接书写，如：100、18.52、0、9；</li><li>字符：用半角的单引号包含的一个符号，如：’A’、’Z’、’0’、’9’、’~’、’+’，汉字和全角的标点符号不是字符；</li><li>字符串：用半角的双引号包含的多个符号，如：”Hello World”、”我是一只傻鸟”、”西施”、”100”、”X”。</li></ul><p><strong>输出数据</strong></p><ul><li>std::cout可以输出各种类型的数据；</li><li>&lt;&lt;操作符可以拼接多个数据项；</li><li>std::endl也可以用于换行；</li><li>using namespace std;指定缺省的命名空间。</li></ul><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>变量是内存变量的简称，用于存放数据。<br><strong>声明变量</strong></p><ul><li><p>变量在使用之前要先声明。</p></li><li><p><strong>语法：数据类型 变量名</strong></p></li><li><p>C++常用的数据类型有五种：整数（int）、浮点数（float和double）、字符（char）、字符串（string）和布尔（bool）。</p></li><li><p>变量在声明的时候可以赋初始值。</p></li><li><p>语法：数据类型 变量名&#x3D;值<br><strong>变量的赋值</strong>：变量名&#x3D;值<br>3）示例</p></li><li><p>注意，布尔型变量输出的时候，如果值是true，将显示1，false显示0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数，程序从这里开始执行，每个程序只能有一个main函数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 整数（int）、浮点数（float和double）、字符（char）、字符串（string）和布尔（bool）。</span></span><br><span class="line">    <span class="comment">// 超女基本信息：姓名、年龄、体重、性别、颜值。</span></span><br><span class="line">    <span class="comment">// 声明变量，存放超女基本信息的数据项。</span></span><br><span class="line">    string name = <span class="string">&quot;西施&quot;</span>;         <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">25</span>;                 <span class="comment">// 年龄。</span></span><br><span class="line">    <span class="type">double</span> weight = <span class="number">48.6</span>;        <span class="comment">// 体重（kg）。</span></span><br><span class="line">    <span class="type">char</span> sex = <span class="string">&#x27;X&#x27;</span>;                <span class="comment">// 性别：X-女；Y-男。</span></span><br><span class="line">    <span class="type">bool</span> yz = <span class="literal">false</span>;               <span class="comment">// 颜值：true-漂亮；false-不漂亮。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;，体重：&quot;</span> &lt;&lt; weight </span><br><span class="line">         &lt;&lt; <span class="string">&quot;，性别：&quot;</span> &lt;&lt; sex &lt;&lt; <span class="string">&quot;，颜值：&quot;</span> &lt;&lt; yz &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    name = <span class="string">&quot;冰冰&quot;</span>;           <span class="comment">// 字符串有双引号包含。</span></span><br><span class="line">    age = <span class="number">23</span>;                <span class="comment">// 整数直接书写。</span></span><br><span class="line">    weight = <span class="number">50.5</span>;           <span class="comment">// 浮点数直接书写。</span></span><br><span class="line">    sex = <span class="string">&#x27;X&#x27;</span>;                <span class="comment">// 字符用单引号包含。</span></span><br><span class="line">    yz = <span class="literal">true</span>;                <span class="comment">// 布尔型取值只能是true和false，或1和0。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;，体重：&quot;</span> &lt;&lt; weight</span><br><span class="line">         &lt;&lt; <span class="string">&quot;，性别：&quot;</span> &lt;&lt; sex &lt;&lt; <span class="string">&quot;，颜值：&quot;</span> &lt;&lt; yz &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用常量"><a href="#使用常量" class="headerlink" title="使用常量"></a>使用常量</h2><p>常量是程序中固定不变的数据。<br><strong>宏常量</strong></p><ul><li>一般在main函数的上面声明，用大写命名。</li><li>语法：<code>#define 常量名 值</code></li></ul><p><strong>const修饰的变量</strong></p><ul><li>在程序的任何地方都可以声明。</li><li>语法：<strong>const 数据类型 常量名&#x3D;值</strong></li></ul><p><strong>常量的特点</strong></p><ul><li>程序中不允许改变常量的值，否则编译的时候会报错。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MONTHS 12               <span class="comment">// 一年中的月份数。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI              3.14159    <span class="comment">// 圆周率。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="comment">// main函数，程序从这里开始执行，每个程序只能有一个main函数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> days = <span class="number">7</span>;          <span class="comment">// 一个星期中的天数。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一年有&quot;</span> &lt;&lt; MONTHS &lt;&lt; <span class="string">&quot;个月。&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆周率的值是：&quot;</span> &lt;&lt; PI &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一个星期有&quot;</span> &lt;&lt; days &lt;&lt; <span class="string">&quot;天。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="标识符的命名"><a href="#标识符的命名" class="headerlink" title="标识符的命名"></a>标识符的命名</h2><h3 id="C-命名规则"><a href="#C-命名规则" class="headerlink" title="C++命名规则"></a>C++命名规则</h3><p>C++规定给标识符（变量、常量、函数、结构体、类等）命名时，必须遵守以下规则。<br>-在名称中只能使用字母字符、数字和下划线；</p><ul><li>名称的第一个字符不能是数字；</li><li>名称区分大写字符与小写字符；</li><li>不能将C++关键字用作名称；</li><li>以下划线和大写字母打头的名称被保留给编译器及其使用的资源使用，如果违反了这一规则，会导致行为的不确定性。</li><li>C++对名称的长度没有限制，但有些平台可能有长度限制（64字符）。</li><li>C++提倡有一定含义的名称（望名知义）。</li></ul><h3 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h3><ul><li>关键字也叫保留字，是C++预先保留的标识符。</li><li>每个C++关键字都有特殊的含义，用于声明类型、对象、函数、命名空间等，程序中不能声明与关键字同名的标识符。</li></ul><table><thead><tr><th align="left">asm</th><th align="left">do</th><th align="left">if</th><th align="left">return</th><th align="left">typedef</th></tr></thead><tbody><tr><td align="left">auto</td><td align="left">double</td><td align="left">inline</td><td align="left">short</td><td align="left">typeid</td></tr><tr><td align="left">bool</td><td align="left">dynamic_cast</td><td align="left">int</td><td align="left">signed</td><td align="left">typename</td></tr><tr><td align="left">break</td><td align="left">else</td><td align="left">long</td><td align="left">sizeof</td><td align="left">union</td></tr><tr><td align="left">case</td><td align="left">enum</td><td align="left">mutable</td><td align="left">static</td><td align="left">unsigned</td></tr><tr><td align="left">catch</td><td align="left">explicit</td><td align="left">namespace</td><td align="left">static_cast</td><td align="left">using</td></tr><tr><td align="left">char</td><td align="left">export</td><td align="left">new</td><td align="left">struct</td><td align="left">virtual</td></tr><tr><td align="left">class</td><td align="left">extern</td><td align="left">operator</td><td align="left">switch</td><td align="left">void</td></tr><tr><td align="left">const</td><td align="left">false</td><td align="left">private</td><td align="left">template</td><td align="left">volatile</td></tr><tr><td align="left">const_cast</td><td align="left">float</td><td align="left">protected</td><td align="left">this</td><td align="left">wchar_t</td></tr><tr><td align="left">continue</td><td align="left">for</td><td align="left">public</td><td align="left">throw</td><td align="left">while</td></tr><tr><td align="left">default</td><td align="left">friend</td><td align="left">register</td><td align="left">true</td><td align="left">enum class</td></tr><tr><td align="left">delete</td><td align="left">goto</td><td align="left">reinterpret_cast</td><td align="left">try</td><td align="left"></td></tr></tbody></table><h2 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h2><p>程序输入数据的方式有多种。</p><ul><li>从控制台的界面中输入（网页、PC桌面程序、APP程序）；</li><li>从文件中读取；</li><li>从数据库中读取；</li><li>从网络中读取。</li><li>1）用std::cin输入数据</li><li>语法：<strong>std::cin&gt;&gt;变量名;</strong><br>注意：</li><li>a）布尔型变量的值在计算机内部用1（true）和0（false）存储；</li><li>b）程序中可以书写true和false，<strong>也可以书写1和0，其它值将强制转换成1</strong>；</li><li>c）用cin输入时可以填1和0，其它值也强制转换成1；</li><li>d）用cout输出时只显示1和0，不显示true和false。</li><li>如果输入的数据与变量的数据类型不匹配，会导致行为的不确定性。</li></ul><h1 id="算数运算和关系运算"><a href="#算数运算和关系运算" class="headerlink" title="算数运算和关系运算"></a>算数运算和关系运算</h1><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>运算符描述</p><table><thead><tr><th align="left">+</th><th align="left">两个数相加。</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">一个数减另一个数。</td></tr><tr><td align="left">*</td><td align="left">两个数相乘。</td></tr><tr><td align="left">&#x2F;</td><td align="left">分子除以分母。</td></tr><tr><td align="left">%</td><td align="left">取模运算，整除后的余数</td></tr><tr><td align="left">注意：</td><td align="left"></td></tr></tbody></table><ul><li>整数进行除法运算时，如果分母为0，程序将异常退出；</li><li>浮点数进行除法运算时，如果分母为0.0，将得到inf（infinite，无穷大）；</li><li>两个整数进行除法运算时，将舍去小数部分，得到一个整数；</li><li>整数与浮点数进行除法运算时，得到的结果是浮点数；</li><li>进行除法运算时，在整数前面加(float)或(double)可以将整数转换为float或double类型；</li><li>取模运算只能用于整数（分母也不能为0）。</li></ul><h2 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h2><p>运算符描述</p><table><thead><tr><th align="left">++变量名</th><th align="left">先把变量的值加1，然后再执行表达式。</th></tr></thead><tbody><tr><td align="left">变量名++</td><td align="left">先执行表达式，再把变量的值加1。</td></tr><tr><td align="left">–变量名</td><td align="left">先把变量的值减1，然后再执行表达式。</td></tr><tr><td align="left">变量名–</td><td align="left">先执行表达式，再把变量的减1。</td></tr></tbody></table><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><p><strong>赋值运算</strong><br>运算符示例描述</p><ul><li>&#x3D;：c &#x3D; a + b; 将把a + b的值赋给c。<ul><li>把右边操作数的值赋给左边操作数。</li></ul></li><li>+&#x3D;：c +&#x3D; a; 相当于 c &#x3D; c + a;<ul><li>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数。</li></ul></li><li>-&#x3D;：c -&#x3D; a; 相当于 c &#x3D; c - a;<ul><li>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数。</li></ul></li><li><code>*=：c *= a; 相当于 c = c * a</code>;<ul><li>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数。</li></ul></li><li>&#x2F;&#x3D;：c &#x2F;&#x3D; a; 相当于 c &#x3D; c &#x2F; a;<ul><li>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数。</li></ul></li><li>%&#x3D;：c %&#x3D; a; 相当于 c &#x3D; c % a;<ul><li>求余数且赋值运算符，求两个操作数的模赋值给左边操作数，浮点数不适用取余数。<br>注意：</li></ul></li><li>字符串（string）只能使用等号（&#x3D;）赋值，不能使用其它的赋值运算符；</li><li><strong>浮点数不能使用%&#x3D;运算符</strong>；</li><li>等号（&#x3D;）赋值运算符可以连续使用；</li><li>如果赋值运算符两边操作数的数据类型不同，C++将自动转换数据类型，可能会损失精度，也可能超出取值范围，如果转换不成功，编译时会报错。</li></ul><h2 id="C-11初始化赋值"><a href="#C-11初始化赋值" class="headerlink" title="C++11初始化赋值"></a>C++11初始化赋值</h2><p>1）C++和C++11初始化赋值</p><ul><li>把值写在小括号中，等于号可以省略（C++标准）</li><li>int a&#x3D;16;</li><li>int a&#x3D;(15);  &#x2F;&#x2F; 声明变量a，初始化值为15。</li><li>int b(20);   &#x2F;&#x2F; 声明变量b，初始化值为20。<br>把值写在花括号中，等于号也可以省略（C++11标准），统一初始化列表。</li><li>int a&#x3D;{15};  &#x2F;&#x2F; 声明变量a，初始化值为15。</li><li>int b{20};   &#x2F;&#x2F; 声明变量b，初始化值为20。<br>注意：在Linux平台下，编译需要加-std&#x3D;c++11参数。</li></ul><h2 id="关系预算"><a href="#关系预算" class="headerlink" title="关系预算"></a>关系预算</h2><p>用于比较两个表达式的值，运算的结果为<strong>1-true和0-false</strong>。<br>1）关系运算<br>关系数学的表示C++的表示</p><table><thead><tr><th align="left">等于</th><th align="left">&#x3D;</th><th align="left">&#x3D;&#x3D;</th></tr></thead><tbody><tr><td align="left">不等于</td><td align="left">≠</td><td align="left">!&#x3D;</td></tr><tr><td align="left">小于</td><td align="left">&lt;</td><td align="left">&lt;</td></tr><tr><td align="left">小于等于</td><td align="left">≤</td><td align="left">&lt;&#x3D;</td></tr><tr><td align="left">大于</td><td align="left">&gt;</td><td align="left">&gt;</td></tr><tr><td align="left">大于等于</td><td align="left">≥</td><td align="left">&gt;&#x3D;</td></tr><tr><td align="left">注意：</td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>关系运算符的两边可以是数值，也可以是表达式；</li><li>用std::cout输出关系运算表达式时，关系表达式要加括号；</li><li>关系运算也适用于字符串（string），字符串常用的关系运算是&#x3D;&#x3D;和!&#x3D;，其它的基本上不用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="comment">// main函数，程序从这里开始执行，每个程序只能有一个main函数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">7</span>;</span><br><span class="line">    <span class="type">bool</span> result;</span><br><span class="line">    result = a &lt;= b<span class="number">-3</span>;            <span class="comment">// a和b先做比较（关系）运算，然后再赋值给result。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result=&quot;</span> &lt;&lt; result &lt;&lt; endl;    <span class="comment">// 关系运算表达式需要括号，算术运算表达式可以不用括号。</span></span><br><span class="line"></span><br><span class="line">    string str1 = <span class="string">&quot;西施&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;西瓜&quot;</span>;</span><br><span class="line">    cout &lt;&lt; (str1 &gt;= str2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>根据给定的逻辑因子（表达式或值）返回一个新的逻辑因子。<br>![[Pasted image 20231222112251.png]]      |<br>注意：</p><ul><li>逻辑运算符的两边可以是数值，也可以是表达式；</li><li>用std::cout输出逻辑运算表达式时，逻辑表达式要加括号；</li><li>在实际开发中，逻辑运算的多重组合是重点。</li></ul><h2 id="逗号运算"><a href="#逗号运算" class="headerlink" title="逗号运算"></a>逗号运算</h2><p>把一行语句中的多个表达式连接起来，程序将从左到右执行表达式。<br>语法：<strong>表达式一,表达式二,……,表达式n;</strong></p><ul><li>逗号运算常用于声明多个变量。</li><li>也可以用于其它语句中，但是，逗号运算符是所有运算符中级别最低的，以下两个表达式的效果是不同的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数，程序从这里开始执行，每个程序只能有一个main函数。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*int a =10, b=20;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">//b = a = 2, a * 2;</span></span><br><span class="line">    b = (a = <span class="number">2</span>, a * <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="运算的优先级"><a href="#运算的优先级" class="headerlink" title="运算的优先级"></a>运算的优先级</h2><p>一个表达式可以包含多个运算符，运算符的优先级决定了表达式各部分的执行顺序。</p><ul><li>例如，按照运算规则， <code>*的优先级比+高，所以的b * c将先执行</code>：a + b * c;</li><li>如果想让a + b先执行，则必须使用括号：(a + b) * c;</li><li>如果一个表达式中操作符的优先级相同，那么它们的结合律（associativity）决定了它们的执行顺序（从左到右或从右到左）。例如，算术运算的组合方式是从左到右，赋值运算则是从右到左。如下：</li></ul><table><thead><tr><th align="left">表达式</th><th align="left">结合律</th><th align="left">组合方式</th></tr></thead><tbody><tr><td align="left">a&#x2F;b%c</td><td align="left">从左到右</td><td align="left">(a&#x2F;b)%c</td></tr><tr><td align="left">a&#x3D;b&#x3D;c</td><td align="left">从右到左</td><td align="left">a&#x3D;(b&#x3D;c)</td></tr><tr><td align="left">下表是全部运算符的优先级和结合律</td><td align="left"></td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th><th align="left">名称或含义</th><th align="left">使用形式</th><th align="left">结合方向</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">[]</td><td align="left">下标</td><td align="left"><code>地址[表达式]</code></td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">()</td><td align="left">圆括号</td><td align="left">（表达式）&#x2F;函数名(形参表)</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">.</td><td align="left">成员选择（对象）</td><td align="left">对象.成员名</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">-&gt;</td><td align="left">成员选择（指针）</td><td align="left">对象指针-&gt;成员名</td><td align="left">左到右</td></tr><tr><td align="left">2</td><td align="left">-</td><td align="left">负号运算符</td><td align="left">-表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">(类型)</td><td align="left">强制类型转换</td><td align="left">(数据类型)表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">++</td><td align="left">前置自增运算符</td><td align="left">++变量名</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">++</td><td align="left">后置自增运算符</td><td align="left">变量名++</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">–</td><td align="left">前置自减运算符</td><td align="left">–变量名</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">–</td><td align="left">后置自减运算符</td><td align="left">变量名–</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">*</td><td align="left">取值运算符</td><td align="left"><code>*指针变量</code></td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">&amp;</td><td align="left">取地址运算符</td><td align="left">&amp;变量名</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">!</td><td align="left">逻辑非运算符</td><td align="left">!表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">~</td><td align="left">按位取反运算符</td><td align="left">~表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">sizeof</td><td align="left">长度运算符</td><td align="left">sizeof(表达式)</td><td align="left">右到左</td></tr><tr><td align="left">3</td><td align="left">&#x2F;</td><td align="left">除</td><td align="left">表达式&#x2F;表达式</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">*</td><td align="left">乘</td><td align="left"><code>表达式*表达式</code></td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">%</td><td align="left">余数（取模）</td><td align="left">整型表达式&#x2F;整型表达式</td><td align="left">左到右</td></tr><tr><td align="left">4</td><td align="left">+</td><td align="left">加</td><td align="left">表达式+表达式</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">-</td><td align="left">减</td><td align="left">表达式-表达式</td><td align="left">左到右</td></tr><tr><td align="left">5</td><td align="left">&lt;&lt;</td><td align="left">左移</td><td align="left">变量</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">&gt;&gt;</td><td align="left">右移</td><td align="left">变量&gt;&gt;表达式</td><td align="left">左到右</td></tr><tr><td align="left">6</td><td align="left">&gt;</td><td align="left">大于</td><td align="left">表达式&gt;表达式</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">&gt;&#x3D;</td><td align="left">大于等于</td><td align="left">表达式&gt;&#x3D;表达式</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">&lt;</td><td align="left">小于</td><td align="left">表达式</td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">&lt;&#x3D;</td><td align="left">小于等于</td><td align="left">表达式</td><td align="left">左到右</td></tr><tr><td align="left">7</td><td align="left">&#x3D;&#x3D;</td><td align="left">等于</td><td align="left"><code>表达式==表达式</code></td><td align="left">左到右</td></tr><tr><td align="left"></td><td align="left">!&#x3D;</td><td align="left">不等于</td><td align="left">表达式!&#x3D; 表达式</td><td align="left">左到右</td></tr><tr><td align="left">8</td><td align="left">&amp;</td><td align="left">按位与</td><td align="left">表达式&amp;表达式</td><td align="left">左到右</td></tr><tr><td align="left">9</td><td align="left">^</td><td align="left">按位异或</td><td align="left">表达式^表达式</td><td align="left">左到右</td></tr><tr><td align="left">10</td><td align="left">按位或</td><td align="left">按位或</td><td align="left">表达式</td><td align="left">表达式</td></tr><tr><td align="left">11</td><td align="left">&amp;&amp;</td><td align="left">逻辑与</td><td align="left">表达式&amp;&amp;表达式</td><td align="left">左到右</td></tr><tr><td align="left">12</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">逻辑或</td></tr><tr><td align="left">13</td><td align="left">?:</td><td align="left">条件运算符</td><td align="left">表达式1? 表达式2: 表达式3</td><td align="left">右到左</td></tr><tr><td align="left">14</td><td align="left">&#x3D;</td><td align="left">赋值运算符</td><td align="left">变量&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">&#x2F;&#x3D;</td><td align="left">除后赋值</td><td align="left">变量&#x2F;&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left"><code>*=</code></td><td align="left">乘后赋值</td><td align="left"><code>变量*=表达式</code></td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">%&#x3D;</td><td align="left">取模后赋值</td><td align="left">变量%&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">+&#x3D;</td><td align="left">加后赋值</td><td align="left">变量+&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">-&#x3D;</td><td align="left">减后赋值</td><td align="left">变量-&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">&lt;&lt;&#x3D;</td><td align="left">左移后赋值</td><td align="left">变量</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">&gt;&gt;&#x3D;</td><td align="left">右移后赋值</td><td align="left">变量&gt;&gt;&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">&amp;&#x3D;</td><td align="left">按位与后赋值</td><td align="left">变量&amp;&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left">^&#x3D;</td><td align="left">按位异或后赋值</td><td align="left">变量^&#x3D;表达式</td><td align="left">右到左</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">&#x3D;</td><td align="left">按位或后赋值</td><td align="left">变量</td></tr><tr><td align="left">15</td><td align="left">,</td><td align="left">逗号运算符</td><td align="left">表达式,表达式,…</td><td align="left">左到右</td></tr><tr><td align="left">注意：</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>如果不确定运算符的优先级，可以加括号；</li><li>多用括号，让代码的可读性更好。</li></ul><h1 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><ul><li>最后一个else可以没有<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式一)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 表达式一为真时执行的语句。</span></span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (表达式n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 表达式n为真时执行的语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 全部表达式都不为真时执行的语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h2><ul><li>三目运算也叫条件运算或三元运算，可以实现简单if语句的功能，但是书写更简洁。</li><li>语法： <strong>表达式一 ? 表达式二 : 表达式三</strong></li><li>先计算表达式一的值，如果为真，整个表达式的结果为表达式二的值，如果为假，整个表达式的结果为表达式三的值。</li></ul><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch也是一种选择结构的语句，可以代替简单的多条件的if语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 值一: </span><br><span class="line">       语句一; </span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值二: </span><br><span class="line">       语句二; </span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> 值n: </span><br><span class="line">       语句n; </span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">       上述条件都不满足时执行的语句; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>case后面必须是整数和字符，或者是结果为整数和字符的表达式，但不能使用变量。</li><li>default不是必须的，当没有default时，如果全部的case匹配失败，那么就什么都不执行。</li><li>每个分支不要漏写break;语句。</li></ul><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125; <span class="keyword">while</span> (表达式);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="循环跳转"><a href="#循环跳转" class="headerlink" title="循环跳转"></a>循环跳转</h2><ul><li>break和continue两个关键字用于控制循环体中代码的执行流程。</li><li>break跳出（中止）当前循环语句。</li><li>continue回到当前循环语句的首部。</li></ul><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句一 ; 表达式 ; 语句二)</span><br><span class="line">&#123;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在for循环的语句一中，可以声明计数器变量。</li><li>在for循环中，语句一、表达式和语句二都可以为空，for (;;)等同于while (true)。</li><li>continue和break两个关键字也可以用在for循环体中。</li></ul><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><ul><li>goto语句也称为无条件转移语句。</li><li>goto的语法：<strong>goto 语句标号;</strong></li><li>语句标号的语法：语句标号:</li><li>如果在程序中使用了goto，程序的流程将跳转到语句标号的位置，并执行它后面的代码。</li><li>其中语句标号是按标识符规定书写的符号，放在某一语句行的前面，可以独占一行，标号后加半角冒号。</li><li>语句标号用于标识语句的位置，与goto语句配合使用。</li><li>在实际开发中，<strong>goto语句容易造成程序流程的混乱，不方便理解</strong>，调试也更麻烦，不建议使用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>;;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x%<span class="number">5</span>==<span class="number">1</span> &amp;&amp; x%<span class="number">6</span>==<span class="number">5</span> &amp;&amp; x%<span class="number">7</span>==<span class="number">4</span> &amp;&amp; x%<span class="number">11</span>==<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d\n&quot;</span>,x );</span><br><span class="line"><span class="keyword">goto</span> END;<span class="comment">//无条件转向语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">END: ;<span class="comment">//标识（标识符）后面必须有语句，哪怕是空语句</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="函数声明与定义"><a href="#函数声明与定义" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">声明和定义函数的语法：</span><br><span class="line">返回值的数据类型 函数名(参数一的数据类型 参数一, 参数二的数据类型 参数二,……)</span><br><span class="line">&#123;</span><br><span class="line">    实现函数功能的代码。</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数的声明：让编译器知道函数的存在，包括返回值的数据类型、函数名和参数列表<br><strong>注意：</strong></li><li>函数的声明和定义可以书写在一起，也可以分开，如果书写在一起，一般放在main函数的上面，如果分开，一般在main函数的上面声明，在main函数的下面定义。</li><li>如果函数的声明和定义分开书写，函数的声明后面一定要有分号，函数的定义后面一定不能写分号。</li><li>在同一个程序中，函数只需要声明和定义一次，也可以多次声明，但只能定义一次。</li><li>函数的声明必须和函数的定义一致（返回值的数据类型、函数名和参数列表），如果函数名和参数列表不同，表示它们不是同一个函数。</li><li>return语句返回值的数据类型必须与函数的声明一致。</li><li>在函数体中，return语句可以多次使用。</li><li>如果函数的重点是实现功能，不关心返回值，返回值的数据类型填void，return语句后面就空着。</li><li>函数可以没有任何参数。</li><li>函数名是标识符，必须满足标识符的命名规则。</li></ul><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>语法：<strong>函数名(参数一,参数二,……)</strong><br>注意：</p><ul><li><strong>声明函数的代码必须放在调用之前</strong>，定义函数的代码可以放在调用之后。</li><li>调用函数的时候，参数列表必须与函数的声明一致（参数的个数、书写的顺序和数据类型）</li><li>不管在什么地方，都不能调用main函数，但是，在普通函数中，可以调用其它的普通函数</li><li>调用函数的代码可以独占一条语句，也可以用于表达式（赋值运算、算术运算、关系运算、函数的参数）</li><li>如果函数用于表达式中，返回值的数据类型要匹配（否则可能会被隐式转换或编译错误）</li><li>如果函数有返回值，可以不关心它</li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul><li><strong>作用域是指程序中变量存在（或生效）的区域</strong>，超过该区域变量就不能被访问。</li><li>变量分全局变量和局部变量两种，全局变量在整个程序中都可以访问，局部变量只能在函数或语句块的内部才能访问。</li></ul><p>C++中定义变量的场景主要有五种：</p><ol><li>在全部函数外面定义的是全局变量。</li><li>在头文件中定义的是全局变量。</li><li>在函数和语句块内部定义的是局部变量。</li><li>函数的参数是该函数的局部变量。</li><li>函数内部用static修饰的是<strong>静态局部变量</strong>。</li></ol><p><strong>全局变量</strong></p><ul><li>在整个程序生命周期内都是有效的，在定义位置之后的任意函数中都能访问。</li><li>全局变量在<strong>主程序退出时由系统收回内存空间</strong></li></ul><p><strong>局部变量</strong></p><ul><li>在函数或语句块内部的语句使用，在函数或语句块外部是不可用的。</li><li>局部变量在函数返回或<strong>语句块结束时由系统收回内存空间</strong></li></ul><p><strong>静态局部变量</strong></p><ul><li><strong>用static修饰的局部变量生命周期和程序相同</strong>，并且只会被初始化一次。</li><li>其作用域为局部，当定义它的函数或语句块结束时，<strong>其作用域随之结束</strong>，但是下次用于用到这个变量上次的值</li><li>当程序想要使用全局变量的时候应该先考虑使用static（考虑到数据安全性）。</li></ul><p><strong>注意事项</strong></p><ul><li>全局变量和静态局部变量自动初始化为0。</li><li>局部变量不会自动初始化，其值是不确定的，程序中应该有初始化局部变量的代码，否则编译可能会报错（不同的编译器不一样）。</li><li>局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，<strong>就会屏蔽全局变量而使用局部变量</strong>，如果想使用全局变量，可以在变量名前加两个冒号（::）。</li><li>for循环初始化语句中定义的变量的作用域是for语句块。</li></ul><h2 id="函数参数的传递"><a href="#函数参数的传递" class="headerlink" title="函数参数的传递"></a>函数参数的传递</h2><p>调用函数的时候，调用者把数值赋给了函数的参数。</p><ul><li>实参：调用者程序中书写的在函数名括号中的参数，可以是常量、变量和表达式。</li><li>形参：函数的参数列表。<br>在函数定义的代码中，修改形参的值，会不会影响实参。</li></ul><h2 id="函数分文件编写"><a href="#函数分文件编写" class="headerlink" title="函数分文件编写"></a>函数分文件编写</h2><ul><li>头文件<code>（*.h）</code>：需要包含的头文件，声明全局变量，函数的声明，数据结构和类的声明等。</li><li>源文件<code>（*.cpp）</code>：函数的定义、类的定义。</li><li>主程序：main函数，程序的核心流程，需要用#include “头文件名”把头文件包含进来。</li><li>编译：</li><li><code>#pragma once</code> 是C++中的预处理指令，用于确保头文件只被编译一次。当多个文件包含同一个头文件时，使用 <code>#pragma once</code> 可以避免重复包含同一个头文件导致的编译错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*demo01.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span>         <span class="comment">// 包含头文件tools.h，min和max函数在里面。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;girls.h&quot;</span>          <span class="comment">// 包含头文件girls.h，print函数在里面。</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;max(5,8)=&quot;</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min(5,8)=&quot;</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*girls.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;girls.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> no, string str)</span>   <span class="comment">// 表白神器。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tools.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>    <span class="comment">// 比较两个数的大小，返回较大者。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>    <span class="comment">// 比较两个数的大小，返回较小者。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*girls.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> no, string str)</span></span>;   <span class="comment">// 表白神器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*toolss.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;    <span class="comment">// 比较两个数的大小，返回较大者。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;    <span class="comment">// 比较两个数的大小，返回较小者。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="c-数据类型上"><a href="#c-数据类型上" class="headerlink" title="c++数据类型上"></a>c++数据类型上</h1><h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符用于求数据类型或变量占用的内存空间。</p><ul><li>用于数据类型：sizeof(数据类型)</li><li>用于变量：sizeof(变量名) 或 sizeof 变量名<br>注意：</li><li>在32位和64位操作系统中，同一种数据类型占用的内存空间可能不一样。</li><li>字符串（string）不是C++的基本数据类型，用sizeof求它占用内存的大小没有意义。<br>![[Pasted image 20231222200833.png]]</li></ul><h2 id="获取类型名"><a href="#获取类型名" class="headerlink" title="获取类型名"></a>获取类型名</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类型名称：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(num).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value = <span class="number">3.14</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类型名称：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(value).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类型名称：&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(str).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><ul><li>C++用int关键字来声明整型变量（int 是 integer 的简写）。</li><li>在声明整型变量的时候，可以在int关键字之前加signed、unsigned、short和long四种修饰符。</li><li>signed：有符号的，可以表示正数和负数。</li><li>unsigned：无符号的，只能表示正数，例如超女的身高和体重等。</li><li>short：短的，取值范围小，占用内存少。</li><li>long：长的，取值范围大，占用内存多。</li></ul><table><thead><tr><th align="left">类型简写</th><th align="left">类型全程</th><th align="left">长度</th><th align="left">取值范围</th></tr></thead><tbody><tr><td align="left">short</td><td align="left">signed short int</td><td align="left">2字节</td><td align="left">-32768~32767</td></tr><tr><td align="left">unsigned short</td><td align="left">unsigned short int</td><td align="left">2字节</td><td align="left">0~65535</td></tr><tr><td align="left">int</td><td align="left">signed int</td><td align="left">4字节</td><td align="left">-2147483648~2147483647</td></tr><tr><td align="left">unsigned</td><td align="left">unsigned int</td><td align="left">4字节</td><td align="left">0~4294967295</td></tr><tr><td align="left">unsigned long</td><td align="left">unsigned long int</td><td align="left">8字节</td><td align="left">0~18446744073709551615</td></tr><tr><td align="left">long</td><td align="left">signed long int</td><td align="left">8字节</td><td align="left">-9223372036854775808~9223372036854775807</td></tr></tbody></table><p><strong>注意</strong></p><ul><li>整数的取值范围与计算机操作系统和C++语言编译器有关，没有一个固定的数值，我们可以根据它占用的内存大小来推断它的取值范围</li><li>一个字节有8个位，表示的数据的取值范围是$2^8-1$，即255</li><li>如果占用的内存是两个字节，无符号型取值范围是$2^8ⅹ2^8-1$</li><li>如果占用的内存是四个字节，无符号型取值范围是$2^8ⅹ2^8ⅹ2^8ⅹ2^8-1$</li><li>如果占用的内存是八个字节，无符号型取值范围是$2^8ⅹ2^8ⅹ2^8ⅹ2^8ⅹ2^8ⅹ2^8ⅹ2^8ⅹ2^8-1$</li><li>如果是有符号，取值范围减半，<strong>因为符号占一个位</strong></li><li>计算机用最高位1位来表达符号（<strong>0-正数，1-负数</strong>），unsigned修饰过的正整数不需要符号位，在表达正整数的时候比signed修饰的正整数取值大一倍</li><li>给整型变量赋值不能超出它的取值范围，否则能产生不可预后的后果</li><li>在实际开发中，为了防止超出取值范围，应该保证有足够的空间</li></ul><h3 id="整数的书写"><a href="#整数的书写" class="headerlink" title="整数的书写"></a>整数的书写</h3><p>整数默认是十进制，一个表示十进制的数字不需要任何特殊的格式。</p><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>二进制由 0 和 1 两个数字组成，<strong>书写时必须以0b或0B</strong>（不区分大小写）开头。<br>以下是合法的二进制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0b101</span>;      <span class="comment">// 换算成十进制为 5</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0b</span>110010;  <span class="comment">// 换算成十进制为 -50</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0B</span>100001;   <span class="comment">// 换算成十进制为 33</span></span><br></pre></td></tr></table></figure><p>以下是非法的二进制：</p><ul><li>int m &#x3D; 101010;  &#x2F;&#x2F; 无前缀 0B，相当于十进制</li><li>int n &#x3D; 0B410;    &#x2F;&#x2F; 4不是有效的二进制数字</li><li>注意，C++标准并不支持上面的二进制写法，只是有些编译器自己进行了扩展，才支持二进制数字。换句话说，并不是所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本有关系。</li></ul><h4 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h4><p>八进制由 0~7 八个数字组成，<strong>书写时必须以0开头</strong>（注意是数字 0，不是字母 o）。<br>以下是合法的八进制数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">015</span>;      <span class="comment">// 换算成十进制为 13</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0101</span>;    <span class="comment">// 换算成十进制为 -65</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0177777</span>;  <span class="comment">// 换算成十进制为 65535</span></span><br></pre></td></tr></table></figure><p>以下是非法的八进制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">256</span>;  <span class="comment">// 无前缀 0，相当于十进制</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">03</span>A2;  <span class="comment">// A不是有效的八进制数字</span></span><br></pre></td></tr></table></figure><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>十六进制由数字 0<del>9、字母 A</del>F 或 a~f（不区分大小写）组成，<strong>书写时必须以0x或0X（不区分大小写）开头。</strong><br>以下是合法的十六进制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> a = <span class="number">0X2A</span>;   <span class="comment">// 换算成十进制为 42</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">-0XA0</span>;  <span class="comment">// 换算成十进制为 -160</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0xffff</span>;   <span class="comment">// 换算成十进制为 65535</span></span><br></pre></td></tr></table></figure><p>以下是非法的十六进制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = <span class="number">5</span>A;    <span class="comment">// 没有前缀 0X，是一个无效数字</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0X3</span>H;  <span class="comment">// H不是有效的十六进制数字</span></span><br></pre></td></tr></table></figure><h4 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h4><ul><li>在C++中，不要在十进制数前面加0，会被编译器当成八进制。</li><li>还有，不要随便删掉别人程序中整数前面的0，它不是多余的。</li></ul><h3 id="C-11的long-long类型"><a href="#C-11的long-long类型" class="headerlink" title="C++11的long long类型"></a>C++11的long long类型</h3><ul><li>在VS中，long是4字节，32位。      -2147483648~2147483647</li><li>在Linux中，long是8字节，64位。   -9223372036854775808~9223372036854775807</li><li>C++11标准增了long long类型的整数，至少64位，且至少与long一样长。</li><li>在VS中，long long是8字节，64位。 -9223372036854775808~9223372036854775807</li><li>在Linux中，long和long long类型都是8字节，64位。</li></ul><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>C++浮点型分三种：float（单精度）、double（双精度）、long double（扩展精度）。<br>三者的区别是表示有效数字的范围不同。</p><table><thead><tr><th align="left">数据类型</th><th align="left">占用空间</th><th align="left">有效数字范围</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4字节</td><td align="left">7位有效数字          8位</td></tr><tr><td align="left">double</td><td align="left">8字节</td><td align="left">15～16位有效数字    17位</td></tr><tr><td align="left">long double</td><td align="left">不少于double</td><td align="left">不低于double         17位</td></tr><tr><td align="left">注意：</td><td align="left"></td><td align="left"></td></tr></tbody></table><ul><li>在VS和Linux中，long double占用的内存空间分别是8和16字节</li><li><strong>有效数字包括了小数点前面和后面的数字</strong></li><li>C++缺省显示6位有效数字，如果要显示更多的有效数字，可以用printf()函数</li><li>浮点数的存储方法和整数不一样，比较复杂，如无必要，不用研究。</li><li>在实际开发中，用整数代替浮点数，整数的运算更快，精度更高。9223372036854775807<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>           <span class="comment">// 使用printf函数需要包含这个头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// float 7位有效数字；double 15～16位有效数字；long double不低于double</span></span><br><span class="line">    <span class="type">float</span> aa = <span class="number">1234.45f</span>;    cout &lt;&lt; <span class="string">&quot;aa=&quot;</span> &lt;&lt; aa &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> bb = <span class="number">12345123056789.45</span>;    cout &lt;&lt; <span class="string">&quot;bb=&quot;</span> &lt;&lt; bb &lt;&lt; endl;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> cc = <span class="number">12345126789.459</span>;    cout &lt;&lt; <span class="string">&quot;cc=&quot;</span> &lt;&lt; cc &lt;&lt; endl;</span><br><span class="line">    <span class="type">float</span> dd = <span class="number">1223232332334.45f</span>;    cout &lt;&lt; <span class="string">&quot;dd=&quot;</span> &lt;&lt; dd &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;aa=%lf\n&quot;</span>, aa);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bb=%lf\n&quot;</span>, bb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cc=%lf\n&quot;</span>, cc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dd=%lf\n&quot;</span>, dd);<span class="comment">//这里说明了float的有效数字是小数前后之和为7位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符型（char）<strong>占用的内存空间是1个字节</strong>，<strong>书写用单引号包含</strong>。</li><li>在内存中，不存放字符本身，而是存放与它对应的编码，即ASCII码。</li><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是现今最通用的单字节编码方案，包含了33个控制字符（具有特殊含义无法显示的字符）和95个可显示字符。</li><li>ASCII表见百度</li></ul><h3 id="字符本质"><a href="#字符本质" class="headerlink" title="字符本质"></a>字符本质</h3><ul><li>字符的本质是<strong>整数</strong>，<strong>取值范围是0～127</strong>。</li><li>在书写的时候可以用单引号包含，也可以用整数。</li><li>如果书写的时候用单引号包含，程序执行的时候，将把符号解释为对应的整数。</li><li>显示的时候，<strong>把整数解释为对应的符号</strong>，也可以直接显示整数。</li><li>可以与整数进行任何运算，运算的时候，书写方式可以用字符，也可以用整数。</li><li>C++为什么没有提供1字节的整型？</li><li>字符型也可以用unsigned修饰，意义何在？</li></ul><h3 id="C-11的原始字面量"><a href="#C-11的原始字面量" class="headerlink" title="C++11的原始字面量"></a>C++11的原始字面量</h3><ul><li>原始字面量（值）可以直接表示字符串的实际含义，不需要转义和连接。</li><li>语法：R”(字符串的内容)”</li><li>R”xxx(字符串的内容)xxx”</li><li>通过这种方式的字符串可以按照格式直接打印，不需要转义字符等<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用C++11原始字面量</span></span><br><span class="line">    string path1 = <span class="string">R&quot;abcd(C:\Program Files\Microsoft OneDrive\tail\nation)abcd&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;path1 is &quot;</span> &lt;&lt; path1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string str = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">        &lt;no&gt;0001&lt;/no&gt;</span></span><br><span class="line"><span class="string">        &lt;name&gt;西施&lt;/name&gt;</span></span><br><span class="line"><span class="string">        &lt;sc&gt;火树银花&lt;/sc&gt;</span></span><br><span class="line"><span class="string">        &lt;height&gt;170&lt;/height&gt;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的写法错误</span></span><br><span class="line">    <span class="comment">// string ste=&quot;sdfh</span></span><br><span class="line">    <span class="comment">//             sdfjklsd&quot;</span></span><br><span class="line">    <span class="comment">//这种对的</span></span><br><span class="line">    <span class="comment">//string a=&quot;sjdhf\nsdhffj&quot;;</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><ul><li>C++风格字符串：<strong>string 变量名&#x3D;”字符串的内容” ;</strong></li><li>C风格字符串：<strong>char 变量名[]&#x3D;”字符串的内容” ;</strong></li><li>C风格字符串的本质是字符数组，C++风格字符串的本质是类，它封装了C风格字符串。</li></ul><p>C++风格字符串的常用操作：</p><ul><li>赋值：变量名&#x3D;”字符串的内容” ;</li><li>拼接：变量名&#x3D;变量名+”字符串的内容一”+”字符串的内容一”+……+”字符串的内容n” ;</li><li>如果字符串的内容都是常量，不要写加号（+），如果内容很长，可以分成多行书写。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较：支持==、!=、&gt;和&lt;关系运算符，常用的是==和!=。</span><br></pre></td></tr></table></figure></li></ul><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><ul><li>在C和C++中，关系运算和逻辑运算的结果有两种：真和假</li><li>C语言用0表示假，非0表示真</li><li>为了提高代码的可读性，C++新增了 bool 类型，占用1字节的内存，用true表示真，false表示假</li><li>bool类型本质上是1字节的整数（unsigned char），取值只有1和0</li><li>在程序中，书写的时候可以用true和false，编译器把它们解释为1和0</li><li>如果对bool型变量赋非0的值，将转换成1</li><li>用cin输入和cout输出的时候，仍是1和0，不会被解释为true和false</li></ul><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>计算机进行运算时，要求各操作数的类型具有相同的大小和存储方式。<br>在实际开发中，不同类型的数据进行混合运算是基本需求。</p><ul><li>自动类型转换：某些类型的转换编译器可以隐式的进行，不需程序员干预。</li><li>强制类型转换：有些类型的转换需要程序员显式指定。</li></ul><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><ul><li>不同数据类型的差别在于取值范围和精度，数据的取值范围越大，精度越高。</li><li>整型从低到高：char -&gt; short -&gt; int -&gt; long -&gt; long long</li><li>浮点型从低到高：float -&gt; double -&gt; long double</li></ul><p><strong>自动类型转换的规则如下</strong>：</p><ul><li>如果一个表达式中出现了不同类型操作数的混合运算，<strong>较低类型将自动向较高类型</strong>转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">double</span> result = a + b; <span class="comment">// 这里a会被隐式转换为double类型，然后和b相加</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>当表达式中含有浮点型操作数时，所有操作数都将转换为浮点型。</li><li>赋值运算的右值类型与左值类型不一致时，将右值类型提升&#x2F;降低为左值类型。</li><li>赋值运算右值超出了左值类型的表示范围，把该右值截断后赋给左值，所得结果可能毫无意义。</li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>为了让程序设计更灵活，转换的目的更清晰，C++提供了强制类型转换的方法，也称之为显式转换。</li><li>强制类型转换的语法：**(目标类型)表达式或目标类型(表达式)**</li></ul><h2 id="数据类型的别名typedef"><a href="#数据类型的别名typedef" class="headerlink" title="数据类型的别名typedef"></a>数据类型的别名typedef</h2><p>创建数据类型的别名有两个目的：</p><ul><li>为名称复杂的类型创建别名，方便书写和记忆。</li><li>创建与平台无关的数据类型，提高程序的兼容性。</li><li>语法：<strong>typedef 原数据类型名 别名;</strong><br>C++11还可以用using关键字创建数据类型的别名。</li><li>语法：<strong>using 别名&#x3D;原数据类型名;</strong></li></ul><h1 id="指针和内存"><a href="#指针和内存" class="headerlink" title="指针和内存"></a>指针和内存</h1><h2 id="指针的基本概念"><a href="#指针的基本概念" class="headerlink" title="指针的基本概念"></a>指针的基本概念</h2><p><strong>变量的地址</strong></p><ul><li>变量是内存变量的简称，在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的。</li><li>C++用运算符&amp;获取变量在内存中的起始地址。</li><li><strong>语法：&amp;变量名</strong></li></ul><p><strong>指针变量</strong></p><ul><li>指针变量简称指针，它是一种特殊的变量，<strong>专用于存放变量在内存中的起始地址</strong>。</li><li>语法：<code>数据类型 *变量名;</code></li><li>数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。</li><li><code>星号*与乘法中使用的星号是相同</code>的，但是，在这个场景中，星号用于表示这个变量是指针。</li></ul><p><strong>对指针赋值</strong></p><ul><li>不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。我们用整型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；用浮点型指针存放浮点型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址。</li><li>语法：<strong>指针&#x3D;&amp;变量名;</strong></li></ul><p><strong>注意</strong></p><ul><li>对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“<strong>基类型</strong>”。</li><li>如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型。</li></ul><p><strong>指针占用的内存</strong></p><ul><li>指针也是变量，是变量就要占用内存空间。</li><li>在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。</li><li>在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，<code>int*是整型指针类型，int*</code>可以用于声明变量，可以用于sizeof运算符，可以用于数据类型的强制转换，总的来说，把<code>int*当成</code>一种数据类型就是了。</li></ul><h2 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h2><ul><li>声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针</li><li>指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）</li><li><code>*运算符</code>被称为间接值或解除引用（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值，<code>*也是乘法符号</code>，C++根据上下文来确定所指的是乘法还是解引用<br>![[Pasted image 20231222211916.png]]<br>程序在存储数据的时候，必须跟踪三种基本属性：</li><li>数据存储在哪里</li><li>数据是什么类型</li><li>数据的值是多少</li></ul><p>用两种策略可以达到以上目的：</p><ul><li>声明一个普通变量，声明时指出数据类型和变量名（符号名），系统在内部跟踪该内存单元。</li><li>声明一个指针变量，存储的值是地址，而不是值本身，程序直接访问该内存单元。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int *pa;//定义指针</span></span><br><span class="line">    <span class="type">int</span> *pa=&amp;a;<span class="comment">//指针初始化；</span></span><br><span class="line">    <span class="comment">//int *pa=NULL;//指针初始化</span></span><br><span class="line">    <span class="comment">//pa=NULL;//指针初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%p\n&quot;</span>,pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="指针用于函数的参数"><a href="#指针用于函数的参数" class="headerlink" title="指针用于函数的参数"></a>指针用于函数的参数</h2><p>如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为<strong>地址传递或传地址</strong>。</p><ul><li><strong>值传递</strong>：函数的形参是普通变量</li></ul><p>传地址的意义如下：</p><ul><li>可以在函数中修改实参的值。</li><li>减少内存拷贝，提升性能。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数的时候，调用者把数值赋给了函数的参数。</span></span><br><span class="line"><span class="comment">// 实参：调用者程序中书写的在函数名括号中的参数。</span></span><br><span class="line"><span class="comment">// 形参：函数的参数列表。</span></span><br><span class="line"><span class="comment">// 用下面的方式格式c++形式的指针</span></span><br><span class="line"><span class="comment">// void Get(int &amp;a,int &amp;b);</span></span><br><span class="line"><span class="comment">// Get(a,b)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *no, string *str)</span>    <span class="comment">// 向超女表白的函数。 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; *no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">*no = <span class="number">8</span>;</span><br><span class="line">*str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个函数，从3名超女的身高数据中，选出最高的和最矮的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span>* max, <span class="type">int</span>* min)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*max = a &gt; b ? a : b;               <span class="comment">// 取a和b中的大者。</span></span><br><span class="line">*min = a &lt; b ? a : b;                <span class="comment">// 取a和b中的小者。</span></span><br><span class="line">*max = *max &gt; c ? *max : c;   <span class="comment">// 取*max和c中的大者。</span></span><br><span class="line">*min = *min &lt; c  ? *min : c;    <span class="comment">// 取*min和c中的大者。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// void Get(int &amp;a,int &amp;b);</span></span><br><span class="line"><span class="comment">// Get(a,b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> bh = <span class="number">3</span>;      <span class="comment">// 超女的编号。</span></span><br><span class="line">string message = <span class="string">&quot;我是一只傻傻鸟。&quot;</span>;          <span class="comment">// 向超女表白的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(&amp;bh, &amp;message);            <span class="comment">// 调用向超女表白的函数。</span></span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">int *no = &amp;bh;          </span></span><br><span class="line"><span class="comment">string *str = &amp;message; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; *no &lt;&lt; &quot;号：&quot; &lt;&lt; *str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*no = 8;</span></span><br><span class="line"><span class="comment">*str = &quot;我有一只小小鸟。&quot;;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从3名超女的身高数据中，选出最高的和最矮的。</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">180</span>, b = <span class="number">170</span>, c = <span class="number">175</span>, m, n;</span><br><span class="line"><span class="built_in">func1</span>(a, b, c, &amp;m, &amp;n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m=&quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;,n=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><p>在 C++ 中，程序运行时，内存主要分成四个区，分别是栈、堆、数据段和代码段<br>![[Pasted image 20231222212505.png]]</p><ul><li><strong>栈</strong>：存储局部变量、函数参数和返回值。</li><li><strong>堆</strong>：存储动态开辟内存的变量。</li><li><strong>数据段</strong>：存储全局变量和静态变量。</li><li><strong>代码段</strong>：存储可执行程序的代码和常量（例如字符常量），此存储区不可修改。</li></ul><p><strong>栈和堆的主要区别</strong><br>1）管理方式不同：<strong>栈是系统自动管理的，在出作用域时，将自动被释放</strong>；<strong>堆需手动释放</strong>，若程序中不释放，程序结束时由操作系统回收。<br>2）空间大小不同：堆内存的大小受限于物理内存空间；而栈就小得可怜，一般只有8M（可以修改系统参数)。<br>3）<strong>分配方式不同</strong>：堆是动态分配；栈有静态分配和动态分配（都是自动释放）。<br>4）分配效率不同：栈是系统提供的数据结构，计算机在底层提供了对栈的支持，进栈和出栈有专门的指令，效率比较高；堆是由C++函数库提供的。<br>5）是否产生碎片：对于栈来说，进栈和出栈都有着严格的顺序（<strong>先进后出</strong>），不会产生碎片；而堆频繁的分配和释放，会造成内存空间的不连续，容易产生碎片，太多的碎片会导致性能的下降。<br>6）<strong>增长方向不同</strong>：栈向下增长，以降序分配内存地址；堆向上增长，以升序分配内存地址。</p><h2 id="动态分配内存new和delete"><a href="#动态分配内存new和delete" class="headerlink" title="动态分配内存new和delete"></a>动态分配内存new和delete</h2><p>使用堆区的内存有四个步骤：</p><ol><li>声明一个指针；</li><li>用new运算符向系统申请一块内存，让指针指向这块内存；</li><li>通过对指针解引用的方法，像使用变量一样使用这块内存；</li><li>如果这块内存不用了，用delete运算符释放它。</li></ol><p>申请内存的语法：<strong>new 数据类型(初始值);</strong>   &#x2F;&#x2F; C++11支持{}</p><ul><li>如果申请成功，返回一个地址；如果申请失败，返回一个空地址（暂时不考虑失败的情况）。</li><li>释放内存的语法：<strong>delete 地址</strong>;</li><li>释放内存不会失败（还钱不会失败）<br><strong>注意</strong>：</li><li>动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。</li><li>如果动态分配的内存不用了，必须用delete释放它，否则有可能用尽系统的内存。</li><li>动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。</li><li>就算指针的作用域已失效，所指向的内存也不会释放。</li><li>用指针跟踪已分配的内存时，不能跟丢。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1）声明一个指针；</span></span><br><span class="line"><span class="comment">// 2）用new运算符向系统申请一块内存，让指针指向这块内存；</span></span><br><span class="line"><span class="comment">// 3）通过对指针解引用的方法，像使用变量一样使用这块内存；</span></span><br><span class="line"><span class="comment">// 4）如果这块内存不用了，用delete运算符释放它。</span></span><br><span class="line"><span class="comment">// 申请内存的语法：new 数据类型(初始值);   // C++11支持&#123;&#125;</span></span><br><span class="line"><span class="comment">// 释放内存的语法：delete 地址;</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">*p = <span class="number">8</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">    <span class="comment">// for (int ii = 1; ii &gt; 0; ii++)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// int* p = new int[100000];     // 一次申请100000个整数，这个语法以后再讲。</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;ii=&quot;&lt;&lt;ii&lt;&lt;&quot;,p=&quot; &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><ul><li>指针是指针变量的简称，也是变量，是变量就有地址。</li><li>指针用于存放普通变量的地址。</li><li><strong>二级指针用于存放指针变量的地址</strong>。</li><li>声明二级指针的语法：<code>数据类型** 指针名</code>;</li><li>使用指针有两个目的：<ul><li>传递地址</li><li>存放动态分配的内存的地址</li></ul></li><li><strong>在函数中，如果传递普通变量的地址，形参用指针；传递指针的地址，形参用二级指针。</strong></li><li>把普通变量的地址传入函数后可以在函数中修改变量的值；把指针的地址传入函数后可以在函数中指针的值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> **pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*pp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pp=&quot;</span> &lt;&lt; pp &lt;&lt; <span class="string">&quot;,*pp=&quot;</span> &lt;&lt; *pp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ii = <span class="number">8</span>;               cout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;,ii的地址是：&quot;</span> &lt;&lt; &amp;ii &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span>* pii = &amp;ii;        cout &lt;&lt; <span class="string">&quot;pii(指针)=&quot;</span> &lt;&lt; pii &lt;&lt; <span class="string">&quot;,pii的地址(指针的指针)是：&quot;</span> &lt;&lt; &amp;pii &lt;&lt; <span class="string">&quot;,*pii(值)=&quot;</span> &lt;&lt; *pii &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span>** ppii = &amp;pii;  cout &lt;&lt; <span class="string">&quot;ppii=&quot;</span> &lt;&lt; ppii &lt;&lt; <span class="string">&quot;,ppii的地址(指针的指针)是：&quot;</span> &lt;&lt; &amp;ppii &lt;&lt; <span class="string">&quot;,*ppii=&quot;</span> &lt;&lt; *ppii &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;**ppii=&quot;</span> &lt;&lt; **ppii &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int* p=0;</span></span><br><span class="line"><span class="comment">// func(&amp;p);</span></span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">int** pp = &amp;p;</span></span><br><span class="line"><span class="comment">*pp = new int(3);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; &quot;pp=&quot; &lt;&lt; pp &lt;&lt; &quot;,*pp=&quot; &lt;&lt; *pp &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; &quot;,*p=&quot; &lt;&lt; *p &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><ul><li>在C和C++中，用0或NULL都可以表示空指针。</li><li>声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。</li></ul><p><strong>使用空指针的后果</strong></p><ul><li><strong>如果对空指针解引用，程序会崩溃</strong>。</li><li>如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。</li><li>在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。</li></ul><p><strong>空指针访问会出现异常？</strong></p><blockquote><p>NULL指针分配的分区：其范围是从 0x00000000到0x0000FFFF。这段空间是空闲的，对于空闲的空间而言，<strong>没有相应的物理存储器与之相对应</strong>，所以对这段空间来说，<strong>任何读写操作都是会引起异常的</strong>。空指针是程序无论在何时都没有物理存储器与之对应的地址。为了保障“无论何时”这个条件，需要人为划分一个空指针的区域，固有上面NULL指针分区。</p></blockquote><p><strong>C++11的nullptr</strong></p><ul><li>用0和NULL表示空指针会产生歧义，C++11建议用<strong>nullptr表示空指针</strong>，也就是<code>(void *)0</code></li><li>NULL在C++中就是0，这是因为在C++中<code>void*</code> 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在<strong>重载</strong>整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用nullptr替代NULL吧，而NULL就当做0使用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* no, string* str)</span>    <span class="comment">// 向超女表白的函数。 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((no == <span class="number">0</span>) || (str == <span class="number">0</span>)) <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; *no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// int ba = 3;      // 超女的编号。</span></span><br><span class="line"><span class="comment">// string mess = &quot;我是一只傻傻鸟。&quot;;          // 向超女表白的内容。</span></span><br><span class="line"><span class="type">int</span>* bh = <span class="literal">nullptr</span>;   <span class="comment">//  new int(3);</span></span><br><span class="line">string* message = <span class="number">0</span>; <span class="comment">//  new string(&quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(bh,message);            <span class="comment">// 调用向超女表白的函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> bh; <span class="keyword">delete</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><ul><li>野指针就是指针指向的<strong>不是一个有效（合法）的地址</strong>。</li><li>在程序中，如果访问野指针，可能会造成程序的崩溃。</li></ul><p><strong>出现野指针的情况主要有三种</strong>：</p><ol><li>指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。</li><li>如果用指针指向了动态分配的内存，内存被释放后，<strong>指针不会置空</strong>，但是，<strong>指向的地址已失效</strong>。</li><li>指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收），让指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针。</li></ol><p><strong>规避方法</strong>：</p><ol><li>指针在定义的时候，如果没地方指，<strong>就初始化为nullptr</strong>。</li><li><strong>动态分配的内存被释放后</strong>，<strong>将其置为nullptr</strong>。</li><li><strong>函数不要返回局部变量的地址</strong>。<br>注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是可能，不是一定，程序的表现是不稳定，增加了调试程序的难度。</li></ol><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li>函数的二进制代码存放在内存四区中的代码段，函数的地址是它在内存中的起始地址。如果把<strong>函数的地址作为参数传递给函数</strong>，就可以在函数中灵活的调用其它函数</li></ul><p><strong>使用函数指针的三个步骤</strong>：</p><ol><li>声明函数指针；</li><li>让函数指针指向函数的地址；</li><li>通过函数指针调用函数。</li></ol><p><strong>声明函数指针</strong></p><ul><li>声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设函数的原型是</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> bh,string str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> no,string message)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> id,string info)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> id,string info)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func5</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"><span class="comment">//则函数指针的声明是,一般在主函数中</span></span></span><br><span class="line"><span class="function"><span class="title">int</span>  <span class="params">(*pfa)</span><span class="params">(<span class="type">int</span>,string)</span></span>;</span><br><span class="line"><span class="built_in">bool</span> (*pfb)(<span class="type">int</span>,string);</span><br><span class="line"><span class="built_in">bool</span> (*pfc)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure></li><li>pfa、pfb、<strong>pfc是函数指针名</strong>，必须用括号，否则就成了返回指针的函数。</li></ul><p>2）函数指针的赋值</p><ul><li>函数名就是函数的地址。</li><li>函数指针的赋值：<strong>函数指针名&#x3D;函数名</strong>;<br>3）函数指针的调用</li><li><code>(*函数指针名)(实参)</code>;</li><li>函数指针名(实参);</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;iostream&gt;         // 包含头文件。</span></span><br><span class="line"><span class="comment">// using namespace std;        // 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(int no, string str)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; no &lt;&lt; &quot;号：&quot; &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// int bh = 3;                                                 // 超女的编号。</span></span><br><span class="line"><span class="comment">// string message = &quot;我是一只傻傻鸟。&quot;;    // 向超女表白的内容。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func(bh, message);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void (*pfunc)(int, string);           // 声明表白函数的函数指针。</span></span><br><span class="line"><span class="comment">// pfunc = func;                              // 对函数指针赋值，语法是函数指针名=函数名。</span></span><br><span class="line"><span class="comment">// pfunc(bh, message);                  // 用函数指针名调用函数。 C++</span></span><br><span class="line"><span class="comment">// (*pfunc)(bh, message);              // 用函数指针名调用函数。 C语言</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zs</span><span class="params">(<span class="type">int</span> a)</span>         <span class="comment">// 张三的个性化表白函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout  &lt;&lt;<span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;我要先翻三个跟斗再表白。\n&quot;</span>;   <span class="comment">// 个性化表白的代码。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> a)</span>         <span class="comment">// 李四的个性化表白函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;我有一只小小鸟。\n&quot;</span>;   <span class="comment">// 个性化表白的代码。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span> (*pf)(<span class="type">int</span>),<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;表白之前的准备工作已完成。\n&quot;</span>;       <span class="comment">// 表白之前的准备工作。</span></span><br><span class="line"><span class="built_in">pf</span>(b);                                                                     <span class="comment">// 用函数指针名调用个性化表白函数。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;表白之后的收尾工作已完成。\n&quot;</span>;       <span class="comment">// 表白之后的收尾工作。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">show</span>(zs, <span class="number">3</span>);          <span class="comment">// 张三要表白。</span></span><br><span class="line"><span class="built_in">show</span>(ls, <span class="number">4</span>);          <span class="comment">// 李四要表白。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.802数据结构</title>
      <link href="/data.github.io/post/54ac7a95.html"/>
      <url>/data.github.io/post/54ac7a95.html</url>
      
        <content type="html"><![CDATA[<h1 id="代码题汇总"><a href="#代码题汇总" class="headerlink" title="代码题汇总"></a>代码题汇总</h1><p>1、设计一个算法把树 b 的左、右子树进行交换。要求算法的空间复杂度为 O(1)。</p><ul><li>2007年,2013年出现</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(BTree &amp;b)</span>&#123;</span><br><span class="line">BTNode *temp;</span><br><span class="line"><span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Swap(b-&gt;lchild);<span class="comment">//交换左子树</span></span><br><span class="line">Swap(b-&gt;rchild);<span class="comment">//交换右子树</span></span><br><span class="line"><span class="comment">//交换左右指针域</span></span><br><span class="line">temp=b-&gt;lchild;</span><br><span class="line">b-&gt;lchild=b-&gt;rchild;</span><br><span class="line">b-&gt;rchild=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个题从叶子结点开始着手想.</span></span><br><span class="line"><span class="comment">//在叶子结点交换了空指针,其他就是交换了左右子树的指针域</span></span><br><span class="line"><span class="comment">//在b!=NULL条件中,需同时写递归左右子树,才能保证回溯到同一层时,他们的都是交换后的</span></span><br></pre></td></tr></table></figure><p>2、单链表逆置</p><ul><li>思想：逆置链表初始为空，原表中结点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空； </li><li>2012年，2017年</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inverse</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LNode *p, *q;</span><br><span class="line">p = L-&gt;next;     <span class="comment">//p指针指向第一个结点</span></span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指向NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q-&gt;next = L-&gt;next;  </span><br><span class="line">L-&gt;next = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、顺序表中的数据序列为降序、设计一算法将数据序列变换为升序序列（2013年）</p><ul><li>描述算法的基本设计思想</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[max];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        temp=L.data[i];</span><br><span class="line">        L.data[i]=L.data[length-i<span class="number">-1</span>];</span><br><span class="line">        L.data[Length-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2014年"><a href="#2014年" class="headerlink" title="2014年"></a>2014年</h2><p>4、现有二叉平衡树(或为空树，根结点的左右子树高度差最大为1，且左右子树为二叉平衡树)，试设计一算法判断该二叉树是否为二叉平衡树</p><ul><li>思想：先求出左右子树的高度，然后判断是否满足平衡二叉树定义</li><li>2014年，2016年，2017年，模拟二第一个题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span>&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//空结点的时候,满足要求</span></span><br><span class="line"><span class="type">int</span> l=<span class="built_in">Depth</span>(b-&gt;lchild);<span class="comment">//左子树的高度</span></span><br><span class="line"><span class="type">int</span> r=<span class="built_in">Depth</span>(b-&gt;rchild);<span class="comment">//右子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(l-r&gt;<span class="number">1</span> || r-l&gt;<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不满足要求</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">IsBalance</span>(b-&gt;lchild)&amp;&amp;<span class="built_in">IsBalance</span>(b-&gt;rchild);<span class="comment">//递归每个子树是否为平衡二叉树</span></span><br><span class="line"><span class="comment">//在递归子树的过程中,只要其中一个不满足,后面递归的都是false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断子树高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">l=<span class="built_in">Depth</span>(b-&gt;lchild);<span class="comment">//左子树高度</span></span><br><span class="line">r=<span class="built_in">Depth</span>(b-&gt;rchild);<span class="comment">//右子树高度</span></span><br><span class="line"><span class="keyword">return</span> (l&gt;r) ? (l+<span class="number">1</span>):(r+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：这类题可以把他们分解成多个子问题看,一是求出该节点的高度，二是利用该高度和定义判断。高度单独写个递归函数求高度，定义判断也写个单独写个递归函数（利用高度函数,把它看成一个变量）。</p><p>2014年第二个算法题较难</p><h2 id="2015年"><a href="#2015年" class="headerlink" title="2015年"></a>2015年</h2><p>试设计一算法，使得尽可能少的时间内重排数组，将所有取负值的关键字放在所有非负值前面</p><p>思想：以0为枢轴，将负值放在0前，非负值放在0后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort1</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">-1</span>,j=n;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line"><span class="keyword">do</span> j--;<span class="keyword">while</span>(q[i]&gt;x);</span><br><span class="line"><span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line"><span class="type">int</span> temp=q[i];</span><br><span class="line">q[i]=q[j];</span><br><span class="line">q[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2016年"><a href="#2016年" class="headerlink" title="2016年"></a>2016年</h2><p>1、请设计一个算法，将有n个元素的数组A中的元素A[0]至A[n-1]循环右移动k位，并要求址用一个元素大小的附加存储，元素移动或交换次序位O(n)</p><p>方式一</p><ul><li>通过逆置的方法实现移动位置</li><li>分析数组A的后K个位置（b）通过两次逆置平移到前K个位置，同理（a）一样</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211102141288.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组逆置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(ElemType A[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(r-l+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        temp=A[l+i];</span><br><span class="line">        A[l+i]=A[r-i];</span><br><span class="line">        A[r-i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同段逆置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Right_k</span><span class="params">(ElemType A[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Reverse</span>(A,<span class="number">0</span>,n-k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">Reverse</span>(A,n-k,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">Reverse</span>(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2</p><ul><li>思想：利用双重循环并辅助存储实现元素的向右移动(对比希尔排序组内操作)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line">   <span class="type">int</span> temp;<span class="comment">//作为附加存储</span></span><br><span class="line">    <span class="comment">//相当于对数组执行了k次右移动一次的操作</span></span><br><span class="line">   <span class="keyword">if</span>(k%n != <span class="number">0</span>)&#123;<span class="comment">//k不是n的倍数时执行，k是n的倍数时数组中的元素位置不变</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; ++i)&#123;<span class="comment">//执行k次以下的操作，即向右移动了k位</span></span><br><span class="line">            temp = a[n <span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                 a[j + <span class="number">1</span>] = a[j];<span class="comment">//将数组中的元素向右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[<span class="number">0</span>] = temp;<span class="comment">//将原来的数组末尾的元素移到数组的第一位</span></span><br><span class="line">        &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但这时间复杂度可能位O(1)到O(n^2)</span></span><br></pre></td></tr></table></figure><p>2、设计在二叉排序树上查找结点的值等于key(int 型)</p><ul><li>思想：从根节点开始，二叉排序树非空，用给定值与·根节点关键字比较，相等则相等；若小于根节点，则在右子树找，若大于根节点则在左子树找，递归实现</li><li>（注意要返回结点）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">searchBST</span><span class="params">(BSTree b,<span class="type">int</span> key)</span></span>&#123; <span class="comment">// 查找 </span></span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="comment">// 二叉树为空，结束查找,等价于bt==NULL   </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;        <span class="comment">// 二叉树不为空   key的值和 左右子树比较大小 </span></span><br><span class="line">        <span class="keyword">if</span>(b-&gt;data == key)  <span class="comment">// 查找成功 </span></span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data &gt;key)&#123; <span class="comment">// 二叉树的值 大于 key的值，去左子树寻找 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(b-&gt;lchild,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data &lt; key)&#123; <span class="comment">// 二叉树的值  小于key的值，去右子树寻找 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchBST</span>(b-&gt;rchild,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211122044665.png" alt="image-20221112204406329"></p><p>思想：数据x插到第i个数据组的末尾，即第i+1个数据组的开始，而第i个数据组的首地址由S[i]给出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inser</span><span class="params">(<span class="type">int</span> s[],ElemType D[],<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;n) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(i==n) D[m]=x;<span class="comment">//在最后一个位置加上元素,以0开始</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(in j=m<span class="number">-1</span>;j&gt;s[i+<span class="number">1</span>];j--)<span class="comment">//将在s[i+1]及s[i+1]的元素都后移动一位</span></span><br><span class="line">            D[i+<span class="number">1</span>]=D[j]; </span><br><span class="line">        D[s[i+<span class="number">1</span>]]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) s[i]++;<span class="comment">//维护D与s的关系,应为原s[i+1]被占位,现属于s[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用快速排序，以所有元素的平均值作为枢轴</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">Average</span>(q,l,r),i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="type">int</span> temp=q[i];</span><br><span class="line">            q[i]=q[j];</span><br><span class="line">            q[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Average</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) sum+=q[i];</span><br><span class="line">    <span class="keyword">return</span> sum/(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211121917033.png" alt="image-20221112191707509"></p><p>思想：用一个无头结点的链表存储偶数项结点，用头插法插入新结点，最终将原来链表和新链表连接就行了</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211122020803.png" alt="image-20221112202022011"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DLinkNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *prev,*next;</span><br><span class="line">&#125;DLinkNode,*DLinkList;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReverseEven</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    DLinkList p,L1,pre;<span class="comment">//p为当前结点,L1指向偶数项的最大项,</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    pre=L;<span class="comment">//pre作为当前结点的前驱</span></span><br><span class="line">    L1=<span class="literal">NULL</span>;<span class="comment">//相当一个无头结点的双链表</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//偶数项操作</span></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//pre指针指向下一个奇数项</span></span><br><span class="line">            pre-&gt;next=p-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;prev=pre;</span><br><span class="line">            <span class="comment">//L1头插法</span></span><br><span class="line">            <span class="keyword">if</span>(L1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                p-&gt;next=L;</span><br><span class="line">                L-&gt;prev=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next=L1;</span><br><span class="line">                L1=p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p=pre-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> pre=p;p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next=L1;</span><br><span class="line">    L1-&gt;prev=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  求逆序数对</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    LL res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">merge_sort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="题型总结"><a href="#题型总结" class="headerlink" title="题型总结"></a>题型总结</h1><p>1</p><p>对于给定输入大小N来估计一个程序的运行时间</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211112147157.png" alt="image-20221111214122173"></p><p>基本步骤</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211112147732.jpg"></p><p>2</p><p>下表1中第0行是待排序序列的原始输入（），最后一行为排序后的序列；其他各行是5中排序算法的到的某个中间步骤的内容，表2列出了这5中排序算法，请按排序直接给出每行序列对应的排序算法的编号</p><p>3</p><p>给定表达式和运算符的优先级别，且右结合</p><ul><li>左结合:依次从左往右算</li><li>右结合：依次从右往左算</li></ul><p>做法还是用加括号的方式，若是右结合，首先从右往左依据运算符的优先级加上括号</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211152130784.jpg"></p><p>英文题——2021年<a href="https://testbook.com/question-answer/let-q-denote-a-queue-containing-sixteen-numbers-an--5dfc712df0deec0cf9f0fc1c">解析</a></p><h1 id="模拟题"><a href="#模拟题" class="headerlink" title="模拟题"></a>模拟题</h1><h2 id="模拟1"><a href="#模拟1" class="headerlink" title="模拟1"></a>模拟1</h2><p>已知二叉树采用左右链表存储，给定一个值，设计算法判断 二叉树中是否存在改值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Judge</span><span class="params">(BiTNode *b,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空结点为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data==x) <span class="keyword">return</span> <span class="literal">true</span>;;<span class="comment">//找到该节点</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="built_in">return</span> (<span class="built_in">Judge</span>(b-&gt;lchild,x) || <span class="built_in">Judge</span>(b-&gt;rchild,x));</span><br><span class="line">    <span class="comment">//在后面遍历中只要有一个为true都返回true</span></span><br><span class="line">    <span class="comment">//这样就不用写成先判断,左为true ,返回true;左为flase,再判断有v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计一个算法，求该处二叉树中两个结点的最近公共祖先结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BiTNode *p=<span class="literal">NULL</span>;<span class="comment">//初始化祖先结点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(BiTNode *L,BiTNode *a,BiTNode *b,BiTree &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点为0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L==a || L==b) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//找到其中一个结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Find</span>(L,a,b,q)==<span class="number">2</span>) q=L,<span class="keyword">return</span> <span class="number">3</span>;<span class="comment">//说明找到最近公共结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">Find</span>(L-&gt;lchild,a,b,q)+<span class="built_in">Find</span>(L-&gt;rchild,a,b,q));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用一个变量和判断是否找到最近公共结点</span></span><br></pre></td></tr></table></figure><h2 id="模拟2"><a href="#模拟2" class="headerlink" title="模拟2"></a>模拟2</h2><p>编写函数Find(BSNode *root,int key),其功能以结点root为根的二叉搜索树中找比参数key大的最小值，若找不到返回NULL，否则返回该结点的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSNode *<span class="title">Find</span><span class="params">(BSNode *root ,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data&lt;=key) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//当前结点小于key,说明不满足</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;lchild-&gt;data&lt;=key) <span class="keyword">return</span> root;<span class="comment">//当前结点的左孩子小于key,说明找到最小值</span></span><br><span class="line">            <span class="keyword">else</span> root=root-&gt;lchild;<span class="comment">//否则在左子树中寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟3"><a href="#模拟3" class="headerlink" title="模拟3"></a>模拟3</h2><p>求出给定二叉排序树中最小和最大的关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">Findmin</span><span class="params">(BiTNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;lchild!=<span class="literal">NULL</span>) L=L-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">Findmax</span><span class="params">(BiTNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;rchild!=<span class="literal">NULL</span>) L=L-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先存在两个升序的链表head1和head2,使这两个链表合并后依然有序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Link函数主要是连接m结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Link</span><span class="params">(LinkList &amp;r,LinkList &amp;m)</span></span>&#123;</span><br><span class="line">    r-&gt;next=m;</span><br><span class="line">    r=m;</span><br><span class="line">    m=m-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//L为初始化后带头带头结点的链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(LinkNode *head1,LinkNode *head2,LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LinkNode *p,*q,*r;</span><br><span class="line">    p=head1-&gt;next;</span><br><span class="line">    q=head2-&gt;next;</span><br><span class="line">    r=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>|| q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&gt;q-&gt;data) <span class="built_in">Link</span>(r,q);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">Link</span>(r,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断剩余的链表</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) <span class="built_in">LinK</span>(r,p);</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>) <span class="built_in">Link</span>(r,q);</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟4"><a href="#模拟4" class="headerlink" title="模拟4"></a>模拟4</h2><p>二叉树采用左右链存储，完成下列算法</p><p>判断二叉树是否为完全二叉树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Judge</span><span class="params">(BiTNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L-&gt;lchild!=<span class="literal">NULL</span> &amp;&amp; L-&gt;rchild==<span class="literal">NULL</span>) a++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (L-&gt;child==<span class="literal">NULL</span> &amp;&amp; L-&gt;rchild!=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Judge</span>(L-&gt;lchil) &amp;&amp; <span class="built_in">Judge</span>(L-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若左子树为空，右子树存在，则不是完全二叉树</span></span><br><span class="line"><span class="comment">//完全二叉树最多存在一个读为1的结点，度为1的结点的二叉树大于1不是完全二叉树</span></span><br></pre></td></tr></table></figure><p>输出二叉树从右到左数第k个叶节点</p><ul><li>用递归的思想，先递归右子树，然后遍历左子树，左右遍历根，遇到叶子节点counter++</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindPK</span><span class="params">(BiTree  T,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;rchild &amp;&amp; flag==<span class="number">0</span>) <span class="built_in">FindPK</span>(T-&gt;rchild,k);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild &amp;&amp; flag==<span class="number">0</span>) <span class="built_in">FindPK</span>(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; T-&gt;rchild==<span class="literal">NULL</span>) counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter==k)&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        cout&lt;&lt;T-&gt;data;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计算法O(n)时间内将数组A[0..n-1]划分成两个部分，使左边所有元素为奇数，右边所有元素为偶数，要求所使用的辅助存储空间为O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exchange</span><span class="params">(<span class="type">int</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">-1</span>,j=n;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(A[i]%<span class="number">2</span>==<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(A[j]%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">Swap</span>(A[i],A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似快排交换法，当两边都不满足就交换</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.排序</title>
      <link href="/data.github.io/post/ac84d2d9.html"/>
      <url>/data.github.io/post/ac84d2d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="常见题型注意点"><a href="#常见题型注意点" class="headerlink" title="常见题型注意点"></a>常见题型注意点</h2><p>如何判断给定多组序列是那种排序</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209172246899.jpg"></p><p>简单选择是交换</p><table><thead><tr><th>排序算法</th><th>n趟后排序判断</th></tr></thead><tbody><tr><td>直接插入排序</td><td>判断前n+1个元素是否有序</td></tr><tr><td>冒泡和选择排序</td><td>是否有n个元素处于最终位置(最左&#x2F;最右)</td></tr><tr><td></td><td></td></tr><tr><td>快排</td><td>第1趟确定至少一个元素位置</td></tr><tr><td>（枢轴将表分为两个子表）（多个子表）</td><td>第2趟还可以至少确定2个元素</td></tr><tr><td></td><td>第3趟还可以确定至少4个（累计至少7个）</td></tr><tr><td>特殊情况</td><td>若确定的元素在最右(左)端，则下次至少确定一个（一次子表）</td></tr><tr><td></td><td></td></tr><tr><td>2路归并排序</td><td>判断块($2^n$)中的元素是否有序</td></tr></tbody></table><h3 id="记忆口诀"><a href="#记忆口诀" class="headerlink" title="记忆口诀"></a>记忆口诀</h3><p>不稳定性：<strong>快选堆希</strong>（快速排序、选择排序、堆排序、希尔排序）</p><p>关于移动次数和关键字顺序无关的排序：一堆（堆排序）海龟（归并排序）选（选择排序）基（基数排序）友</p><h3 id="排序算法思想汇总"><a href="#排序算法思想汇总" class="headerlink" title="排序算法思想汇总"></a>排序算法思想汇总</h3><ol><li>直接插入排序：每次将一个<strong>待排序</strong>的记录按其关键字大小，<strong>插入</strong>（依次对比、移动）到前面<strong>已经排好序的子序列</strong>中，直到全部记录插入完成</li><li>希尔排序：是把元素按下标的一定增量进行分组，对每组使用直接插入排序算法排序。随着增量逐渐减少，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</li><li>冒泡排序：是对所有相邻记录的关键字值进行比效，如果是逆顺（a[j]&gt;a[j+1]），则将其交换，最终达到有序化;</li><li>快速排序：使用<a href="https://so.csdn.net/so/search?q=%E5%88%86%E6%B2%BB&spm=1001.2101.3001.7020">分治</a>的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</li><li>归并排序：是建立在归并操作上的一种有效的排序算法，归并排序对序列的元素进行逐层折半分组，然后从最小分组开始比较排序，合并成一个大的分组，逐层进行，最终所有的元素都是有序的</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>排序：重新排列表中的元素，使表中元素<strong>满足按关键字有序</strong>的过程（关键字可以相同）</p></li><li><p>排序算法的评价指标：时间复杂度、空间复杂度；</p></li><li><p>排序算法的稳定性：关键字相同的元素在排序之后<strong>相对位置不变</strong>，称为稳定的；</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208022209150.png" alt="image-20220802220924852"></p></li><li><p>排序算法的分类：<br><strong>内部排序：</strong> 数据都在内存——关注如何使时间、空间复杂度更低；<br><strong>外部排序：</strong> 数据太多，无法全部放入内存——关注如何使时间、空间复杂度更低，如何使读&#x2F;写磁盘次数更少；</p></li></ol><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">美国旧金山大学-可视化学习网站</a></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><a href="https://www.runoob.com/w3cnote/insertion-sort.html">直接插入排序</a></p><ol><li><p><strong>算法思想：</strong> 每次将一个<strong>待排序</strong>的记录按其关键字大小，<strong>插入</strong>（依次对比、移动）到前面<strong>已经排好序的子序列</strong>中，直到全部记录插入完成</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208022216520.gif"></p></li><li><p><strong>代码实现：</strong></p></li></ol><ul><li>不带“哨兵”</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序递增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> n)</span></span>&#123;    <span class="comment">//q中共n个数据元素</span></span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;q[i<span class="number">-1</span>])&#123;    <span class="comment">//q[i]关键字小于前驱</span></span><br><span class="line">            temp = q[i];  </span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; q[j]&gt;temp; --j)</span><br><span class="line">                q[j+<span class="number">1</span>] = q[j];     <span class="comment">//所有大于temp的元素都向后挪</span></span><br><span class="line">            q[j+<span class="number">1</span>] = temp;         <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A[0]不存储信息</span></span><br></pre></td></tr></table></figure><ul><li>带“哨兵” ，优点：不用每轮循环都判断<code>j&gt;=0</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序递增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> n)</span></span>&#123;    <span class="comment">//q中从1开始存储，0放哨兵</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;q[i<span class="number">-1</span>])&#123;    </span><br><span class="line">            q[<span class="number">0</span>] = q[i];     <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; q[<span class="number">0</span>] &lt; q[j]; --j)  <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                q[j+<span class="number">1</span>] = q[j];     <span class="comment">//向后挪动</span></span><br><span class="line">            q[j+<span class="number">1</span>] = q[<span class="number">0</span>];          <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>算法效率分析</strong></li></ol><ul><li>空间复杂度：O(1)</li><li>时间复杂度：主要来自于对比关键字、移动关键字，若有n个元素，则需要n-1躺处理<ul><li><strong>最好情况：</strong> 原本为有序，共n-1趟处理，每一趟都只需要对比1次关键字，不需要移动元素，共对比<code>n-1</code>次 —— <strong>O(n)</strong></li><li><strong>最差情况：</strong> 原本为逆序 —— O(n²)</li><li><strong>平均情况：</strong> O(n²)</li></ul></li><li>算法稳定性：稳定</li></ul><ol><li><strong>对链表进行插入排序</strong></li></ol><ul><li>移动元素的次数变少了，因为只需要修改指针，不需要依次右移；</li><li>但是关键字对比的次数依然是<strong>O(n²)数量级，因此整体看来时间复杂度仍然是O(n²)</strong></li></ul><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><ol><li><p><strong>思路：</strong> 先用折半查找找到应该插入的位置，再移动元素；</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208022239663.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208022239718.png"></p></li><li><p>为了保证稳定性，当查找到和插入元素关键字一样的元素时，应该继续在这个元素的右半部分继续查找以确认位置; 即当 <code>A[mid] == A[0]</code> 时，应继续在mid所指位置右边寻找插入位置</p></li><li><p>当<code>low&gt;high</code>时，折半查找停止，应将$[low,i-1]or[high+1,i-1]$内的元素全部右移，并将A[0]复制到low所指的位置；</p></li><li><p><strong>代码实现</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序递增，用q[0]占位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> i,j,l,r,mid;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        q[<span class="number">0</span>] = q[i];                    <span class="comment">//将q[i]暂存到q[0]</span></span><br><span class="line">        l = <span class="number">1</span>;</span><br><span class="line">        r = i<span class="number">-1</span>;            <span class="comment">//折半查找的范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;               <span class="comment">//折半查找</span></span><br><span class="line">            mid = (l + r)/<span class="number">2</span>;       <span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(q[mid]&gt;q[<span class="number">0</span>])             <span class="comment">//查找左半子表</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//查找右半子表</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&gt;r+<span class="number">1</span>;--j)       <span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">            q[j+<span class="number">1</span>] = q[j];</span><br><span class="line">        q[r+<span class="number">1</span>] = q[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>与<code>直接插入排序</code>相比，比较关键字的次数减少了，但是移动元素的次数没有变，<strong>时间复杂度仍然是O(n²)</strong></li></ol><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ol><li><p><strong>思路：</strong> 先追求表中元素的部分有序，再逐渐逼近全局有序；</p><p>初始增量第一趟 <strong>gap &#x3D; length&#x2F;2 &#x3D; 4</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208042318800.png" alt="img"></p><p>（2）第二趟，增量缩小为 2</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208042318518.png" alt="img"></p><p>（3）第三趟，增量缩小为 1,得到最终排序结果</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208042318644.png" alt="img"></p></li><li><p>更适用于基本有序的排序表和数据量不大的排序表，<strong>仅适用于线性表为顺序存储的情况</strong></p></li><li><p><strong>代码实现：</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序递增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(ElemType q[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//q[0]为暂存单元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dk=n/<span class="number">2</span>; dk&gt;=<span class="number">1</span>; dk=dk/<span class="number">2</span>)   <span class="comment">//步长递减(看题目要求，一般是1/2),相当建立了分组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=dk+<span class="number">1</span>; i&lt;=n; ++i)<span class="comment">//组内利用直接插入的方法进行排序，每次增加一个步长</span></span><br><span class="line">            <span class="keyword">if</span>(q[i]&lt;q[i-dk])&#123;</span><br><span class="line">                q[<span class="number">0</span>]=q[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i-dk; j&gt;<span class="number">0</span> &amp;&amp; q[<span class="number">0</span>]&lt;q[j];j-=dk)<span class="comment">//j&gt;0要加上，j-=dk可能为负数</span></span><br><span class="line">                    q[j+dk]=q[j];         <span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                q[j+dk]=q[<span class="number">0</span>];            <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>算法效率分析</strong></li></ol><ul><li>空间效率：空间复杂度&#x3D;<strong>O(1)</strong></li><li>时间效率: 最坏情况下时间复杂度&#x3D;<strong>O(n²)</strong></li><li>稳定性：希尔排序是一种<strong>不稳定</strong>的排序方法</li></ul><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p><strong>基于“交换”的排序：</strong>根据序列中两个元素关键字的比较结果来对换这两个记录再序列中的位置；</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol><li><p>第一趟排序使关键字值最小的一个元素“冒”到最前面（其最终位置）—— <strong>每趟冒泡的结果是把序列中最小元素放到序列的最终位置，这样最多做<code>n-1</code>趟冒泡就能把所有元素排好序</strong>；</p></li><li><p>为保证稳定性，关键字相同的元素不交换；(下图是最大的一个元素冒到最后一个位置)</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208022239789.gif"></p></li><li><p><strong>代码实现</strong></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使关键字值最小的一个元素“冒”到最前面（其最终位置）</span></span><br><span class="line"><span class="comment">//冒泡排序,有序递增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> n)</span></span>&#123;   <span class="comment">//从0开始存放</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i; j--) <span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(q[j<span class="number">-1</span>]&gt;q[j])&#123;      <span class="comment">//若为逆序</span></span><br><span class="line">                <span class="built_in">swap</span>(q[j<span class="number">-1</span>],q[j]);  <span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;       <span class="comment">//本趟遍历后没有发生交换，说明表已经有序，可以结束算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>算法效率分析</strong></li></ol><ul><li>空间复杂度：<strong>O(1)</strong></li><li>时间复杂度<ul><li>最好情况 (有序) ：只需要一趟排序，比较次数&#x3D;n-1，交换次数&#x3D;0，最好时间复杂度&#x3D;O(n)</li><li>最坏情况 (逆序) ：比较次数 &#x3D; <code>(n-1)+(n-2)+...+1 = n(n-1)/2</code> &#x3D; 交换次数，最坏时间复杂度 &#x3D; O(n²)，平均时间复杂度 &#x3D; O(n²)</li></ul></li></ul><ol><li>冒泡排序可以用于<strong>链表、顺序表</strong></li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>（书本上的方法是<strong>快速排序挖空法</strong>，acwing的方法是<strong>快速排序交换法</strong>）</p><ol><li>每一趟排序都可使一个<strong>中间元素确定其最终位置</strong></li><li>用一个元素（不一定是第一个）把待排序序列“划分”为两个部分，左边更小，右边更大，该元素的最终位置已确认</li><li>算法实现（重点）</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209262203759.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分为左右两个部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=q[l];                     <span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; q[r]&gt;=x) r--;  <span class="comment">//r所指元素大于枢轴，r左移</span></span><br><span class="line">        q[l]=q[r];                  <span class="comment">//r所指元素小于枢轴，移动到左侧</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; q[l]&lt;=x) l++;  <span class="comment">//l所指元素小于枢轴，l右移</span></span><br><span class="line">        q[r]=q[l];                  <span class="comment">//l所指元素大于枢轴，移动到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    q[l]=x;                         <span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> l;                       <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;                  <span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">Partition</span>(q,l,r);<span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(q,l,x<span class="number">-1</span>);<span class="comment">//划分左子表</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(q,x+<span class="number">1</span>,r);<span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">1</span></span><br></pre></td></tr></table></figure><ol><li><strong>算法效率分析</strong></li></ol><ul><li>每一层的<code>QuickSort</code>只需要处理剩余的待排序元素，时间复杂度不超过O(n);</li><li></li><li>把n个元素组织成二叉树，二叉树的层数就是递归调用的层数，n个结点的二叉树<strong>最小高度</strong> &#x3D; <code>⌊log₂n⌋ + 1</code>, <strong>最大高度</strong> &#x3D; <code>n</code></li><li><strong>时间复杂度 &#x3D; O(n×递归层数)</strong> （递归层数最大为n）<ul><li>最好 &#x3D; <code>O(nlog₂n)</code> : 每次选的枢轴元素都能将序列划分成均匀的两部分；</li><li>最坏 &#x3D; <code>O(n²)</code> ：序列本就有序或逆序，此时时间、空间复杂度最高；</li><li>平均时间复杂度 &#x3D; <code>O(nlog₂n)</code> （接近最好而不是最坏）</li></ul></li><li>**空间复杂度 &#x3D; O(递归层数)**（递归层数最小为log₂n）<ul><li>最好 &#x3D; <code>O(log₂n)</code></li><li>最坏 &#x3D; <code>O(n)</code></li></ul></li><li>若每一次选中的“枢轴”可以将待排序序列划分为<strong>均匀</strong>的两个部分，则递归深度最小，算法效率最高；</li><li>若初始序列本就<strong>有序或者逆序</strong>,则快速排序的性能最差；</li><li><strong>快速排序算法优化思路：</strong> 尽量选择可以把数据中分的枢轴元素<ul><li>选头、中、尾三个位置的元素，取中间值作为枢轴元素；</li><li>随机选一个元素作为枢轴元素；</li></ul></li><li>快速排序使所有内部排序算法中平均<strong>性能最优</strong>的排序算法；</li><li><strong>稳定性：</strong> 不稳定；</li></ul><p><strong>手算模拟</strong></p><ul><li>枢轴选择第一个元素，每趟先从j所指向得指针开始</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208052313585.gif"></p><p>对于快速排序选择枢轴为中间元素时，这样一般是<strong>先交换当前元素与第一个元素的位置</strong>（或者最后一个位置）——如果不把这个枢纽放在最左端或者最右端，那么不管左右指针从哪边先开始移动，都会出现指针错位的情况（ij两个指针遇到这个枢纽时，会跳过去，之后交换枢纽时，很可能出错不符合快排思想）</p><blockquote><p>eg:1,4,10,34,2,45,24   </p><p>选取枢轴为34。 </p><p>第一步：34，4，10，1，2，45，24——然后按照枢轴为第一个位置进行快速排序操作</p></blockquote><p><strong>常见题型</strong></p><ul><li>对于快速排序，每趟排序将会将<strong>枢轴元素</strong>放到最终位置<ul><li>对快速排序第n趟结果，可以直接排好最终序列，然后对比有几个元素在最终位置上</li></ul></li></ul><h4 id="acw算法实现"><a href="#acw算法实现" class="headerlink" title="acw算法实现"></a>acw算法实现</h4><ol><li>第一步，先v判断v&lt;x,满足则一直判断下一个位置</li><li>第二，若v&gt;&#x3D;x,则判断r&gt;x,满足则判断下一个位置</li><li>第三，若r&lt;&#x3D;x，交换对应的数值大小</li><li>然后递归处理两端</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203012314248.gif"></p><p><strong>时间复杂度</strong></p><ul><li>最好时间复杂度:  $O(nlog_2n)$</li><li>最坏时间复杂度:  $O(n^2)$</li><li>平均时间复杂度:  $O(nlog_2n)$</li></ul><p><a href="https://www.acwing.com/problem/content/submission/code_detail/11404073/">题目</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//l为最左端，r为最右端，x为判断值，有序递增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//最终条件,左遇右,回归</span></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l+r&gt;&gt;<span class="number">1</span>];;<span class="comment">//初始化，l+r的值右移1位，相当l+r的值除以2取整</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)<span class="comment">//判断相遇，则退出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);<span class="comment">//判断左端数据，小于x</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);<span class="comment">//判断右端数据,小于y</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);<span class="comment">//交换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);<span class="comment">//左递归</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);<span class="comment">//右递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>选择排序思想：</strong> 每一趟在<strong>待排序元素中选取关键字最小</strong>（或最大）的元素<strong>加入有序子序列</strong>；</p><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><ol><li><code>n</code>个元素的简单选择排序需要<code>n-1</code>趟处理；</li><li>代码实现</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有序递增</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> n)</span></span>&#123;       <span class="comment">//q从0开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;          <span class="comment">//一共进行n-1趟，i指向待排序序列中第一个元素</span></span><br><span class="line">        <span class="type">int</span> min = i;                   <span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)       <span class="comment">//在q[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(q[j]&lt;q[min]) min = j;   <span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i)                     </span><br><span class="line">            <span class="built_in">swap</span>(q[i],q[min]);         <span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208041239107.gif"></p><ol><li><strong>算法效率分析</strong></li></ol><ul><li><strong>空间复杂度</strong> &#x3D; <code>O(1)</code></li><li>无论有序、逆序、乱序，都需要n-1的处理，总共需要<strong>对比关键字</strong> <code>(n-1)+(n-2)+...+1 = n(n-2)/2</code> 次，元素<strong>交换次数</strong> &lt; <code>n-1</code>; <strong>时间复杂度</strong> &#x3D; <code>O(n²)</code></li><li><strong>稳定性：</strong> 不稳定</li><li><strong>适用性：</strong> 既可以用于顺序表，也可以用于链表；</li></ul><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li><strong>什么是“堆（Heap）”？</strong></li></ol><p>可理解为顺序存储的二叉树，注意</p><blockquote><p>可以将堆视为一棵 <strong>完全二叉树</strong> (✔)</p><p>可以将堆视为一棵 <strong>二叉排序树</strong> (✖)</p></blockquote><ul><li>大根堆：完全二叉树中，根 ≥ 左、右</li><li>小根堆：完全二叉树中，根 ≤ 左、右</li></ul><ol><li><strong>如何基于“堆”进行排序</strong></li></ol><p>基本思路：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列，<strong>堆顶元素的关键字最大或最小</strong> （以下以大根堆为例）</p><p>① 将给定初始序列(n个元素)，<strong>建立初始大根堆</strong>：把所有<strong>非终端结点</strong> <strong>从后往前</strong>都检查一遍，是否满足大根堆的要求——<code>根 ≥ 左、右</code>，若不满足，则将<strong>当前结点与更大的孩子</strong>互换</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161623312.png"></p><ul><li>在顺序存储的完全二叉树中:<ul><li>非终端结点的编号 <code>i≤⌊n/2⌋</code></li><li><code>i</code> 的左孩子 <code>2i</code></li><li><code>i</code> 的右孩子 <code>2i+1</code></li><li><code>i</code> 的父节点<code>⌊i/2⌋</code></li></ul></li><li>更小的元素“下坠”后，可能导致下一层的子树不符合大根堆的要求，则采用相同的方法继续往下调整 —— <strong>小元素不断“下坠”</strong></li></ul><p>② <strong>基于大根堆进行排序</strong>：每一趟将堆顶元素加入有序子序列中，堆顶元素与待排序序列中最后一个元素交换后，即最大元素换到末尾，之后该位置就不用改变，即移出完全二叉树(<code>len=len-1</code>)，把剩下的待排序元素序列再调整为大根堆；————<strong>“一趟处理”</strong></p><p>③ 剩下最后一个元素则不需要再调整；</p><ol><li><strong>代码实现</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对初始序列建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)   <span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(q, i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="comment">从最底层的分支结点开始调整*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> k, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    q[<span class="number">0</span>] = q[k];                      <span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k; i&lt;=len; i*=<span class="number">2</span>)&#123;     <span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">                                      <span class="comment">// i为当前所选根结点的左孩子</span></span><br><span class="line">                                      <span class="comment">//i*=2是为了判断调整后再下一层是否满足大根堆</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; q[i]&lt;q[i+<span class="number">1</span>])      <span class="comment">//判断：当前所选根结点的左、右结点哪个更大</span></span><br><span class="line">            i++;                      <span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(q[<span class="number">0</span>] &gt;= q[i]) </span><br><span class="line">            <span class="keyword">break</span>;                    <span class="comment">//筛选结束：i指向更大的子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q[k] = q[i];              <span class="comment">//将A[i]调整至双亲结点上</span></span><br><span class="line">            k=i;                      <span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q[k] = q[<span class="number">0</span>];                       <span class="comment">//被筛选的结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于大根堆进行排序,将它排序成升序序列,如下图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(q, len);          <span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>; i--)&#123;      <span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        <span class="built_in">swap</span>(q[i], q[<span class="number">1</span>]);          <span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        <span class="built_in">HeadAdjust</span>(q,<span class="number">1</span>,i<span class="number">-1</span>);       <span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>建堆开始是从最后一个分支节点开始，往前面的分支结点(在该分支点往子树排序递归)走。</li><li>每次排序，都是从该结点往子树递归<ul><li>对于大根树，根节点小于子节点时，选择的是子树的根的<strong>较大值</strong>作为交换</li><li>对于<strong>小根树</strong>，根节点大于子节点时，选择的是子树的根的<strong>较小值</strong>作为交换</li></ul></li></ul><p>建堆中的时间复杂度：$O(nlog_2n)$</p><p>若题目要求序列<a href="https://blog.csdn.net/Code_beeps/article/details/91488526">从小到大排序则构造大根堆</a></p><ul><li>首先先初始化建立大根堆</li><li>然后将最后交换到最后一个位置(排好序除外)，再调整到大根堆状态，一直遍历完</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211292049424.png"></p><h4 id="在堆中操作"><a href="#在堆中操作" class="headerlink" title="在堆中操作"></a>在堆中操作</h4><p><strong>插入</strong></p><ul><li>对于<strong>小根堆</strong>，新元素放到<strong>表尾</strong>，与父节点对比,若新元素比父节点更小，则将二者互换。新元素就这样一路“上升”，直到无法继续上升为止</li></ul><p><strong>删除</strong></p><ul><li>被<strong>删除的元素</strong>用<strong>堆底元素替代</strong>，然后让该元素不断“<strong>下坠</strong>”，直到无法下坠为止</li></ul><p>删除和插入的时间复杂度为$O(log_2 n)$</p><h4 id="acw算法实现-1"><a href="#acw算法实现-1" class="headerlink" title="acw算法实现"></a>acw算法实现</h4><p><strong>手写一个堆操作</strong></p><p>size:相当于heap最后一个元素下标，size–:减少一个元素</p><ol><li>插入一个数 ：<code>heap[++size]=x;up(size);</code>相当于在末尾插入一个元素</li><li>求集合中的最小值 ： <code>heap[1]</code></li><li>删除最小值： <code>heap[1]=heap[size] ; size--; down(1)</code></li><li>删除任意一个元素：  <code>heap[k]=heap[size];size--;down(k);up(k)</code>：相当最后一个元素操作</li><li>修改任意一个元素 ： <code>heap[k]=x;down(k);up(k)</code></li></ol><p><strong>时间复杂度</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205171512399.jpg"></p><p><strong>代码</strong></p><p><strong>根结点从1开始</strong>；下标为x的左儿子下标为<strong>2x</strong>,右儿子为<strong>2x+1</strong></p><p>该代码是<strong>建立小根堆</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;<span class="comment">//t存储三个结点中存在的最小的结点的下标，初始化为当前结点u</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">// 左子节点存在并且小于当前结点，更新t的下标</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//判断右儿子是否较小</span></span><br><span class="line">    <span class="keyword">if</span> (u != t) <span class="comment">//交换位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//交换数值后，t情况不明，可能需要调整。直到它比左右子节点都小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    cnt = n;<span class="comment">//cnt为数组元素个数</span></span><br><span class="line">    <span class="comment">//把堆初始化成小根堆，从二叉树的倒数第二行开始，把数字大的下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);<span class="comment">//输出堆顶最小值</span></span><br><span class="line">        <span class="comment">//删除最小值</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt -- ];<span class="comment">// 将堆最后一个数放到堆顶，cnt--使得在逻辑上删除这个数</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><strong>归并（Merge）</strong>：把两个或多个已经有序的序列合并成一个；</li><li><strong>k路归并：每选出一个元素，需对比关键字k-1</strong>次；</li><li>外部排序通常采用归并排序，内部排序一般采用2路归并；</li><li><strong>代码实现</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建辅助数组B</span></span><br><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//A[l,...,mid],A[mid+1,...,r] 各自有序，将这两个部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=l; k&lt;=r; k++)</span><br><span class="line">        B[k] = A[k];           <span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    <span class="keyword">for</span>(i=l, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;= r; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])          <span class="comment">//为保证稳定性两个元素相等时，优先使用靠前的那个</span></span><br><span class="line">            A[k]=B[i++];        <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//没有归并完的部分复制到尾部，while只会执行一个 </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)  A[k++]=B[i++];     <span class="comment">//若第一个表未检测完，复制</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) A[k++]=B[j++];     <span class="comment">//若第二个表未检测完，复制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;    <span class="comment">//从中间划分</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, l, mid);    <span class="comment">//对左半部分归并排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(A, mid+<span class="number">1</span>, r); <span class="comment">//对右半部分归并排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(A,l,mid,r);     <span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法效率分析<ul><li>归并排序的比较次数与序列的初始状态无关；</li><li>2路归并的“归并树”——倒立的二叉树，树高<code>h</code>，归并排序趟数<code>m = h-1</code>，第<code>h</code>层最多$2 ^ {h-1}$个结点，则满足$n ≤ 2 ^ {h-1}$，即<code>h-1 = ⌈log₂n⌉</code>; <strong>结论: n个元素进行2路归并排序，归并趟数 m &#x3D; ⌈log₂n⌉</strong></li><li>每趟归并时间复杂度为<code>O(n)</code>, 算法<strong>总时间复杂度</strong>为<code>O(nlog₂n)</code>;</li><li><strong>空间复杂度</strong>为<code>O(n)</code>; (归并排序算法可视为本章占用辅助空间最多的排序算法)</li><li>稳定性：归并排序是<strong>稳定</strong>的</li><li>对于<code>N</code>个元素进行<code>k</code>路归并排序，排序的趟数<code>m</code>满足 $k^m &#x3D; N, m &#x3D; ⌈log_kN⌉$</li></ul></li></ul><h4 id="acw算法实现-2"><a href="#acw算法实现-2" class="headerlink" title="acw算法实现"></a>acw算法实现</h4><p><strong>思想</strong></p><ol><li>确定分界点：mid&#x3D;(l+r)&#x2F;2</li><li>归并排序left,right</li><li>归并（合二为一）–难点</li></ol><p><a href="https://blog.csdn.net/u010711495/article/details/116891262?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164622666416780255279046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164622666416780255279046&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-116891262.first_rank_v2_pc_rank_v29&utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3&spm=1018.2226.3001.4187">图解过程</a></p><p>图解</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203022114282.png"></p><p><strong>稳定性好</strong></p><ul><li>在排序对比时，遇到相同位置的数字，不发生交换，就比较稳定；可能发生交换不稳定</li></ul><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205162334188.gif" style="zoom:200%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//回归条件</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//取中间值，</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);<span class="comment">//左端递归排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);<span class="comment">//右端递归排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并合一，两个有序序列合成一个有序序列</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;<span class="comment">//i指向左半边,j指向右半边</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两边都没有循环完，判断大小</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左右其中一边没有循环完的接到序列后面</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将tem付给q数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ol><li><strong>算法效率分析</strong></li></ol><ul><li>空间效率：<code>O(r)</code>, 其中r为基数，需要的辅助空间(队列)为r；</li><li>时间效率：一共进行<code>d</code>趟分配收集，一趟分配需要<code>O(n)</code>, 一趟收集需要<code>O(r)</code>, 时间复杂度为 <strong><code>O[d(n+r)]</code><strong>，且</strong>与序列的初始状态无关</strong></li><li>稳定性：稳定！</li></ul><ol><li>基数排序擅长解决的问题</li></ol><p>①数据元素的关键字可以方便地拆分为d组，且d较小；<br>②每组关键字的取值范围不大，即r较小；<br>③数据元素个数n较大；</p><p><strong>例子演示</strong></p><blockquote><p> 现有如下序列：{3，44，38，5，47，15，36，32，50}，现在要利用基数排序算法对这9个元素进行从小到大的排序，怎么排呢？</p></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210042100518.png" alt="image-20221004210031054"></p><p> <img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210042101371.png" alt="image-20221004210105594"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210042101059.png" alt="image-20221004210127849"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><table><thead><tr><th>稳定</th><th>不稳定</th></tr></thead><tbody><tr><td>直接插入排序</td><td>简单选择排序</td></tr><tr><td>冒泡排序</td><td>希尔排序</td></tr><tr><td>归并排序</td><td>快速排序</td></tr><tr><td>基数排序</td><td>堆排序</td></tr></tbody></table><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>平均情况下：<strong>快速排序、希尔排序、归并排序、堆排序</strong> 均为 O(nlog2n)； <strong>基数排序</strong>为O(d(n+r))； <strong>其余</strong>全是O(n²);</li><li>最坏情况下：<strong>快速排序、希尔排序</strong> 为O(n²)，其余与平均情况一样；</li><li>最好情况下：<strong>直接插入排序、冒泡排序、希尔排序</strong> 为 O(n)，其余与平均情况一样；</li></ul><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li><strong>快速排序</strong> ：平均 —— O(log2n)；最坏 —— O(n);</li><li><strong>2路归并排序</strong>：O(n)；</li><li><strong>基数排序</strong>：O®;</li><li>其余都是 O(1);</li><li>就辅助空间而言：堆排序&lt;快速排序&lt;归并排序</li></ul><h4 id="过程特征"><a href="#过程特征" class="headerlink" title="过程特征"></a>过程特征</h4><ul><li>经过一趟排序，能够保证一个元素到达最终位置： 交换类——<strong>冒泡、快速</strong>；选择类———<strong>简单选择、堆</strong>；</li><li>排序方法的<strong>元素比较次数</strong>与原始序列<strong>无关</strong>：<strong>简单选择、折半插入</strong></li><li>排序方法的<strong>排序趟数</strong>与原始序列<strong>有关</strong>：<strong>交换类——冒泡、快速</strong></li><li>排序方法中，<strong>元素的移动次数</strong>与原始序列<strong>无关</strong>：<strong>基数排序</strong></li><li>初始序列有序时，冒泡排序比较<code>n-1</code>次，不需要移动元素；</li><li><strong>希尔排序</strong>和<strong>堆排序</strong>利用顺序存储的随机访问特征，注意链式存储不支持这种性质；</li></ul><h4 id="排序算法的选择"><a href="#排序算法的选择" class="headerlink" title="排序算法的选择"></a>排序算法的选择</h4><ul><li>若<strong>n较小</strong>，可采用时间复杂度为<strong>O(n²)<strong>的排序方法：</strong>直接插入排序、简单选择排序</strong>，该情况下，若记录本身信息量较大，用简单选择排序；</li><li>若<strong>n较大</strong>，应采用时间复杂度为<strong>O(nlog2n)<strong>的排序方法：</strong>快速排序、归并排序、堆排序</strong></li><li><strong>快速排序</strong>——目前基于比较的内部排序方法中<strong>最好</strong>的方法，当关键字随机分布时，平均实际最短；</li><li>若<strong>n很大</strong>，记录的关键字位数较少且可分解，选择<strong>基数排序</strong></li><li>若记录本上信息量较大，可用链表作为存储结构；</li><li>若要求排序稳定且时间复杂度为O(nlog2n)，则选择<strong>归并排序</strong>，通常和直接插入排序结合使用：先利用直接插入排序求得较长的有序子文件，再两两归并，仍是稳定；</li><li>基数排序不能对<code>float</code>和<code>double</code>类型的实数进行排序；</li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th></th><th>直接插入</th><th>折半插入</th><th>希尔排序</th><th>冒泡</th><th>快排</th><th>简单选择</th><th>堆排序</th><th>归并排序</th></tr></thead><tbody><tr><td>最好时间复杂度</td><td>$O(n)$有序</td><td></td><td>$O(n^ {1.3})$</td><td></td><td>$O(nlog_2 n)$枢轴均匀分开为两个表</td><td>$O(n^ 2)$</td><td>$O(nlog_2n)$</td><td></td></tr><tr><td>平均时间复杂度</td><td>$O(n^ 2)$逆序</td><td>$O(n^ 2)$</td><td></td><td>$O(n^ 2)$</td><td></td><td>$O(n^ 2)$</td><td>$O(nlog_2n)$</td><td>$O(nlog_2n)$</td></tr><tr><td>最坏时间复杂度</td><td>$O(n^ 2)$</td><td></td><td>$O(n^ 2)$</td><td>$O(n^ 2)$</td><td>$O(n^ 2)$逆序或者正序</td><td>$O(n^ 2)$</td><td>$O(nlog_2n)$</td><td></td></tr><tr><td>最好空间</td><td></td><td></td><td></td><td></td><td>$O(log_2n)$</td><td></td><td></td><td></td></tr><tr><td>平均空间</td><td></td><td></td><td>$O(1)$</td><td>$O(1)$</td><td>$O(log_2n)$</td><td>$O(1)$</td><td>$O(1)$</td><td>$O(n)$</td></tr><tr><td>最坏空间</td><td></td><td></td><td></td><td></td><td>$O(n)$</td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209252114100.jpg"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211162129900.jpg"></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><a href="https://blog.csdn.net/liu17234050/article/details/104297177">文件</a></p><p><a href="https://blog.csdn.net/m0_64407685/article/details/124277683?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-124277683.nonecase&spm=1018.2226.3001.4187">文件2</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.查找</title>
      <link href="/data.github.io/post/b5847043.html"/>
      <url>/data.github.io/post/b5847043.html</url>
      
        <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>查找</strong>：在数据集合中寻找满足某种条件的数据元素的<strong>过程</strong>称为查找</p><p><strong>查找表</strong>〈查找结构)：思于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成</p><p><strong>关键字</strong>：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207272247243.png" alt="image-20220727224712187"></p><p>静态查找表：查找符合条件的元素（只关注查找效率）</p><p>动态查找表：还要插入和删除操作  (除了查找效率，还要关注插入和删除的效率)</p><p>查找长度：在查找运算中，需要对比关键字的次数称为查找长度</p><p>平均查找长度：所有查找过程中进行关键字的比较次数的平均值</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207272256194.png" alt="image-20220727225653582"></p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul><li>又叫线性查找——用于线性表</li></ul><p><strong>算法思想：</strong></p><ul><li>从头到脚遍历（或者从脚到头遍历）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="type">int</span> Tablelen;<span class="comment">//表长</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.Tablelen &amp;&amp; ST.elem[i]!=key;i++)</span><br><span class="line"><span class="keyword">return</span> i==ST.Tablelen ? <span class="number">-1</span> : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有哨兵"><a href="#有哨兵" class="headerlink" title="有哨兵"></a>有哨兵</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="comment">//查找表的数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="type">int</span> Tablelen;<span class="comment">//表长</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line">ST.elem[<span class="number">0</span>]=key;<span class="comment">//哨兵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=ST.Tablelen;ST.elem[i]!=key;i--)</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//查找成功返回下标；失败返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用哨兵占数组0号位置，数据从下标1开始存</li><li>无需判断是否越界，效率高</li></ul><p>查找效率</p><ul><li>查找成功：$ASL&#x3D;\frac{1+n}{2}$</li><li>查找失败：ASL&#x3D;n+1</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><strong>对于有序表来说</strong></p><p>该树又称查找判定树</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207272312835.png" alt="image-20220727231243733"></p><p>查找不成功：$ASL&#x3D;\frac{n}{2}+\frac{n}{n+1}$</p><p><strong>被查概率不等时</strong></p><ul><li>概率大的靠在前面</li></ul><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><ul><li>又称二分查找，只适用于<strong>有序</strong>的<strong>顺序表</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="comment">//查找表的数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType *elem;</span><br><span class="line"><span class="type">int</span> Tablelen;<span class="comment">//表长</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> low=<span class="number">0</span>,high=L.Tablelen<span class="number">-1</span>,mid;</span><br><span class="line"><span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(L.elem[mid]==key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率分析</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207272322797.png" alt="image-20220727232219361"></p><p>​折半查找在<strong>查找不成功</strong>时与定值进行关键字的比较<strong>次数最多为树的高度</strong>：$⌈log_2 (n+1)⌉$或者$⌊log_2 n⌋$+1</p><h3 id="查找判定树"><a href="#查找判定树" class="headerlink" title="查找判定树"></a>查找判定树</h3><p>当$mid&#x3D;⌊(low+high)&#x2F;2⌋$</p><ul><li>对于任何一个结点，必有：<strong>右子树结点-左子树结点树&#x3D;0&#x2F;1</strong><ul><li>low和high有奇数个元素，则左右两部分元素相等</li><li>当low和high有偶数个元素，mid分割后左半部分比右半部少一个元素</li></ul></li><li><strong>折半查找的判定树一定是平衡二叉树</strong>（也是二叉排序树）</li><li>只有最下面一层是不满的</li><li>判定结点关键则：<strong>左&lt;根&lt;右</strong>，满足排序二叉树定义</li><li>失败结点：n+1等于成功结点的空链域数目</li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207272322797.png" alt="image-20220727232219361"></li></ul><p>时间复杂度：$O(log_2n)$</p><p>当$mid&#x3D;⌈(low+high)&#x2F;2⌉$，则与上述相反</p><ul><li>对于任何一个结点，必有：<strong>左子树结点-右子树结点树&#x3D;0&#x2F;1</strong></li></ul><p><strong>题型</strong></p><ul><li>若是求查找成功或者失败的平均查找长度，则需要画出判定树进行求解</li></ul><p>快速画出查找判定树</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210242208000.jpg"></p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>分块查找，又称索引顺序查找，算法过程如下:</p><ul><li><p>①在索引表中确定待查记录所属的分块（可顺序、可折半)</p></li><li><p>②在块内顺序查找</p></li></ul><p>“<strong>索引表</strong>“中保存每个分块的<strong>最大关键字和分块的存储区间</strong></p><p>可以用折半查找和顺序查找来遍历索引表</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207282300609.png" alt="image-20220728230000455"></p><p> <strong>折半查找索引</strong></p><ul><li>若索引表中<strong>不包含目标关键字</strong>，则折半查找索引表最终停在low&gt;high，<strong>要在low所指分块中查找</strong></li></ul><h3 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207282304142.png" alt="image-20220728230402623"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207282306906.png" alt="image-20220728230609383"></p><p>若查找表为动态查找表，一般用链式存储</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207292315272.png" alt="image-20220729231452882"></p><ul><li>注意题目是用折半查找还是顺序表查找索引表</li></ul><p>解答<strong>有序表查找</strong>问题，<strong>画出其判定树判断</strong></p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="5叉查找树"><a href="#5叉查找树" class="headerlink" title="5叉查找树"></a>5叉查找树</h2><p>结点定义1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5叉查找树定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    ElemType keys[<span class="number">4</span>];<span class="comment">//最多4个关键字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *child[<span class="number">5</span>];<span class="comment">//最多5个孩子</span></span><br><span class="line">    <span class="type">int</span> num;  <span class="comment">//结点中有几个关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结点内关键字有序</li><li>一个节点最少一个关键字，2个分叉</li><li>最多4个关键字，5个分叉</li></ul><p>提高查找效率</p><ul><li>m叉查找树中，规定除了根节点外，任何结点至少有$⌈m&#x2F;2⌉$个分叉，即至少含有$⌈m&#x2F;2- 1⌉$个关键字</li><li>m叉查找树中，规定对于任何一个结点，所有子树的高度都要相同</li></ul><h2 id="B树-1"><a href="#B树-1" class="headerlink" title="B树"></a>B树</h2><p>B树，又称<strong>多路平衡查找树</strong>，B树中所有<strong>结点的孩子个数的最大值</strong>称为B树的<strong>阶</strong>，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树:</p><ol><li>树中<strong>每个结点至多有m棵子树</strong>，即<strong>至多</strong>含有<strong>m-1</strong>个关键字。</li><li>若<strong>根结点不是终端结点</strong>，则<strong>至少有两棵子树。</strong><ul><li>根节点的子树数∈⌈2, m⌉，关键字数∈⌈1, m-1⌉。</li><li>其他结点的子树数∈⌈⌈m&#x2F;2⌉, m⌉;关键字数∈⌈⌈m&#x2F;2⌉-1, m-1⌉</li></ul></li><li>除根结点外的所有<strong>非叶结点</strong>至少有「m&#x2F;2⌉棵子树，即至少含有「m&#x2F;2⌉-1个关键字。</li><li>所有的<strong>叶结点都出现在同一层次上</strong>，并且不带信息（可以视为外部结点或类似于折半查找判定树的<strong>查找失败结点</strong>，实际上这些结点不存在，指向这些结点的指针为空)。</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302131472.png" alt="image-20220730213139111"></p><p>关键字的值:子树0&lt;关键字1&lt;子树1&lt;关键字2&lt;子树2&lt;….(类比二叉查找树左&lt;中&lt;右)</p><p><strong>高度</strong></p><ul><li>最小高度——m-1个关键字，m个分叉<ul><li>$h\geq log_m(n+1)$</li></ul></li><li>最大高度——根节点2个分叉，其他节点⌈m&#x2F;2⌉个分叉<ul><li>$log_{⌈m&#x2F;2⌉} \frac{1+n}{2}+1$</li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302156050.png" alt="image-20220730215600665"></li></ul></li><li>n个关键字的结点必有n+1个叶子节点(对于终端结点)</li></ul><h2 id="B树操作"><a href="#B树操作" class="headerlink" title="B树操作"></a>B树操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>情况如下</p><p>新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</p><ol><li>在插入key后，若<strong>导致原结点关键字数超过上限</strong>，则从中间位置(⌈m&#x2F;2⌉)将其中的关键字分为两部分，<strong>左部分</strong>包含的关键字放在原结点中，<strong>右部分</strong>包含的关键字<strong>放到新结点中</strong>，<strong>中间位置⌈m&#x2F;2⌉的结点插入原结点的父结点</strong></li><li>若此时<strong>导致其父结点的关键字个数也超过了上限</strong>，则继续进行这种分裂操作，直至这个过程<strong>传到根结点</strong>为止，进而导致<strong>B树高度增I</strong>。</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302209536.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208012320524.png"></p><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul><li><p>若被删除关键字在<strong>终端节点</strong>，则<strong>直接删除该关键字</strong>(要注意节点关键字个数<strong>是否低于下限⌈m&#x2F;2⌉- 1</strong>)</p></li><li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱或直接后继</strong>来替代被删除的关键字（相当中序排序前驱和后继）</p><ul><li>直接前驱:当前关键字<strong>左侧指针所指子树中“最右下</strong>”的元素</li><li>直接后继:当前关键字右侧指针所指子树中“最左下”的元素</li><li>对非终端结点的操作必然可以转为对终端结点的操作</li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302216240.png"></li></ul></li><li><p>兄弟够借：若被删除关键字所在结点删除前的关键字个<strong>数低于下限</strong>，且与此结点<strong>右（或左)兄弟结点</strong>的关键字个数<strong>还很宽裕</strong>，则需要调整该结点、右(或左）兄弟结点及其双亲结点（父子换位法)</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302217193.png"></p></li><li><p><strong>兄弟不够借</strong>：若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均等于⌈m&#x2F;2⌉-1，则将关键字<strong>删除后与左(或右）兄弟结点及双亲结点中的关键字进行合并</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302217119.png"></p></li></ul><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302219498.png" alt="image-20220730221941446"></p><p>一棵<strong>m阶</strong>的B+树需满足下列条件:</p><ul><li>每个分支结点最多有<strong>m棵子树</strong>(孩子结点)。</li><li>非叶子结点的<strong>根结点至少有两棵子树</strong>，其他每个分支结点至少有⌈m&#x2F;2⌉棵子树。<ul><li>根节点的关键字数n∈⌈2, m⌉</li><li>其他结点的关键字数n∈⌈⌈m&#x2F;2⌉, m⌉</li></ul></li><li>结点的<strong>子树个数与关键字个数相等</strong>。</li><li>所有<strong>叶结点</strong>包含全部关键字及指向相应记录的<strong>指针</strong>，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。——支持顺序查找</li><li>所有<strong>分支结点</strong>中仅包含它的各个<strong>子结点中关键字的最大值</strong>及指向其子结点的指针。</li></ul><p><strong>查找</strong></p><ul><li>B+树中，无论查找成功与否，最终一定都要走到最下面一层结点</li></ul><p>在B+树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207302225805.png" alt="image-20220730222504542"></p><h1 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h1><p><strong>散列表</strong>：又称哈希表。是一种数据结构，</p><ul><li><p>特点是︰数据元素的<strong>关键字</strong>与<strong>其存储地址直接相关</strong></p></li><li><p>若不同的关键字通过散列函数<strong>映射到同一个值</strong>，则称它们为“<strong>同义词</strong>”</p></li><li><p>通过散列函数确定的位置<strong>已经存放了其他元素</strong>，则称这种情况为<strong>冲突</strong></p></li></ul><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>又称链接法，链地址法</p><p>处理冲突：将所有<strong>同义词放在一个链表中</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208021246489.png" alt="image-20220802124604465"></p><h3 id="散列查找-1"><a href="#散列查找-1" class="headerlink" title="散列查找"></a>散列查找</h3><p>若对拉链法存放的形式，若该位置为空链表，则查找长度为0</p><p><strong>装填因子<em>α</em></strong>&#x3D;表中记录数（元素个数）&#x2F;散列表长度</p><ul><li>同时也等于平均查找失败的ASL</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211042315657.png" alt="image-20221104231540488"></p><p>注意：算失败平均长度时，失败结点(空结点)是否要算入个数待定——网上两种说法</p><p>默认不算</p><p>对于例题，已知装填因子和表中记录数，则算出的散列表长度为N&#x3D;⌈表中记录数&#x2F;装填因子⌉，则模p取不大于N的最大素数</p><h3 id="常见散列函数"><a href="#常见散列函数" class="headerlink" title="常见散列函数"></a>常见散列函数</h3><p><a href="https://blog.csdn.net/liu17234050/article/details/104270709?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165941636116782248584598%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165941636116782248584598&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-104270709-null-null.142%5Ev38%5Enew_blog_pos_by_title&utm_term=%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95&spm=1018.2226.3001.4187">常见散列函数</a></p><p><strong>留数除余法</strong></p><ul><li>H(key) &#x3D; key % p </li><li>散列表<strong>表长为m</strong>，取一个不大于m但<strong>最接近或等于m</strong>的<strong>质数p</strong></li></ul><p><strong>直接定址法</strong></p><ul><li>$H(key) &#x3D; key或 H(key) &#x3D; a*key + b$</li><li>其中，a和b是常数。它适合<strong>关键字的分布基本连续</strong>的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</li></ul><p><strong>数字分析法</strong></p><ul><li><p>选取数码分布较为均匀的若干位作为散列地址</p></li><li><p>设关键字是r进制数（如十进制数)，而r个数码在各位上出现的<strong>频率不一定相同</strong>，可能在某些位上分布均匀一些，每种数码出现的机会均等;</p></li><li><p>而在某些位上<strong>分布不均匀</strong>，只有<strong>某几种数码经常出现</strong>，此时可选取数码<strong>分布较为均匀的若干位作为散列地址</strong>。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</p></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208021258064.png" alt="image-20220802125810977"></p><p><strong>平方取中法</strong></p><ul><li><p>取关键字的平方值的中间几位作为散列地址。</p></li><li><p>平方取中法比较<strong>适合</strong>于<strong>不知道关键字的分布</strong>，而<strong>位数又不是很大</strong>的情况</p></li><li><p>比如假设关键字是 4321，那么它的平方就是 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址</p></li></ul><p><strong>散列查找</strong>是典型的“<strong>用空间换时间</strong>”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低。</p><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>所谓开放定址法，是指可存放新表项的<strong>空闲地址既向它的同义词</strong>表项开放，又向它的<strong>非同义词表项开放</strong>。</p><p>其数学递推公式为：$H_i&#x3D;(H(key)+d_i)%m$</p><ul><li>$i&#x3D;0,1,2,…,k,k&lt;&#x3D;m-1$,</li><li>m为散列表长度，$d_i$为增量序列</li><li>i可以理解为第i次发生冲突</li></ul><h3 id="线性寻址法"><a href="#线性寻址法" class="headerlink" title="线性寻址法"></a>线性寻址法</h3><ul><li>发生冲突时，每次往后探测下一个相邻位置是否为空</li><li>$i&#x3D;0,1,2,…,k,k&lt;&#x3D;m-1$,</li></ul><p>线性探测容易产生“聚集”现象。当表中的第i、i+1、i+2的位置上已经存储某些关键字，则下一次哈希地址为i、i+1、i+2、i+3的关键字都将企图填入到i+3的位置上，这种多个哈希地址不同的关键字争夺同一个后继哈希地址的现象称为“聚集”。聚集对查找效率有很大影响</p><h4 id="判断查找成功和失败时的平均长度"><a href="#判断查找成功和失败时的平均长度" class="headerlink" title="判断查找成功和失败时的平均长度"></a>判断查找成功和失败时的平均长度</h4><p><a href="https://blog.csdn.net/weixin_38233103/article/details/109228137?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166350527916800180628997%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166350527916800180628997&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-1-109228137-null-null.142">判断查找成功和失败时的平均长度</a></p><p>接下来重点讲解查找失败的ASL<br>求解查找失败的ASL需要计算出每个散列位置（即每个模对应的值）查找失败所需要的的次数，本题散列函数模的是7，所以只需要计算模为0,1,2,3,4,5,6的关键字查找失败所需要的次数。<strong>查找到空说明查找失败</strong>，查找示意图如下</p><p>查找模为0的关键字，失败时比较的次数为3</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209182238805.png"></p><p>查找模为1的关键字，失败时比较次数为2  </p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209182238887.png"></p><p> 查找模为2的关键字，失败时比较次数为1</p><p>查找模为3的关键字，失败时比较次数为2  </p><p> 查找模为4的关键字，失败时比较次数为1</p><p> 查找模为5的关键字，失败时比较次数为5</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209182240044.png"></p><p> 查找模为6的关键字，失败时比较次数为4</p><p> 将上述过程整理成表格如下</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209182240378.png" alt="image-20220918224010748"><br>查找失败的平均比较次数为：<br><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209182239032.gif"></p><p>注意：模为m,分母为m，只找在地址在0到m-1的数据判断（其他数据不看）,但是对于比较失败结点，一个结点的失败比较是从对比地址位置当前往后面直到找到空的次数（在散列表范围内）</p><p>查找成功时，<strong>分母为哈希表元素个数</strong>，查找不成功时，分母为 <strong>mod 的 K 值</strong>。</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211042238063.jpg"></p><h3 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h3><ul><li>$i&#x3D;0^2,1^2,-1^2,2^2,…,k^2,-k^2,k&lt;&#x3D;m&#x2F;2$</li><li><strong>注意</strong>：散列表长度m必须是一个可以表示成<strong>4j+ 3的素数</strong>，才能探测到所有位置</li><li>平方探测法:比起线性探测法更不易产生“聚集（堆积)”问题</li></ul><h3 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a>伪随机序列法</h3><ul><li>自己设计一个占位序列</li></ul><p><strong>注意</strong></p><ul><li>采用“<strong>开放定址法</strong>”时，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入</li><li>散列表的同义词结点的查找路径，可以做一个<strong>“删除标记</strong>“，进行逻辑删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.图</title>
      <link href="/data.github.io/post/c32bee47.html"/>
      <url>/data.github.io/post/c32bee47.html</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>定义：图G由</strong>顶点集V<strong>和边集E</strong>组成，记$G&#x3D;(V,E)$</p><ul><li>V(G)表示图G中顶点的有限非空集</li><li>E(G)表示图G中顶点之间的关系(<strong>边</strong>)集合</li><li>$|V|$表示图G中<strong>顶点个数</strong>，也称图G的<strong>阶</strong></li><li>$|E|$表示图G中<strong>边的条数</strong></li><li>图不可以是空，V一定是非空集</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207162218866.png" alt="image-20220716221815058"></p><p><strong>无向图</strong></p><ul><li><p><strong>定义</strong>：E为<strong>无向边</strong>（<strong>边</strong>）的有限集合时，则图G为<strong>无向图</strong></p></li><li><p>边是顶点的无序对，记为$(v,w)或(w,v)$,其中<strong>v,w为顶点</strong>，互为相邻点</p></li><li><p><strong>顶点v的度</strong>指的是依附于<strong>该顶点的边的条数</strong>，记为$TD(v)$</p></li><li><p>在具有n个顶点,e条边的无向图中，无向图的<strong>全部顶点的度的和等于边数的2倍</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207162228548.png" alt="image-20220716222848799"></p></li></ul><p> <strong>有向图</strong></p><ul><li><strong>定义</strong>：E为<strong>有向边（弧）</strong>的有限集合，图<strong>G为有向图</strong></li><li><strong>入度</strong>是以顶点<strong>v为终点</strong>(弧头端)的有向边的数目，记$ID(v)$</li><li><strong>出度</strong>是以顶点<strong>v为起点</strong>(弧尾)的有向边的数目，记为$OD(v)$</li><li>弧是顶点的有序对，记为   <strong><code>&lt;v,w&gt;</code></strong> ，其中v,w为顶点，v称为弧尾，w称为弧头（<strong>有箭头</strong>），表示<strong>从顶点v到顶点w的弧</strong></li><li>一个顶点的度<strong>等于其入度和出度之和</strong></li><li>n个顶点，e条边的<strong>入度之和</strong>与<strong>出度之和</strong>相等且为e</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207162233020.png" alt="image-20220716223356972"></p><p><strong>简单图</strong></p><ul><li>不存在重复边</li><li>不存在顶点到自身的边</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207162237417.png" alt="image-20220716223749589"></p><p><strong>多重图</strong></p><ul><li>图G中某两个结点之间的边数多于一条：无向图两个顶点存在2个以上的边；有向图由B指向E的弧存在两条</li><li>又允许<strong>顶点通过同一条边和自己关联</strong>，则G为多重图</li></ul><h3 id="顶点与顶点之间描述"><a href="#顶点与顶点之间描述" class="headerlink" title="顶点与顶点之间描述"></a>顶点与顶点之间描述</h3><ul><li><strong>路径</strong>：顶点$v_p$到顶点$v_q$之间的一条路径是指顶点序列</li><li><strong>回路</strong>：第一个顶点和最后一个顶点 相同的路径称为<strong>回路</strong>或<strong>环</strong></li><li><strong>简单路径</strong>：在路径序列中，顶点不重复出现的路径</li><li><strong>简单回路</strong>：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</li><li>路径长度：路径上边的数目</li><li>点到点的距离：从顶点u到顶点v的<strong>最短路径若存在</strong>，该路径长度称为<strong>u到v的距离</strong>；若<strong>不存在路径</strong>，则记为<strong>无穷</strong></li><li><strong>无向图中</strong>，若从顶点v到顶点w有路径存在，则称v和w是<strong>连通</strong>的</li><li><strong>有向图中</strong>，若从顶点v到顶点w和从顶点w到顶点v之间<strong>都有路径</strong>，则称这两个顶点是<strong>强连通</strong>的</li></ul><p><strong>连通图</strong></p><p><strong>定义</strong>：图G中任意两个顶点都是连通的，图G为连通图，否则为非连通图</p><p><strong>常见考点</strong></p><ul><li>对于n个顶点的无向图G</li><li>G为连通图，则最少有n-1个边</li><li>G为非连通图，则最多可能有$C^2_{n-1}$个边</li></ul><p><strong>强连通图</strong></p><p>**定义:**若图中任何一对顶点都是强连通的，则称此图为强连通图。</p><p>常见考点</p><ul><li>对于n个顶点的有向图，若图G为强连通图，则最少有n条边（<strong>形成回路</strong>），最多n(n-1)条边</li></ul><p>判断强连通分量，当某个顶点只有出弧没有入弧度时，其他顶点无法到达这个顶点（注意单独一个顶点可构成一个强连通分量），例子顶点1无入弧构成一个强连通分量（本身），删除顶点1及所有以之为尾的弧。其他依次类推</p><h3 id="图的局部"><a href="#图的局部" class="headerlink" title="图的局部"></a>图的局部</h3><p><strong>无向图</strong></p><p><strong>子图</strong>：设有两个图$G &#x3D;(V,E)和G’&#x3D; (V’ ,E’)$，若v’是v的子集，且E’是E的子集，<strong>则称G’是G的子图</strong></p><ul><li>并非任意结点和边都能构成子图，要满足图的定义</li></ul><p><strong>生成子图</strong>：若满足$V(G)&#x3D;V(G’)$的子图（子图含有所有顶点）</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207171954012.png" alt="image-20220717195346955"></p><p>有向图同上</p><p><strong>连通分量</strong>：<strong>无向图</strong>的极大连通子图（子图必连通，且包含尽可能多的边和顶点）</p><p><strong>强连通分量</strong>：<strong>有向图</strong>的极大强连通子图（子图必连通，且包含尽可能保留多的边）</p><p><strong>生成树</strong></p><ul><li>连通图的生成树是包含图中全部顶点的一个<strong>极小</strong>连通子图（边尽可能少，且要保持连通）</li><li>若图中顶点数为n,则生成树含有<strong>n-1</strong>条边</li><li>生成树砍去一条边变成非连通图，加上则形成一个回路</li><li>在非连通图中，连通分量的生成树构成非连通图的森林</li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207172009634.png" alt="image-20220717200943992"></li></ul><p><strong>边的权</strong>：在一个图中，<strong>每条边</strong>都可以标上具有某种含义的数值，该数值称为<strong>该边的权值</strong>。</p><p>**带权图(网)**：边上带有权值的图称为带权图，也称网。</p><p><strong>带权路径长度</strong>：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p><h3 id="特殊形状的图"><a href="#特殊形状的图" class="headerlink" title="特殊形状的图"></a>特殊形状的图</h3><ul><li><strong>无向完全图</strong>：<strong>无向图</strong>任意两个顶点都存在边，n个顶点，共$C_n^2$条边</li><li><strong>有向完全图</strong>：<strong>有向图</strong>中任意两个顶点之间都存在<strong>方向相反的两条弧</strong></li><li><strong>稀疏图</strong>：边数很少的图</li><li><strong>稠密图</strong>：边数很多的图</li><li><strong>树</strong>：不存在回路，且连通的图<ul><li>n个顶点，必有n-1个边(图边数大于n-1,必有回路)</li></ul></li><li>有向树：一个顶点的入度为0（根结点）、其余顶点的入度均为1的有向图，称为有向树。</li></ul><p><strong>题型</strong></p><p>问任何情况下都连通最少边数情况：一个完全无向图的边树加最后一个顶点连通的边</p><p>已知边，非连通图最少顶点：一个完全图加上一个独立的顶点</p><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p>1代表有边，0代表无边</p><p>对于有向图</p><ul><li>有向图表，是对应横向指向列项</li><li>第i个结点的<strong>出度</strong>&#x3D;<strong>第i行</strong>的非零元素个数</li><li>第i个结点的<strong>入度</strong>&#x3D;<strong>第i列</strong>的非零元素个数</li><li>第i个结点的度&#x3D;第i行、第i列的非零元素个数之和</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207172022163.png" alt="image-20220717202202684"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> Vex[MaxVertexNum];   <span class="comment">//顶点表</span></span><br><span class="line"><span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵，边表</span></span><br><span class="line"><span class="type">int</span> venum,arcnum;        <span class="comment">//图的当前顶点数和边数/弧数   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邻接矩阵法存储带权图&#x2F;网</strong></p><ul><li><p>与上图类似，无边就用无穷（0）代替，有边用相应的权值代替</p></li><li><p>空间复杂度：$O(|V|^2)$,只有顶点数有关。适用存储稠密图</p></li><li><p>无向图的邻接矩阵是<strong>对称矩阵</strong>，可以压缩存储</p></li></ul><p><strong>邻接矩阵法性质</strong></p><ul><li>设图G的邻接矩阵为A(矩阵元素为0&#x2F;1），则$A^n$的元素$A ^n [i][j]$等于由<strong>顶点i</strong>到<strong>顶点j的长度为n</strong>的<strong>路径的数目</strong></li></ul><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul><li>顺序+链式存储：对于图G中的每个顶点<code>Vi</code>，将所有邻接于<code>Vi</code>的顶点<code>Vj</code>链成一个单链表，这个单链表就称为顶点</li><li>Vi的邻接表，再将所有顶点的<code>邻接表表头</code>放到数组中，就构成了图的邻接表。</li><li>无向图<ul><li>整体空间复杂度：$O(|V|+2|E|)$</li></ul></li><li>有向图<ul><li>整体空间复杂度：$O(|V|+|E|)$</li><li>顶点结点后面连接的边结点：<strong>顶点结点指向边结点</strong>，与顺序无关</li><li>有向图的邻接表是头结点指向表结点</li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202212032238799.jpg"></li></ul></li><li>图的邻接表表示方式不唯一</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207192309301.png" alt="image-20220719230925693"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="comment">//边表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;      <span class="comment">//该弧指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *next;<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;</span><br><span class="line">    VertexType data;    <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;     <span class="comment">//第一条边/弧</span></span><br><span class="line">&#125;VNode,AdjList[MaxvertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;   <span class="comment">//图的顶点和弧数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207192314622.png" alt="image-20220719231432186"></p><h3 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h3><p>只适用于<strong>存储有向图</strong></p><p>结点信息：弧结点，顶点结点</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207211948815.png" alt="image-20220721194857896"></p><p>边结点信息：绿色指向橙色(尾指头)</p><p>水平方向为顶点结点指向其他结点</p><p>竖直方向为顶点结点被指向</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207211947313.png" alt="image-20220721194725901"></p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>用来存储无向图</p><p>顶点信息</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207211955848.png" alt="image-20220721195523888"></p><p>横向为与橙色结点连接的边</p><p>竖直为与绿色结点连接的边</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207211959901.png" alt="image-20220721195901448"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207252240601.png" alt="image-20220725224016111"></p><h1 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h1><p><a href="https://blog.csdn.net/qq_40310148/article/details/106747750?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-106747750.nonecase&spm=1018.2226.3001.4187">图的基本操作</a></p><p>1.Adjacent(G,x,y)：判断图G是否存在边&lt;x,y&gt;或(x,y)</p><p>邻接矩阵查找时间复杂度：O（1）</p><p>邻接表查找时间复杂度：O（1）~O（|V|）</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207212009864.png" alt="image-20220721200947697"></p><p>其他操作有向图同理</p><p>2.Neighbors(G,x)：列出图G中与结点x邻接的边</p><p>邻接矩阵查找时间复杂度：O（|V|）：遍历一个顶点的一行或者一列</p><p>邻接表查找时间复杂度：O（1）~O（|V|）</p><p>V为顶点数</p><p>E为边数</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><p><strong>思路</strong>：广度优先遍历，指的是从图的一个未遍历的节点出发，<strong>先遍历这个节点的相邻节点</strong>，再依次遍历每个相邻节点的相邻节点。</p><p>一般需要借助<strong>队列结构</strong>实现广度树的广度优先遍历</p><p>对应的二叉树层序遍历</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>找到与一个顶点相邻的所有顶点</li><li>标记那些顶点被访问过</li><li>需要一个辅助队列</li></ol><p>FirstNeighbor(G,x)︰求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。</p><p>NextNeighbor(G,x,y)︰假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</p><blockquote><ol><li>A 入队；</li><li>A 出队，判断 A 的邻接点；</li><li>A 的邻接点 B、C 入队；</li><li>B 出队，判断 B 的邻接点；</li><li>B 的邻接点 D、E 入队；</li><li>C 出队，判断 C 的邻接点，都被标记不入队列；</li><li>D 出队，判断 D 的邻接点；</li><li>E 出队，判断 E 的邻接点。</li><li>队列为空，终止。</li></ol></blockquote><p>流程</p><ul><li>结点A出队，然后判断结点A所有邻接点入队</li><li>结点B出队，判断结点B的所有邻接点入队(不包括已被标记的)，重复上述步骤</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207212106536.gif"></p><p>手动模拟</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211182153650.png" alt="image-20221118215341798"></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[max_vertex_num] <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">visited[i]=<span class="literal">false</span>;<span class="comment">//初始化标记数组</span></span><br><span class="line"><span class="built_in">InitQueue</span>(Q);<span class="comment">//初始化辅助队列</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line"><span class="keyword">if</span>(!visited[i])  <span class="comment">//对每个来连通分量调用一次BFS</span></span><br><span class="line"><span class="built_in">BFS</span>(G,i);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;   <span class="comment">//从顶点v出发，广度优先遍历G</span></span><br><span class="line"><span class="built_in">visit</span>(v);        <span class="comment">//访问初始结点</span></span><br><span class="line">visited[v]=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">Enqueue</span>(Q,v);      <span class="comment">//顶点v入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队列不为空执行循环</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line"><span class="built_in">DeQueue</span>(Q,v);   <span class="comment">//顶点v出队</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> w=<span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,v,w))&#123;</span><br><span class="line"><span class="comment">//检测v所有邻接点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!visited[w])<span class="comment">//w为v尚未访问的邻接顶点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">visit</span>(w);</span><br><span class="line">    visited[w]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,w);    <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一个图<strong>的邻接矩阵</strong>表示方式唯一，广度优先遍历序列<strong>唯一</strong></li><li>同一个<strong>邻接表</strong>表示方式不唯一，广度优先遍历<strong>不唯一</strong></li></ul><p>结论：对于<strong>无向图</strong>，<strong>调用BFS的次数&#x3D;连通分量数</strong></p><p>邻接矩阵存储的图：时间复杂度&#x3D;$O(|V| ^ 2)$</p><p>邻接表存储的图：时间复杂度&#x3D;$O(|V|+| E|)$</p><h3 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h3><ul><li>广度优先生成树由广度优先遍历过程确定。由于邻接表的表示方式不唯一，因此基于邻接表的广度优先生成树也不唯一</li><li>对于连通图，广度优先搜索可以得到广度优先生成树</li><li>对于非连通图，广度优先搜索可以得到广度优先生成森林</li></ul><p>对于先访问2结点</p><blockquote><p>对于邻接表的寻找</p><p>从结点2开始，后面的边结点（1，6）全部作为子孩子</p><p>遇到标记过的直接跳过，然后再到顶点结点1，访问边结点（5）…；</p><p>对于结点1操作访问完了，再继续访问结点6后面的子孩子….</p></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207212128060.png" alt="image-20220721212851655"></p><h2 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h2><p><strong>思路</strong>：从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是<strong>不撞南墙不回头，先走完一条路，再换一条路继续走</strong>。</p><p>一般需要借助<strong>栈结构</strong>来实现树的深度优先遍历</p><p>对应树的先根遍历（二叉树先序遍历）</p><h3 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h3><ul><li>同一个图<strong>的邻接矩阵</strong>表示方式唯一，深度优先遍历序列<strong>唯一</strong></li><li>同一个<strong>邻接表</strong>表示方式不唯一，深度优先遍历<strong>不唯一</strong></li></ul><p>虚线箭头表示回溯</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207212210914.gif"></p><p>对于邻接表深度优先遍历，就是访问该节点如果没有被访问则跳到该节点对应的头链表，访问后面节点，如果被访问过了，则跳过访问下一个节点</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210152225141.png" alt="image-20221015222535396"></p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>空间复杂度</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207212142501.png" alt="image-20220721214250715"></p><p><strong>时间复杂度</strong></p><ul><li>邻接矩阵存储的图：时间复杂度&#x3D;$O(|V| ^ 2)$</li><li>邻接表存储的图：时间复杂度&#x3D;$O(|V|+| E|)$</li></ul><h3 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207212213279.png" alt="image-20220721221257078"></p><p>在在B点回溯两次，则作为结点B的两个子树</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><p><strong>无向图</strong></p><ul><li><p>对无向图进行BFS&#x2F;DFS遍历调用BFS&#x2F;DFS函数的次数&#x3D;连通分量数</p></li><li><p>对于连通图，只需要调用一次BFS&#x2F;DFS</p></li></ul><p><strong>有向图</strong></p><ul><li><p>调用BFS&#x2F;DFS函数的次数要具体问题具体分析</p></li><li><p>若起始顶点到其他各顶点都有路径，则只需调用1次BFS&#x2F;DFS函数</p></li><li><p>对于强连通图，从任一结点出发都只需调用1次BFS&#x2F;DFS</p></li></ul><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>生成树</strong>：连通图的生成树是包含图中全部顶点的一个极小连通子图</p><p><strong>最小生成树</strong>：对于一个<strong>带权连通无向图</strong>G&#x3D;(V,E)，生成树不同，每棵树的权〈即树中所有边上的权值之和)也可能不同。设R为G的所有生成树的集合，若<strong>T</strong>为R中<strong>边的权值之和最小</strong>的生成树，则T称为G的最小生成树</p><ul><li>最小生成树不止一个</li><li>边数&#x3D;顶点数 — 1</li><li>只有连通图有最小生成树，非连通图只有生成森林</li><li>如果连通图本身是一棵树，则最小生成树是本身</li></ul><h2 id="求最小生成树"><a href="#求最小生成树" class="headerlink" title="求最小生成树"></a>求最小生成树</h2><h3 id="prim算法-普里姆"><a href="#prim算法-普里姆" class="headerlink" title="prim算法(普里姆)"></a>prim算法(普里姆)</h3><p><strong>思想：</strong>从<strong>某一个顶点</strong>开始构建生成树;每次将<strong>代价最小的新顶点纳入生成树</strong>，直到所有顶点都纳入为止。</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207231956245.png" alt="image-20220723195645967"></p><p>时间复杂度：$O(|V| ^2 )$——适合用于边稠密图</p><ul><li>共处理n-1轮，每轮最坏循环n次</li></ul><h4 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h4><ul><li>初始从$v_0$开始</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207232002882.png" alt="image-20220723200229700"></p><h3 id="Kruskal算法（克鲁斯卡尔）"><a href="#Kruskal算法（克鲁斯卡尔）" class="headerlink" title="Kruskal算法（克鲁斯卡尔）"></a>Kruskal算法（克鲁斯卡尔）</h3><p><strong>思想：</strong>每次<strong>选择一条权值最小的边</strong>，使这条边的两头连通（原本已经连通的就不选)，直到所有结点都连通。</p><p>时间复杂度：$O(|E|log_2|E| )$—适合用于边稀疏图</p><h4 id="实现思想-1"><a href="#实现思想-1" class="headerlink" title="实现思想"></a>实现思想</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207232004476.png" alt="image-20220723200444367"></p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="BFS算法"><a href="#BFS算法" class="headerlink" title="BFS算法"></a>BFS算法</h2><ul><li>无权图可以视为特殊的带权图，每条边的权值为1</li></ul><p>其实就是通过生成了广度优先树，从树中可以看出路径长度</p><p>就是对BFS的小修改，再visit一个顶点时，修改其最短路径长度d[]（各节点到初始结点的最短距离）,并在<strong>path[]记录前驱结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS算法求解非带权图单源最短路径问题</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>    <span class="comment">//求到u的单源最短路径 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i]=∞;      <span class="comment">//初始化路径长度</span></span><br><span class="line">path[i]=<span class="number">-1</span>;       <span class="comment">//初始化到达每个顶点的前驱结点 </span></span><br><span class="line">&#125;</span><br><span class="line">visit[u]=<span class="literal">true</span>;</span><br><span class="line">d[u]=<span class="number">0</span>;            <span class="comment">//自身到自身的距离为0 </span></span><br><span class="line"><span class="built_in">EnQueue</span>(Q,u);</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isEmpty</span>(Q))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DeQueue</span>(Q,u);</span><br><span class="line"><span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G,u);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighbor</span>(G,u,w))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[w])</span><br><span class="line">&#123;</span><br><span class="line">visit[w]=<span class="literal">true</span>;</span><br><span class="line">d[w]=d[u]+<span class="number">1</span>;         <span class="comment">//路径长度加1 </span></span><br><span class="line">path[w]=u;           <span class="comment">//记录前驱结点</span></span><br><span class="line"><span class="built_in">EnQueue</span>(Q,w);       <span class="comment">//w入队 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>局限性：只适用无向图或者权值相同的图</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209072018661.png" alt="image-20220907201814504"></p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><strong>思想</strong></p><ul><li>用三个数组，标记是否被访问，记录最短路径长度（没连接为无穷），记录路径前驱（初始都为-1）</li><li>每轮先找到<strong>未被访问且dist最小</strong>的顶点vi，并标记为true</li><li>然后找到顶点vi的邻接点(未被访问)，并更新path和dist<ul><li>dist的含义是当前<strong>初始结点$v_ 0$到未被访问的最短路径</strong>(在访问过结点中的路径)</li><li>修改从$v_ 0$出发到未被访问的$v _ k$任一个顶点到达的最短路径长度：$dis[j]+arcs[j][k]&lt;dist[k],则dist[k]&#x3D;dis[j]+arcs[j][k]$</li><li>$arcs[j][k]$:顶点j到顶点k的权值</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207251257869.png" alt="image-20220725125724420"></p><p>例子</p><p>若结点vi是未加入到最短路径的结点</p><p>则相当于所有结点vi到最短路径的结点是否最短，再加入该结点</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207262221158.jpg"></p><p>图解</p><p>无向图</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207251314091.gif"></p><p>有向图</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207251314260.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207251315023.png"></p><p>时间复杂度：$O(|V| ^2)$</p><ul><li>不适合用于带负权值的带权图</li></ul><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>动态规划思想</p><p>对于n个顶点的图G，求任意一对顶点Vi一&gt;Vj之间的最短路径可分为如下几个阶段:</p><p>初始∶不允许在其他顶点中转，最短路径是?</p><p>0:若允许在V0中转，最短路径是?<br>1∶若允许在V0、V1中转，最短路径是?</p><p>2∶若允许在V0、V1、V2中转，最短路径是?..<br>n-1:若允许在V0、V1、.…..Vn-1中转，最短路径是?</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207251321977.jpeg" alt="img"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是弗洛伊德算法的核心部分 </span></span><br><span class="line">    <span class="comment">//k为中间点 </span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.vexnum; k++)&#123;</span><br><span class="line">        <span class="comment">//v为起点 </span></span><br><span class="line">        <span class="keyword">for</span>(v = <span class="number">0</span> ; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">            <span class="comment">//w为终点 </span></span><br><span class="line">            <span class="keyword">for</span>(w =<span class="number">0</span>; w &lt; G.vexnum; w++)&#123;</span><br><span class="line">                <span class="comment">//起点到终点距离大于起点到中间点与中间点到终点距离之和</span></span><br><span class="line">                <span class="keyword">if</span>(D[v][w] &gt; (D[v][k] + D[k][w]))&#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];<span class="comment">//更新最小路径 </span></span><br><span class="line">                    P[v][w] = P[v][k];<span class="comment">//更新最小路径中间顶点 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>找路径</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207251324112.png" alt="image-20220725132402665"></p><blockquote><p>路径判断先看v0-v4，存储下标为3：v0-v3-v4</p><p>看v0到v3，存储下标为2：v0-v2-v3-v4</p><p>看v2到v3，存储下标为1：v0-v2-v1-v3-v4</p><p>最后看相邻结点之间的存储下标，都为-1,则最终结果为：v0-v2-v1-v3-v4</p></blockquote><p>Floyd算法不能解决带有“负权回路”的图〈有负权值的边组成回路)，这种图有可能没有最短路径</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207251324741.png" alt="image-20220725132454253"></p><h1 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h1><p><strong>定义</strong>:若一个有向图中不存在环，则称为有向无环图，简称DAG图</p><p><strong>DAG表达式描述</strong></p><p>就是将一个式子用DAG图表示</p><ul><li>顶点中不能出现相同的操作数</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207252242534.png" alt="image-20220725224245826"></p><p>构造步骤</p><ol><li>把各个操作数不重复地排成一排</li><li>标出各个运算符的生效顺序（先后顺序有点出入无所谓)</li><li>按顺序加入运算符，注意“<strong>分层</strong>”</li><li>从底向上逐层检查同层的运算符是否可以合体</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207252245408.png" alt="image-20220725224533076"></p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p><strong>AOV网</strong>：用DAG图表示一个工程，顶点表示活动，有向边$&lt; V_i,V_j &gt;$表示活动$V_i$必须先于活动$V_j$进行</p><ul><li>每个AOV网有多个或一个拓扑排序</li></ul><p><strong>拓扑排序</strong>:在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序:</p><ul><li>每个顶点出现且只出现一次。</li><li>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。</li><li>就是找到做事的先后顺序</li></ul><h3 id="拓扑实现"><a href="#拓扑实现" class="headerlink" title="拓扑实现"></a>拓扑实现</h3><ul><li>①从AOV网中选择一个<strong>没有前驱</strong>（入度为0)的顶点并输出。</li><li>②从网中<strong>删除该顶点和所有以它为起点的有向边</strong>。</li><li>③重复①和②直到当前的<strong>AOV网为空</strong>或当前网中<strong>不存在无前驱的顶点</strong>为止(说明有回路)。</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207252255976.png" alt="image-20220725225538702"></p><p>邻接表时间复杂度：$O(|V|+|E |)$</p><p>邻接矩阵时间复杂度：$O(|V| ^2 )$</p><h3 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h3><p><strong>实现</strong></p><ul><li>①从AOV网中选择一个<strong>没有后继</strong>（出度为0)的顶点并输出。</li><li>②从网中<strong>删除该顶点和所有以它为起点的有向边</strong>。</li><li>③重复①和②直到当前的<strong>AOV网为空</strong>。</li></ul><p>也可用DFS算法实现逆拓扑排序</p><ul><li>DFS实现逆拓扑排序在顶点退栈前输出</li></ul><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><h2 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h2><p><strong>AOE网</strong>：在带权有向图中，以<strong>顶点表示事件</strong>，以<strong>有向边表示活动</strong>，以边上的<strong>权值</strong>表示<strong>完成该活动的开销</strong>(如完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207252310460.png" alt="image-20220725231021277"></p><p><strong>性质</strong></p><ul><li>只有在某顶点所代表的事件<strong>发生后</strong>，从<strong>该顶点出发的各有向边</strong>所代表的<strong>活动才能开始</strong>;</li><li>只有在进入某顶点的<strong>各有向边</strong>所代表的<strong>活动都已结束时</strong>，该顶点所代表的事件才能发生。另外，有些<strong>活动是可以并行进行</strong>的</li><li>在AOE网中<strong>仅有一个入度为0</strong>的顶点，称为<strong>开始顶点（源点)<strong>，它表示整个工程的</strong>开始</strong></li><li>也仅有一个<strong>出度为0</strong>的顶点，称为<strong>结束顶点（汇点)<strong>，它表示整个工程的</strong>结束</strong>。</li></ul><h2 id="关键路径-1"><a href="#关键路径-1" class="headerlink" title="关键路径"></a>关键路径</h2><p><strong>关键路径：</strong>从源点到汇点的有向路径可能有多条，所有路径中，<strong>具有最大路径长度的路径称为关键路径</strong>，而把关键路径上的<strong>活动称为关键活动</strong></p><ul><li><p>若关键活动不能按时完成，则整个工程要延时完成</p></li><li><p>**事件$v_k$的最早发生时间$ve(k)$**：决定所有从$v_ k$开始的活动那个能够开工的最早时间（表示从起点v0到活动点vk的最大权值之和）</p><ul><li>$ve(源点)&#x3D;0$，$ve( k)&#x3D;Max(ve(j)+weight(v_j,v_k))$，k为j的后继</li></ul></li><li><p><strong>活动$a_i$的最早发生时间$e(i)$<strong>：指该</strong>活动弧起点</strong>所表示的事件的最早发生时间——$e(i)&#x3D;v(k)$</p></li><li><p>**事件$v_k$的最迟发生时间$vl(k)$**：指不推迟整个工程完成前提下，该事件最迟必须发生的事件(从汇点开始减去到活动点的最小权值之和)</p><ul><li>vl(汇点)&#x3D;ve(汇点)</li><li>$vl( k)&#x3D;Min(vl(j)-weight(v_j,v_k))$,k为j的前驱</li></ul></li><li><p>**活动$a_i$的最迟开始时间$l(i)$**：它是指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。</p><ul><li>$l(i)&#x3D;vl(j)-weight(v_k,v_j)$</li></ul></li><li><p>**活动$a_ i$的时间余量$d(i)&#x3D;l(i)-e(i)$**：表示在不增加完成整个工程所需总时间的情况下，活动$a_ i$可以拖延的时间;<strong>若一个活动的时间余量为零</strong>，则说明该活动必须要如期完成，</p></li><li><p>$d(i)&#x3D;0$：活动a是<strong>关键活动</strong>,由关键活动组成的路径就是关键路径</p></li></ul><p>最迟发生时间就是，从终点开始，每次选出活动时间最短的一条边</p><p>最早发生时间，就是边上最大权值的。</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207262333922.jpg"></p><p>结点——事件时间</p><ul><li>结点最早开始时间：正着找，相加，取最大值</li><li>结点最晚开始时间：反着找，相减，取最小值</li><li>适用有多个结点到该节点时与活动之间权值之间的关系</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210092044847.png" alt="image-20221009204438150"></p><p>活动</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210092052824.png" alt="image-20221009205213503"></p><p> 如下表所示给出了某工程各工序之间的优先关系和各工序所需的时间(需解决)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.树与二叉树</title>
      <link href="/data.github.io/post/65d6c3b7.html"/>
      <url>/data.github.io/post/65d6c3b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ul><li>树是n个结点的有限集，空树:结点为0的树</li><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>非空树应满足<ul><li>有且只有一个特定的称为根的结点</li><li>当n&gt;1时，其余结点可以分为m个互不相交的有限集合，其中每个集合本身又是一棵树，并称为根的子树</li></ul></li><li>非空树特性<ul><li>有且只有一个根节点</li><li>没有后继的结点称为<strong>叶子结点</strong>（终端结点）——注：只有一个结点的树，该节点不是叶子节点</li><li>有后继的结点称为<strong>分支结点</strong>（非终端结点）</li><li>除了根节点外，任何结点都有且<strong>只有一个前驱</strong></li><li>每个结点可以有0个或多个后继</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207012108033.png" alt="image-20220701210802760"></p><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="结点之间的关系描述"><a href="#结点之间的关系描述" class="headerlink" title="结点之间的关系描述"></a>结点之间的关系描述</h4><ul><li>祖先结点：从根到该节点所经分支上的所有节点（该分支上的其他结点都是）</li><li>子孙结点：以某节点为根的子树中任一节点都称为该节点的子孙（该结点分支后面的所有结点）</li><li>父节点(双亲结点)：若一个节点含有子节点，则这个节点称为其子节点的父节点（结点的前驱）</li><li>子节点：一个节点含有的子树的根节点称为该节点的子节点</li><li>兄弟节点：具有<strong>相同父节点</strong>的节点互称为兄弟节点</li><li>堂兄弟结点：父节点在同一层的节点互为堂兄弟（就是父亲结点的兄弟结点的子节点），在同一层</li><li><strong>路径</strong>：只能从上往下</li><li><strong>路径长度</strong>：经过的边数</li><li>树的路径长度：从根结点到每个结点的路径长度之和</li></ul><h4 id="结点、树的属性描述"><a href="#结点、树的属性描述" class="headerlink" title="结点、树的属性描述"></a>结点、树的属性描述</h4><ul><li>结点的层次（深度）：从上往下数</li><li>结点的高度：从下往上数</li><li>树的高度：总共多少层</li><li><strong>结点的度</strong>：一个节点含有的<strong>子结点</strong>的个数称为该节点的度</li><li><strong>树的度</strong>：一棵树中，<strong>结点最大的度</strong>称为树的度</li><li>森林：m棵互不相交的树的集合</li><li>有序树：从逻辑上看，树中结点的各子树<strong>从左至右</strong>是<strong>有次序</strong>的，不能互换</li><li>无序树：从逻辑上看，树中结点的各子树<strong>从左至右</strong>是<strong>无次序</strong>的，可以互换</li></ul><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ol><li>树的结点总数 &#x3D; 所有结点的度数之和 + 1</li><li>度为<code>m</code>的树、<code>m</code>叉数的区别</li></ol><table><thead><tr><th>度为 <code>m</code> 的树</th><th><code>m</code> 叉树</th></tr></thead><tbody><tr><td>树的度：<code>m</code>为各结点的度的最大值</td><td><code>m</code>叉树：每个结点最多只能有 <code>m</code> 个孩子的树</td></tr><tr><td>任意结点的度 ≦ m</td><td>任意结点的度 ≦ m</td></tr><tr><td>至少有一个结点度 &#x3D; m</td><td>允许所有结点的度 &lt; m</td></tr><tr><td>一定是非空树，至少有m+1个结点</td><td>可以是空树</td></tr><tr><td>第i层至多有 $m^{i-1}$个结点</td><td>第i层至多有 $m^{i-1}$个结点</td></tr><tr><td>高度为<code>h</code>、度为 <code>m</code> 的树<strong>至少</strong>有<code>h+m-1</code>个结点（允许一层只有一个结点）</td><td>高度为<code>h</code>的<code>m</code>叉树至多有$\frac{m^h-1}{m-1}$个结点</td></tr><tr><td></td><td>具有<code>n</code>个结点的<code>m</code>叉树，最小高度为$⌈ log_m(n(m-1)+1)⌉$</td></tr></tbody></table><p>⌈  ⌉：向上取整</p><p>已知不同度的结点个数，求叶子结点</p><ul><li>关键，先求出树的结点数，然后判断出不同度的结点个数，相减就是叶子结点</li><li>叶子结点的度为0</li></ul><p>结点度为$0,1,…,m$分别为$n_0,n_1,…n_m$</p><ul><li>总结点数&#x3D;$n_0+n_1+…+n_m$</li><li>(总度数)总分支数&#x3D;$1n_1+2n_2…+mn_m$</li><li>总结点数&#x3D;总分支数+1      (结点数&#x3D;总度数+1)</li></ul><p>对于m叉树(根节点标号为1)，结点标号为i的第一个子孩子下标为$(i-1)*m+2$</p><p>过程推导 </p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210202129638.png" alt="image-20221020212946468"></p><p>一颗有m个结点的树，该树对应二叉树无右孩子的结点个数为n,则该树叶节点的个数为m-n+1</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211282027507.png" alt="image-20221128202705945"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211282026588.png" alt="image-20221128202613357"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>二叉树是n个结点的有限集合</li><li>由一个根节点和两个互不相交的被称为根的<strong>左子树</strong>和<strong>右子树</strong>组成。左子树和右子树分别是一个二叉树</li><li>特点<ul><li>每个结点至多只有两棵子树</li><li>左右子树不能颠倒</li><li>二叉树是<strong>有序树</strong></li></ul></li></ul><h3 id="几种特殊的二叉树"><a href="#几种特殊的二叉树" class="headerlink" title="几种特殊的二叉树"></a>几种特殊的二叉树</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ul><li>一棵树高度为h，且含有$2^h-1$个结点的二叉树，每层满结点</li><li>特点<ul><li>只有最后一层为叶子结点</li><li>不存在度为1的结点（要不度为0，要不度为2）</li><li>按层序从1开始编号，结点i的左孩子为<code>2i</code> ，右孩子为<code>2i+1</code>;结点i的父节点为<code>⌊i/2⌋</code> (如果有)。⌊⌋ :向下取整</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022122956.png" alt="image-20220702212156606"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ul><li>当且仅当其每个结点都与高度为h的满二叉树中编号为<code>1~n</code>的结点一一对应时，称为完全二叉树</li><li>特点<ul><li>只有最后两层可能有叶子节点</li><li>最多只有一个度为1的结点（只有左孩子没有右孩子）</li><li>按层序从1开始编号，结点i的左孩子为<code>2i</code> ，有孩子为<code>2i+1</code>;结点i的父节点为<code>⌊i/2⌋</code> (如果有)。⌊⌋ :向下取整</li><li><code>i&lt;=⌊n/2⌋</code>为分支结点，<code>i&gt;⌊n/2⌋</code>为叶子结点</li><li>n为奇数，每个分支结点都有左右孩子</li><li>n为偶数，编号为n&#x2F;2的结点只有左孩子</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022128470.png" alt="image-20220702212826288"></p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><ul><li>一棵二叉树有如下性质<ul><li><strong>左子树</strong>上的所有结点的关键字均<strong>小于根节点</strong>的关键字</li><li><strong>右子树</strong>上的所有结点的关键字<strong>均大于根节点</strong>的关键字</li><li>左子树和右子树分别是一棵二叉排序树</li></ul></li><li>该树可用于元素的排序、搜索</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022133497.png" alt="image-20220702213343598"></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><ul><li>树上的任一结点的左子树和右子树的<strong>深度之差不超过1</strong></li><li>该树有更高的搜索效率</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022135724.png" alt="image-20220702213514829"></p><h3 id="二叉树常见性质"><a href="#二叉树常见性质" class="headerlink" title="二叉树常见性质"></a>二叉树常见性质</h3><ul><li>设非空二叉树中度为0，1，2的结点个数分别为$n_0,n_1,n_2$,则$n_0&#x3D;n_2+1$</li><li>二叉树第ｉ层最多$2^{i-1}$个结点</li><li>高度为h的二叉树最多$2^h- 1$(满二叉树)</li></ul><h4 id="完全二叉树性质"><a href="#完全二叉树性质" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h4><ul><li>具有n个结点的完全二叉树的高度为$⌈log_2 (n+1)⌉$或者$⌊log_2 n⌋$+1<ul><li>通过高度为h-1和高度为h的结点判断</li></ul></li><li>设非空二叉树中度为0，1，2的结点个数分别为$n_0,n_1,n_2$<ul><li>完全二叉树中度为1的结点最多一个;$n_0+n_2$一定为奇数</li><li>若完全二叉树有<code>2k</code>个结点,则必有$n_1&#x3D;1,n_0&#x3D;k,n_2&#x3D;k-1$</li><li>若完全二叉树有<code>2k-1</code>个结点,则必有$n_1&#x3D;0,n_0&#x3D;k,n_2&#x3D;k-1$</li></ul></li></ul><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;<span class="comment">//无存储信息设为true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>考点：</strong></p><ul><li><code>i</code>的左孩子：<code>2i</code></li><li><code>i</code>的右孩子：<code>2i + 1</code></li><li><code>i</code>的父节点：$⌊i&#x2F;2⌋$</li><li><code>i</code>所在的层次：$⌊log_2n⌋ + 1 或 ⌈log_2(n+1)⌉$</li></ul><p><strong>若完全二叉树中共有n个结点</strong>（非完全二叉树不能用）</p><ul><li>判断<code>i</code>是否有左孩子：<code>2i ≦ n</code></li><li>判断<code>i</code>是否有右孩子：<code>2i+1 ≦ n</code></li></ul><p><strong>最坏情况：</strong> <strong>高度为h且只有h个结点</strong>的单支树（所有结点只有右孩子），也至少需要$2^h-1$个存储单元；</p><p><strong>结论：</strong> 二叉树的顺序存储结构，<strong>只适合存储完全二叉树和满二叉树</strong></p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root -&gt; data = <span class="number">1</span>;</span><br><span class="line">root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p -&gt; data = <span class="number">2</span>;</span><br><span class="line">p -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">p -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; lchild = p; <span class="comment">//作为根节点的左孩子</span></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207032054999.png" alt="image-20220703205422393"></p><ul><li>找到指定结点p的左&#x2F;右孩子；</li><li>n个结点的二叉链表共有n+1个空链域,(有n-1个变连接，共2n个指针)</li><li>找到指定节点p的父结点: 只能从根结点开始遍历；</li></ul><p><strong>三叉链表</strong>：方便找到其父节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>          <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><p><a href="https://blog.csdn.net/weixin_45525272/article/details/105837185">二叉树的遍历和线索二叉树</a></p><p>遍历：按照某种次序把所有的结点访问一遍</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><strong>先序遍历</strong>：根左右</p><p><strong>中序遍历</strong>：左根右</p><p><strong>后序遍历</strong>：左右根</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul><li>若二叉树为空，不用操作</li><li>若二叉树非空：<ul><li>访问根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ul></li></ul><p>小仙儿从树根开始绕着整棵树的外围转一圈，经过结点的顺序就是先序遍历的顺序</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071910649.gif"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将访问根节点，遍历左树和右树交换位置,就可以实现中序和后序遍历</span></span><br></pre></td></tr></table></figure><p>手算层次遍历</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207032058178.png" alt="image-20220703205803539"></p><p><strong>空间复杂度：</strong> O(h)</p><p>中序遍历和后序遍历与先序遍历类似</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul><li><p>顺序：左根右</p></li><li><p>中序遍历可以看成，二叉树每个节点，垂直方向投影下来（可以理解为每个节点从最左边开始垂直掉到地上），然后从左往右数，得出的结果便是中序遍历的结果</p></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071914581.gif"></p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul><li>就是围着树的外围绕一圈，如果发现一剪刀就能剪下的葡萄（必须是一颗葡萄）（也就是葡萄要一个一个掉下来，不能一口气掉超过1个这样），就把它剪下来，组成的就是后序遍历了。</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071917460.gif"></p><p>程序遍历序列</p><ul><li>先序：第一次路过时访问</li><li>中序：第二次路过时访问</li><li>后序：第三次路过时访问</li></ul><h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4><p>层次遍历很好理解，就是从根节点开始，一层一层，从上到下，每层从左到右，依次写值就可以了</p><ul><li>相当广度优先遍历</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071919769.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208292014087.gif"></p><p>算法思想：</p><ul><li>初始化一个<strong>辅助队列</strong></li><li>根节点入队</li><li>若队列非空，则队头结点出队，访问该结点，依次将其左、右孩子插入队尾（如果有的话）</li><li>重复以上操作直至队列为空</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">   BiTNode * data;</span><br><span class="line">   <span class="keyword">typedef</span> LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   LinkNode *front, *rear;  </span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue(Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong>:若只给出一棵二叉树得前&#x2F;中&#x2F;后&#x2F;层 序遍历序列中得一种，不能确定一棵二叉树</p><h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p><strong>关键</strong>：找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点、</p><h4 id="先序序列-中序序列"><a href="#先序序列-中序序列" class="headerlink" title="先序序列 + 中序序列"></a>先序序列 + 中序序列</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071931027.png" alt="image-20220707193144845"></p><p>先序序列的第一个元素一定是根节点</p><p>关键：<strong>该方法的核心就是用先序序列元素作即根节点分割中序序列</strong></p><p><strong>动图</strong></p><blockquote><p>先序：1  2  3  4  5  6  7 </p><p>中序：4  2  5  1  6  3  7 </p><p>对1中序左边425，在先序找到425的排序245，则2作为下一棵树的根节点</p><pre><code>      1    /   \   2     3  / \   / \  4   5 6   7</code></pre></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071933398.gif"></p><h4 id="后序序列-中序序列"><a href="#后序序列-中序序列" class="headerlink" title="后序序列 + 中序序列"></a>后序序列 + 中序序列</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071938477.png" alt="image-20220707193808450"></p><p><strong>关键</strong>：</p><ol><li>先确定后序最后一个元素为根节点，</li><li>然后用后序序列元素即根节点分割中序序列，</li></ol><p><strong>动图</strong></p><blockquote><p>后序：E F A H C I G B D</p><p>中序：E A F D H C B G I</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     D</span><br><span class="line">   /   \</span><br><span class="line">  A      B</span><br><span class="line"> / \    / \ </span><br><span class="line">E   F  C   G</span><br><span class="line">       /    \ </span><br><span class="line">      H      I</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072042235.gif"></p><h4 id="层序序列-中序序列"><a href="#层序序列-中序序列" class="headerlink" title="层序序列 + 中序序列"></a>层序序列 + 中序序列</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072044019.png" alt="image-20220707204447135"></p><p><strong>动图</strong></p><blockquote><p>层序：ABCDE</p><p>中序：ACBED</p></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072100311.gif"></p><p><strong>结论</strong>：前序，后序，层序序列的<strong>两两组合无法唯一确定</strong>一棵二叉树</p><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><ol><li>线索二叉树的概念与作用<ul><li>遍历二叉树是以一定规则将二叉树中的结点排列出个成一个线性组合</li><li>线索二叉树是为了加快查找结点前驱和后继的速度</li></ul></li><li>线索二叉树的存储结构</li></ol><ul><li>中序线索二叉树——线索指向中序前驱、中序后继</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><blockquote><p>ltag &#x3D;&#x3D; 0: 指针指向孩子</p><p>rtag &#x3D;&#x3D; 1: 指针是“线索”</p><p><code>*lchild：指向前驱结点（前驱线索）或者左孩子</code></p></blockquote><p>   <code>*rchild：指向后继结点（后继线索）或者右孩子</code></p><blockquote><p>结构：</p><p>二叉链表：<code>*lchild , data  ,  *rchild</code></p><p>线索链表：<code>*lchild , ltag , data , rtag , *rchild</code></p></blockquote><h3 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h3><p><strong>关键</strong>：画出图形，确定好各个结点的顺序，然后根据是否有孩子判断线索化</p><h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><p><strong>中序线索二叉树</strong>：线索指向中序前驱，中序后继</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072124463.png" alt="image-20220707212418284"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);    <span class="comment">//中序遍历左子树</span></span><br><span class="line">        visit(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        InThread(T-&gt;rchild);    <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//q为当前结点，pre和q相当于中序相邻关系</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="comment">//建立当前结点的前驱线索,只有左子树为空才能建立前驱线索</span></span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid == <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//pre无右子树才能得到后继线索</span></span><br><span class="line">    <span class="comment">//建立pre结点的后继线索，前驱不空且前驱后继为空建立，可通过中间的图形判断</span></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      InThread(T);            <span class="comment">//中序线索化二叉树</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208292043490.png" alt="image-20220829204345948"></p><p>注意：后面结点的E为G，难的改</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207091940437.gif"></p><h4 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h4><p><strong>先序线索二叉树</strong>：线索指向先序前驱，先序后继</p><p>先确定好先序遍历的排序</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125676.png" alt="image-20220707212513691"></p><p>注意【转圈】问题，当<code>ltag==0</code>时，才能对左子树先序线索化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);</span><br><span class="line">      <span class="keyword">if</span>(T-&gt;ltag == <span class="number">0</span>)         <span class="comment">//lchild不是前驱线索，有左子树</span></span><br><span class="line">         PreThread(T-&gt;lchild);</span><br><span class="line">      PreThread(T-&gt;rchild);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid == <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PreThread(T);            <span class="comment">//先序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h4><p><strong>后序线索二叉树</strong>：线索指向后序前驱，后序后继</p><p>先确定好后序元素pai’xu</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125827.png" alt="image-20220707212547580"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      PostThread(T-&gt;lchild);</span><br><span class="line">      PostThread(T-&gt;rchild);</span><br><span class="line">      visit(T);                  <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PostThread(T);            <span class="comment">//后序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线索二叉树中找前驱、后继"><a href="#线索二叉树中找前驱、后继" class="headerlink" title="线索二叉树中找前驱、后继"></a>线索二叉树中找前驱、后继</h3><h4 id="中序二叉树"><a href="#中序二叉树" class="headerlink" title="中序二叉树"></a>中序二叉树</h4><p><strong>后继</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072124463.png" alt="image-20220707212418284"></p><p>中序线索二叉树找中序后继：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序后继 <code>next</code></p><blockquote><p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p><p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 则 next &#x3D; p的右子树中最左下结点;</p></blockquote><p>根结点指的是指定结点*p ——情况如下（F结点指向A结点）</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092002611.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//循环找到最左下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//右子树最左下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p!=<span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 &#x3D; O(1)</p><p><strong>前驱</strong></p><p>中序线索二叉树找中序前驱：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序前驱 <code>pre</code></p><blockquote><p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p><p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子, 则 next &#x3D; p的左子树中最右下结点;</p></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092014851.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最右下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;rchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//左子树最右下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//rtag==1，直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p!=<span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序二叉树"><a href="#先序二叉树" class="headerlink" title="先序二叉树"></a>先序二叉树</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125676.png" alt="image-20220707212513691"></p><p><strong>后继</strong></p><p>根为当前结点，黄色部分为后继(左)</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092017361.png"></p><p>先序线索二叉树找先序后继：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序后继 <code>next</code></p><blockquote><p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p><p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子（左孩子不知道）——<code>*p不能指向</code></p><blockquote><p>case1: 若p有左孩子 ——— 根 <strong>左</strong> 右  &#x2F;  根 (<strong>根</strong> 左 右) 右</p><p>case2: 若p没有左孩子 ——— 根 <strong>右</strong>  &#x2F;  根 (<strong>根</strong> 左 右)</p></blockquote></blockquote><p><strong>先序</strong></p><p>先序线索二叉树找先序前驱：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序前驱<code>pre</code></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092030251.png" alt="image-20220709202819459"></p><blockquote><p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p><p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找p的先序前驱，（除非从头开始遍历&#x2F;三叉链表</p></blockquote><h4 id="后序二叉树"><a href="#后序二叉树" class="headerlink" title="后序二叉树"></a>后序二叉树</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125827.png" alt="image-20220707212547580"></p><p><strong>前驱</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092032086.png"></p><p>后序线索二叉树找后序前驱：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序前驱<code>pre</code></p><blockquote><p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p><p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子（不知道有没有右孩子）</p><blockquote><p>case1: 若p有右孩子 ——— 左 <strong>右</strong> 根 &#x2F; 左 (左 右 <strong>根</strong>) 根</p><p>case2: 若p没有右孩子 ——— <strong>左</strong> 根 （左子树按后序遍历，最后一个结点，p的左孩子）</p></blockquote></blockquote><p><strong>后继</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092037903.png" alt="image-20220709203740011"></p><p>后序线索二叉树找后序后继：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序后继<code>next</code></p><blockquote><p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p><p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非从头开始遍历&#x2F;三叉链表</p></blockquote><ul><li>后序遍历找后序时麻烦，所以需要栈的支持</li></ul><p><strong>总结</strong></p><ul><li>后续线索二叉树找后继难，先序线索二叉树找前驱难，需要父节点</li></ul><table><thead><tr><th></th><th>中序线索二叉树</th><th>先序线索二叉树</th><th>后续线索二叉树</th></tr></thead><tbody><tr><td>找前驱</td><td>Ture</td><td>False</td><td>Ture</td></tr><tr><td>找后继</td><td>Ture</td><td>Ture</td><td>False</td></tr></tbody></table><h1 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><ul><li>顺序存储，每个结点中保存指向双亲的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100  <span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>      <span class="comment">//树的结点定义</span></span><br><span class="line">   ElemType data; </span><br><span class="line">   <span class="type">int</span> parent;      <span class="comment">//双亲位置域，用来存储父节点的数组下标信息</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的类型定义</span></span><br><span class="line">   PTNode nodes[MAX_TREE_SIZE];   <span class="comment">//双亲表示</span></span><br><span class="line">   <span class="type">int</span> n;                         <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102236747.png" alt="image-20220710223636837"></p><ul><li>增：新增数据元素，无需按逻辑上的次序存储；（需要更改结点数<code>n</code>）</li><li>删（叶子结点）：① 将伪指针域设置为<code>-1</code>；②或者用后面的数据填补；（需要更改结点数<code>n</code>）</li><li>查询：①优点-查指定结点的双亲很方便；②缺点-查指定结点的孩子只能从头遍历，空数据导致遍历更慢；</li></ul><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><ul><li>孩子表示法(顺序+链式)，顺序存储各个结点，每个结点中保存孩子链表头指针</li><li>把每个结点的孩子结点排列起来，看成是一个线性表，以单链表作存储结构，则n个结点有n个孩子链表（叶子结点的孩子链表为空），然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</li><li>特点：找孩子易，找双亲难</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102242382.png" alt="image-20220710224230720"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> child;    <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 下一个孩子的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>    <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">   <span class="type">int</span> n, r;   <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><ul><li>链式存储，优点：可以将树之转换为二叉树操作</li><li>结点X的左孩子作为结点X的左孩子，结点X的左孩子的兄弟结点作为结点X的右孩子</li><li>每个结点有两个指针域，分别指向“第一个孩子”和”下一个兄弟结点”</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102249716.png" alt="image-20220710224942563"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">   ElemType data;                               <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>     <span class="comment">//第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p><strong>树、森林与二叉树的转换</strong></p><p>森林：是m棵互不相交的树的集合</p><p><strong>本质</strong>：森林中各个树的根节点之间视为兄弟关系，用二叉链表存储森林</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102251412.png" alt="image-20220710225107038"></p><h2 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ul><li><strong>先根遍历</strong>：若树非空，先访问根节点，再依次对每棵子树进行先根遍历；（与对应二叉树的<strong>先序遍历序列</strong>相同）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PreOrder(T);      <span class="comment">//先跟遍历下一个子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>后根遍历</strong>：若树非空，先依次对每棵子树进行后根遍历，最后再返回根节点；（与对应二叉树的<strong>中序遍历序列相同</strong>）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PostOrder(T);      <span class="comment">//后跟遍历下一个子树</span></span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>层序遍历</strong>（队列实现）：<ul><li>若树非空，则根结点入队；</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；</li><li>重复以上操作直至队尾为空；</li></ul></li></ul><h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><ul><li>二叉树先序遍历：等同于依次对各个树进行<strong>先根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>先序遍历</strong>；</li><li>二叉树中序遍历：等同于依次对各个树进行<strong>后根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>中序遍历</strong>；</li></ul><p><strong>对比</strong></p><table><thead><tr><th>树</th><th>森林</th><th>二叉树</th></tr></thead><tbody><tr><td>先根遍历</td><td>先序遍历</td><td>先序遍历</td></tr><tr><td>后根遍历</td><td>中序遍历</td><td>中序遍历</td></tr></tbody></table><h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022133497.png" alt="image-20220702213343598"></p><ul><li>定义：<strong>左子树结点值&lt;根结点值&lt;右子树结点值</strong></li><li>利用<strong>中序排序</strong>可以得到有序递增序列</li><li>用于元素的有序搜索和查找</li><li>左子树的所有结点值小于根节点</li><li>右子树的所有结点值大于根节点</li></ul><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul><li>若树非空，目标值与根节点的值比较</li><li>若相等，查找成功</li><li>若小于根结点，则在左子树上查找，否则在右子树查找</li><li>查找成功，返回结点指针；失败返回NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（非递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(1)</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;key)&#123;        <span class="comment">//若树空或等于跟结点值，则结束循环</span></span><br><span class="line">      <span class="keyword">if</span>(key &lt; T-&gt;key)       <span class="comment">//值小于根结点值，在左子树上查找</span></span><br><span class="line">         T = T-&gt;lchild;</span><br><span class="line">      <span class="keyword">else</span>                  <span class="comment">//值大于根结点值，在右子树上查找</span></span><br><span class="line">         T = T-&gt;rchild;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)  树的高度</span></span><br><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)        <span class="comment">//值为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(key == T-&gt;key)    <span class="comment">//查找成功</span></span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)   <span class="comment">//遍历左子树</span></span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;lchild, key);</span><br><span class="line">   <span class="keyword">else</span>                    <span class="comment">//遍历右子树</span></span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;rchild, key);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul><li>树为空，直接插入结点；</li><li>否则，若关键字小于根节点值，则插入左子树，若关键字K大于根节点值，则插入到右子树</li><li>存在相同的关键字，插入则失败</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中插入关键字为k的新结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;           <span class="comment">//原树为空，新插入的结点为根结点</span></span><br><span class="line">      T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">      T-&gt;key = k;</span><br><span class="line">      T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">//插入成功</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;key)               <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)                 </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h3><ul><li>不同关键字序列可以构成不同的二叉排序树</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Crear_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">   T = <span class="literal">NULL</span>;                     <span class="comment">//初始时T为空树</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">      BST_Insert(T,str[i]);     <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>始终要按照这种规律：<strong>左子树结点值&lt;根结点值&lt;右子树结点值</strong></p><p>先搜索找到目标结点</p><ul><li>若被删除结点z为<strong>叶节点</strong>，则直接删除</li><li>若结点<strong>z只有一棵左子树或者右子树</strong>，则让z的子树成为z父节点的子树，代替z的位置</li><li>若结点<strong>z有左，右两颗子树</strong>，则令z的直接后继（或者直接前驱）代替z，然后从二叉树中删除这个直接后继（或直接前驱），然后就作为第一或第二种情况<ul><li>前驱和后继通过<strong>中序遍历</strong>得到</li><li>z的直接后继q代替删除结点z，原后继位置由q的右子树的根代替</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121252128.png" alt="image-20220712125220888"></p><h4 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul><li>查找长度：查找运算中，需要对比关键字的次数，反映了查找操作时间复杂度；<ul><li>计算：每个关键字对比次数(从头开始)之和除以总个数</li></ul></li><li>每层对比一次</li><li>查找成功的平均查找长度<code>ASL</code><ul><li>最好情况:n个结点的二叉树最小高度为$⌊log_2n⌋+1$，则平均查找长度&#x3D;$O(⌊log_2n⌋)$</li><li>最坏情况：每个结点只有一个分支，平均查找长度&#x3D;O(n),n为结点数</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121254663.png" alt="image-20220712125437593"></p><ul><li>查找失败的平均查找长度<code>ASL</code><ul><li>在每个叶节点后面添加失败结点，算失败结点的平均查找长度</li><li>对比关键字次数乘以失败结点个数之和</li><li>注意：失败关键字次数<strong>不算</strong></li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121255944.png" alt="image-20220712125509789"></li></ul></li></ul><h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><p><strong>定义</strong>：树上任一结点的左子树和右子树的高度之差不超过1</p><p><strong>结点的平衡因子</strong>&#x3D;左子树高 — 右子树高</p><p>平衡二叉树不是二叉排序树，但可以根据二叉排序树构造平衡二叉树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;         <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> balance;     <span class="comment">//平衡因子</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>;</span> *rchild; </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121303050.png" alt="image-20220712130337037"></p><h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><ul><li>插入新节点后如何调整“不平衡”问题</li><li>每次<strong>调整最小不平衡子树</strong></li><li>根据特性判断（这是基于二叉排序树判断）</li></ul><p><strong>做题插入判断</strong></p><ul><li>先找到<strong>最小不平衡子树</strong>，路径是平衡因子为2到插入结点方向的路径的<strong>三个结点</strong></li><li>在三个结点中，找到<strong>第二个大的数</strong>来作为新的根节点，<strong>最小</strong>作为新根节点的<strong>左子树的根，最大则为右子树的根</strong>，插入后移动二叉树， 直到没有最小平衡二叉树为止</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207142237100.jpg"></p><h4 id="LL-需右旋"><a href="#LL-需右旋" class="headerlink" title="LL(需右旋)"></a>LL(需右旋)</h4><ul><li><p>在A结点的<strong>左孩子的左子树</strong>中插入导致不平衡</p></li><li><p>调整： A的<strong>左孩子结点右上旋</strong>代替A成为根节点，将<strong>A结点向下旋转为B的右子树</strong>的根节点，而B的原右子树则作为A结点的左子树</p></li><li><p>子树左右顺序一样</p></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121308312.png"></p><h4 id="RR（需左旋）"><a href="#RR（需左旋）" class="headerlink" title="RR（需左旋）"></a>RR（需左旋）</h4><ul><li>调整： A的<strong>右孩子</strong>结点<strong>左上旋</strong>代替A成为根节点，将A结点<strong>向下旋转</strong>成为B的<strong>左子树</strong>的根节点，而B的原左子树则作为A结点的右子树</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121308481.png"></p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><ul><li><p>在A结点的左孩子的右子树中插入导致不平衡</p></li><li><p>调整： A的左孩子的右子树，先左上旋再右上旋(先左旋再右旋)</p></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121309007.png"></p><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><ul><li><p>在A结点的<strong>右孩子的左子树</strong>中插入导致不平衡</p></li><li><p>调整： A的右孩子的左子树，先右上旋再左上旋</p></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121309870.png"></p><p><strong>左孩子右上旋，右孩子左上旋</strong></p><h3 id="查找与效率分析"><a href="#查找与效率分析" class="headerlink" title="查找与效率分析"></a>查找与效率分析</h3><p>假设以$n_h$表示深度为h的平衡树中含有的最少结点数</p><p>则$n_0&#x3D;0,n_1&#x3D;1,n_2&#x3D;2$,并且有$n_h&#x3D;n_{h-1}+n_{h-2}+1$</p><p>含有n个结点的平衡二叉树的最大深度为$O(log_2 n)$,平衡树二叉树的平均查找长度为$O(log_2 n)$</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>高度为n的平衡二叉树最少需要多少个节点</p><ul><li>利用公式F(h) &#x3D; F(h-1) + F(h -2 ) + 1</li><li>其中F(0)&#x3D;0,F(1)&#x3D;1,f(2)&#x3D;2…</li></ul><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>结点的权：有某种显示含义的数值（结点的重要性等）</li><li>结点的带权路径长度：从树的根到该结点的<strong>路径长度</strong>(经过的边数)与该结点上的<strong>权值</strong>的乘积</li><li>树的带权路径长度：树中所有<strong>叶子结点</strong>的带权路劲长度之和<strong>WPL</strong></li><li>哈夫曼树（最优二叉树）：在含有n个带权叶节点的二叉树中，其中<strong>带权路径长度（WPL）最小</strong>的二叉树</li></ul><h3 id="哈夫曼树构造"><a href="#哈夫曼树构造" class="headerlink" title="哈夫曼树构造"></a>哈夫曼树构造</h3><p>给定n个权值分别为$w_1,w_2,…,w_n$的结点，构造算法描述如下</p><ol><li>将n个结点分别作为n棵仅含有一个结点的二叉树，构成森林F</li><li>构造一个新的结点，从F中选取两颗根节点<strong>权值最小的树作为新结点的左、右子树</strong>，并且将<strong>新结点</strong>的权值置为左右树上根节点的<strong>权值之和</strong><ul><li>关键：每次到两个权值最小的结点合并</li></ul></li><li>从F中删除刚才选出的两棵树，同时将新得到的树中加入F中</li><li>重复步骤2，3,直到F中只剩下一棵树位置</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209012006345.gif"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102314120.png" alt="image-20220710231422068"></p><p><strong>注意</strong></p><ul><li>每个初始结点最终都成为叶结点，且<strong>权值越小</strong>的结点到根节点的路径长度越大</li><li>哈夫曼树的结点总数为2n-1</li><li>哈夫曼树不存在度为1的结点</li><li>哈夫曼树不唯一，但WPL必然相同且为最优</li></ul><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p><strong>固定长度编码</strong>：每个字符都用相等长度的二进制位表示</p><p><strong>可变长度编码</strong>：允许对不同字符用不等长的二进制位表示</p><p><strong>前缀编码</strong>：若没有一个编码是其他编码的前缀，则称这样的编码为前缀编码</p><p><strong>由哈夫曼树得到哈夫曼编码</strong>：字符集中的每个字符作为一个叶子结点，各个字符出现的<strong>频度</strong>作为结点的权值，哈夫曼编码可用于数据压缩</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102325658.png" alt="image-20220710232521625"></p><h3 id="k叉树构造最小路径和"><a href="#k叉树构造最小路径和" class="headerlink" title="k叉树构造最小路径和"></a>k叉树构造最小路径和</h3><p>对于 k 叉树，设 m 为叶子数 , 若 <code>( m - 1 ) % ( k - 1 ) != 0</code> , 要增加虚(子叶)结点。第一次构造用 <code>( m - 1 ) % ( k - 1 ) + 1</code> 个结点，之后都用 k 个结点构造 k 叉树。</p><p>在哈夫曼树中，由此组成的字符串的编码有多少位，其实就是算该树的带权路径长度</p><h4 id="常见编码区别"><a href="#常见编码区别" class="headerlink" title="常见编码区别"></a>常见编码区别</h4><p>前缀编码：若没有一个编码是其他编码的前缀，则称这样的编码为前缀编码</p><p>Huffman编码：是一种构造最优前缀编码的方式</p><p>最优前缀编码</p><p>Huffman编码一定是前缀编码和最优前缀编码</p><p>最优前缀编码不一定是Huffman编码</p><ul><li>一般先判断是不是Huffman编码，在判断是最优前缀编码</li></ul><h1 id="课后代码习题"><a href="#课后代码习题" class="headerlink" title="课后代码习题"></a>课后代码习题</h1><h2 id="二叉树遍历习题"><a href="#二叉树遍历习题" class="headerlink" title="二叉树遍历习题"></a>二叉树遍历习题</h2><ol><li><p>编写后续遍历二叉树的非递归算法</p><p>思想:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//后面再看</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line"><span class="built_in">InitStack</span>(S);</span><br><span class="line">r=<span class="literal">NULL</span>;</span><br><span class="line">p=T;</span><br><span class="line"><span class="keyword">while</span>(p || !<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h2 id="二叉排序树-1"><a href="#二叉排序树-1" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><h2 id="树常用代码"><a href="#树常用代码" class="headerlink" title="树常用代码"></a>树常用代码</h2><p><a href="https://blog.csdn.net/qq_43506256/article/details/122096393">树常用代码</a></p><p><strong>总结</strong>：通过二叉链表存储结构存储的，一般都是用递归的方法，递归到叶子节点的后的空结点(叶子结点左右孩子指向NULL)，然后回溯得到相应的结果，注意条件一般需要区分空结点、叶子节点和分支结点(在这里的条件一般都同时包含左右子树递归等式，如下图的意思)。</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210272107579.png" alt="image-20221027210732025"></p><p>1.假设<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">二叉树</a>采用二叉链存储结构存储，设计一个算法计算一棵给定二叉树的所有叶子节点个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">leafNode</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line"><span class="type">int</span> num1,num2;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点无叶子结点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild ==<span class="literal">NULL</span> &amp;&amp; b-&gt;rchild==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//说明本身为叶子结点，左右孩子无结点</span></span><br><span class="line"><span class="comment">//分支结点利用不断递归到叶子结点，然后回溯记录左右子树的个数</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">num1=leafNode(b-&gt;lchild);<span class="comment">//当前结点左子树的叶子结点个数</span></span><br><span class="line">num2=leafNode(b-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (num1+num2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211162130841.png" alt="image-20221025213316476"></p><p>2.假设二叉树采用二叉链<a href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a>存储，设计一个算法计算一棵给定二叉树的所有双分支节点 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DSonNodes</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> num1,num2,n;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild==<span class="literal">NULL</span> || b-&gt;rchild==<span class="literal">NULL</span>) n=<span class="number">0</span>;<span class="comment">//说明是叶子结点</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">n=<span class="number">1</span>;<span class="comment">//说明本身为分支结点</span></span><br><span class="line">num1=<span class="built_in">DSonNodes</span>(b-&gt;lchild);</span><br><span class="line">num2=<span class="built_in">DSonNodes</span>(b-&gt;rchild);</span><br><span class="line"><span class="built_in">retrun</span> (num1+num2+n);<span class="comment">//返回的是包含当前结点的分支总数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.假设二叉树采用二叉链存储结构存储，设计一个算法求其中最小值的节点值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FindMinNode</span><span class="params">(BTNode *b,ElemType &amp;min)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(b-&gt;data&lt;min) min=b-&gt;data;</span><br><span class="line">FindMinNode(b-&gt;lchild,min);<span class="comment">//递归左子树</span></span><br><span class="line">FindMinNode(b-&gt;rchild,min);<span class="comment">//递归右子树</span></span><br><span class="line"><span class="comment">//通过不断递归子树，从叶子结点往分子结点不断回溯得到最小值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根节点找最小值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MinNode</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">ElemType min=b-&gt;data;</span><br><span class="line">FinMinNode(b,min);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.假设二叉树采用二叉链存储结构存储，所有节点的值为正整数，设计一个算法求所有节点值之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindSum</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点返回0</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (b-&gt;data+FindSum(b-&gt;lchild)+FindSum(b-&gt;rchild));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不为空结点,返回当前结点,左子树和右子树数据之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.假设二叉树采用二叉链存储结构存储，为设计一个算法求其中节点值为 x的节点个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindCount</span><span class="params">(BTNode *b,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点返回0;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data==x)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>+FindCount(b-&gt;lchild,x)+FindCount(b-&gt;rchild,x));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (FindCount(b-&gt;lchild,x)+FindCount(b-&gt;rchild,x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.假设二叉树采用二叉<a href="https://so.csdn.net/so/search?q=%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">链表</a>存储结构，设计一个递归算法求二叉树的高度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BTNodeDepth</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点为0</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">l=BTNodeDepth(b-&gt;lchild);<span class="comment">//求左子树的高度</span></span><br><span class="line">r=BTNodeDepth(b-&gt;rchild);<span class="comment">//求右子树的高度</span></span><br><span class="line"><span class="keyword">return</span> (l&gt;r) ? (l+<span class="number">1</span>) : (r+<span class="number">1</span>);<span class="comment">//在本轮中返回左右子树最大的并加上本次的结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.假设二叉树 b 采用二叉链存储结构，设计一个算法 <code>void findparent(BTNode*b,ElemType x,BTNode *&amp;p)</code>求指定值为 x 的节点的双亲节点 p。<br>提示：根节点的双亲为 NULL，若在 b 中未找到值为 x 的节点,p 亦为 NULL，并假设二叉树中所有节点值是唯一的。<br>算法思想：设在二叉树 b 中查找 x 节点的双亲 p 的过程为 f(b,x,p)，找到后 p 指向 x 节点的双亲节点,否则 p&#x3D;NULL。当 b 为空树或根节点值为 x 时，p&#x3D;NULL，否则在左子树中查找，若未找到则在右子树中查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意BTNode *&amp;p等价与BTree &amp;p ;b只作为指针遍历所以用BTNode,p需要改边其指针所以引用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findparent</span><span class="params">(BTNode *b,ElemType x,BTNode *&amp;p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(b-&gt;data==x) p=<span class="literal">NULL</span>;<span class="comment">//树的根节点的双亲结点为NULL</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild !=<span class="literal">NULL</span> &amp;&amp; b-&gt;lchild-&gt;data==x) p=b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;rchild !=<span class="literal">NULL</span> &amp;&amp; b-&gt;rchild-&gt;data==x) p=b;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">findparent(b-&gt;lchild,x,p);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>) findparent(b-&gt;rchild,x,p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p=<span class="literal">NULL</span>;<span class="comment">//本身为空结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种情况根节点为空，p=NULL</span></span><br><span class="line"><span class="comment">//第二种情况左孩子不为空，且左孩子的值为x,指针 p=b</span></span><br><span class="line"><span class="comment">//第三种情况右孩子不为空，且右孩子的值为x,指针 p=b</span></span><br><span class="line"><span class="comment">//第四种情况，左右孩子的值都不为x,先遍历左子树,直到找到，否则返回p=NULL，然后遍历右子树</span></span><br></pre></td></tr></table></figure><p>8.二叉树 T 采用二叉链表存储结构，用根结点用 t 指示， 设计一个算法，求指针 p 所指结点的双亲结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BTNode* <span class="title function_">getParent</span><span class="params">(BTNode  *t,BTNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//空树</span></span><br><span class="line"><span class="keyword">if</span>(t==p) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//没有双亲结点</span></span><br><span class="line"><span class="keyword">if</span>(t-&gt;lchild==p || t-&gt;rchild==p) <span class="keyword">return</span> t;<span class="comment">//找到双亲结点</span></span><br><span class="line"><span class="comment">//普通情况</span></span><br><span class="line">BTNode *parent=getParent(t-&gt;lchild,p);<span class="comment">//先遍历左子树</span></span><br><span class="line"><span class="keyword">if</span>(parent!=<span class="literal">NULL</span>) <span class="keyword">return</span> parent;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> getParent(t-&gt;rchild,p);<span class="comment">//在遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先确定边界条件,在看普通情况加上子树遍历</span></span><br><span class="line"><span class="comment">//相当就是找p的双亲结点是否为t</span></span><br></pre></td></tr></table></figure><p>9.假设二叉树采用二叉链存储结构，设计一个算法输出值为 x的结点的所有祖先。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ancestor</span><span class="params">(BTNode *b,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空结点</span></span><br><span class="line"><span class="comment">//若结点 b 的左孩子或右孩子的 data 域为 x</span></span><br><span class="line"><span class="comment">//条件2</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((b-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; b-&gt;lchild-&gt;data==x) || (b-&gt;rchild!=<span class="literal">NULL</span> &amp;&amp; b-&gt;rchild-&gt;data==x))&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//条件3,若 f(b-&gt;lchild,x) 为 true 或 f(b-&gt;rchild,x) 为 true</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ancestor(b-&gt;lchild,x) || ancestor(b-&gt;rchild,x))&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="literal">false</span>;<span class="comment">//其他情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过把b作为祖先节点,判断他的左右孩子是否满足x,若是直接输出b的值即可</span></span><br><span class="line"><span class="comment">//逻辑:一般情况先用条件3递归到空结点,在回溯的时候满足条件2,则后面一直返回true,输出其祖先结点</span></span><br></pre></td></tr></table></figure><p>10.设计一个算法把树 b 的左、右子树进行交换。要求算法的空间复杂度为 O(1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(BTree &amp;b)</span>&#123;</span><br><span class="line">BTNode *temp;</span><br><span class="line"><span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Swap(b-&gt;lchild);<span class="comment">//交换左子树</span></span><br><span class="line">Swap(b-&gt;rchild);<span class="comment">//交换右子树</span></span><br><span class="line"><span class="comment">//交换左右指针域</span></span><br><span class="line">temp=b-&gt;lchild;</span><br><span class="line">b-&gt;lchild=b-&gt;rchild;</span><br><span class="line">b-&gt;rchild=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个题从叶子结点开始着手想,先一直递归到底层,底层作为操作交换</span></span><br><span class="line"><span class="comment">//在叶子结点交换了空指针,其他就是交换了左右子树的指针域</span></span><br><span class="line"><span class="comment">//在b!=NULL条件中,需同时写递归左右子树,才能保证回溯到同一层时,他们的都是交换后的</span></span><br></pre></td></tr></table></figure><p>11.假设二叉树采用链式存储结构进行存储，设计一个算法，求二叉树 b 中值为 x 的结点层号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用本算法时h指出根节点层次为1,h表示的是当前结点所在层数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Nodelevel</span><span class="params">(BTNode *b,ElemType x,<span class="type">int</span> h)</span>&#123;</span><br><span class="line"><span class="type">int</span> h1;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data==x) <span class="keyword">return</span> h;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">h1=Nodelevel(b-&gt;lchild,x,h+<span class="number">1</span>);<span class="comment">//往下递归要加一层,在左子树递归</span></span><br><span class="line"><span class="keyword">if</span>(h1==<span class="number">0</span>) <span class="keyword">return</span> Nodelevel(b-&gt;rchild,x,h+<span class="number">1</span>);<span class="comment">//左子树未找到,右子树递归</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先先递归往最左子树遍历,若找到返回高度,不断回溯到最初点;</span></span><br><span class="line"><span class="comment">//若是没找到,遍历到空结点,返回0,就遍历当前结点的右子树</span></span><br></pre></td></tr></table></figure><p>12.求先序遍历序列中第k(1≤k≤二叉树中节点个数)个节点的值。<br>算法思想：用一个全局变量 n(初值为 1)保存先序遍历时访问节点的序号。当二叉树 b为空时返回特殊字符‘ ’ (空格字符)，当 k&#x3D;&#x3D;n 时表示找到了满足条件的节点，返回 b-&gt;data；当 k≠n 时，在左子树中查找，若找到了返回该值，否则在右子树中查找，并返回其结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line">ElemType <span class="title function_">PreNode</span><span class="params">(BTNode *b,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==k) <span class="keyword">return</span> (b-&gt;data);</span><br><span class="line">    n++;</span><br><span class="line">    ch=PreNode(b-&gt;lchild,k);<span class="comment">//遍历左子树</span></span><br><span class="line">    <span class="keyword">if</span>(ch!=<span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> ch;</span><br><span class="line">    ch=PreNode(b-&gt;rchild,k);<span class="comment">//遍历右子树</span></span><br><span class="line">    <span class="keyword">return</span> ch;              <span class="comment">//返回右子树中的遍历结果   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.求中序遍历序列中第k(1≤k≤二叉树中节点个数)个节点的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">1</span>;<span class="comment">//全局变量</span></span><br><span class="line">ElemType <span class="title function_">InNode</span><span class="params">(BTNode *b,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">ElemType ch;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">ch=InNode(b-&gt;lchild,k);</span><br><span class="line"><span class="keyword">if</span>(ch!=<span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> ch;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==k) <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> InNode(b-&gt;rchild,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>14.求后序遍历序列中第k(1≤k≤二叉树中节点个数)个节点的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">1</span>; <span class="comment">//全局变量</span></span><br><span class="line">ElemType <span class="title function_">PostNode</span><span class="params">(BTNode *b,<span class="type">int</span> k)</span></span><br><span class="line">&#123; </span><br><span class="line">ElemType ch;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">ch=PostNode(b-&gt;<span class="number">1</span>child,k); <span class="comment">//遍历左子树</span></span><br><span class="line"><span class="keyword">if</span> (ch!=<span class="string">&#x27; &#x27;</span>) <span class="comment">//在左子树找到了便返回 ch</span></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    ch=PostNode(b-&gt;rchild,k); <span class="comment">//遍历右子树</span></span><br><span class="line">    <span class="keyword">if</span> (ch!=<span class="string">&#x27; &#x27;</span>) <span class="comment">//在右子树找到了便返回 ch</span></span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    <span class="keyword">if</span> (n==k)</span><br><span class="line">        <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>15.二叉树的带权路径长度为每个叶结点的深度与权值之积的总和，可以采用先序遍历或层序遍历解决。<br>算法思想：基于先序递归遍历的算法思想：采用一个 static 变量记录 wpl,把每个结点的深度作为递归函数的一个参数传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wpl_PreOrder</span><span class="params">(BiTree root, <span class="type">int</span> deep)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> wpl = <span class="number">0</span>; <span class="comment">//定义一个 static 全局变量存储 wpl</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    wpl = wpl + deep*root-&gt;weight; <span class="comment">//为叶子结点直接累计 wpl</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">    wpl_PreOrder(root-&gt;leight, deep+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">    wpl_PreOrder(root-&gt;rchild, deep+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> wpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wpl_PreOrder</span><span class="params">(BiTree root ,<span class="type">int</span>  deep)</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> wpl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; root-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//为叶子结点直接累计 wpl</span></span><br><span class="line">        wpl=wpl+deep*root-&gt;weight;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>) wpl_PreOrder(root-&gt;lchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rchild!=<span class="literal">NULL</span>) wpl_PreOrder(root-&gt;rchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> wpl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态局部变量存储在静态存储区，当静态局部变量离开作用域后，并没有被销毁。当该函数再次被调用的时候，该变量的值为上次函数调用结束时的值。</span></span><br></pre></td></tr></table></figure><p>16.设计一个算法，将给定的表达式树（二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。<br><img src="https://img-blog.csdnimg.cn/2e2ce613a0b54d088ffce149e7ba4383.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Lic5ZGxUUFR,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出等价的中缀表达式分别为 (a+b)<em>(c</em>(-d)) 和 (a*b)+(-(c-d)) 。<br>算法思想：将二叉树的中序遍历递归算法稍加变形即可得到。除根结点和叶子结点外，遍历到其他结点是在遍历其左子树之前加上左括号，遍历完右子树后加上右括号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;BTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BtreeToExp</span><span class="params">(BTree *root, <span class="type">int</span> deep)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="comment">//若为叶子结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); <span class="comment">//若有子表达式则加 1 层括号</span></span><br><span class="line">        BtreeToExp(root-&gt;left, deep+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data);</span><br><span class="line">        BtreeToExp(root-&gt;right, deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(deep &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;）&quot;</span>); <span class="comment">//若有子表达式则加 1 层括号</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.栈与队列</title>
      <link href="/data.github.io/post/cc7ab6f2.html"/>
      <url>/data.github.io/post/cc7ab6f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型定义汇总"><a href="#数据类型定义汇总" class="headerlink" title="数据类型定义汇总"></a>数据类型定义汇总</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表静态存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList; </span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表动态存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;          <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;       <span class="comment">//最大容量</span></span><br><span class="line">    <span class="type">int</span> length;       <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;              <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Lnode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Lnode</span> *next;</span><br><span class="line">&#125;Lnode，*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;            </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;  </span><br><span class="line">&#125;DNode, *Linklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Linknode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Linknode</span> *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的顺序存储(循环队列)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">                              <span class="comment">//连续的存储空间，大小为—— MaxSize*sizeof(ElemType)</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;      <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="comment">//一个存放队列的队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;               <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的顺序存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line">                       <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">                       <span class="comment">//每个char字符占1B</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的动态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;           <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//行</span></span><br><span class="line">    <span class="type">int</span> j;<span class="comment">//列</span></span><br><span class="line">    <span class="type">int</span> v;<span class="comment">//值</span></span><br><span class="line">&#125;triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    triple data[maxsize+<span class="number">1</span>]; <span class="comment">//不用data[0]</span></span><br><span class="line">    <span class="type">int</span> mu,nu,tu; <span class="comment">//行数,列数,非零个数</span></span><br><span class="line">&#125;tsmatrix;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树顺序存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;TreNode;</span><br><span class="line">TreNode t[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTnode</span>&#123;</span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild; <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三叉链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTnode</span>&#123;</span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild; <span class="comment">//左、右孩子指针</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *parent;          <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树线索化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的存储——双亲表示法(存储存储)</span></span><br><span class="line"><span class="comment">//树的结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;      </span><br><span class="line">   ElemType data; </span><br><span class="line">   <span class="type">int</span> parent;      <span class="comment">//双亲位置域，用来存储父节点的数组下标信息</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="comment">//树的类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;                   </span><br><span class="line">   PTNode nodes[MAX_TREE_SIZE];   <span class="comment">//双亲表示</span></span><br><span class="line">   <span class="type">int</span> n;                         <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的存储——孩子表示法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTNode</span>&#123;</span><br><span class="line">   <span class="type">int</span> child;    <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;    <span class="comment">// 下一个孩子的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">CTNode</span> *firstChild;    <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">   CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">   <span class="type">int</span> n, r;   <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树的存储——孩子兄弟表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">   ElemType data;                               <span class="comment">//数据域</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild, *nextsibling;     <span class="comment">//第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>&#123;</span><br><span class="line">   <span class="type">int</span> key;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">   <span class="type">int</span> key;         <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> balance;     <span class="comment">//平衡因子</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *lchild; *rchild; </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//B树，5cha</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">ElemType key[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> *child[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图——邻接矩阵法</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> Vex[MaxVertexNum];   <span class="comment">//顶点表</span></span><br><span class="line"><span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵，边表</span></span><br><span class="line"><span class="type">int</span> venum,arcnum;        <span class="comment">//图的当前顶点数和边数/弧数   </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//图——邻接表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="comment">//边表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;      <span class="comment">//该弧指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *next;<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//顶点表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;</span><br><span class="line">    VertexType data;    <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;     <span class="comment">//第一条边/弧</span></span><br><span class="line">&#125;VNode,AdjList[MaxvertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;   <span class="comment">//图的顶点和弧数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h1><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><ol><li>栈是特殊的线性表：只允许在一端进行插入或删除操作， 其逻辑结构与普通线性表相同；</li></ol><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul><li>栈顶：允许进行插入和删除的一端 （最上面的为栈顶元素）；</li><li>栈底：不允许进行插入和删除的一端 （最下面的为栈底元素）；</li><li>空栈：不含任何元素的空表；</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202182015068.png" alt="image-20220218201522912"></p><ul><li>特点：<strong>后进先出</strong>（后进栈的元素先出栈）；</li><li>缺点：栈的大小不可变，解决方法——共享栈；</li></ul><h2 id="栈的基本运算"><a href="#栈的基本运算" class="headerlink" title="栈的基本运算"></a>栈的基本运算</h2><p><strong>“创&amp;销”</strong></p><ul><li>InitStack(&amp;S) 初始化栈：构造一个空栈S，分配内存空间；</li><li>DestroyStack(&amp;S) 销毁栈：销毁并释放栈S所占用的内存空间；</li></ul><p><strong>“增&amp;删”</strong></p><ul><li>Push(&amp;S, x) 进栈：若栈S未满，则将x加入使其成为新栈顶；</li><li>Pop(&amp;S, &amp;x) 出栈：若栈S非空，则弹出（删除）栈顶元素，并用x返回；、</li></ul><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><p>例：进栈顺序为：a -&gt; b -&gt; c -&gt; d -&gt; e</p><blockquote><p>合法的出栈顺序：e d c b a &#x2F; b e d c a (出栈 和进栈交替进行) &#x2F; … </p></blockquote><h1 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h1><h2 id="顺序栈定义"><a href="#顺序栈定义" class="headerlink" title="顺序栈定义"></a>顺序栈定义</h2><p><strong>栈底</strong>：数组下标为0</p><p><strong>栈顶</strong>：top指向的数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">                     <span class="comment">//连续的存储空间大小为 MaxSize*sizeof(ElemType)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="顺序栈基本操作"><a href="#顺序栈基本操作" class="headerlink" title="顺序栈基本操作"></a>顺序栈基本操作</h2><p>初始化栈顶元素<code>S.top=-1</code>;栈顶元素<code>S.data[S.top]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="comment">//栈元素从数组为0下标开始</span></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)      <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>                 <span class="comment">//栈不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>)        <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.top + <span class="number">1</span>;    <span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;    <span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    S.data[++S.top] = x;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];       <span class="comment">//先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;       <span class="comment">//栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x = S.data[S.top--];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是逻辑上的删除，数据依然残留在内存里</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];      <span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testStack</span><span class="params">()</span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进栈：每执行一次，top指向的数组下标增1</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202182021684.jpg"></p><p>入栈与出栈</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204212054383.gif"></p><p><strong>PS: 也可以初始化时定义 S.top &#x3D; 0 ：top指针指向下一个可以插入元素的位置(栈顶元素的后一个位置)；</strong></p><ol><li>判空：<code>if(S.top == 0)</code></li><li>进栈使用：<code>S.data[S.top++] = x</code>;</li><li>出栈使用：<code>x = S.data[--S.top]</code>;</li><li>判断栈满：<code>s.top == MaxSize</code></li></ol><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p>两个顺序栈共享一个一维数组空间，为了更有效的利用存储空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqStack</span><span class="params">(ShStack &amp;S)</span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;        <span class="comment">//一个栈顶指针指向-1</span></span><br><span class="line">    S.top1 = MaxSize;   <span class="comment">//一个栈顶指针指向MaxSize</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栈满条件：<code> top1-top0==1</code></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202182024683.png" alt="image-20220218202435535"></p><h1 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>进栈和出栈都只能在栈顶一端进行(<strong>链头作为栈顶</strong>)</li><li>链表的头部作为栈顶，意味着：<ul><li>在实现数据”<strong>入栈</strong>“操作时，需要将数据从链表的<strong>头部插入</strong>；</li><li>在实现数据”<strong>出栈</strong>“操作时，需要<strong>删除</strong>链表头部的<strong>首元节点</strong>；</li></ul></li></ul><p>因此，链栈实际上就是一个只能<strong>采用头插法插入或删除数据</strong>的链表;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>      <span class="comment">//指针域</span></span><br><span class="line">&#125;*LiStack;                      <span class="comment">//栈类型的定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>初始化</li><li>进栈</li><li>出栈</li><li>获取栈顶元素</li><li>判空、判满</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202211945218.png" alt="image-20220221194535365"></p><h4 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;L)</span>&#123;   <span class="comment">//L为头指针</span></span><br><span class="line">    L = new Linknode; <span class="comment">//new是c++中动态分配空间，和malloc功能类似</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(LiStack &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 进栈(：链栈基本上不会出现栈满的情况)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    Linknode *s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = new Linknode;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line">    Linknode *s;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="comment">//栈空不能出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s = L-&gt;next;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L-&gt;next = L-&gt;next-&gt;next;</span><br><span class="line">    delete(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p><a href="https://blog.csdn.net/nyist_zxp/article/details/80810742">new</a></p><ul><li><p>new开辟的动态空间要用delete释放，new出来的空间给的是首地址</p></li><li><p>new&#x2F;delete是关键字，效率高于malloc和free。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br></pre></td></tr></table></figure></li></ul><h4 id="不带头结点"><a href="#不带头结点" class="headerlink" title="不带头结点"></a>不带头结点</h4><p><strong>链栈推荐不带头结点</strong>：链栈不需要在头部附加头结点，因为<strong>栈都是在头部进行操作的</strong>， 如果加了头结点，等于要对头结点之后的结点进行操作，反而使算法更复杂，所以只要有链表的头指针就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Linknode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Linknode</span> *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initStack</span><span class="params">(LiStack &amp;L)</span></span>&#123;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LiStack &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        teturn <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.进栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Linknode *s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = <span class="keyword">new</span> Linknode;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = L;</span><br><span class="line">    L = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    Linknode *s; </span><br><span class="line">    <span class="keyword">if</span>(L = <span class="literal">NULL</span>)     <span class="comment">//栈空不出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s = L;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="built_in">delete</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="出栈的合法顺序判断"><a href="#出栈的合法顺序判断" class="headerlink" title="出栈的合法顺序判断"></a>出栈的合法顺序判断</h2><p><strong>方法：</strong></p><p>1、一路向左致死方休</p><ul><li>从最小数(字母)起，下一个只能在其左侧，直到边上才停止，然后删除继续（记为一组）；删完则合法</li><li>最小数指的是从开始入栈的顺序开始数</li></ul><p>2、后组不可与前组出现交叉</p><blockquote><p>eg：2413</p><p>符合1，但21,43出现交叉，故错。2431便可</p></blockquote><p>两个条件都要满足</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208182205582.jpg"></p><p><strong>注意</strong>：一组中最后删除要在最左边，以上方法完全适用，否则不一定</p><blockquote><p>入栈：abcde</p><p>判断：cebda</p></blockquote><table><thead><tr><th>开始</th><th>删除</th><th>剩余</th></tr></thead><tbody><tr><td>cebda</td><td>cba</td><td>ed</td></tr><tr><td>ed</td><td>e</td><td>d</td></tr><tr><td>d</td><td>d</td><td>无 (合法)</td></tr></tbody></table><blockquote><p>入栈:abc</p><p>出栈：cab   不合法——a不在最左边且b在a的右边</p><p>出栈：abc   合法——最小在最左边，直接删除合法</p><p>如最小在最左边，直接删除</p><p>若最小不在最左边，且下一个在其右边则不合法</p></blockquote><p><a href="https://blog.csdn.net/weixin_38233103/article/details/107091537">方法2</a></p><blockquote><p>设1, 2, 3, 4, 5,6以所给的次序进栈, 若在进栈操作时, 允许出栈操作, 则下面得不到的序列为( )<br>A. 654321<br>B. 231654<br>C. 435621<br>D. 312456</p></blockquote><blockquote><p>方法如下：以B为例</p><p>第一步：用 2 和后边的比，找出比 2 小的数， <strong>2</strong> 3 <strong>1</strong> 6 5 4 ；加粗的数是按照降序排列即为合理。<br>第二步：用 3 和后边的比，找出比 3 小的数， 2 <strong>3</strong> <strong>1</strong> 6 5 4 ；加粗的数是按照降序排列即为合理。<br>第三步：用 1 和后边的比，找出比 1 小的数， 2 3 <strong>1</strong> 6 5 4 ； 没找到，也为合理。<br>第四步：用 6 和后边的比，找出比 6 小的数， 2 3 1 <strong>6</strong> <strong>5 4</strong> ；加粗的数是按照降序排列即为合理。<br>第五步：用 5 和后边的比，找出比 5 小的数， 2 3 1 6 <strong>5</strong> <strong>4</strong> ；<br>剩一个，不用比了。在以上比较过程中，都合理，此选项就合理。<br>再举个不合理的例子：以D为例</p><p>第一步：用 3 和后边的比，找出比 3 小的数， <strong>3 1 2</strong> 4 5 6 ；加粗的数不是按照降序排列的，不合理。该选项不合理！！！</p></blockquote><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="队列定义"><a href="#队列定义" class="headerlink" title="队列定义"></a>队列定义</h3><ul><li>队列是操作受限的<strong>线性表</strong>，只允许在一端进行插入 (入队)，另一端进行删除 (出队)</li><li>操作特性：<strong>先进先出 FIFO</strong></li><li>队头：允许删除的一端</li><li>队尾：允许插入的一端</li><li>空队列：不含任何元素的空表</li></ul><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><h3 id="“创-销”"><a href="#“创-销”" class="headerlink" title="“创&amp;销”"></a>“创&amp;销”</h3><ul><li><code>InitQueue(&amp;Q)</code>: 初始化队列，构造一个空列表Q</li><li><code>DestroyQueue(&amp;Q)</code>: 销毁队列，并释放队列Q所占用的内存空间</li></ul><h3 id="“增-删”"><a href="#“增-删”" class="headerlink" title="“增&amp;删”"></a>“增&amp;删”</h3><ul><li><code>EnQueue(&amp;Q, x)</code>: 入队，若队列Q未满，将x加入，使之成为新的队尾</li><li><code>DeQueue(&amp;Q, &amp;x)</code>: 出队，若队列Q非空，删除队头元素，并用x返回</li></ul><h3 id="“查-其他”"><a href="#“查-其他”" class="headerlink" title="“查&amp;其他”"></a>“查&amp;其他”</h3><ul><li><code>GetHead(Q,&amp;x)</code>: 读队头元素，若队列Q非空，则将队头元素赋值给x</li><li><code>QueueEmpty(Q)</code>: 判队列空，若队列Q为空，则返回true</li></ul><h2 id="队列的顺序结构"><a href="#队列的顺序结构" class="headerlink" title="队列的顺序结构"></a>队列的顺序结构</h2><ul><li>头指针：指向队头元素；</li><li>队尾指针：指向队尾元素的后一个位置（下一个应该插入的位置）</li></ul><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列的顺序存储类型</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">                              <span class="comment">//连续的存储空间，大小为——      MaxSize*sizeof(ElemType)</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> test&#123;</span><br><span class="line">    SqQueue Q;                <span class="comment">//声明一个队列</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)    <span class="comment">//判空条件后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><ol><li>循环队列</li></ol><blockquote><p><strong>Q:</strong> 能否用 <code>Q.rear == MaxSize</code> 作为队列满的条件？</p><p><strong>A:<strong>不能！会有假溢出, 所以需要用 <strong>模运算</strong> 将存储空间 {0,1,2,…,MaxSize} 在逻辑上变成“环状”——</strong>循环队列！</strong></p></blockquote><blockquote><p>a%b &#x3D;&#x3D; a除以b的余数</p><p>初始：Q.front &#x3D; Q.rear &#x3D; 0;</p><p>队首指针进1：Q.front &#x3D; (Q.front + 1) % MaxSize</p><p>队尾指针进1：Q.rear &#x3D; (Q.rear + 1) % MaxSize —— 队尾指针后移，当移到最后一个后，下次移动会到第一个位置</p><p>队列长度：(Q.rear + MaxSize - Q.front) % MaxSize</p></blockquote><h3 id="循环队列判满"><a href="#循环队列判满" class="headerlink" title="循环队列判满"></a>循环队列判满</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><ul><li>牺牲一个单元来区分队空和队满</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202211952764.png" alt="image-20220221195244607"></p><p>本方案的<strong>尾指针指向最后一个元素的下一个位置</strong></p><h5 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h5><ul><li>只能从队尾插入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front)        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;                      <span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;         <span class="comment">//队尾指针加1取模</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队尾插入操作</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208152305742.gif"></p><h5 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h5><ul><li>只能让队头元素出列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队，删除一个队头元素，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针后移动</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208152309005.gif"></p><h5 id="获得队头元素"><a href="#获得队头元素" class="headerlink" title="获得队头元素"></a>获得队头元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：队列的尾指针是<strong>指向最后一个元素还是最后一个元素的下一个位置</strong></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><ul><li>不牺牲存储空间，设置size</li><li>size记录队列长度</li><li>队满条件<code>size=MaxSize</code></li><li>队空条件<code>size=0</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">//队列当前长度</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p> 不牺牲存储空间，设置tag</p><ul><li>定义一个变量 <code>tag</code>，<code>tag = 0</code> –最近进行的是删除操作；<code>tag = 1</code> –最近进行的是插入操作；</li><li>每次删除操作成功时，都令<code>tag = 0</code>；只有删除操作，才可能导致队空；</li><li>每次插入操作成功时，都令<code>tag = 1</code>；只有插入操作，才可能导致队满；</li></ul><ol><li>队满条件：<code>Q.front == Q.rear &amp;&amp; tag == 1</code></li><li>队空条件：<code>Q.front == Q.rear &amp;&amp; tag == 0</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> tag;               <span class="comment">//最近进行的是删除or插入</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>其他出题方式</p><ul><li>注意front和rear指向的位置，特别是<strong>rear,可能指向队尾元素，也可能指向队尾的下一个元素</strong></li></ul><h2 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h2><p><strong>队列的链式存储</strong>:注意是两个定义一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个存放数据和next指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>      <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="comment">//一个存放队列的队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>               <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h3 id="基本操作—带头结点"><a href="#基本操作—带头结点" class="headerlink" title="基本操作—带头结点"></a>基本操作—带头结点</h3><h4 id="初始化判空"><a href="#初始化判空" class="headerlink" title="初始化判空"></a>初始化判空</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131607595.png" alt="image-20220613160707170"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;<span class="comment">//头结点的下一个指向NULL，与Q.rear-&gt;next=NULL等价</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)     <span class="comment">//也可用 Q.front -&gt; next == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><ul><li>入队：在链表尾部插入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//s作为最后一个结点，指针域指向NULL</span></span><br><span class="line">    Q.rear-&gt;next = s;   <span class="comment">//新结点插入到当前的rear之后</span></span><br><span class="line">    Q.rear = s;         <span class="comment">//表尾指针指向新的表尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131621527.gif"></p><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><ul><li>对头结点指向的结点进行删除操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                    <span class="comment">//空队</span></span><br><span class="line">    </span><br><span class="line">    LinkNode *p = Q.front-&gt;next;         <span class="comment">//p指针指向即将删除的结点 (头结点所指向的结点)</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;             <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)                      <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear = Q.front;                <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                             <span class="comment">//释放结点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131633545.gif"></p><ul><li>队列满的条件</li></ul><p>顺序存储：预分配存储空间</p><p>链式存储：一般不会队满，除非内存不足</p><ul><li>计算链队长度 (遍历链队)</li></ul><p>设置一个<code>int length</code> 记录链式队列长度</p><h3 id="基本操作—不带头结点"><a href="#基本操作—不带头结点" class="headerlink" title="基本操作—不带头结点"></a>基本操作—不带头结点</h3><h4 id="初始化判空-1"><a href="#初始化判空-1" class="headerlink" title="初始化判空"></a>初始化判空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)     <span class="comment">//也可以用 Q.rear == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="入队-2"><a href="#入队-2" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素入队时需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;            <span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;               <span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;           <span class="comment">//新结点插入到rear结点之后</span></span><br><span class="line">        Q.rear = s;                 <span class="comment">//修改rear指针指向新的表尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131648902.gif"></p><h4 id="出队-2"><a href="#出队-2" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队————不带头结点</span></span><br><span class="line"><span class="comment">//考虑空队，不同情况，只剩一个元素的情况</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front; <span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x=p-&gt;data;           <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front=p-&gt;next;     <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)&#123;       <span class="comment">//如果是最后一个结点出队</span></span><br><span class="line">        Q.front=<span class="literal">NULL</span>;    <span class="comment">//front指向NULL</span></span><br><span class="line">        Q.rear=<span class="literal">NULL</span>;     <span class="comment">//rear指向NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);            <span class="comment">//释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206131653536.gif"></p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>双端队列允许从<strong>两端插入</strong>、<strong>两端删除</strong>的线性表；</li><li>如果只使用其中一端的插入、删除操作，则等同于栈；</li><li>输入受限的双端队列：允许<strong>一端插入</strong>，<strong>两端删除</strong>的线性表；</li><li>输出受限的双端队列：允许<strong>两端插入</strong>，<strong>一端删除</strong>的线性表；</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202261600690.png" alt="image-20220226160014797"></p><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><blockquote><p><strong>例</strong>: 数据元素输入序列为 <code>1,2,3,4</code>，判断 4!&#x3D;24 个输出序列的合法性</p></blockquote><table><thead><tr><th>栈</th><th>输入受限的双端队列</th><th>输出受限的双端队列</th></tr></thead><tbody><tr><td>14个合法(卡特兰数)</td><td>验证在栈中不合法的序列</td><td>验证在栈中不合法的序列</td></tr><tr><td></td><td>只有 4213 和 4231 不合法</td><td>只有 4132 和 4231 不合法</td></tr></tbody></table><p>卡特兰数</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210282209937.png" alt="image-20221028220940666"></p><p><strong>PS: 栈中合法的序列，双端队列中一定也合法</strong></p><p>判断输入受限和输出受限的合法出栈队列</p><blockquote><p>eg:以1234的方式入栈</p><p>判断：4231的输出序列是否合理</p></blockquote><p>对于输入受限的双端队列</p><blockquote><p>只有一端可以输入，则可以以1234（只有往左方向输入）</p><p>判断从两端是否能正常输出(对于4231)</p><p>显然4输出后2加载13之间不能输出，不合格</p></blockquote><p>对于输出首先的双端队列</p><blockquote><p>只有一端可以输出，从两端依次插入1234，看是否可以得到4231这个序列</p><p>显然在插入2的时候不能成立(423)</p></blockquote><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="栈在括号匹配的应用"><a href="#栈在括号匹配的应用" class="headerlink" title="栈在括号匹配的应用"></a>栈在括号匹配的应用</h2><p>用栈实现括号匹配</p><ul><li><code>((()))</code> 最后出现的左括号最先被匹配 (栈的特性—LIFO)——<strong>后进先出</strong></li><li>遇到左括号就入栈;</li><li>遇到右括号，就“消耗”一个左括号 (出栈);</li></ul><p>匹配失败情况：</p><ul><li>扫描到右括号且栈空，则该右括号单身;</li><li>扫描完所有括号后，栈非空，则该左括号单身;</li><li>左右括号不匹配;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">InitStack(SqStack &amp;S)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S, <span class="type">char</span> x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶元素出栈，用x返回</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, <span class="type">char</span> &amp;x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    SqStack S;      <span class="comment">//声明</span></span><br><span class="line">    InitStack(S);   <span class="comment">//初始化栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            Push(S, str[i]);       <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(S))      <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//匹配失败</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> topElem;          <span class="comment">//存储栈顶元素</span></span><br><span class="line">            Pop(S, topElem);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断左右括号是否匹配</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StackEmpty(S);                <span class="comment">//栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>需要界限符，运算符在两个操作数中间:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① a + b</span><br><span class="line">② a + b - c</span><br><span class="line">③ a + b - c*d</span><br><span class="line">④ ((15 ÷ (7-(1+1)))×3)-(2+(1+1))</span><br><span class="line">⑤ A + B × (C - D) - E ÷ F</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="中缀表达式的计算-用栈实现"><a href="#中缀表达式的计算-用栈实现" class="headerlink" title="中缀表达式的计算(用栈实现)"></a><strong>中缀表达式的计算(用栈实现)</strong></h4><p>两个算法的结合： 中缀转后缀 + 后缀表达式的求值</p><ul><li>初始化两个栈，<strong>操作数栈</strong> 和<strong>运算符栈</strong></li><li>若扫描到操作数，压人操作数栈</li><li>若扫描到运算符或界限符，则按照“<strong>中缀转后缀</strong>”相同的逻辑压入运算符栈 (期间也会弹出运算符，<strong>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈项元素并执行相应运算，运算结果再压回操作数栈</strong>)</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206212129740.gif"></p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">① a b +</span><br><span class="line">② ab+ c - / a bc- +</span><br><span class="line">③ ab+ cd* -</span><br><span class="line">④ 15 7 1 1 + - ÷ 3 × 2 1 1 + + -</span><br><span class="line">⑤ A B C D - × + E F ÷ - (机算结果)</span><br><span class="line">  A B C D - × E F ÷ - + (不选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="中缀表达式转后缀表达式-手算"><a href="#中缀表达式转后缀表达式-手算" class="headerlink" title="中缀表达式转后缀表达式-手算"></a>中缀表达式转后缀表达式-手算</h4><p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p><p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[左操作数 右操作数 运算符]</code>的方式组合成一个新的操作数</p><p><strong>步骤3：</strong> 如果还有运算符没被处理，继续步骤2</p><p><strong>“左优先”原则:</strong> 只要左边的运算符能先计算，就优先算左边的 (保证运算顺序唯一)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中缀：A + B - C * D / E + F</span><br><span class="line">       ①   ④   ②   ③   ⑤     </span><br><span class="line">后缀：A B + C D * E / - F +</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203021115998.png" alt="image-20220302111528996"></p><ul><li>总体的思路：把每一个表达式先用括号括上，再把运算符提到括号后</li></ul><blockquote><p>例子，a+b&#x2F;c-d</p><p>加括号后：((a+(b&#x2F;c))-d)</p><p>将运算符提到括号后：((a(bc)&#x2F;)+d)-</p><p>去括号：abc&#x2F;+d-</p></blockquote><h4 id="中缀表达式转后缀表达式-机算—重点"><a href="#中缀表达式转后缀表达式-机算—重点" class="headerlink" title="中缀表达式转后缀表达式-机算—重点"></a>中缀表达式转后缀表达式-机算—重点</h4><p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<strong>从左到右</strong>处理各个元素，直到末尾。可能遇到三种情况:</p><ul><li>遇到<strong>操作数</strong>: 直接加入后缀表达式。</li><li>遇到<strong>界限符</strong>: 遇到 <code>&#39;(&#39;</code> 直接入栈; 遇到 <code>&#39;)&#39;</code> 则依次弹出栈内运算符并加入后缀表达式，直到弹出 <code>&#39;(&#39;</code> 为止。注意: <code>&#39;(&#39;</code> 不加入后缀表达式。</li><li>遇到<strong>运算符</strong>: 依次弹出栈中优先级<strong>高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式，若碰到 <code>&#39;(&#39;</code> 或栈空则停止。之后再把当前运算符入栈。<ul><li>若当前为运算符+(-)，栈中为+,-,×,÷的一种，则栈必要弹出一个运算符</li><li>若当前运算符为×(÷)，栈中为加减时，栈不弹出；栈为乘除时要弹出</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206201249680.gif" alt="image-20220302111528996"></p><h4 id="后缀表达式的计算—手算"><a href="#后缀表达式的计算—手算" class="headerlink" title="后缀表达式的计算—手算"></a>后缀表达式的计算—手算</h4><ul><li><p>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应的运算，合体为一个操作数；</p><p><strong>注意：</strong> 两个操作数的左右顺序</p></li></ul><h4 id="后缀表达式的计算—机算"><a href="#后缀表达式的计算—机算" class="headerlink" title="后缀表达式的计算—机算"></a>后缀表达式的计算—机算</h4><p>用栈实现后缀表达式的计算（栈用来存放当前暂时不能确定运算次序的操作数）</p><p><strong>步骤1:</strong> 从左往后扫描下一个元素，直到处理完所有元素;</p><p><strong>步骤2:</strong> 若扫描到操作数，则压入栈，并回到<code>步骤1</code>;否则执行<code>步骤3</code>;</p><p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压回栈顶，回到<code>步骤1</code>;</p><p><strong>注意:</strong> 先出栈的是“<strong>右操作数</strong>”</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206201316904.gif" alt="image-20220302111528996"></p><h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运算符在两个操作数前面:</span><br><span class="line">① + a b</span><br><span class="line">② - +ab  c</span><br><span class="line">③ - +ab *cd</span><br></pre></td></tr></table></figure><h4 id="中缀表达式转前缀表达式—手算"><a href="#中缀表达式转前缀表达式—手算" class="headerlink" title="中缀表达式转前缀表达式—手算"></a>中缀表达式转前缀表达式—手算</h4><p><strong>步骤1：</strong> 确定中缀表达式中各个运算符的运算顺序</p><p><strong>步骤2：</strong> 选择下一个运算符，按照<code>[运算符 左操作数 右操作数]</code>的方式组合成一个新的操作数</p><p><strong>步骤3：</strong> 如果还有运算符没被处理，就继续执行<code>步骤2</code></p><p><strong>“右优先”原则:</strong> 只要右边的运算符能先计算，就优先算<strong>右边</strong>的;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中缀：A + B * (C - D) - E / F</span><br><span class="line">       ⑤   ③    ②    ④   ①</span><br><span class="line">前缀：+ A - * B - C D / E F</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203021114766.jpg"></p><ul><li>总体的思路：把每一个表达式先用括号括上，再把运算符提到<strong>括号前</strong>，然后去括号</li></ul><blockquote><p>例子，a+b&#x2F;c-d</p><p>加括号后：((a+(b&#x2F;c))-d)</p><p>将运算符提到括号后：-(+(a&#x2F;(bc))d)</p><p>去括号：-+a&#x2F;bcd</p><p>注意：a-b+c</p><p>正确:  +-abc</p><p>错误：-a+bc</p></blockquote><h4 id="前缀表达式的计算—机算"><a href="#前缀表达式的计算—机算" class="headerlink" title="前缀表达式的计算—机算"></a>前缀表达式的计算—机算</h4><p>用栈实现前缀表达式的计算</p><p><strong>步骤1:</strong> 从<strong>右往左扫</strong>描下一个元素，直到处理完所有元素；</p><p><strong>步骤2:</strong> 若扫描到操作数则压入栈，并回到<code>步骤1</code>，否则执行<code>步骤3</code></p><p><strong>步骤3:</strong> 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到<code>步骤1</code>；</p><p><strong>注意:</strong> 先出栈的是“<strong>左操作数</strong>”</p><h4 id="利用二叉树得到前后缀表达式"><a href="#利用二叉树得到前后缀表达式" class="headerlink" title="利用二叉树得到前后缀表达式"></a>利用二叉树得到前后缀表达式</h4><blockquote><p>例子：Exp &#x3D; a * b + （ c - d &#x2F; e ）* f<br>构造二叉树</p></blockquote><ul><li>中缀排序，利用叶子结点作为操作数，中间节点作为运算符</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208192258035.jpeg" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①前缀表达式： + * a b * - c / d e f （前序遍历）</span><br><span class="line">②中缀表达式： a * b + c - d / e * f （中序遍历）</span><br><span class="line">③后缀表达式： a b * c d e / - f * + （后续遍历）</span><br></pre></td></tr></table></figure><h2 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h2><p>函数调用的特点：<strong>最后被调用</strong>的函数<strong>最先执行</strong>结束(LIFO)</p><p>函数调用时，需要用一个栈存储：</p><ul><li>调用返回地址</li><li>实参</li><li>局部变量</li></ul><p>递归调用时，函数调用栈称为 “递归工作栈”:</p><ul><li>每进入一层递归，就将递归调用所需信息压入栈顶；</li><li>每退出一层递归，就从栈顶弹出相应信息；</li></ul><p><strong>缺点</strong>：太多层递归可能回导致栈溢出；</p><p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题；</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h2><p><strong>一维数组存储</strong></p><ul><li>起始地址为<code>LOC</code>,且物理存放位置连续</li><li>下标取值范围叫数组的维界</li><li>数组下标默认0开始，除非题目特别说明</li><li>数组元素<code>a[i]</code>的存放地址&#x3D;$LOC+i*sizeof(ElemType)$——下标从0开始</li></ul><p><strong>二维数组存储</strong></p><ul><li>描述矩阵元素时，行、列号通常从<code>1</code>开始；</li><li>描述数组时，通常下标从 <code>0</code> 开始；</li><li>二维数组存储方式为<strong>行优先存储和列优先存储</strong></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241226721.png" alt="image-20220624122648285"></p><p><strong>行优先存储</strong></p><ul><li>M行N列的二维数组<code>b[M][N]</code></li><li><code>b[i][j]</code>的存储位置&#x3D;$LOC+(i*N+j)*sizeof(ElemType)$</li></ul><p><strong>列优先存储</strong></p><ul><li>M行N列的二维数组<code>b[M][N]</code></li><li><code>b[i][j]</code>的存储位置&#x3D;$LOC+(j*M+i)*sizeof(ElemType)$</li></ul><p><a href="https://zhuanlan.zhihu.com/p/88247982"><strong>多维数组下标转地址计算</strong></a></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208282122183.png" alt="image-20220828212158737"></p><ul><li>$A_{mnp}$，下标依次对应上图红绿蓝</li></ul><p><strong>行优先</strong>:例如，数组 $A_{123}$ 中，元素 $a_{010} $采用行优先存储对应的一维数组下标为 $index&#x3D;0∗2∗3+1∗3+0&#x3D;3$ (注意：下标从0开始）</p><p>列优先：例如，数组 $A_{123}$ 中，元素 $a_{010} $对应的行优先存储一维数组的下标为 $index&#x3D;0∗2∗3+1∗1+0&#x3D;1 $(注意：下标从0开始）</p><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><p><a href="https://blog.csdn.net/weixin_44480968/article/details/104664874?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165604643116781818713471%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165604643116781818713471&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104664874-null-null.142%5Ev21%5Ehuaweicloudv1,157%5Ev15%5Enew_3&utm_term=%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8&spm=1018.2226.3001.4187">特殊矩阵的存储</a></p><p><strong>压缩矩阵</strong>：指多个值相同的元素只分配一个存储空间，对0元素不分配存储空间，目的是节省存储空间</p><h3 id="对称矩阵-方阵"><a href="#对称矩阵-方阵" class="headerlink" title="对称矩阵(方阵)"></a>对称矩阵(方阵)</h3><ul><li>若n阶方阵中任意一个元素$a_{ij}$都有$a_{ij}&#x3D;a_{ji}$,则该矩阵为对称矩阵</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241240915.png" alt="image-20220624124026422"></p><h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p><strong>只存储主对角线和下三角元素</strong></p><ul><li>按行优先将各个元素存在一维数组，一维数组大小为$\frac{(1+n)*n}{2}$，将实现一个映射函数将数组下标映射成数组下标。</li><li>数组下标$k&#x3D;\frac{(i-1)*i}{2}+j-1$；<ul><li>一维数组下标从0开始</li><li>i和j从1开始</li></ul></li></ul><p><code>a[i][j]</code>数组下标一般这么考虑：若是按行优先存储，先考虑第i-1行的元素个数，再考虑第i行的元素个数，计算总的个数，其他类似</p><h3 id="三角矩阵-方阵"><a href="#三角矩阵-方阵" class="headerlink" title="三角矩阵(方阵)"></a>三角矩阵(方阵)</h3><ul><li>下三角矩阵：除了主对角线和下三角区，其他元素都相同</li><li>上三角矩阵：除了主对角线和上三角区，其他元素都相同</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241251863.png" alt="image-20220624125058154"></p><p><strong>上三角存储压缩策略</strong></p><ul><li>按行优先存储将绿色区元素存入一维数组，并在最后一个位置存储常数c</li></ul><p>数组下标$k&#x3D;\left{\begin{aligned}\frac{(i-1)(2n-i+2)}{2}+j-i,上三角和主对角线元素\\frac{n(n+1)}{2}，下三角元素\end{aligned}\right.$</p><p><strong>下三角存储</strong></p><p>$k&#x3D;\left{\begin{aligned}\frac{(i-1)i}{2}+j-1,下三角和主对角线元素\\frac{n(n+1)}{2}，上三角元素\end{aligned}\right.$</p><h3 id="三对角矩阵-方阵"><a href="#三对角矩阵-方阵" class="headerlink" title="三对角矩阵(方阵)"></a>三对角矩阵(方阵)</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241304890.png" alt="image-20220624130420525"></p><ul><li>三对角矩阵又叫带状矩阵：当$|i-j|&gt;1$时，有$a_{ij}&#x3D;0$</li></ul><p>压缩策略：行优先（或者列优先）原则，只存储带状部分</p><p>数组下标$k&#x3D;2i+j-3$：计算过程：3(i-1)-1+j-i+2-1</p><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><ul><li>定义：非零元素远远小于矩阵的个数的矩阵</li></ul><h4 id="存储策略-1"><a href="#存储策略-1" class="headerlink" title="存储策略"></a>存储策略</h4><p><strong>顺序存储——三元组</strong>{行，列，值}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//行</span></span><br><span class="line">    <span class="type">int</span> j;<span class="comment">//列</span></span><br><span class="line">    <span class="type">int</span> v;<span class="comment">//值</span></span><br><span class="line">&#125;triple;<span class="comment">//结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    triple data[maxsize+<span class="number">1</span>]; <span class="comment">//不用data[0]</span></span><br><span class="line">    <span class="type">int</span> mu,nu,tu; <span class="comment">//行数,列数,非零个数</span></span><br><span class="line">&#125;tsmatrix;</span><br></pre></td></tr></table></figure><p>注意：一个三元组不仅包含n个元素(定义如上)，还包含统计的列数，行数，总个数</p><p><strong>链式存储——十字链表法</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206241313484.jpg"></p><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p><a href="https://www.cnblogs.com/chunlanse2014/articles/4536248.html">广义表</a></p><p><strong>定义</strong>：又称列表，也是一种线性存储结构，既可以存储不可再分的元素，也可以存储广义表，记作：<code>LS = (a1,a2,…,an)</code></p><ul><li>LS 代表广义表的名称，n为表长</li><li>广义表中存储的<code>单个元素称为 &quot;原子&quot;</code>，而<code>存储的广义表称为 &quot;子表&quot;</code>。<br>例如 ：广义表 LS &#x3D; {1,{1,2,3}}，则此广义表的构成 ：广义表 LS 存储了一个原子 1 和子表 {1,2,3}。</li><li>an 表示广义表存储的数据<ul><li>表头:LS的第一个元素，记head(LS)&#x3D;a1，表头可以为原子或者子表</li><li>表尾：除了表头之外的其他元素组成的表，记tail(LS)&#x3D;(a2,a3…an),<ul><li>注意：<strong>表尾为子表</strong>而不是最后一个元素</li></ul></li></ul></li><li>广义表中每个 ai 既可以代表原子，也可以代表另一个广义表。</li><li>广义表中存储的<code>单个元素称为 &quot;原子&quot;</code>，而<code>存储的广义表称为 &quot;子表&quot;</code>。</li></ul><p>广义表存储数据的一些常用形式：</p><ul><li>A &#x3D; ()：A 表示一个广义表，只不过表是空的。</li><li>B &#x3D; (e)：广义表 B 中只有一个原子 e。</li><li><code>C = (a,(b,c,d))</code> ：广义表 C 中有两个元素，原子 a 和子表 <code>(b,c,d</code>)。</li><li>D &#x3D; (A,B,C)：广义表 D 中存有 3 个子表，分别是A、B和C。这种表示方式等同于 <code>D = ((),(e),(b,c,d))</code> 。</li><li><code>E = (a,E)</code>：广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：<code>E = (a,(a,(a,…)))</code>。</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>广义表的数据元素有相对次序：直接前驱和后继(表头和表尾除外)</li><li>广义表的长度定义为<strong>最外层所包含元素的个数</strong>;<ul><li>如: <code>C=(a,(b, c))</code>是长度为2的广义表。</li><li>计算元素个数时，广义表中存储的<code>每个原子算作一个数据</code>，同样<code>每个子表也只算作是一个数据</code></li><li>注意这种广义表表示A(C,D(E,H))的深度，画出树判断(后面有讲解，A外在加一层括号)</li></ul></li><li>广义表的深度定义为<strong>该广义表展开后所含括号的重数</strong>;<ul><li>A&#x3D;(b, c)的深度为1，B&#x3D;(A, d)的深度为2，C&#x3D;(f,B, h)的深度为3。</li><li>注意:“原子”的<strong>深度为0</strong>;<strong>“空表”的深度为1</strong>。</li><li>广义表的深度，可以通过观察该表中<strong>所包含括号的层数</strong>间接得到，如下示例，该广义表的深度为2。<br><img src="https://img-blog.csdnimg.cn/3eb89cf2f6eb484f87ade938ebfbf590.png" alt="在这里插入图片描述"></li></ul></li><li>广义表可以为其他广义表共享;如:广义表B就共享表A。在B中不必列出A的值，而是通过名称来引用，B&#x3D;(A)</li><li>广义表可以是一个递归的表。如:<code>F=(a,(a, (a, (a, ...)))</code><ul><li>注意:递归表的深度是无穷值，长度是有限值。</li></ul></li><li>广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表，</li></ol><h2 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>广义表中关于tail和head的计算</strong></p><p>针对的非空表进行操作</p><ul><li><strong>广义表的head操作，取出的元素是什么，那么结果就是什么。但是tail操作取出的元素外必须加一个表——“</strong> <strong>（）“</strong></li></ul><blockquote><p>eg:LS&#x3D;(a,b)</p><p>head(LS)&#x3D;a</p><p>tail(LS)&#x3D;(b)</p></blockquote><p>注意</p><blockquote><p>LS&#x3D;(())</p><p>tail(LS)&#x3D;()</p><p>head(LS)&#x3D;()</p><p>广义表()和广义表(())不同，前者是长度维0的空表，对其不能做表头和表尾的运算；</p><p>后者是长度为1的空表(为一元素是空表，对其进行分解)</p></blockquote><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>通常采用链式存储</p><p>广义表有两种表示方式，即广义表的<strong>头尾链表存储表示和扩展性链表表示</strong>；两种方法的区别在于：</p><h3 id="头尾链表存储表示"><a href="#头尾链表存储表示" class="headerlink" title="头尾链表存储表示"></a>头尾链表存储表示</h3><p>链表中有两种结点，**表结点和原子结点(数据结点)**；</p><p>存储结构一如下示意图所示：表示<code>原子的节点由两部分构成</code>，分别是 <code>tag 标记位和原子的值</code>，<code>表示子表的节点由三部分构成</code>，分别是 <code>tag 标记位、hp 指针和 tp 指针</code>。</p><ul><li>tag 标记位用于区分此节点是原子还是子表，通常原子的 tag 值为 0，子表的 tag 值为 1；</li><li>子表节点中的 hp 指针用于连接本子表中存储的原子或子表；</li><li>tp 指针用于连接广义表中下一个原子或子表。</li></ul><p>广义表中两种节点的表示代码定义如下：<br>定义中使用了 union 共用体，因为同一时间此节点不是原子节点就是子表节点，当表示原子节点时，就使用 atom 变量；反之则使用 ptr 结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> tag;         <span class="comment">// 标志域, 0表示原子, 1表示子表</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="type">char</span> atom;   <span class="comment">//  原子结点的值域</span></span><br><span class="line">        <span class="keyword">struct</span>&#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">GNode</span> * hp, *tp;</span><br><span class="line">        &#125;ptr;   <span class="comment">// 子表结点的指针域, hp指向表头, tp指向表尾</span></span><br><span class="line">    &#125;subNode;</span><br><span class="line">&#125;GLNode, *Glist;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208252258739.png" alt="image-20220825225754507"></p><p>对于C&#x3D;(a,(b,c,d))来说，可以对原子加一个括号(写成子表格式)，C&#x3D;( (a) , ( (b),(c),(d) ) )——自我理解</p><p>这样对应下图形式，子表往下最终指向原子，往右指向子表的下一个</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208262251135.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208252258954.png"></p><h3 id="扩展性链表表示"><a href="#扩展性链表表示" class="headerlink" title="扩展性链表表示"></a>扩展性链表表示</h3><p><strong>表结点存储的节点与头尾相同</strong>，但是原子结点(数据结点)多存储一个指向下一个数据的next指针域；</p><p>另一种存储结构的<code>原子的节点也由三部分构成</code>，分别是 ： <code>tag 标记位、原子值和 tp 指针构成</code>；表示子表的节点由三部分构成，分别是 ： <code>tag 标记位、hp 指针和 tp 指针</code>，示意图如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> tag;                <span class="comment">// 标志域, 0表示原子, 1表示子表</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> atom;          <span class="comment">// 原子结点的值域</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">GNode</span>* hp;  <span class="comment">// 子表结点的指针域, hp指向表头</span></span><br><span class="line">    &#125;subNode;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GNode</span>* tp;     <span class="comment">// 这里的tp相当于链表的next指针, 用于指向下一个数据元素</span></span><br><span class="line">&#125;GLNode, *Glist;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208252259999.png" alt="image-20220825225904952"></p><p>对于C&#x3D;(a,(b,c,d))来说，一路指到底，往右指向该层的下一个元素，往下指向内部（下一层）的第一个元素</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208262251720.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208252259947.png"></p><p>针对同一广义表的两种存储表示：<br><code>L = (f, (b, e), ((c, d), a))</code><br>  使用头尾链表存储表示时，最上层存在三个表结点，第一个表结点值域存储一个f，第二个表结点的值域存储一个子表，第三个表结点，存储一个子表，第一个子表再存储一个子表；<br>  使用扩展性链表存储表示时，只需注意，第一个next指针为f发出指向子表，子表内包好(b, e)；括号内的(b, e)，next指针由b发出，再出来第三个next指针由子表(b, e)的next指针发出，指向子表(P, a)，此处P为(c, d)；最后的next指针由P发出指向a；<br>两种表示法分别如下：</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208252300216.png"></p><p><strong>已知一组广义表序列，表示树</strong></p><p>eg:$1(2(3(4,5)),6(7,8(9,10)))$</p><ul><li>我们可以看到，<strong>广义表形式的二叉树</strong>其实结构上是**(( ),( ))<strong>，</strong>第一个下划线<strong>代表</strong>双亲结点<strong>，</strong>第二个和第三个下划线<strong>代表</strong>孩子结点<strong>，</strong>孩子结点有可能不存在。**</li><li>深度为4(相当于外面加层括号（1(2(3(4,5)),6(7,8(9,10)))）——4个括号)</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209202319350.png" alt="image-20220920231904045"></p><ul><li>A(B,C,D)：表示以A为根节点，括号内是A的子结点</li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209202325287.png" alt="image-20220920232548768"></li><li>A(B,C,D(E,G))</li><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209202326037.png" alt="image-20220920232624793"></li></ul><p>若写成这种形式(A(B,C,D(E,G))),也可以写成上述的形式（这种写法可能有问题，遇到了就这么想）</p><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="串的定义和实现"><a href="#串的定义和实现" class="headerlink" title="串的定义和实现"></a>串的定义和实现</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><ol><li><p>串: 零个或多个字符组成的有限序列，如 <code>S = &#39;iPhone 11 Pro Max?&#39;</code>；</p></li><li><p>串名：S是串名；</p></li><li><p>串的长度：串中字符的个数n；</p><ul><li>若题目说了以特殊字符结尾，则总个数位字符实际个数加上1</li></ul></li><li><p>空串：n&#x3D;0时的串，属于任意串的子串(计算子串数量时时注意要加上)</p></li><li><p>子串：串中任意多个连续的字符组成的<strong>子序列</strong>称为该串的子串；</p></li><li><p>主串：包含子串的串；</p></li><li><p>字符在主串中的位置：某个字符在串中的序号（从1开始）；</p></li><li><p>子串在主串中的位置：子串的<strong>第一个字符</strong>在主串中的位置；</p></li><li><p>空串 V.S 空格串：</p><ul><li><code>M = &#39;&#39;</code> 是空串；</li><li><code>N = &#39; &#39;</code> 是空格串；</li></ul></li><li><p>串 V.S 线性表：</p><ul><li><p>串是特殊的线性表，数据元素之间呈线性关系（逻辑结构相似）；</p></li><li><p>串的数据对象<strong>限定</strong>为字符集：中文字符、英文字符、数字字符、标点字符…</p></li><li><p>串的基本操作，如增删改除通常以<strong>子串</strong>为操作对象</p></li></ul></li></ol><h3 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h3><p>容易考到字符串操作，注意记忆常见基本操作</p><p>假设有串 <code>T = &#39;&#39;</code>, <code>S = &#39;iPhone 11 Pro Max?&#39;</code>, <code>W = &#39;Pro&#39;</code></p><ul><li><p><code>StrAssign(&amp;T, chars)</code>: 赋值操作，把串T赋值为chars；</p></li><li><p><code>StrCopy(&amp;T, S)</code>: 复制操作，把串S复制得到串T；</p></li><li><p><code>StrEmpty(S)</code>: 判空操作，若S为空串，则返回true，否则返回false；</p></li><li><p><code>StrLength(S)</code>: 求串长，返回串S的元素个数；</p><blockquote><p>返回<code>length</code>值</p></blockquote></li><li><p><code>ClearString(&amp;S)</code>: 清空操作，将S清为空串；</p><blockquote><p>将<code>length = 0</code>，逻辑上清空，但是内存中还有</p></blockquote></li><li><p><code>DestroyString(&amp;S)</code>: 销毁串，将串S销毁——<strong>回收存储空间</strong>；</p></li><li><p><code>Concat(&amp;T, S1, S2)</code>: 串联联接，用T返回由S1和S2联接而成的新串———可能会导致存储空间的扩展；</p></li><li><p><code>SubString(&amp;Sub, S, pos, len)</code>: 求子串，用Sub返回串S的第pos个字符起长度为len的子串；</p></li><li><p><code>Index(S, T)</code>: 定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中<strong>第一次出现的位置</strong>，否则函数值为0；</p></li><li><p><code>StrCompare(S, T)</code>: 串的比较操作，参照英文词典排序方式；若S &gt; T,返回值&gt;0; S &#x3D; T,返回值&#x3D;0 <strong>(需要两个串完全相同)</strong> ; S &lt; T,返回值&lt;0;</p></li><li><p><code>strreplace(char* str, char* sub, char* rep)</code> ：str为原字符串，sub是待替换的字符串，rep为替换字符串</p></li></ul><p><strong>拓展：字符集编码</strong></p><ol><li>字符集——–y&#x3D;f(x)<ul><li>字符集理解为函数定义域x</li><li>编码:将函数映射成规则f</li><li>f:计算机对应的二进制数</li></ul></li><li>乱码问题:编码方式不同</li></ol><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><ol><li>定长顺序存储表示</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255   <span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   <span class="comment">//静态数组实现（定长顺序存储）</span></span><br><span class="line">                       <span class="comment">//每个分量存储一个字符</span></span><br><span class="line">                       <span class="comment">//每个char字符占1B</span></span><br><span class="line">    <span class="type">int</span> length;        <span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><p>串长的两种表示法：</p><ul><li><p>方案一：用一个额外的变量<code>length</code>来存放串的长度（保留<code>ch[0]</code>）；</p></li><li><p>方案二：用<code>ch[0]</code>充当<code>length</code>；</p><ul><li>优点：字符的位序和数组下标相同；</li></ul></li><li><p>方案三：没有<code>length</code>变量，以字符<code>&#39;\0&#39;</code>表示结尾（对应ASCII码的0）；</p><ul><li>缺点：需要从头到尾遍历；</li></ul></li><li><p><strong>方案四——最终使用方案：</strong><code>ch[0]</code>废弃不用，声明int型变量<code>length</code>来存放串的长度（方案一与方案二的结合）</p></li><li><p>基本操作实现（基于方案四）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];   </span><br><span class="line">    <span class="type">int</span> length;       </span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 已知一直起始位置和长度，求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString &amp;Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界，可举例子判断不等式</span></span><br><span class="line">    <span class="keyword">if</span> (pos+len<span class="number">-1</span> &gt; S.length)<span class="comment">//下标位置从1开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=pos; i&lt;pos+len; i++)</span><br><span class="line">        Sub.ch[i-pos+<span class="number">1</span>] = S.ch[i];</span><br><span class="line">    </span><br><span class="line">    Sub.length = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 比较两个串的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=S.length &amp;&amp; i&lt;=T.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定位操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    n = StrLength(S);</span><br><span class="line">    m = StrLength(T);</span><br><span class="line">    SString sub;        <span class="comment">//用于暂存子串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(Sub,S,i,m);<span class="comment">//求子串</span></span><br><span class="line">        <span class="keyword">if</span>(StrCompare(Sub,T)!=<span class="number">0</span>)<span class="comment">//判断字串是否相同</span></span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> i;    <span class="comment">// 返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;            <span class="comment">//S中不存在与T相等的子串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ps:结合顺序表思考优缺点</p><ol><li>堆分配存储表示</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;           <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">HString S；</span><br><span class="line">S.ch = (<span class="type">char</span> *) <span class="built_in">malloc</span>(MAXLINE * <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">//基地址指针指向连续空间的起始位置</span></span><br><span class="line">                                                <span class="comment">//malloc()需要手动free()</span></span><br><span class="line">S.length;</span><br></pre></td></tr></table></figure><ol><li>串的链式存储</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;           <span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br></pre></td></tr></table></figure><p>问题：存储密度低，每个字符1B，每个指针4B；<br>解决方案：每一个链表的结点存储多个字符——每个结点称为块——<strong>块链结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">4</span>];           <span class="comment">//每个结点存多个个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, * String;</span><br></pre></td></tr></table></figure><p><em>ps:结合链表思考优缺点</em></p><ul><li>存储分配角度：链式存储的字符串无需占用连续空间，存储空间分配更灵活；</li><li>操作角度：若要在字符串中插入或删除某些字符，则顺序存储方式需要移动大量字符，而链式存储不用；</li><li>若要按位序查找字符，则顺序存储支持随机访问，而链式存储只支持顺序访问；</li></ul><h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><p>串的匹配模式：在主串中找到与模式串中找到相同的字串，并返回位置</p><h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><p><strong>模式串</strong>：尝试在主串中找到的串，未必存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//匹配过程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;                <span class="comment">//扫描主串S</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;                <span class="comment">//扫描模式串T</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;             <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k++;            <span class="comment">//检查下一个子串</span></span><br><span class="line">            i=k;</span><br><span class="line">            j=<span class="number">1</span>;             <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206282210475.gif"></p><p><strong>时间复杂度分析：</strong></p><ul><li><p>主串长度为n，模式串长度为m</p></li><li><p>最多比较<code>n-m+1</code>个子串</p></li><li><p>最坏时间复杂度 &#x3D;<code>O(nm)</code></p><ul><li>每个子串都要对比m个字符(对比到最后一个字符才匹配不上)，共要对比n-m+1个子串，复杂度 &#x3D; <code>O((n-m+1)m) = O(nm - m^2 + m) = O(nm)</code></li><li><em>PS:大多数时候，n&gt;&gt;m</em></li></ul></li><li><p>最好时间复杂度 </p><ul><li>匹配成功：<code>O(m)</code></li></ul></li><li><p>匹配失败：每个子串的第一个字符就匹配失败，共要对比n-m+1个子串，复杂度 &#x3D; <code>O(n-m+1) ≈ O(n)</code></p></li></ul><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><strong>与朴素算法对比就是i指针不用回溯</strong></p><p><strong>串的前缀</strong>：包含第一个字符，且不包含最后一个字符的字串</p><p><strong>串的后缀</strong>：包含最后一个字符，且不包含第一个字符的字串</p><ul><li><p>不匹配的字符之前，一定是和模式串一致的；</p></li><li><p>根据模式串T，求出<code>next数组</code></p><ul><li>（只与模式串有关，与主串无关），利用<code>next数组</code>进行匹配，</li><li>当匹配失败时，主串的指针 <code>i</code> 不再回溯！</li></ul></li></ul><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>当j个字符匹配失败，由前<code>1~j-1</code>个字符组成的串为S</p><ul><li>则：<code>next[j]=S</code>的最长相等前后缀长度+1</li><li>与acwing平台的不同，acwing的next数组记录的是最长相等后缀长度</li></ul><p>例：对于串 <code>T = &#39;abaabc&#39;</code></p><table><thead><tr><th>next[0]</th><th>next[1]</th><th>next[2]</th><th>next[3]</th><th>next[4]</th><th>next[5]</th><th>next[6]</th></tr></thead><tbody><tr><td></td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td></tr><tr><td>s串</td><td></td><td>a</td><td>ab</td><td><font color=Crimson>a</font>b<font color=Crimson>a</font></td><td><font color=Crimson>a</font>ba<font color=Crimson>a</font></td><td><font color=Crimson>ab</font>a<font color=Crimson>ab</font></td></tr></tbody></table><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206302139265.gif"></p><ol><li>利用<code>next数组</code>进行模式匹配</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求next数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(String T,<span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || T.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i,++j;</span><br><span class="line">            next[i]=j;<span class="comment">//若pi=pj,则next[j+1]=next[j]+1</span></span><br><span class="line">            </span><br><span class="line">           <span class="comment">//j==0说明模式串,匹配的主串和模式串在上次字符不匹配,且j指向模式串的数组下标0处(即没有字符可以与主串字符对比),所以重新匹配新的字符i++,j++</span></span><br><span class="line">            <span class="comment">//T.ch[i]==T.ch[j],说明主串和模式串字符匹配成功,需匹配新的字符i++,j++</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//匹配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;     <span class="comment">//主串</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;     <span class="comment">//模式串</span></span><br><span class="line">    <span class="keyword">while</span>（i&lt;S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j])&#123;     </span><br><span class="line">            ++j;</span><br><span class="line">            ++i;         <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j]   <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length; <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配字符串</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204251328676.png"></p><ul><li><code>s[a,b] = p[1,j] &amp;&amp; s[i] != p[j+1]</code> 此时要移动p串（不是移动1格，而是直接移动到下次能匹配的位置）</li><li>其中1串为<code>[1, next[ j ]]</code>，3串为<code>[j-next[j]+1,j]</code>。由匹配可知 1串等于3串，3串等于2串。所以<strong>直接移动p串使1到3的位置</strong>即可。这个操作可由**j &#x3D; next[ j ]直接完成。 如此往复下去，当 j &#x3D;&#x3D; m时匹配成功。</li></ul><p><strong>3. 时间复杂度分析：</strong></p><ul><li>求next数组时间复杂度 &#x3D; <code>O(m)</code></li><li>模式匹配过程最坏时间复杂度 &#x3D; <code>O(n)</code></li><li>KMP算法的最坏时间复杂度 &#x3D; <code>O(m+n)</code></li></ul><h2 id="KMP算法进一步优化"><a href="#KMP算法进一步优化" class="headerlink" title="KMP算法进一步优化"></a>KMP算法进一步优化</h2><p><strong>原因</strong>:第4个字符g匹配失败后，然后又和第一个字符g匹配，重复与g匹配了两次</p><table><thead><tr><th>序号j</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>模式串</td><td>g</td><td>0</td><td>0</td><td>g</td></tr><tr><td>next[j]</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>对<code>next</code>数组的优化——<code>nextval</code>数组</p><p><strong>nextval数组的手算</strong></p><ul><li><p>先算出next数组</p></li><li><p>先令<code>nextval[1]=0</code>，也就是对比第j个位置和第next[j]个位置的字符，字符相同则nextval数组存储第next[j]位置的next数组大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=T.length;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j])<span class="comment">//串字符相等</span></span><br><span class="line">        nextval[j]=nextval[next[j]];<span class="comment">//存储的前面字符的nextval的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextval[j]=next[j];<span class="comment">//字符不相等，为原来的next大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>KMP算法优化：当子串和模式串不匹配时<code>j=nextval[j]</code></p></li></ul><table><thead><tr><th><strong>模式串</strong></th><th><strong>A</strong></th><th><strong>B</strong></th><th><strong>A</strong></th><th><strong>B</strong></th><th><strong>A</strong></th><th><strong>A</strong></th><th><strong>B</strong></th></tr></thead><tbody><tr><td><strong>j</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td></tr><tr><td><strong>next[j]</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>2</strong></td><td><strong>3</strong></td><td><strong>4</strong></td><td><strong>2</strong></td></tr><tr><td><strong>nextval[j]</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>4</strong></td><td><strong>1</strong></td></tr></tbody></table><h2 id="next数组问题"><a href="#next数组问题" class="headerlink" title="next数组问题"></a>next数组问题</h2><p><a href="https://blog.csdn.net/Martin0316/article/details/116517065?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165659754816782391882104%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165659754816782391882104&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-2-116517065-null-null.142%5Ev29%5Epc_rank_34,157%5Ev15%5Enew_3&utm_term=kmp%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88next%5B0%5D%E4%B8%BA0%E6%88%96%E8%80%85-1&spm=1018.2226.3001.4187">数组问题</a></p><table><thead><tr><th></th><th>a</th><th>b</th><th>a</th><th>a</th><th>b</th><th>c</th><th>a</th><th>c</th></tr></thead><tbody><tr><td>开始下标</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>next[]_ac</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>0</td><td>1</td><td>0</td></tr><tr><td>next[]_cur</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>0</td><td>1</td></tr><tr><td>开始下标</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>next[]_wd</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>1</td><td>2</td></tr></tbody></table><ul><li>next[]_ac:存储的是字符串最长前后缀字符串（与acwing平台一样）</li><li>next[]_cur:将<code>next[]_ac</code>整体右移动，<code>next[0]=-1</code></li><li>next[]_wd:与王道书上一致,，在<code>next[]_cur</code>整体加1</li></ul><p><strong>注意</strong></p><ul><li>首先我们可以将串的next数组按照王道的写出来</li><li>如果<strong>串的位序从1</strong>开始，就按照王道的规则写；</li><li>如果<strong>串的位序从0</strong>开始，就按照第二个next[]_cur写，也就是将王道规则整体减1；</li></ul><p>注意计算王道规则时，j指向的字符q，计算q之前的字符不包含字符q</p><h1 id="算法综合题"><a href="#算法综合题" class="headerlink" title="算法综合题"></a>算法综合题</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li><p>设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点</p><p><strong>思路</strong></p><ul><li>本题用递归删除，所以用删除链头指针指向的结点即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delet</span><span class="params">(LinkList &amp;L,ElemType x)</span></span>&#123;</span><br><span class="line">LNode *p;</span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//空表</span></span><br><span class="line"><span class="keyword">if</span>(L-&gt;data==x)&#123;<span class="comment">//链头结点值为x，删除结点</span></span><br><span class="line">p=L;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">Delet</span>(L,x);<span class="comment">//递归</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">Delet</span>(L-&gt;next,x);<span class="comment">//链头结点值不为x,指向下一个结点递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>设L为带头结点，编写算法从头到尾反向输出每个结点的值</p><p>思想1：利用链表转置的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">LNode *p,*q;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">q=p;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">q-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=q;</span><br><span class="line">&#125;</span><br><span class="line">p=L-next;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">cout&lt;&lt;p-&gt;data;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思想2：利用栈的递归的思想，先递归输出他后面的结点，在输出该结点自身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R_Print</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next!=<span class="literal">NULL</span>) <span class="built_in">R_Print</span>(L-&gt;next);<span class="comment">//递归后面的结点</span></span><br><span class="line"><span class="keyword">if</span>(L!=<span class="literal">NULL</span>) cout&lt;&lt; L-&gt;data;<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写在带头结点的单链表中删除一个最小值结点的高效算法</p><p>思想：通过记录当前结点及当前结点的前驱，还有最小值结点和最小值结点的前驱判断即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delet</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">// if(L-&gt;next==NULL) return;题目说必有最小结点，不考虑</span></span><br><span class="line">LNode *min,*p,*q,*minpre;<span class="comment">//p为当前结点,q记录p的前驱结点,min记录最小值结点,minpre为当前最小的前驱,</span></span><br><span class="line">p=L-&gt;next;</span><br><span class="line">q=L;</span><br><span class="line">min=p;</span><br><span class="line">minpre=L;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(min-&gt;data &lt; p-&gt;data) min=p,minpre=q;<span class="comment">//满足条件记录最小结点</span></span><br><span class="line">p=p-&gt;next;</span><br><span class="line">q=q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">minpre=min-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>1、设单链表的表头指针为L，结点结构为data和next，其中data为字符型，设计算法判断链表的全部n个字符是否中心对称,例如xyx,xyyx;(王道66页第4题)</p><p>思想:利用栈来判断链表中的数据元素是否中心对称，首先用一个栈(字符型数组存储数据)，记录前半个，然后利用这个栈判断后面后半部分是否对称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dc</span><span class="params">(LinkList L,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> s[n/<span class="number">2</span>];<span class="comment">//作为栈</span></span><br><span class="line">LNode *p;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line"><span class="comment">//数据元素存储栈中</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">s[i]=p-&gt;data;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">i--;<span class="comment">//恢复原来的i值</span></span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) p=p-&gt;next;<span class="comment">//如果为技术,则越过中心点 </span></span><br><span class="line"><span class="comment">//判断右半部分和左半部分十分相等</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; s[i]==p-&gt;data)&#123;</span><br><span class="line">i--;</span><br><span class="line">p=p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//说明没遍历完就退出了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.acwing基础算法</title>
      <link href="/data.github.io/post/9d0a3839.html"/>
      <url>/data.github.io/post/9d0a3839.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础算法"><a href="#一、基础算法" class="headerlink" title="一、基础算法"></a>一、基础算法</h1><ul><li>上课学习主要思想</li><li>下课背模板，一个类型的题目做3到5遍</li></ul><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>———<strong>分治</strong></p><p><strong>主要思想</strong></p><ol><li>确定分界点：q[l],q[(l+r)&#x2F;2],q[r],随机</li><li>调整区间（区间一分为2）：在一个区间小于x,另一个区间大于x</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202232023965.jpg"></p><p>  3.递归处理左右两端</p><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203022010325.jpg"></p><ol><li>第一步，先v判断v&lt;x,满足则一直判断下一个位置</li><li>第二，若v&gt;&#x3D;x,则判断r&gt;x,满足则判断下一个位置</li><li>第三，若r&lt;&#x3D;x，交换对应的数值大小</li><li>然后递归处理两端</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203012314248.gif"></p><p><strong>时间复杂度</strong></p><ul><li>最好时间复杂度:  $O(nlog_2n)$</li><li>最坏时间复杂度:  $O(n^2)$</li><li>平均时间复杂度:  $O(nlog_2n)$</li></ul><p><a href="https://www.acwing.com/problem/content/submission/code_detail/11404073/">题目</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//l为最左端，r为最右端，x为判断值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//最终条件,左遇右,回归</span></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l+r&gt;&gt;<span class="number">1</span>];;<span class="comment">//初始化，l+r的值右移1位，相当l+r的值除以2取整</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)<span class="comment">//判断相遇，则退出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);<span class="comment">//判断左端数据，小于x</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);<span class="comment">//判断右端数据,小于y</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);<span class="comment">//交换位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);<span class="comment">//左递归</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);<span class="comment">//右递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><ul><li>开辟2个新空间，判断大小并存于相应空间内，最后再将新空间分别个原空间</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202232023340.jpg"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><a href="https://blog.csdn.net/ww753951/article/details/118510821?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164622666416780255287758%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164622666416780255287758&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-118510821.first_rank_v2_pc_rank_v29&utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3&spm=1018.2226.3001.4187">归并排序</a></p><p><strong>思想</strong></p><ol><li>确定分界点：mid&#x3D;(l+r)&#x2F;2</li><li>归并排序left,right</li><li>归并（合二为一）–难点</li></ol><p><a href="https://blog.csdn.net/u010711495/article/details/116891262?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164622666416780255279046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164622666416780255279046&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-116891262.first_rank_v2_pc_rank_v29&utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3&spm=1018.2226.3001.4187">图解过程</a></p><p>图解</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203022114282.png"></p><p><strong>稳定性好</strong></p><ul><li>在排序对比时，遇到相同位置的数字，不发生交换，就比较稳定；可能发生交换不稳定</li></ul><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208041252148.gif" style="zoom:200%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//回归条件</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//取中间值，</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);<span class="comment">//左端递归排序</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);<span class="comment">//右端递归排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并合一，两个有序序列合成一个有序序列</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;<span class="comment">//i指向左半边,j指向右半边</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两边都没有循环完，判断大小</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左右其中一边没有循环完的接到序列后面</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将tem付给q数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><ul><li>最好&#x2F;平均&#x2F;最坏时间复杂度:  $O(nlog_2n)$</li></ul><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ol><li>如果有单调性，一定可以二分，但是可以二分的题目，不一定有单调性。</li><li>二分的本质，<strong>问题一半满足，一半不满足，可以寻找到边界</strong>，这个边界可以将数组分为两个部分。因为整数边界必须做出选择，代码将有两个模板。而浮点数不是</li></ol><p>对于整数二分而言，“求分界点”也就是求左侧部分（满足性质A AA）的最后一个数，或者求右侧部分（不满足性质A AA）的第一个数。</p><p><strong>感觉就是区间找边界</strong></p><p><a href="https://www.acwing.com/problem/content/791/">题目</a></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204022250225.jpg"></p><p><strong>条件</strong>:一般都含有等于</p><p><strong>满足左侧最后一个数</strong></p><ul><li>满足条件mid&lt;&#x3D;7，说明mid在（目标值的）左边，所以要更新将mid更新为新的左边界（靠近目标值）</li><li>mid&#x3D;l+r+1&gt;&gt;1;</li></ul><p><strong>满足(条件)右侧第一个数</strong></p><ul><li>满足条件mid&gt;&#x3D;7,说明mid在（目标值）右边，所以要更新mid作为新的右边界</li><li>而求左侧部分（满足性质A AA）的最后一个数，或者求右侧部分（不满足性质A AA）的第一个数<ul><li>理解：比如说mid&lt;&#x3D;7：满足性质的最后一个数；第一个数7就是不满足mid&lt;7的第一个数</li></ul></li></ul><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><ol><li>首先保证数组有序，二分一定有解，但题目可能无解</li><li>首先找到<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>的中间值，mid&#x3D;(left+right)&gt;&gt;1，区间[left, right]被划分成[left, mid]和[mid + 1, right]；如果是mid &#x3D; l + r + 1 &gt;&gt; 1，区间[left, right]被划分成[left, mid - 1]和[mid, right]。</li><li>然后通过check(mid)判断中间值是不是满足这个性质,check是根据不同的题型编写的。</li><li>最后就能使用折半，缩小<a href="https://so.csdn.net/so/search?q=%E5%8C%BA%E9%97%B4&spm=1001.2101.3001.7020">区间</a>了，如果区间缩到了1，那么那个也就是答案。</li></ol><h3 id="模板例子解释"><a href="#模板例子解释" class="headerlink" title="模板例子解释"></a>模板例子解释</h3><p>求左侧最后一个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="comment">//边界在mid的右边</span></span><br><span class="line"><span class="comment">//找满足左侧性质的最后一个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//+1防止死循环，防止mid=l,l=l</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求右侧第一个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最开始的区分时</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="comment">//边界在mid的左边</span></span><br><span class="line"><span class="comment">//求右侧部分（不满足性质A AA）的第一个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//左边界;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质；左侧满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;<span class="comment">//右侧不满足性质</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p><a href="https://www.acwing.com/problem/content/792/">浮点数二分</a></p><ul><li>时刻要保证答案在要寻找区间</li><li>无边界问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">double</span> eps=<span class="number">1e-8</span>,l=<span class="number">-100</span>,r=<span class="number">100</span>;<span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid=(l+r)/<span class="number">2</span>;<span class="comment">//一直二分</span></span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid&gt;=n) r=mid;<span class="comment">//边界在mid的左边</span></span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>[[C++常用库及操作#vector|Vector详解]]</p><p>C++<a href="https://www.acwing.com/problem/content/description/793/">代码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    <span class="comment">//保证A的位数比B多</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);<span class="comment">//取余数,当前</span></span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//进位数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);<span class="comment">//最高位的进位</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203062148103.jpg"></p><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p><a href="https://www.acwing.com/problem/content/794/">高精度减法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;<span class="comment">//t为借位,c[i]=a[i]-b[i]-t</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);<span class="comment">//保证c[i]为正</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">//借位只有0,1,小于0借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//003情况,去除0返回3</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断A是否大于B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//从最高位判断</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p><a href="https://www.acwing.com/problem/content/description/795/">题目</a></p><ul><li>注意返回要去除最高位0</li><li>进位可能很能很大</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203081644298.jpg"></p><p>注意：代码主要是<strong>高精度</strong>乘以有限大（）</p><p><strong>高精度乘低精度</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C=A*b;A为已经逆序的整数数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        t += A[i] * b;       <span class="comment">// t + A[i] * b = 7218</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>); <span class="comment">// 只取个位 8</span></span><br><span class="line">        t /= <span class="number">10</span>;             <span class="comment">// 721 看作 进位,可能有很多位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t) &#123;            <span class="comment">// 处理最后进位,处理最后剩余的 t</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//去除最高位0，可能b=0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p>高精度除以低精度</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203081719844.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">r=r*<span class="number">10</span>+A[i];<span class="comment">//余数乘10加当前位</span></span><br><span class="line">C.<span class="built_in">push_back</span>(r/b);<span class="comment">//r/b作为该位的商 (0~9)</span></span><br><span class="line">r%=b;<span class="comment">//作为余数</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//算出的商(1在最高位)123，reverse反转321,主函数逆序输出123</span></span><br><span class="line"><span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());<span class="comment">//数组反转;因为开始的商在最高位，为了与主函数对应</span></span><br><span class="line"><span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();<span class="comment">//去前导0</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p><a href="https://www.acwing.com/problem/content/797/">一维前缀和</a></p><ul><li>主要思想先算出存储前i项的前缀和，则l到r的前缀和如下图</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]<span class="comment">//s[i]存储下标为1到i的和</span></span><br><span class="line">    </span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]<span class="comment">//l到r的前缀和，s[l-1]不包括a[l]</span></span><br></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p><a href="https://www.acwing.com/problem/content/798/">二位前缀和</a></p><p>计算s[i,j]</p><p><strong>跟子矩阵有关系</strong></p><ul><li>求前缀和</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203091314706.png" alt="image-20220309131412428"></p><ul><li>求子矩阵</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203091314948.png" alt="image-20220309131350008"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S[i, j] <span class="comment">//为第i行j列格子左上部分所有元素的和</span></span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];<span class="comment">//计算s[i][j]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为</span></span><br><span class="line">s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p><a href="https://www.acwing.com/problem/content/description/799/">一维差分</a></p><p><strong>差分数组：</strong></p><p>首先给定一个原数组<code>a</code>：<code>a[1], a[2], a[3],,,,,, a[n];</code></p><p>然后我们构造一个数组<code>b</code> ： <code>b[1] ,b[2] , b[3],,,,,, b[i];</code></p><p>使得 <code>a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]</code></p><p>也就是说，<code>a</code>数组是<code>b</code>数组的前缀和数组，反过来我们把<code>b</code>数组叫做<code>a</code>数组的<strong>差分数组</strong>。换句话说，每一个<code>a[i]</code>都是<code>b</code>数组中从头开始的一段区间和。</p><p>考虑如何构造差分<code>b</code>数组？</p><p>最为直接的方法</p><p><strong>如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span> ]= <span class="number">0</span>;</span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">1</span>] - a[<span class="number">0</span>];</span><br><span class="line">b[<span class="number">2</span>] = a[<span class="number">2</span>] - a[<span class="number">1</span>];</span><br><span class="line">b[<span class="number">3</span>] =a [<span class="number">3</span>] - a[<span class="number">2</span>];</span><br><span class="line">........</span><br><span class="line">b[n] = a[n] - a[n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><p><strong>图示:</strong><br><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203101253916.png" alt="&lt;img src=&quot;https://img-blog.csdnimg.cn/20201215214337143.png&quot;   width=&quot;80%&quot;&gt;"></p><p>我们只要有<code>b</code>数组，通过前缀和运算，就可以在<code>O(n)</code> 的时间内得到<code>a</code>数组 。</p><p><strong>知道了差分数组有什么用呢？</strong> 别着急，慢慢往下看。</p><p><strong>话说有这么一个问题：</strong></p><p>给定区间<code>[l ,r ]</code>，让我们把<code>a</code>数组中的<code>[ l, r]</code>区间中的每一个数都加上<code>c</code>,即 <code>a[l] + c , a[l+1] + c , a[l+2] + c ,,,,,, a[r] + c</code>;</p><p>暴力做法是<code>for</code>循环<code>l</code>到<code>r</code>区间，时间复杂度<code>O(n)</code>，如果我们需要对原数组执行<code>m</code>次这样的操作，时间复杂度就会变成<code>O(n*m)</code>。有没有更高效的做法吗? <strong>考虑差分做法</strong>。</p><p><strong>始终要记得，a数组是b数组的前缀和数组</strong>，比如对<code>b</code>数组的<code>b[i]</code>的修改，会影响到<code>a</code>数组中从<code>a[i]</code>及往后的每一个数。</p><p>首先让差分<code>b</code>数组中的 <code>b[l] + c</code> ,<code>a</code>数组变成 <code>a[l] + c ,a[l+1] + c,,,,,, a[n] + c</code>;</p><p>然后我们打个补丁，<code>b[r+1] - c</code>, <code>a</code>数组变成 <code>a[r+1] - c,a[r+2] - c,,,,,,,a[n] - c</code>;</p><p><strong>为啥还要打个补丁</strong>？</p><p><strong>我们画个图理解一下这个公式的由来:</strong><br><img src="https://img-blog.csdnimg.cn/20201215163431253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyOTI4NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>b[l] + c</code>，效果使得<code>a</code>数组中 <code>a[l]</code>及以后的数都加上了<code>c</code>(红色部分)，但我们只要求<code>l</code>到<code>r</code>区间加上<code>c</code>, 因此还需要执行 <code>b[r+1] - c</code>,让<code>a</code>数组中<code>a[r+1]</code>及往后的区间再减去<code>c</code>(绿色部分)，这样对于<code>a[r]</code> 以后区间的数相当于没有发生改变。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>因此我们得出<strong>一维差分结论</strong>：给<code>a</code>数组中的<code>[ l, r]</code>区间中的每一个数都加上<code>c</code>,只需对差分数组<code>b</code>做 <code>b[l] + = c</code>, <code>b[r+1] - = c</code>。时间复杂度为<code>O(1)</code>, 大大提高了效率。</p><p><img src="https://img-blog.csdnimg.cn/20201217172005485.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差分公式，最后求前缀和</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">b[l] += c;</span><br><span class="line">b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p><a href="https://www.acwing.com/problem/content/800/">二维差分</a></p><p>跟一维差分思想差不多</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203102019216.jpg"></p><p>关系如上图，求其中子矩阵的二维差分矩阵</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204072236908.png" alt="image-20220407223606425"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s[i][j]为b[i][j]的前缀和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[x1][y1]+=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制中一个数"><a href="#二进制中一个数" class="headerlink" title="二进制中一个数"></a>二进制中一个数</h2><p><strong>运算</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//位运算，以二进制进行运算</span></span><br><span class="line">    <span class="comment">//异或运算,^相同为0，不同为1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">6</span>^<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// cont&lt;&lt;6^3&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//用cout输出上面会出错，用变量代替的方式输出</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">6</span>^<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//下面两种方式语法类似</span></span><br><span class="line">    <span class="comment">//与运算；同时为1才为1</span></span><br><span class="line">    a=<span class="number">6</span>&amp;<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//非运算，遇0为1，遇1为0</span></span><br><span class="line">    a=<span class="number">6</span>|<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>n的二进制表示中第k位是几</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203111228807.png" alt="image-20220311122814447"></p><ol><li>先把第K的右移到最后一位    n&gt;&gt;k，第k位关系如上图（4不是）</li><li>x&amp;1：判断最后一位是否为1.</li><li>综合：n &gt;&gt; k &amp; 1</li></ol><p>lowbit()方式原理</p><ul><li>对x的位运算操作</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203111259056.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line"><span class="comment">//返回n的最后一位1(及后面的0)：lowbit(n) = n &amp; -n</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;   </span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><ul><li>快速排序和归并排序都算双指针算法</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203131248684.png" alt="image-20220313124846390"></p><ul><li>将右边核心思想复杂度为O(n^2),左边为O(n)</li><li>先想暴力，找单调性，再根据模板优化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><ul><li>主要是对应的坐标和数值，存储好坐标和数值；题目后面要用数值和坐标，所以将这些稀疏的数值重新映射到数组下标从0到n的数组内，找到数值</li><li>因为数组存储时，坐标是从小到大存储，不能快速找到存储，所以用piar存储坐标和值，然后寻找就行</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203161953374.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p><a href="https://www.acwing.com/problem/content/805/">区间合并</a></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203171301673.jpg"></p><p><strong>分析</strong></p><ul><li>先按左端点排序</li><li>比较参考区间a和区间b有三种情况：包含，相交，分离</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());<span class="comment">//对区间的端点排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;<span class="comment">//设置左右初值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)<span class="comment">//维护区间(st,ed)严格在枚举区间右边(seg);即无交集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//判断不为开始初始值,添加信息</span></span><br><span class="line">            st = seg.first, ed = seg.second;<span class="comment">//更新维护区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);<span class="comment">//有交集,更新右端点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//防止空区间,同时添加最后一段区间</span></span><br><span class="line">    segs = res;<span class="comment">//更新segs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>一般ACM或者笔试题的时间限制是1秒或2秒。<br>在这种情况下，C++代码中的操作次数控制在 $10^7$∼$10^8$ 为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><blockquote><ol><li><p>n≤30, 指数级别, dfs+剪枝，状态压缩dp</p></li><li><p>n≤100 &#x3D;&gt; O($n^3$)，floyd，dp，高斯消元</p></li><li><p>n≤1000 &#x3D;&gt; O($n^2$)，O($n^3logn$)，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</p></li><li><p>n≤10000 &#x3D;&gt; O($n*\sqrt{n}$)，块状链表、分块、莫队</p></li><li><p>n≤100000&gt; O($nlogn$) &#x3D;&gt; 各种sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</p></li><li><p>n≤1000000&#x3D;&gt; O($n^2$), 以及常数较小的 O($nlogn$) 算法 &#x3D;&gt; 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 O(nlogn)O(nlogn) 的做法：sort、树状数组、heap、dijkstra、spfa</p></li><li><p>n≤10000000&#x3D;&gt; O($n$)，双指针扫描、kmp、AC自动机、线性筛素数</p></li><li><p>n≤$10^9$ &#x3D;&gt; O($\sqrt{n}$)，判断质数</p></li><li><p>n≤$10^{18}$&#x3D;&gt; O($nlogn$) ，最大公约数，快速幂，数位DP</p></li><li><p>n≤$10^{1000}$ &#x3D;&gt; O($(logn)^2$)，高精度加减乘除</p></li><li><p>n≤$10^{100000}$ &#x3D;&gt; O($logk×loglogk$)，k表示位数，高精度加减、FFT&#x2F;NTT</p></li></ol></blockquote><h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><p>用数组模拟链表</p><ul><li>用new生成链表，容易超时，所以用数组模拟链表</li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203211255359.jpg"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203221230609.png" alt="image-20220322123006356"></p><ul><li>邻接表（n个链表）：常用来存储图和树</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，</span></span><br><span class="line"><span class="comment">//e[]存储节点的值</span></span><br><span class="line"><span class="comment">//ne[]存储节点的next指针</span></span><br><span class="line"><span class="comment">//idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//空节点</span></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_head</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a;<span class="comment">//新结点赋值</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//该节点存储头结点指向的下标</span></span><br><span class="line">    head = idx ;<span class="comment">//头结点指向idx所对应的下标</span></span><br><span class="line">    idx++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx]=a;<span class="comment">//新结点赋值</span></span><br><span class="line">    ne[idx]=ne[k];<span class="comment">//该新节点指向下标是k的下一个结点下标</span></span><br><span class="line">    ne[k]=idx;<span class="comment">//下标是k的结点指向当前新节点</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];<span class="comment">//就是下标是k的点指向k后面点指向的坐标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/828/">单链表</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], head, idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对链表进行初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//最开始的时候，链表的头节点要指向-1，</span></span><br><span class="line">    <span class="comment">//为的就是在后面进行不断操作后仍然可以知道链表是在什么时候结束</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    插句题外话，我个人认为head其实就是一个指针，是一个特殊的指针罢了。</span></span><br><span class="line"><span class="comment">    刚开始的时候它负责指向空结点，在链表里有元素的时候，它变成了一个指向第一个元素的指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当它在初始化的时候指向-1，来表示链表离没有内容。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//idx在我看来扮演两个角色，第一个是在一开始的时候，作为链表的下标，让我们好找</span></span><br><span class="line">    <span class="comment">//第二在链表进行各种插入，删除等操作的时候，作为一个临时的辅助性的所要操作的元素的下</span></span><br><span class="line">    <span class="comment">//标来帮助操作。并且是在每一次插入操作的时候，给插入元素一个下标，给他一个窝，感动！</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    再次插句话，虽然我们在进行各种操作的时候，元素所在的下标看上去很乱，但是当我们访问</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插入到头节点上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">int_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//和链表中间插入的区别就在于它有head头节点</span></span><br><span class="line">    e[idx] = x;<span class="comment">//第一步，先将值放进去</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//head作为一个指针指向空节点，现在ne[idx] = head;做这把交椅的人换了</span></span><br><span class="line">    <span class="comment">//先在只是做到了第一步，将元素x的指针指向了head原本指向的</span></span><br><span class="line">    head = idx;<span class="comment">//head现在表示指向第一个元素了，它不在是空指针了。（不指向空气了）</span></span><br><span class="line">    idx ++;<span class="comment">//指针向下移一位，为下一次插入元素做准备。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入到下标为k的点的后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//先将元素插进去</span></span><br><span class="line">    ne[idx] = ne[k];<span class="comment">//让元素x配套的指针，指向它要占位的元素的下一个位置</span></span><br><span class="line">    ne[k] = idx;<span class="comment">//让原来元素的指针指向自己</span></span><br><span class="line">    idx ++;<span class="comment">//将idx向后挪</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点个删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];<span class="comment">//让k的指针指向，k下一个人的下一个人，那中间的那位就被挤掉了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">char</span> s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">int_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) head = ne[head];<span class="comment">//删除头节点，相当新的头结点指向原来头结点指向的下一个结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);<span class="comment">//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k, x;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);<span class="comment">//同样的，第k个数，和下标不同，所以要减1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><ul><li>常用来优化某些问题</li></ul><p>用数组模拟</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203241225928.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203241225653.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203241225664.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="comment">//l[]表示前指针，r[]表示右端点</span></span><br><span class="line"><span class="comment">//数组下标不代表数组顺序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 规定 0号是最左边的哨兵， 1号是最右边的哨兵，可用的idx从2开始，且n[i]在i=1和0内容，</span></span><br><span class="line">    <span class="comment">//0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//r表示</span></span><br><span class="line">    l[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    idx=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//相当第一个元素是从下标2开始</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下标是k的点的右边,插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx]=x;<span class="comment">//赋值，idx为当前，k为前面的点</span></span><br><span class="line">    r[idx]=r[k];<span class="comment">//idx的后指针指向k的后指针</span></span><br><span class="line">    l[idx]=k;<span class="comment">//idx前指针指向k</span></span><br><span class="line">    l[r[k]]=idx;<span class="comment">//k的后指针的前指针指向idx</span></span><br><span class="line">    r[k]=idx;<span class="comment">//k的后指针指向idx</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除下标是k的点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];<span class="comment">//k的前指针的后指针指向k的后指针</span></span><br><span class="line">    l[r[k]]=l[k];<span class="comment">//k的后指针的前指针指向k的前指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/829/">双链表实现</a></p><blockquote><p>0为第一个插入的数字，数组下标为2，所以传入插入函数为k+1</p><p>删除也是同样的道理</p></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204211645273.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>, r[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//* 初始化 第一个点的右边是 1   第二个点的左边是 0</span></span><br><span class="line">    idx = <span class="number">2</span>;<span class="comment">//! idx 此时已经用掉两个点了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//* 在第 K 个点右边插入一个 X </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k]; <span class="comment">//todo 这边的 k 不加 1 ， 输入的时候 k+1 就好</span></span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;<span class="comment">//! 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*删除第 k个 点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&quot;R&quot;</span>)<span class="comment">//最右边插入元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>], x); <span class="comment">//!   0和 1 只是代表 头和尾  所以   最右边插入 只要在  指向 1的 那个结点的右边插入就可以了</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最左边插入元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;L&quot;</span>)<span class="comment">//! 同理  最左边插入就是 在指向 0的数的左边插入就可以了   也就是可以直接在 0的 有右边插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k + <span class="number">1</span>, x);<span class="comment">//idx从2开始;k表示第k个插入的数,k=1时，在该点右端插入一个数，但这个结点对应的下标为2（k+1）,</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依次输出，从r[0]开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204212054383.gif"></p><ul><li>特点：<strong>先进后出</strong>，弹出栈顶元素或者压入栈顶元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶,初始化</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;<span class="comment">//++tt先加一后赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)<span class="comment">//tt&gt;0不为空</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> skt[N],tt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;push&quot;</span>)&#123;  <span class="comment">//压入栈顶元素</span></span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            skt[++tt]=x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;pop&quot;</span>)&#123;   <span class="comment">//删除栈顶元素</span></span><br><span class="line">            tt--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tt&gt;<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;skt[tt]&lt;&lt;endl;  <span class="comment">//输出栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><strong>应用</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203301237717.jpg"></p><ul><li>用来返回x的左边最近且比x小(不存在返回-1)</li><li>就是将判断大小，如果栈顶元素比当先的数x,则弹出栈元素；直到x比栈顶元素大，并且将x压入栈顶元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;<span class="comment">//插入数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回x左边最近且比x小的数</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203301240124.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;<span class="comment">//如果栈顶元素大于当前待入栈元素，则出栈</span></span><br><span class="line">        <span class="keyword">if</span>(tt) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);<span class="comment">//栈顶元素就是左侧第一个比它小的元素。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);<span class="comment">//如果栈空，则没有比该元素小的值。</span></span><br><span class="line">        stk[ ++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li>特点：<strong>先进先出</strong></li><li>队头为删除的一端；队尾为插入的一端</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202203291250162.jpg"></p><h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)<span class="comment">//tt&gt;=hh不为空</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tt为队尾,hh为队头</span></span><br><span class="line">    <span class="type">int</span> q[N],tt=<span class="number">-1</span>,hh=<span class="number">0</span>,m;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;push&quot;</span>)&#123;  <span class="comment">//队列尾部插入值</span></span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q[++tt]=x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;pop&quot;</span>)&#123;   <span class="comment">//弹出栈顶元素</span></span><br><span class="line">            hh++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            cout&lt;&lt;((tt&gt;=hh) ? <span class="string">&quot;NO&quot;</span>:<span class="string">&quot;YES&quot;</span>)&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             cout&lt;&lt;q[hh]&lt;&lt;endl;<span class="comment">//输出队头元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;<span class="comment">//判断指针是否超出数组范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><ul><li>将队列中的没有用的元素删掉——具有单调性</li><li>可以用O(1)的时间从队头&#x2F;队尾取出</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p><a href="https://www.acwing.com/problem/content/description/156/">滑动窗口</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//q[N]存储的值是a[]的下标</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="comment">//输出最小值,队头元素最小，队尾最大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;                  <span class="comment">// 判断窗口长度是否大于当前队头的位置，大于，则hh加1，恢复大原来窗口大小</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) -- tt;    <span class="comment">// 第一个条件队列不为空，则t--;第二个条件判断队尾不单调（当前数值x与之前队尾对应的数值y对比，当前的小，则将小的数值作为新的队尾,t--），则tt减1</span></span><br><span class="line">        q[++ tt] = i;                                  <span class="comment">// 下标加到队尾</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);       <span class="comment">// 输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    hh = <span class="number">0</span>; tt = <span class="number">-1</span>; <span class="comment">// 重置！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出最大值，队头元素最大，队尾最小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - k + <span class="number">1</span> &gt; q[hh]) ++ hh;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) -- tt;</span><br><span class="line">        q[++ tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="KMP匹配算法"><a href="#KMP匹配算法" class="headerlink" title="KMP匹配算法"></a>KMP匹配算法</h2><p>KMP<a href="https://www.acwing.com/problem/content/discussion/content/1604/">匹配算法</a></p><ul><li>应用环境：有一个文本串S，和一个模式串P，现在要判断S中是否有和P匹配的子串，并查找P在S中的位置，怎么解决呢？</li></ul><p><strong>暴力算法思路</strong></p><blockquote><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</p><p>如果当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），则i++，j++，继续匹配下一个字符；如果匹配失败（即S[i]! &#x3D; P[j]），令i &#x3D; i - j + 1，j &#x3D; 0，即每次匹配失败时，i 回溯到上次开始匹配的下一个位置，j 被置为0。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s[N],p[M];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=p[j])&#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><ul><li>next[i]&#x3D;j:以i为终点后缀和从1开始的前缀相等，且后缀长度最长；</li><li>最大前缀数和后缀数要小于字符串本身长度</li></ul><p>P&#x3D;“ababf” 的最长公共前后缀：</p><ul><li>P[0] 前面没有字符串，所以最长公共前后缀长度为 0。</li><li>P[1] 前面的字符串为：a，a没有前后缀(前后缀长度要小于字符串长度)。最长公共前后缀长度为 0。</li><li>P[2] 前面的字符串为：ab，它的前缀为：a，后缀为b。前缀不等于后缀，所以没有公共前后缀，最长公共前后缀长度为 0。</li><li>P[3] 前面的字符串为：aba，aba 的前缀有：a，ab， 后缀有：a，ba。因为 ab 不等于 ba，所以最长公共前后缀为 a，最长公共前后缀长度为 1。</li><li>P[4] 前面的字符串为：abab，abab 的前缀有：a，ab，aba，后缀有：a，ab, bab。最长公共前后缀为 ab，长度为 2。</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204271207515.png"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204011255031.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p是模式串（子串）</span></span><br><span class="line">p[<span class="number">1</span>,j]=p[i-j+<span class="number">1</span>,i]<span class="comment">//长度相等</span></span><br></pre></td></tr></table></figure><p> <strong>KMP主要分两步：求next数组、匹配字符串。</strong></p><h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><ul><li>就是求P数组自身的最长前缀</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204251333176.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//j大于0才有意义;当p[i] != p[j + 1]说明不匹配，需要重新</span></span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//将上一个位置的值赋给当前位置</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//当前元素匹配，j++</span></span><br><span class="line">        ne[i] = j;<span class="comment">//记录当前数组下标为i的前缀数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204280008641.gif"></p><h3 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204251328676.png"></p><ul><li>当匹配过程到上图所示时，</li><li><code>s[a,b] = p[1,j] &amp;&amp; s[i] != p[j+1]</code> 此时要移动p串（不是移动1格，而是直接移动到下次能匹配的位置）</li><li>其中1串为<code>[1, next[ j ]]</code>，3串为<code>[j-next[j]+1,j]</code>。由匹配可知 1串等于3串，3串等于2串。所以<strong>直接移动p串使1到3的位置</strong>即可。这个操作可由**j &#x3D; next[ j ]**直接完成。 如此往复下去，当 j &#x3D;&#x3D; m时匹配成功。</li><li>不满足时相等时，相当于移动最长公共前后缀的长度，保证了此时最长前缀是一样的。</li></ul><h4 id="动画-1"><a href="#动画-1" class="headerlink" title="动画"></a>动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204281710562.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//相当向后移动字符串</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//当最后一个满足是j++就可以与n相等</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="comment">//ne[]为next数组</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span></span><br><span class="line">    <span class="comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//当前元素匹配，j移向p串下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功，进行相关操作</span></span><br><span class="line">        j = next[j];  <span class="comment">//继续匹配下一个子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="Trie字符串统计"><a href="#Trie字符串统计" class="headerlink" title="Trie字符串统计"></a>Trie字符串统计</h3><p><strong>Trie树</strong>：又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构</p><p><strong>结构</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205021822917.png"></p><blockquote><p>上述字符串中，对于ab字符串的个数为0</p><p>返回的字符串个数是指的插入字符串的个数</p></blockquote><p><strong>数组模拟Trie树</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205021823550.png"></p><p><strong>实际走向</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071524027.jpeg" alt="绘图2.jpg"></p><p><strong>插入</strong></p><ul><li>结点序号代表的存储位置，字母不存在就要开辟新结点，用来存储该字母</li><li>son：p可以理解为当前结点的父节点，u就是该结点存储的字符信息，两个一起确定结点的具体位置；存储的信息相当于<strong>下一字符的父节点idx</strong></li><li>在cnt[p]：p含义就是该字符的结点序号信息；存储的信息就是该节点出现的次数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">//类似指针，指向当前节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)<span class="comment">//字符串以&#x27;/n&#x27;结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">//将字母转化为数字</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        <span class="comment">//该节点不存在，创建节点,其值为下一个节点位置</span></span><br><span class="line">        p = son[p][u];  <span class="comment">//使“p指针”指向下一个节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;  <span class="comment">//结束时的标记，也是记录以此节点结束的字符串个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><ul><li>通过一直查下一个字符的父节点，直到遍历到最后一个字符</li><li>最后返回结点存储的次数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//该节点不存在，即该字符串不存在</span></span><br><span class="line">        p = son[p][u]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];  <span class="comment">//返回字符串出现的次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完整</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Trie树快速存储字符集合和快速查询字符集合</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">//son[][]存储子节点的位置，分支最多26条；</span></span><br><span class="line"><span class="comment">//cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）</span></span><br><span class="line"><span class="comment">//idx表示当前要插入的节点是第几个,每创建一个节点值+1</span></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">//类似指针，指向当前节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">//将字母转化为数字</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;   <span class="comment">//该节点不存在，创建节点</span></span><br><span class="line">        p = son[p][u];  <span class="comment">//使“p指针”指向下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;  <span class="comment">//结束时的标记，也是记录以此节点结束的字符串个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//该节点不存在，即该字符串不存在</span></span><br><span class="line">        p = son[p][u]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];  <span class="comment">//返回字符串出现的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);<span class="comment">//*op为首地址</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最大异或树"><a href="#最大异或树" class="headerlink" title="最大异或树"></a>最大异或树</h3><p><strong>异或</strong>：a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p><ul><li>相同为0，不同为1</li></ul><p>最大异或对</p><p>例子</p><blockquote><p>三个数1，2，3,三种情况；他们的二进制数进行比较</p><p>1^2&#x3D;3    1^3&#x3D;2   2^3&#x3D;1</p><p>计算：1^3&#x3D;2</p><p>0  1</p><p>1  1</p><p>——</p><p>1   0       所以返回值为2</p></blockquote><p>暴力</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">res=<span class="built_in">max</span>(res,a[i]^a[j]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071534347.jpg"></p><p><strong>思路</strong></p><ul><li>给定一个值，对应的进制数，与另一个数运算时；</li><li>从<strong>最高位</strong>开始看，只要保证最开始前面高位运算的<strong>结果为1</strong>，最后就能保证返回最大值</li><li>可以用trie树来存储所有的数字对应的二进制数(0或1)，一个数字（有32位，最高位为符号位），int 最高位是第31位（符号位），所以从考虑30~0位</li><li>查询返回值：通过在trie树判断，找与该位不同的数，使返回的值最大</li></ul><p>图形例子</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071556516.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,  M=<span class="number">31</span>*N;</span><br><span class="line"><span class="comment">//M代表一个数字串二进制可以到多长</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开始时,未初始化的s对应值都为0</span></span><br><span class="line">        <span class="type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];<span class="comment">//取X的第i位的二进制数是什么  x&gt;&gt;k&amp;1(前面的模板)，将地址赋给s</span></span><br><span class="line">        <span class="keyword">if</span> (!s) s = ++ idx;<span class="comment">//如果插入中发现没有该子节点,开出这条路,地址对应的son[p][u]不为0</span></span><br><span class="line">        p = s;<span class="comment">//指针指向下一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最高位开始</span></span><br><span class="line">        <span class="type">int</span> s = x &gt;&gt; i &amp; <span class="number">1</span>;<span class="comment">//&gt;&gt;：向右移动</span></span><br><span class="line">        <span class="keyword">if</span> (son[p][!s])   <span class="comment">//如果当前层有对应的不相同的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//p指针就指到不同数的地址</span></span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;<span class="comment">//记录当前的最大值</span></span><br><span class="line">            p = son[p][!s];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> p = son[p][s]; <span class="comment">//当前层取相同的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res = <span class="built_in">max</span>(res, <span class="built_in">search</span>(a[i]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res += 1 &lt;&lt; i</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071705415.jpg"></p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集维护额外信息</p><ol><li>将两个集合合并</li><li>询问两个集合是否在同一个集合中</li></ol><h2 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h2><p><a href="https://www.acwing.com/problem/content/838/">合并集合</a></p><p><strong>基本思想</strong>：每个集合一棵树表示，树根的编号就是整个集合的编号；每个结点存储它的父节点,用p[x]表示x的结点</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205091315956.png" alt="image-20220509131556619"></p><ul><li>路径压缩：首先形成一个树，当执行完find()后，该树的所有结点都<strong>指向根结点</strong></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205091310344.png" alt="image-20220509131043086"></p><p>递归含义</p><blockquote><p>递归的含义就相当于你问你爸爸你的祖先是谁，你爸爸也不知道，爸爸就去问爷爷，然后你的爷爷也不知道，爷爷就去问你的太爷爷，你的太爷爷年纪太大了，啥也不记得，就去问你的祖先</p><p>这个时候注意，你的祖先是知道自己是谁的，所以x &#x3D;&#x3D;p[x]</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//返回x的祖宗节点+路径规划</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) &#123;</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> p[x];<span class="comment">//返回祖宗结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) p[i]=i;  <span class="comment">//初始化根结点</span></span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(*op==<span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//集合合并操作</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="连通块中的数量"><a href="#连通块中的数量" class="headerlink" title="连通块中的数量"></a>连通块中的数量</h2><p><a href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></p><ul><li>前面两个操作是跟合并操作一致的</li><li>第三个操作是记录一个集合中的通块的数量<ul><li>通过记录集合树的根结点来记录在一个集合中的通块数量</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N],cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//返回x的祖宗节点+路径规划</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) &#123;</span><br><span class="line">        p[x]=<span class="built_in">find</span>(p[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> p[x];<span class="comment">//返回祖宗结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">p[i]=i;</span><br><span class="line">cnt[i]=<span class="number">1</span>;    <span class="comment">//每个集合初始个数为1</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">string op;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">&quot;C&quot;</span>) </span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a=<span class="built_in">find</span>(a);</span><br><span class="line">b=<span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(a!=b)&#123;    <span class="comment">//如果不在同一个集合中</span></span><br><span class="line">p[a]=b;   <span class="comment">//合并到b集合中</span></span><br><span class="line">cnt[b]+=cnt[a];    <span class="comment">//记录b集合通快的个数</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;Q1&quot;</span>)&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;cnt[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h2><p><a href="https://www.acwing.com/problem/content/242/">食物链</a></p><p><strong>核心思想</strong></p><ol><li>首先判断真话1X和Y是同类<ul><li>在同一个集合时，<strong>不满足</strong><code>d[x] - d[y]) % 3 ==0</code>说明是假话</li><li>在不同集合，不能证明两个不是同类，所以说他们是同类。将一个集合合并到另一个集合<code>p[px] = py</code>,px对应的集合合并到py。再记录px结点到py结点（根结点）的距离</li></ul></li><li>判断真话 x捕食y<ul><li>在同一个集合中时，不满足<code>d[x] - d[y] - 1) % 3 ==0</code>说明时假话</li><li>在不同集合中，将一个集合合并到另外一个集合中。同时记录px到py结点距离</li></ul></li></ol><p><strong>三个物种关系</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151636872.png"></p><p>2.集合合并</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151658138.png"></p><p><strong>被吃关系合并</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151700887.png"></p><p><strong>d[i]含义</strong></p><ol><li>d[i]的正确理解，应是第 i 个节点到其父节点距离，而不是像有些同学所讲的，到根节点的距离！！这点大家一定要搞清楚，之所以有这样的误会，是因为find()函数进行了路径压缩，当查询某个节点 i 时，如果 <strong>i 的父节点不为根节点的话，就会进行递归调用</strong>，将 i 节点沿途路径上所有节点均指向父节点，此时的 <strong>d[i] 存放</strong>的是 i 到父节点，也就是<strong>根节点的距离。</strong></li><li>d[x]始终代表到父节点的距离，只不过在find之后x的父节点直接变成了祖宗，所以逻辑上成了到祖宗的距离</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205151309395.jpg"></p><p><strong>find()函数</strong></p><ul><li>.p[x]至根节点之间的节点全部进行路径压缩</li><li>p[x]至根节点之间的节点k，其d[k]已经变成节点k到根节点的距离，不再是只到父节点的距离；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//压缩路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);<span class="comment">//循环调用返回根节点</span></span><br><span class="line">        d[x] += d[p[x]];<span class="comment">// x到根节点的距离 = x到父节点的距离 + 父节点到父节点的距离</span></span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>距离关系</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205152021445.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当动物x和动物y的距离%3等于1时,说明x捕食y</span></span><br><span class="line"><span class="comment">//当动物x和动物y的距离%3等于2时,说明y捕食x 也可以说y是x的天敌</span></span><br><span class="line"><span class="comment">//当动物x和动物y的距离%3等于0时,说明x和y是同类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//压缩路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; n || y &gt; n) res ++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x), py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="number">1</span>)  <span class="comment">//真话 x和y是同类</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span> !=<span class="number">0</span>) res ++ ;<span class="comment">//在同一个集合中,不是同类时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)<span class="comment">//不在同一个集合则不能证明不是同类则默认该说法正确,将其合并</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;<span class="comment">//合并到一个集合</span></span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                    <span class="comment">/*因为合并x和y所在集合多出了一段长度</span></span><br><span class="line"><span class="comment">                    这块长度是find(x)到find(y)的距离</span></span><br><span class="line"><span class="comment">                    所以求多出来的这块部分的长度</span></span><br><span class="line"><span class="comment">                    当x和y是同类时,有这样的特性</span></span><br><span class="line"><span class="comment">                    (d[x]+d[find[x]]-d[y])%3==0</span></span><br><span class="line"><span class="comment">                    这里的d[x]是还未合并时,x到find[x]的距离</span></span><br><span class="line"><span class="comment">                    ∴d[find[x]]=d[y]-d[x]</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//真话 x捕食y</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                  当x和y在一个集合中时,由题目可知,x捕食y</span></span><br><span class="line"><span class="comment">                  此时有 </span></span><br><span class="line"><span class="comment">                  x到根节点的距离-y到根节点的距离=1+3k k为任意</span></span><br><span class="line"><span class="comment">                  实数</span></span><br><span class="line"><span class="comment">                  ∴当(len[x]-len[y]-1-3k)%3 ==0 时可确认</span></span><br><span class="line"><span class="comment">                  x捕食y</span></span><br><span class="line"><span class="comment">                  反之当(len[x]-len[y]-1-3k)%3 !=0 </span></span><br><span class="line"><span class="comment">                  x不可能捕食y</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span> !=<span class="number">0</span>) res ++ ;<span class="comment">//在同一个集合,不是捕食关系时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (px != py)<span class="comment">//不在同一个集合时，将之合并</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    设find(x)到find(y)的距离为d([find(x)])</span></span><br><span class="line"><span class="comment">                    此时有d[x]+d([find(x)])-d[y]=3k+1</span></span><br><span class="line"><span class="comment">                    ∴d[find(x)]=-d[x]+d[y]+1+3k</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><a href="https://blog.csdn.net/u010452388/article/details/81283998?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165268377916782248514520%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165268377916782248514520&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81283998-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">堆</a></p><p><strong>二叉树：</strong>二叉树(Binary Tree)是每个<strong>结点</strong>最多有<strong>两个子树</strong>的有序树</p><p>满二叉树：一棵深度为k且有2^k^ -1个结点的二叉树称为满二叉树。</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161616387.png" alt="image-20220516161637244"></p><p>完全二叉树：除了最后一层结点，上面所有结点都是非空的；最后一层结点是从左到右依次排列的</p><p><strong>堆：</strong>是一个<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a>；堆的结构可以分为<a href="https://so.csdn.net/so/search?q=%E5%A4%A7%E6%A0%B9%E5%A0%86&spm=1001.2101.3001.7020">大根堆</a>和小根堆</p><p><strong>小根堆与大根堆</strong>：每个结点的<strong>值</strong>都<strong>大于其左孩子和右孩子</strong>结点的值，称之为大根堆；每个结点的<strong>值</strong>都小于其左孩子和右孩子结点<strong>的值，称之为</strong>小根堆。</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161623312.png"></p><p><strong>存储形式</strong>：映射成一维数组存储</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161628374.png"></p><p>还有一个基本概念：查找数组中某个数的父结点和左右孩子结点，比如已知索引为<strong>i</strong>的数，那么</p><p>注意根节点下标从0开始</p><p>1.父结点索引：$(i-1)&#x2F;2$（这里计算机中的除以2，省略掉小数）</p><p>2.左孩子索引：$2i+1$</p><p>3.右孩子索引：$2i+2$</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><a href="https://www.acwing.com/problem/content/840/">堆排序</a></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205161645364.png" alt="image-20220516164534251"></p><p>注意根结点是从下标为1开始</p><p><strong>两个操作</strong>————<strong>针对小根堆</strong></p><ul><li><p>**down(x)**：往下调整，就是从某个结点一直往下对比操作，三个结点对比，小的在父节点，大的在子节点。直到交换到不能交换为止（大的值往下沉）</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208041257965.png" alt="image-20220804125712199"></p></li><li><p><strong>up(x)</strong>: 往上调整，就是从某个结点一直上对比操作，三个结点对比，小的在父节点，大的在子节点。（小的值往上压）</p></li></ul><p><strong>手写一个堆操作</strong></p><p>size:相当于heap最后一个元素下标，size–:减少一个元素</p><ol><li>插入一个数 ：<code>heap[++size]=x;up(size);</code>相当于在末尾插入一个元素</li><li>求集合中的最小值 ： <code>heap[1]</code></li><li>删除最小值： <code>heap[1]=heap[size] ; size--; down(1)</code></li><li>删除任意一个元素：  <code>heap[k]=heap[size];size--;down(k);up(k)</code>：相当最后一个元素操作</li><li>修改任意一个元素 ： <code>heap[k]=x;down(k);up(k)</code></li></ol><p><strong>时间复杂度</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205171512399.jpg"></p><p><strong>代码</strong></p><p>代码模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="comment">//针对得小根堆</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>根结点从1开始</strong>；下标为x的左儿子下标为<strong>2x</strong>,右儿子为<strong>2x+1</strong></p><p>建立得小根堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;<span class="comment">//t存储三个结点中存在的最小的结点的下标，初始化为当前结点u</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">// 左子节点存在并且小于当前结点，更新t的下标</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//判断右儿子是否较小</span></span><br><span class="line">    <span class="keyword">if</span> (u != t) <span class="comment">//交换位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//交换数值后，t这个结点存储原本u的值，u存储存储t的值（三个数中的最小值）。u不用调整了，但t情况不明，可能需要调整。直到它比左右子节点都小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    cnt = n;<span class="comment">//cnt为数组元素个数</span></span><br><span class="line">    <span class="comment">//把堆初始化成小根堆，从二叉树的倒数第二行开始，把数字大的下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);<span class="comment">//输出堆顶最小值</span></span><br><span class="line">        <span class="comment">//删除最小值</span></span><br><span class="line">        h[<span class="number">1</span>] = h[cnt -- ];<span class="comment">// 将堆最后一个数放到堆顶，cnt--使得在逻辑上删除这个数</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h2><p><strong>实现上述5个操作</strong></p><p>size:相当于heap最后一个元素下标，size–:减少一个元素</p><ol><li>插入一个数 ：<code>heap[++size]=x;up(size);</code>相当于在末尾插入一个元素</li><li>求集合中的最小值 ： <code>heap[1]</code></li><li>删除最小值： <code>heap[1]=heap[size] ; size--; down(1)</code></li><li>删除任意一个元素：  <code>heap[k]=heap[size];size--;down(k);up(k)</code>：相当最后一个元素操作</li><li>修改任意一个元素 ： <code>heap[k]=x;down(k);up(k)</code></li></ol><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><ol><li>题目要对第i个插入的数字进行操作，所以不能直接的用堆排序直接交换，要记录元素x是第几个插入的和在堆的位置。所以要用下面两个数组记录</li><li><strong>查找元素</strong>时需要知道它在当前<strong>堆中的位置</strong>在哪里，才好进行 down 或 up，所以<strong>需要hp数组</strong>（<strong>第几个插入的数字 对应 目前堆里的位置</strong>），但是单纯swap交换数字，不会改变位置指针，所以需要<strong>ph数组来</strong>用作位置指针(目前<strong>堆里的位置 对应 第几个插入的数字</strong>）</li><li>一个堆结点的位置信息：存储数字x，该x是第k个插入，第k个插入对应的位置</li></ol><p><code>hp[]</code> 和<code>ph[]</code>是互逆的俩个指针，创建这俩个指针用于维护k和idx的映射关系，为任意删除和插入操作做铺垫，如果不删和插入除特定的点 就无需创建</p><p>交换前</p><blockquote><p>a，b为在堆中的具体位置</p><p>hp[堆里的位置]&#x3D;第k个插入</p><p>ph[第k个插入]&#x3D;堆里的位置</p><p>hp[a]&#x3D;k          ph[k]&#x3D;a                h[a]&#x3D;4</p><p>hp[b]&#x3D;k+1     ph[k+1]&#x3D;bh[b]&#x3D;3</p></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205171534237.png"></p><p>交换后</p><blockquote><p>hp[a]&#x3D;k+1        ph[k]&#x3D;bh[a]&#x3D;3</p><p>hp[b]&#x3D;k             ph[k+1]&#x3D;a   h[a]&#x3D;4</p></blockquote><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205171534299.png"></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt;</span><br><span class="line"><span class="comment">//cnt记录堆元素个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//交换操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将下标为u的结点往上调整  O(log n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span>&gt;<span class="number">0</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])<span class="comment">//up操作中只需要判断up儿子与根的大小就可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//m记录第几个插入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="comment">//strcmp(),对比字符串,完全相同返回0</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))<span class="comment">//相当对尾结点插入</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            m ++ ;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))<span class="comment">//删除最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))<span class="comment">//删除第k个插入的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);<span class="comment">//相当将第k个结点移到最后一个节点</span></span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//修改第k个结点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>时间复杂度：O(1)——直接查找</p><p>本质：<strong>本质是通过映射来压缩存储空间，<a href="https://editor.csdn.net/md/?articleId=114260724">离散化</a>就是一种特殊的哈希表，它特殊在需要数据有序，然后进行对分映射。我们这里的哈希表更加广义和一般，不需要有序</strong></p><p><strong>存储结构</strong></p><ul><li>开放寻址法：就是判断坑位是否为空，为空就复制，不为空就找下一个<ul><li>简单地讲，也就是说，一间厕所，来了一个顾客就蹲其对应的位置，如果又来一个顾客，把厕所单间门拉开，一看里面有位童鞋正在用劲，那么怎么办？很自然的，拉另一个单间的门，看看有人不，有的话就继续找坑。当然了，一般来说，这个顾客不会按顺序一个一个地拉厕所门，而是会去拉他认为有可能没有被占用的单间的门，这可以通过闻味道，听声音来辨别，这就是寻址查找算法。</li></ul></li><li>拉链法：利用链表处理冲突。输入x，将x进行mod映射为k，然后h[k]作为链表的头指针，然后就是链表头插法操作：e[idx] &#x3D; x, ne[idx] &#x3D; h[k], h[k] &#x3D; idx ++;这样就把<strong>新元素像拉链一样挂在了h数组</strong>的下面了。寻找也是同理先求x的映射k，然后从h[k]开始链表的遍历<ul><li>跟邻接单链表类似</li><li>取的模为x，就在h[x]开一个链表存储数，h[x]相当于头结点</li></ul></li></ul><p><strong>字符串哈希方式</strong></p><p><strong>作用</strong>：将一系列大的数映射到一个范围较小的数组中（离散法是特殊的哈希方式）</p><h2 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title="模拟散列表"></a>模拟散列表</h2><p><strong>哈希表核心</strong></p><ol><li><p>哈希函数：常用取模函数，常用比范围大的最小质数进行取模,减小冲突的概率</p><blockquote><p>构建哈希函数： 除留取余法</p><p>p与操作次数有关,也就是大于操作次数的最小质数</p><p>f(x) &#x3D; x mod p 将x映射到 0到p-1 之间的数。</p><p>其中：<strong>p要取成一个质数</strong>，而且要离2的整次幂尽可能远。</p></blockquote></li><li><p>解决冲突</p><ul><li>拉链法： 数组+单链表</li><li>开放寻址法： 数组大小通常是数据范围两到三倍</li></ul></li></ol><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p><code>const int N = 200003</code>;</p><blockquote><p>开放寻址操作过程中会出现冲突的情况，一般会开成两倍的空间，减少数据的冲突</p><p>如果使用%来计算索引， 把哈希表的长度设计为素数（质数）可以大大减小哈希冲突<br>比如<br>10%8 &#x3D; 2      10%7 &#x3D; 3<br>20%8 &#x3D; 4      20%7 &#x3D; 6<br>30%8 &#x3D; 6      30%7 &#x3D; 2<br>40%8 &#x3D; 0      40%7 &#x3D; 5<br>50%8 &#x3D; 2      50%7 &#x3D; 1<br>60%8 &#x3D; 4      60%7 &#x3D; 4<br>70%8 &#x3D; 6      70%7 &#x3D; 0</p><p>这就是为什么要找第一个比空间大的质数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// N为大于2e5最小质数,</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;<span class="comment">//开发寻找，会出现冲突的情况，一般会开成两倍的空间, 同时去下一个质数;null:这是一个大于10^9的数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="comment">//冲突情况:当前位置不为空，并且不为x</span></span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123; </span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="comment">//末尾，从头开始</span></span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);<span class="comment">//0x3f在数组占位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[<span class="built_in">find</span>(x)] = x;<span class="comment">//找到符合条件位置并插入</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//查询</span></span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;<span class="comment">// 大于1e5的最小质数,用于作为哈希函数</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;<span class="comment">// h[N]为拉链法的数组 e[N]为链表值 ne[N]为链表next值</span></span><br><span class="line"><span class="comment">//单链表插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;<span class="comment">// 哈希函数, +N是避免取模运算出现负数</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    <span class="comment">//头结点插入,头结点有很多个</span></span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//memset函数，将数组的每一个元素初始化为-1</span></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希表"><a href="#字符串哈希表" class="headerlink" title="字符串哈希表"></a>字符串哈希表</h2><p><a href="https://www.acwing.com/solution/content/97009/">字符串前缀哈希法</a></p><p><strong>核心思想</strong></p><ul><li><p>就是把一段字符串映射成一个数字，通过查询数字来判断，数字相等，则字符串等价</p><blockquote><p>注：该方法不存在冲突，因为一一映射不存在冲突</p></blockquote></li><li><p>根据经验，将字符串映射为 P &#x3D; 131&#x2F;13331 进制数字, 且用尽可能大的 <code>unsigned long long</code> 类型来存储变量可以尽可能地减少冲突，这是本问题的核心思想</p></li></ul><p><strong>注意点</strong>：</p><ul><li>由于数字 0 和数字 000 是相等的，所以如果某个字符被映射到了 0，如 <code>′a′→0′a′→0</code>。则 <code>′aaa′→0′aaa′→0</code>, 则 ‘a’ 和 ‘aaa’ 被认为是相等的。</li><li>所以不要将字符映射为 0</li></ul><p><strong>映射方法</strong>：</p><ul><li>注意到不能将字符映射位 0 的前提下，映射方法可以随意定制</li><li>为方便起见，映射方法一般为：字符 →→ 该字符的 ASCII 码</li></ul><p><strong>核心性质</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205182029320.png" alt="image-20220518202914558"></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;<span class="comment">//由于前缀值的值会很大 所以应该将数组中的数据定义为ULL型;如果溢出了相当取模</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">//P为权重</span></span><br><span class="line"><span class="comment">//131为经验值 即P=131或13331时 哈希冲突的可能性最小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"><span class="comment">//h[]存放字符串的前缀值</span></span><br><span class="line"><span class="comment">//p[]存放各个位数的相应权值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 最开始的权值必须赋值为1 否则接下来就会出错</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];<span class="comment">//根据性质 1 挨个计算 h[i]</span></span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;<span class="comment">// 用 p 数组存储 p 的幂, p[i] 表示 p 的 i 次幂</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-STL介绍"><a href="#C-STL介绍" class="headerlink" title="C++ STL介绍"></a>C++ STL介绍</h1><p>[[C++常用库及操作]]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()  返回第一个元素/返回最后一个元素</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()   在vector添加/删除一个元素 </span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()  返回一个当前vector容器中起始元素/末尾元素的迭代器</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"><span class="built_in">begin</span>()与<span class="built_in">front</span>()区别：</span><br><span class="line">    <span class="built_in">begin</span>():返回一个当前vector容器中起始元素的迭代器</span><br><span class="line">    <span class="built_in">front</span>():返回当前vector容器中起始元素的引用</span><br><span class="line">    </span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()   判断是否为空</span><br><span class="line">    <span class="built_in">clear</span>()   将字符串的内容清空，让源字符串成为一个空字符串（长度为<span class="number">0</span>个字符）</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()    判断大小</span><br><span class="line">    <span class="built_in">empty</span>()    判断为空</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acwing基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.搜索与图论</title>
      <link href="/data.github.io/post/33e8919d.html"/>
      <url>/data.github.io/post/33e8919d.html</url>
      
        <content type="html"><![CDATA[<h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>全称：<strong>深度优先搜索算法</strong></p><ol><li>dfs 最重要的是<strong>搜索顺序</strong>。用什么顺序遍历所有方案。</li><li>递归加回溯</li></ol><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>对于全排列问题，以 n &#x3D; 3 为例，可以这样进行搜索</p><p><strong>dfs递归搜索树</strong></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205191543338.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];<span class="comment">//保存序列</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//数字是否被用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[i])&#123;   <span class="comment">//如果数字 i 没有被用过</span></span><br><span class="line">path[u]=i;<span class="comment">//放入空位</span></span><br><span class="line">st[i]=<span class="literal">true</span>;<span class="comment">//修改数字状态</span></span><br><span class="line"><span class="built_in">dfs</span>(u+<span class="number">1</span>);<span class="comment">//填下一个位</span></span><br><span class="line">st[i]=<span class="literal">false</span>;<span class="comment">//回溯，取出i</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>手动模拟</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205191545074.png"></p><h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><p>n<a href="https://www.acwing.com/problem/content/845/">皇后问题</a></p><h3 id="第一种搜索方法"><a href="#第一种搜索方法" class="headerlink" title="第一种搜索方法"></a>第一种搜索方法</h3><ul><li>每一行必定有一个皇后，对行进行深度遍历。</li><li>对于第 r 行的第 i 个位置，判断每个点是否可以放皇后，如果可以，则放皇后，然后处理 r + 1 行。直到 r &#x3D; n，程序指行完毕</li></ul><p><strong>对角线下标问题</strong></p><ol><li>反对角线，<code>y=-x+c,c=x+y,c</code>这里代表截距</li><li>正对角线<code>y=x+c，c=y-x</code>,所以这里的c可能是负的，但作为数组下标，不能是负的，所以我们把正对角线加上一个偏移量，<code>c=y-x+n</code>是没影响的，因为截距最大是n，所以我加了n，也可以加比n大的任何数，x就是下面的h也就是行，y就是下面的l 也就是列</li><li>理解为<code>xoy</code>平面方程<code>y=kx+b</code>方程，截距问题</li></ol><p><strong>时间复杂度</strong>：O(n!)</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205211614109.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];<span class="comment">//存储棋盘</span></span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];<span class="comment">//点对应列和两个斜线是否有皇后，dg为对角线,udg为反对角线</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//u相当行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)<span class="comment">//放满了棋盘，输出棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最开始的循环：就是第一行第一个放皇后，递归输出所有满足条件的方案，回溯，下一步就是在第一行第二列放皇后，递归输出所有方案....</span></span><br><span class="line">    <span class="comment">//u行,i列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])<span class="comment">//不冲突，放皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;<span class="comment">//对应的 列， 斜线 状态改变</span></span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);<span class="comment">//递归下一行</span></span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;<span class="comment">//恢复现场</span></span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化,全是空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);<span class="comment">//从第0行递归</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种搜索方法"><a href="#第二种搜索方法" class="headerlink" title="第二种搜索方法"></a>第二种搜索方法</h3><ol><li>（DFS按每个元素枚举）时间复杂度O(2的n^2^)</li><li>时间复杂度分析：每个位置都有两种情况，总共有 n^2^ 个位置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同搜索顺序 时间复杂度不同  所以搜索顺序很重要！</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N * <span class="number">2</span>], udg[N * <span class="number">2</span>];<span class="comment">// 因为是一个个搜索，所以加了row</span></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// s表示已经放上去的皇后个数,x行，n列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理超出边界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (y == n) y = <span class="number">0</span>, x ++ ;<span class="comment">//枚举下一行</span></span><br><span class="line">    <span class="keyword">if</span> (x == n)<span class="comment">// x==n说明已经枚举完n^2个位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)<span class="comment">// s==n说明成功放上去了n个皇后</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两种情况一直递归</span></span><br><span class="line">    <span class="comment">// 分支1：不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分支2：放皇后</span></span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])</span><br><span class="line">    &#123;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//初始化,全是空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acwing基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.线性表</title>
      <link href="/data.github.io/post/750c418c.html"/>
      <url>/data.github.io/post/750c418c.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>数据结构</strong>：相互之间存在一种或者多种特定关系的数据元素的集合，包含三个方面的内容：逻辑结构、存储结构和数据的运算</p><p><strong>数据</strong>：信息的载体；所有能输入到计算机并被计算机程序识别和处理的集合</p><p><strong>数据元素</strong>：是数据的基本单位，由若干数据项组成</p><p><strong>数据项</strong>：构成数据元素的最小单位</p><p><strong>数据对象</strong>：具有相同性质的数据元素的集合，数据的一个子集</p><p><strong>数据类型</strong></p><ul><li><p>原子类型：其值不可再分的数据类型：int…</p><ul><li>该数据类型是一个值和操作的集合</li></ul></li><li><p>结构类型：其值可以再分解成若干成分的数据类型：结构体..</p></li><li><p>抽象数据类型（ADT）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT抽象数据类型名&#123;</span><br><span class="line">    数据对象：&#123;数据对象的定义&#125;</span><br><span class="line">    数据关系：&#123;数据关系之间定义&#125;</span><br><span class="line">    基本操作：&#123;基本操作的定义&#125;</span><br><span class="line">&#125;ADT抽象数据类型名</span><br></pre></td></tr></table></figure><ul><li>是指一个数学模型以及定义在该模型上的一组操作；</li><li>仅仅取决于它的<strong>一组逻辑特性</strong>，而其在计算机内部如何表示和实现无论内部的结构怎么变化，只要它的数学特性不变，都不会影响外部的使用</li></ul></li><li><p><a href="https://blog.csdn.net/Ricol_xu/article/details/120924436?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1-120924436-blog-103006673.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1-120924436-blog-103006673.pc_relevant_default&utm_relevant_index=2">区别</a>：数据类型既关心逻辑结构又关心物理结构，也就是关注<strong>数据结构如何实现</strong>，而抽象数据类型<strong>只关心抽象特征。</strong></p></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208081304179.jpeg" alt="img"></p><h2 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h2><h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p><strong>概念</strong>：逻辑结构是指数据元素之间的逻辑关系，与数据的存储无关，是独立与计算机的<br>抽象表达方式</p><p><strong>分类</strong></p><ol><li>线性结构：元素都是一对一的关系<ul><li>一般线性表</li><li>受限线性表(栈、队列和串)</li><li>线性表推广（数组、广义表）</li></ul></li><li>非线性结构<ul><li>集合：数据元素除了属于同一个集合，无其他关系</li><li>树形结构：一对多的关系</li><li>图状结构：多对多的关系</li></ul></li></ol><p>栈是逻辑结构、可以链式存储，也可以顺序存储</p><h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p><strong>概念</strong>：存储结构是指数据结构在计算机中的表示（又称映象），也称物理结构</p><p><strong>分类</strong></p><p><strong>顺序存储</strong></p><ul><li>概念：<strong>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</strong>，元素之间的关系有存储单元的邻接关系来体现</li><li>优点：可以实现随机存取，每个元素占用最少的存储时间<ul><li><strong>存储单元</strong>的内容可按需随意取出或存入,且存取的速度与存储单元的位置无关</li></ul></li><li>缺点：只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片<ul><li><strong>外部碎片</strong>：指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</li><li>例子解释：一整块的的存储物理单元，可以放10个，但是你的顺序存储是9个元素，那么你把0~8的位置都占据了，剩下了9号，突然有一个操作，把你的4号位置元素搬掉了，也就是说剩下了4号和9号。好的，现在有一组新的顺序存储来了，大小刚好是2个，虽然你现在这个有2个空闲位置，但是你却没有办法用，因为4号和9号并非顺序挨着的，你只能用新的，那么这就是碎片的缘由</li></ul></li><li>逻辑和存储都相邻</li></ul><p><strong>链式存储</strong></p><ul><li><p>概念：<strong>不要求逻辑上相邻的元素在物理位置上也相邻</strong>，借助指示元素存储地址的指针来表示元素之间的逻辑关系</p></li><li><p>优点：不会出现碎片的现象，能充分利用所有的存储单元</p></li><li><p>缺点：每个元素因存存储指针而占用额外的存储空间，且只能实现顺序存取</p></li><li><p>逻辑相邻，借指针来存储</p></li></ul><p><strong>索引存储</strong></p><ul><li><p>概念：在存储信息的同时，还建立附加的<strong>索引表</strong></p></li><li><p>优点：检索速度快</p></li><li><p>缺点</p><ul><li><p>附加的索引表额外占用存储空间</p></li><li><p>增加和删除数据时也要修改索引表，会花费较多的时间</p></li></ul></li><li><p>建立索引表</p></li></ul><p><strong>散列存储</strong></p><ul><li>概念：根据元素的<strong>关键字</strong>直接计算出该元素<strong>的存储地址</strong>，又称哈希存储</li><li>优点：检索、增加和删除结点的操作很快</li><li>缺点：若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间的开销</li><li>例：循环队列只能顺序存储</li></ul><p><strong>顺序存取和随机存取区别</strong></p><ul><li>随机存取(直接存取)：指的是当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关。</li><li>顺序存取：是一种按记录的逻辑顺序进行读、写操作的存取方法，所需要的时间与该数据所在的物理地址有关。顺序存取表现为：<strong>在存取第N个数据时，必须先访问前（N-1）个数据</strong>。非随机存取也叫顺序存取，不能通过下标访问。</li></ul><p><strong>区分逻辑结构和存储结构</strong></p><ul><li>如果一个数据结构可以用多个存储结构表示，则属于逻辑结构；反之则属于存储结构</li></ul><h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><p><strong>概念</strong>：施加在数据上的运算包括运算的定义和实现。运算定义针对逻辑结构，指出运算的功能。​运算的实现是针对存储结构，指出运算的具体操作步骤</p><ul><li>运算的定义—逻辑结构</li><li>运算的实现—存储结构</li></ul><p>常见逻辑结构：线性表、栈</p><p>常见存储结构：邻接表</p><h2 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h2><p>算法的基本概念</p><p>算法：是对特定问题求解步骤的一种描述，他是指令的有限序列，其中的每条指令表示一个或者多个操作</p><p><strong>重要特性</strong></p><ul><li><p>有穷性：有穷步骤，有穷时间（算法有穷，程序可以无穷）</p></li><li><p>确定性：相同输入只能得到相同输出</p></li><li><p>可行性：用已有的操作实现算法</p></li><li><p>输入：0个输入或者多个输入</p></li><li><p>输出：一个输出或者多个输出</p></li></ul><p><strong>优秀算法的标准</strong></p><ul><li><p>正确性：正确求解问题</p></li><li><p>可读性：可帮助人们理解</p></li><li><p>健壮性：输入非法数据时，算法能做出反映来处理</p></li><li><p>高效率与低存储量需求</p><ul><li>执行速度快，时间复杂度低</li><li>不费内存，空间复杂度低</li></ul></li></ul><p><strong>程序&#x3D;数据结构+算法</strong></p><ul><li><p>数据结构处理信息</p></li><li><p>算法处理信息步骤</p></li></ul><h3 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h3><p>概念：是对时间复杂度和空间复杂度来描述</p><p><strong>时间复杂度</strong>P5</p><p><strong>分类</strong></p><ul><li><p>最好时间复杂度：最好情况下，算法的时间复杂度</p></li><li><p>平均时间复杂度：所有可能输入实例在等概率出现的情况下，算法的期望运行时间</p></li><li><p>最坏时间复杂度：最坏情况下，算法的时间复杂度</p></li><li><p>算法中所有的语句执行次数记为T(n)——时间开销,他是算法问题规模n的函数，时间复杂度主要分析T(n)的数量级</p></li></ul><p>常见的渐进时间复杂度：常对幂指阶</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208082249069.jpeg" alt="img"></p><p><strong>T(n)&#x3D;O(f(n))</strong></p><ul><li><p>O是T(n)的数量级</p></li><li><p>f(n)运算频度</p></li><li><p>看最高阶，忽略系数（系数为1）</p></li><li><p><a href="https://blog.csdn.net/kjcxmx/article/details/82738221?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%BE%8B%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-82738221.first_rank_v2_pc_rank_v29&spm=1018.2226.3001.4187">时间复杂度求解</a></p><ul><li><p>设运行次数</p></li><li><p>循环条件：次数与n的关系</p></li><li><p>求解</p></li></ul></li></ul><p><strong>空间复杂度</strong></p><ul><li><p>算法的空间复杂度S(n)(空间开销)定义为该算法所耗费的存储空间，他是问题规模n的函数</p></li><li><p>函数递归：空间复杂度&#x3D;递归调用的深度（次数）</p></li><li><p>算法原地工作是指算法所需的辅助空间为常量。即O(1)</p></li></ul><p><strong>计算规则</strong></p><ul><li><p>加法规则：$O( f(n) )+O( g(n) )&#x3D;O( max(f(n),g(n) )$、就是保留阶数高的一个数</p></li><li><p>乘法规则：$O( f(n) ) ×O( g(n) )&#x3D;O( (f(n)×g(n) )$</p></li></ul><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p><strong>概念</strong>：线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，</p><ul><li>当n&#x3D;0时线性表是一个空表</li></ul><p><strong>特点</strong></p><ul><li><p>表中元素的个数有限</p></li><li><p>表中元素具有逻辑上的顺序性，有其<strong>先后次序</strong></p></li><li><p>表中元素都是数据元素,每个元素都是单个元素</p></li><li><p>每个元素数据类型相同，占有相同大小的存储空间</p></li></ul><p><strong>术语</strong>   </p><ul><li><p>表头元素：第一个数据元素$a_1$</p></li><li><p>表尾元素:$a_n$</p></li><li><p>$a_i$:在线性表中的第“i”个元素线性表中的位序</p><ul><li>注：位序从1开始，数组下标从0开始</li></ul></li><li><p><strong>前驱</strong>：除了第一个元素，其他元素只有一个直接前驱</p></li><li><p><strong>后继</strong>：除了最后一个元素，其他元素只有一个直接后继</p></li></ul><p><strong>抽象数据类型线性表定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据结构教材书上P19</span></span><br><span class="line">ADT List&#123;</span><br><span class="line">    数据对象：D=&#123;&#125;;</span><br><span class="line">    数据关系：R1=&#123;&#125;;</span><br><span class="line">    基本操作：</span><br><span class="line">        <span class="built_in">InitList</span>(&amp;L)</span><br><span class="line">        操作结果：初始化表，构造一个空的线性表</span><br><span class="line">        <span class="built_in">Length</span>(L)</span><br><span class="line">        初始条件：线性表已存在</span><br><span class="line">        操作结果：求表长，返回线性表L的长度，即L中数据元素的个数</span><br><span class="line">        .......</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本操作</p><p>创造、增加、删除、修改、查看等</p><ul><li><p><code>InitList(&amp;L)</code>：初始化表，构造一个空的线性表</p></li><li><p><code>Length(L):</code>求表长，返回线性表L的长度，即L中数据元素的个数</p></li><li><p><code>LocateElem(L,e)</code>:按值查找操作,在表L中查找具有给定关键字值的元素</p></li><li><p><code>GetElem(L,i)</code>:按位查找操作,获取表L中第i个位置的元素的值</p></li><li><p><code>ListInsert (&amp;L,i,e)</code>:插入操作。在表L中的第i个位置上插入指定元素</p></li><li><p><code>ListDelete(&amp;L, i,&amp;e)</code>:删除操作,删除表L中第i个位置的元素，并用e返回删除元素的值</p></li><li><p><code>PrintList (L)</code>:输出操作,按前后顺序输出线性表L的所有元素值</p></li><li><p><code>Empty (L)</code>:判空操作,若L为空表，则返回true,否则返回false</p></li><li><p><code>DestroyList(&amp;L)</code>:销毁操作,销毁线性表，并释放线性表L所占用的内存空间</p></li></ul><p>函数名要有可读性</p><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h2><p><strong>注意</strong></p><ol><li>王道讲课中–SqList &amp;L的意思是传入结构体的地址，c++引用语法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;   <span class="comment">//·将所有数据元素设置为默认初始值0,如果没有这一步，内存中会有遗留的“脏数据”</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.Length=<span class="number">0</span>;        <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">                       <span class="comment">//在内存里分配存储顺序表L的空间</span></span><br><span class="line">                       <span class="comment">//包括MaxSize*sizeof(ElemType)和存储length的空间</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><p><strong>malloc函数</strong></p><ul><li>因为malloc返回的是不确定类型的指针</li><li>malloc() 在堆区分配一块指定大小的内存空间，用来存放数据,分配失败则返回NULL</li><li><code>L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)</code> 其中<code>(ElemType*)</code>可强制转换数据类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="built_in">malloc</span>( <span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">100</span> );<span class="comment">//返回开辟成功内存块的首地址</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;          <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;       <span class="comment">//最大容量</span></span><br><span class="line">    <span class="type">int</span> length;       <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;              <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作初始化一个顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList *L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    L-&gt;MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SqList *L,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=L-&gt;data;   <span class="comment">//地址赋值</span></span><br><span class="line"></span><br><span class="line">    L-&gt;data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L-&gt;MaxSize+len)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[i]=p[i];                 <span class="comment">//将旧数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;MaxSize=L-&gt;MaxSize+len;           <span class="comment">//数组最大长度</span></span><br><span class="line">    <span class="built_in">free</span>(p);                           <span class="comment">//释放原来的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;<span class="comment">//声明一个顺序表</span></span><br><span class="line">    <span class="built_in">InitList</span>(&amp;L);<span class="comment">//初始化顺序表</span></span><br><span class="line"><span class="comment">//以下代码对比</span></span><br><span class="line">    <span class="built_in">IncreaseSize</span>(&amp;L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c-引用"><a href="#c-引用" class="headerlink" title="c++引用"></a>c++引用</h3><h4 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h4><p>作用： 给变量起别名<br><strong>语法：</strong> <strong>数据类型 &amp;别名 &#x3D; 原名</strong><br>**示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h4><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h4><p><strong>作用：</strong>函数传参时，可以利用引用的技术让**形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;值传递&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;地址传递&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;引用传递&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="结构体传参问题"><a href="#结构体传参问题" class="headerlink" title="结构体传参问题"></a>结构体传参问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> Length;        </span><br><span class="line">&#125;SqList;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;*LinkList,LNode;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLinkList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">//因为用LinkList定义首地址(传入的是地址，所以用L-&gt;next),传入参数定义(LinkList)要一样</span></span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//开辟新结点</span></span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;单链表定义的LinkList&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入参数用SqList定义的结构体</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    L.Length=<span class="number">0</span>;        </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输出顺序表&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitListLNode</span><span class="params">(LNode &amp;L)</span></span>&#123;</span><br><span class="line">L.data=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//传入参数是用LNode定义的结构体(不是地址)，所以用L.data</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;单链表定义LNode的结点&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList2</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">L-&gt;data=<span class="number">8</span>;</span><br><span class="line"><span class="comment">//传入参数定义的LNode *L,用的指针,所以*L</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;单链表LNode *L&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L; </span><br><span class="line">    LNode Le;</span><br><span class="line">    LinkList Li;                         </span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="built_in">InitList2</span>(&amp;Le);</span><br><span class="line">    <span class="built_in">InitListLNode</span>(Le);  </span><br><span class="line">    <span class="built_in">InitLinkList</span>(Li);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>示意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作——在L的位序i处插入元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span>&#123;   <span class="comment">//c++引用</span></span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize) <span class="comment">//当前存储空间已满，不能插入  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length; j &gt; i; j--)&#123;    <span class="comment">//将第i个元素及其之后的元素后移,从最后一个元素开始</span></span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i<span class="number">-1</span>]=e;  <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;      <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    <span class="built_in">ListInsert</span>(L,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="图片动画"><a href="#图片动画" class="headerlink" title="图片动画"></a>图片动画</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192208359.gif"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>示意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10      <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 ElemType:int</span></span><br><span class="line">    <span class="type">int</span> Length;         <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">LisDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span>&#123; <span class="comment">// e用引用型参数 </span></span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>]                 <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j &lt; L.length;j++)&#123;    <span class="comment">//将第i个后的元素前移</span></span><br><span class="line">        L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;      <span class="comment">//长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    SqList L;          <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L);       <span class="comment">//初始化这个顺序表</span></span><br><span class="line">    <span class="comment">//...插入几个元素</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">-1</span>;        <span class="comment">//用变量e把删除的元素“带回来”</span></span><br><span class="line">    <span class="keyword">if</span>(LisDelete(L,<span class="number">3</span>,e))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已删除第三个元素，删除元素值=%d\n&quot;</span>,e);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位序i不合法，删除失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="图片动画-1"><a href="#图片动画-1" class="headerlink" title="图片动画"></a>图片动画</h3><ul><li>删除7</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192218881.gif"></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h3><p>静态分配按位查找示意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="comment">// ElemType *data;  //用动态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                     <span class="comment">//顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="comment">// ...判断i的值是否合法</span></span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];      <span class="comment">//注意是i-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h3><p>动态分配示意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10            <span class="comment">//定义最大长度 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;  <span class="comment">//用静态的“数组”存放数据元素 </span></span><br><span class="line">    <span class="type">int</span> Length;              <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length ;i++)</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)  </span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;     <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;               <span class="comment">//推出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="顺序表做题思路"><a href="#顺序表做题思路" class="headerlink" title="顺序表做题思路"></a>顺序表做题思路</h2><ol><li>一般要在开头考虑是否为空表，一般用bool类型命令函数</li><li>数据类型用<code>ElemType</code>表示</li></ol><p><strong>插入删除移动次序</strong></p><table><thead><tr><th></th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>平均移动次序</td><td><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208122309968.png" alt="image-20220812230946121"></td><td><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208122310422.png" alt="image-20220812231004948"></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h2 id="单链表定义"><a href="#单链表定义" class="headerlink" title="单链表定义"></a>单链表定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            <span class="comment">//定义单链表节点类型  LNode:结点</span></span><br><span class="line">    ElemType data;       <span class="comment">//每个结点存放一个数据元素 data:数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指针指向下一个结点 next:指针域</span></span><br><span class="line">    <span class="comment">//struct LNode *next LNode指的是标签名</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Nea</span>&#123;</span>          </span><br><span class="line">    ElemType data;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Nea</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LNode *p = (LNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))<span class="comment">//增加一个新的结点：在内存中申请一个结点所需的空间，并用指针p指向这个结点</span></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202131622506.png" alt="image-20220213162258317"></p><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//上下代码等价</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>           </span><br><span class="line">    ElemType data;       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">LNode</span>;</span> <span class="comment">//重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">LinkList</span>;</span> </span><br><span class="line"><span class="comment">//之后定义结构体变量只需使用LNode 结构变量名</span></span><br><span class="line"><span class="comment">//同理，定义结构体指针变量只需使用LinkList 指针变量名,函数中一般传入使用LinkList定义的，相当于传入的是链表地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一种，定义时仅有LinkList</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Lnode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Lnode</span> *next;</span><br><span class="line">&#125;LinkList;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text_Link</span><span class="params">(LinkList *la,LinkList *&amp;lb)</span></span>&#123;<span class="comment">//对la的形参定义是：只对la进行遍历等操作，不可更改；对lb的定义是可以修改lb</span></span><br><span class="line">    LinkList *p;  <span class="comment">//定义p指针变量</span></span><br><span class="line">    p=(LinkList*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkList)); <span class="comment">//创建新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种，定义时为Lnode，*LinkList</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Lnode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Lnode</span> *next;</span><br><span class="line">&#125;Lnode，*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text_Link</span><span class="params">(LinkList la,LinkList &amp;lb)</span></span>&#123;<span class="comment">//对la的形参定义是：只对la进行遍历等操作，不可更改；对lb的定义是可以修改lb</span></span><br><span class="line">    LinkList p;  <span class="comment">//定义p指针变量</span></span><br><span class="line">    p=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Lnode)); <span class="comment">//创建新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以理解为void text(int x)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">(Lnode x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要表示一个单链表时，只需声明一个<strong>头指针L</strong>，<strong>指向</strong>单链表的第一个结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LNode *L;    <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是结点</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">LinkList L;  <span class="comment">// 声明一个指向单链表第一个结点的指针，强调这是链表</span></span><br><span class="line"><span class="comment">//注意：LNode *等价于LinkList </span></span><br></pre></td></tr></table></figure><h3 id="带头结点"><a href="#带头结点" class="headerlink" title="带头结点"></a>带头结点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个单链表（带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;  </span><br><span class="line">    L = (LNode*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//头指针指向的结点——分配一个头结点；即头结点的指针为头指针（不存储数据）;malloc返回的是指针首地址</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)          <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;       <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空（带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//L-&gt;next表示当前指针的下一个指针</span></span><br></pre></td></tr></table></figure><h3 id="不带头节点"><a href="#不带头节点" class="headerlink" title="不带头节点"></a>不带头节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;  <span class="comment">//注意用引用 &amp;</span></span><br><span class="line">    L = <span class="literal">NULL</span>; <span class="comment">//空表，暂时还没有任何结点；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkList L;  <span class="comment">//声明一个指向单链表的指针: 头指针</span></span><br><span class="line">    <span class="comment">//初始化一个空表</span></span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带头结点与不带头节点区别</p><ol><li>不带头结点：写代码麻烦！对第一个数据节点和后续数据节点的处理需要用不同的代码逻辑，对空表和非空表的处理也需要用不同的代码逻辑; <strong>头指针指向的结点用于存放实际数据;</strong></li><li>带头结点：<strong>头指针指向的头结点不存放实际数据,头结点指向的下一个结点才存放实际数据;</strong></li></ol><h2 id="基本操作方法"><a href="#基本操作方法" class="headerlink" title="基本操作方法"></a>基本操作方法</h2><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><h4 id="带头结点-1"><a href="#带头结点-1" class="headerlink" title="带头结点"></a>带头结点</h4><p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e &#x3D; 找到第i-1个结点(前驱结点)，将新结点插入其后；其中头结点可以看作第0个结点，故i&#x3D;1时也适用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//在第i个位置插入元素e（带头结点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="comment">//判断i的合法性, i是位序号(从1开始)</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法,i&gt;lengh</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;                   </span><br><span class="line">    s-&gt;next = p-&gt;next;              <span class="comment">//s的下一个指针指向p的下一个指针</span></span><br><span class="line">    p-&gt;next = s;                 <span class="comment">//将结点s连到p后,后两步千万不能交换顺序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="图片动画-2"><a href="#图片动画-2" class="headerlink" title="图片动画"></a>图片动画</h5><ul><li>a1为头结点</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192218457.gif"></p><h4 id="不带头节点-1"><a href="#不带头节点-1" class="headerlink" title="不带头节点"></a>不带头节点</h4><p><code>ListInsert(&amp;L, i, e)</code>: 在表L中的第i个位置上插入指定元素e &#x3D; 找到第i-1个结点(前驱结点)，将新结点插入其后; 因为不带头结点，所以不存在“第0个”结点，因此！<strong>i&#x3D;1 时，需要特殊处理——插入(删除)第1个元素时，需要更改头指针L;</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入到第1个位置时的操作有所不同！</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(size of(LNode));</span><br><span class="line">        s-&gt;data =e;</span><br><span class="line">        s-&gt;next =L;</span><br><span class="line">        L=s;          <span class="comment">//头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i&gt;1的情况与带头结点一样！唯一区别是j的初始值为1</span></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)                 <span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在第i-1个结点后插入新结点</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//申请一个结点</span></span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="指定结点的后插操作"><a href="#指定结点的后插操作" class="headerlink" title="指定结点的后插操作"></a>指定结点的后插操作</h4><ul><li><p><code>InsertNextNode(LNode *p, ElemType e)</code>: 给定一个结点p，在其之后插入元素e; 根据单链表的链接指针只能往后查找，故给定一个结点p，那么p之后的结点我们都可知，但是p结点之前的结点无法得知;</p></li><li><p>相当封装好的插入函数</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">//某些情况下分配失败，比如内存不足</span></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;          <span class="comment">//用结点s保存数据元素e </span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;          <span class="comment">//将结点s连到p之后</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;                         <span class="comment">//平均时间复杂度 = O(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有了后插操作，那么在第i个位置上插入指定元素e的代码可以改成：</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    </span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> InsertNextNode(p, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="指定结点的前插操作"><a href="#指定结点的前插操作" class="headerlink" title="指定结点的前插操作"></a>指定结点的前插操作</h4><ol><li>如何找到p结点的前驱节点？<ul><li>传入头指针L！就可以知道整个链表的信息了！</li><li>InsertPriorNode(LinkList L, LNode *p, ElemType e)：循环查找p的前驱q，再对q进行后插操作，时间复杂度为O(n);</li></ul></li></ol><p>Q: 那如果不传入头指针L呢？</p><p><strong>不传入头指针L的代码实现</strong>:创建节点后，交换数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之前插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, ElenType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>) <span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点来了！</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;       <span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data; <span class="comment">//将p中元素复制到s</span></span><br><span class="line">    p-&gt;data = e;       <span class="comment">//p中元素覆盖为e</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>；</span><br><span class="line">&#125;  <span class="comment">//时间复杂度为O(1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="图片动画-3"><a href="#图片动画-3" class="headerlink" title="图片动画"></a>图片动画</h5><ul><li>相当于创建一个数据，然后交换插入数据位置，改变其后指向指针</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192219223.gif"></p><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><h4 id="带头结点-2"><a href="#带头结点-2" class="headerlink" title="带头结点"></a>带头结点</h4><p><code>ListDelete(&amp;L, i, &amp;e)</code>: 删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值;<strong>头结点</strong>视为“<strong>第0个</strong>”结点；</p><p>思路：找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点；</p><p>先找到第i-1个结点p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *p;       <span class="comment">//指针p指向当前扫描到的结点 </span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;        <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;          <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)&#123;     <span class="comment">//如果i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        p = p-&gt;next;             <span class="comment">//p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)            <span class="comment">//i&gt;lengh, p最后会等于NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    LNode *q = p-&gt;next;         <span class="comment">//令q指向被删除的结点</span></span><br><span class="line">    e = q-&gt;data;                <span class="comment">//用e返回被删除元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;          <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q)                     <span class="comment">//释放结点的存储空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204192238689.gif"></p><p>时间复杂度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最坏，平均时间复杂度：O(n)</span><br><span class="line">最好时间复杂度：删除第一个结点 O(1)</span><br></pre></td></tr></table></figure><h4 id="指定结点删除"><a href="#指定结点删除" class="headerlink" title="指定结点删除"></a>指定结点删除</h4><p>方法</p><ul><li>删除指定p结点，将p的后继结点的数据传给p（交换数据）,然后p的next指向p后继结点的后继节点</li><li>实际上就是删除p的后继结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *q = p-&gt;next;      <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data; <span class="comment">//让p和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;       <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;                                                     </span><br><span class="line">&#125; <span class="comment">//时间复杂度 = O(1)</span></span><br><span class="line">                                        </span><br></pre></td></tr></table></figure><h5 id="图片动画-4"><a href="#图片动画-4" class="headerlink" title="图片动画"></a>图片动画</h5><ul><li>将结点p的后继数据给p,然后修改p的后继，释放原来p的后继</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082134193.gif"></p><p><strong>但是</strong> 如果p是最后一个结点，那么<code>p-&gt;next = q-&gt;next</code> and <code>p-&gt;data = p-&gt;next-&gt;data</code> 就会出错，只能从表头开始依次寻找o的前驱，时间复杂度为O(n); 这就是单链表的<strong>局限性</strong>——无法逆向检索。</p><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><h4 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h4><ul><li><code>GetElem(L, i):</code> 按位查找操作，获取表L中第i个位置的元素的值;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    LNode *p;               <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;                <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                  <span class="comment">//L指向头结点,头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;  <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;               <span class="comment">//返回p指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h4><ul><li><code>LocateElem(L, e):</code>按值查找操作，在表L中查找具有给定关键字值的元素;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LNode * <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;    <span class="comment">//p指向第一个结点</span></span><br><span class="line">    <span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;           <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单链表的长度"><a href="#单链表的长度" class="headerlink" title="单链表的长度"></a>单链表的长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;       <span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h2><ul><li><strong>思路</strong>： 初始化一个单链表 -&gt; 每取一个数据元素，插入到表尾&#x2F;表头</li><li><strong>核心</strong>：初始化操作，指定结点的后插操作</li></ul><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="type">int</span> x;                                   <span class="comment">//设ElemType为整型int</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点(初始化空表)</span></span><br><span class="line">    LNode *s, *r = L;                        <span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s                                <span class="comment">//r指针指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图片动画-5"><a href="#图片动画-5" class="headerlink" title="图片动画"></a>图片动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204201234259.gif"></p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;       <span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                          <span class="comment">//初始为空链表,这步不能少！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);                         <span class="comment">//输入要插入的结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                          <span class="comment">//输入9999,链表结束</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;                         <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图片动画-6"><a href="#图片动画-6" class="headerlink" title="图片动画"></a>图片动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206061242973.gif"></p><p>在头结点后面插入新的数据</p><p><strong>PS: 只要是初始化单链表，都先将头指针指向NULL — <code>L-&gt;next = NULL</code>;</strong></p><h4 id="重要应用—链表逆置"><a href="#重要应用—链表逆置" class="headerlink" title="重要应用—链表逆置"></a>重要应用—链表逆置</h4><ul><li><a href="https://blog.csdn.net/qq_42322103/article/details/82668765">头插法图解</a></li><li><strong>算法思想</strong>：逆置链表初始为空，原表中结点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">Inverse</span><span class="params">(LNode *L)</span></span><br><span class="line">&#123;</span><br><span class="line">LNode *p, *q;</span><br><span class="line">p = L-&gt;next;     <span class="comment">//p指针指向第一个结点</span></span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//头结点指向NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q-&gt;next = L-&gt;next;  </span><br><span class="line">L-&gt;next = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206071221996.gif"></p><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><p>结点描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br></pre></td></tr></table></figure><h2 id="双链表初始化（带头结点）"><a href="#双链表初始化（带头结点）" class="headerlink" title="双链表初始化（带头结点）"></a>双链表初始化（带头结点）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>            <span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;               <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  <span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(Dlinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));      <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                              <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;   <span class="comment">//头结点的prior指针永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化双链表</span></span><br><span class="line">    DLinklist L;         <span class="comment">// 定义指向头结点的指针L</span></span><br><span class="line">    InitDLinkList(L);    <span class="comment">//申请一片空间用于存放头结点，指针L指向这个头结点</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的next指针是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082159971.png" alt="image-20220608215936343"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132140514.png" alt="image-20220213214025352"></p><p>与单链表中一样，<code>DLinklist</code> 强调链表， <code>DNode *</code>强调结点，二者本质上等价;</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><h3 id="后插"><a href="#后插" class="headerlink" title="后插"></a>后插</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; <span class="comment">//将结点 *s 插入到结点 *p之后</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || s==<span class="literal">NULL</span>) <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)   <span class="comment">//p不是最后一个结点=p有后继结点,NULL不会指向p</span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="图片动画-7"><a href="#图片动画-7" class="headerlink" title="图片动画"></a>图片动画</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204201307984.gif"></p><h3 id="按位序插入"><a href="#按位序插入" class="headerlink" title="按位序插入"></a>按位序插入</h3><ul><li>思路：从头结点开始，找到某个位序的<strong>前驱结点</strong>，对该前驱结点执行后插操作；</li></ul><h3 id="前插"><a href="#前插" class="headerlink" title="前插"></a>前插</h3><ul><li>思路：找到给定结点的前驱结点，再对该前驱结点执行后插操作；</li></ul><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除p的后继结点q</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><p>如果要删除的结点q是最后一个结点，会出现错误，故增加条件判断以提高代码健壮性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="comment">//三种情况判断：1.p结点为空结点  2、p的没有后继结点  3.p的后继节点是否是最后一个结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeletNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q =p-&gt;next;            <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//p没有后继结点;</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)           <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DestoryList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        DeletNextDNode(L);  <span class="comment">//删除头结点的后继结点</span></span><br><span class="line">    <span class="built_in">free</span>(L); <span class="comment">//释放头结点</span></span><br><span class="line">    L=<span class="literal">NULL</span>;  <span class="comment">//头指针指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="图片动画-8"><a href="#图片动画-8" class="headerlink" title="图片动画"></a>图片动画</h3><ol><li>删除p结点的后继结点</li></ol><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204201315741.gif"></p><h2 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h2><h3 id="后项遍历"><a href="#后项遍历" class="headerlink" title="后项遍历"></a>后项遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前项遍历"><a href="#前项遍历" class="headerlink" title="前项遍历"></a>前项遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理，eg打印</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳过头结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p-&gt;prior!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//对结点p做相应处理</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong> 双链表不可随机存取，按位查找和按值查找操作都只能用遍历的方式实现，时间复杂度为<strong>O(n)</strong></p><h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><ul><li><strong>最后一个结点的指针不是NULL,而是指向头结点</strong></li></ul><p>初始化</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082209463.png" alt="image-20220608220935407"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>            </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *Linklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)             <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;            <span class="comment">//头结点next指针指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//为空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L, LNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132150443.png"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ol><li>单链表<ul><li>从<strong>一个结点出发只能找到该结点后续的各个结点</strong>；对链表的操作大多都在头部或者尾部；设立头指针，从头结点找到尾部的时间复杂度&#x3D;O(n)，即对表尾进行操作需要O(n)的时间复杂度;</li></ul></li><li>循环单链表<ul><li>从一个结点出发，可以<strong>找到其他任何一个结点</strong>；设立尾指针，从尾部找到头部的时间复杂度为O(1)，即对表头和表尾进行操作都只需要O(1)的时间复杂度;</li></ul></li></ol><h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><ul><li><strong>表头结点的<code>prior</code>指向表尾结点，表尾结点的<code>next</code>指向头结点</strong></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132151941.png" alt="image-20220213215101834"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>          </span><br><span class="line">    ElemType data;               </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;DNode, *DLinklist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));    <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    L-&gt;prior = L;          <span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;           <span class="comment">//头结点的next指向头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始化循环单链表</span></span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkList(L);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(DLinklist L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环双链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(DLinklist L, DNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始化</p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202206082210257.png" alt="image-20220608221014694"></p><h3 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h3><ul><li>对于循环双链表，操作 <code>p-&gt;next-&gt;prior = s</code> 不会出问题辣！因为就算p是最后一个结点，也不会出现空指针现象了(这个问题在双链表里会出现！)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123; </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h3><ul><li>和插入操作一样！<code>q-&gt;next-&gt;prior</code> 对于循环双链表不会出错了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p的后继结点q</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>用数组的方式实现的链表: 分配一整片连续的内存空间，各个结点集中安置，包括了——数据元素and下一个结点的数组下标(游标)</li><li>单链表：各个结点散落在内存中的各个角落，每个结点有指向下一个节点的指针(下一个结点在内存中的地址);</li></ul><p>注意</p><ul><li>其中数组下标为0的结点充当”头结点”</li><li>游标为-1表示已经到达表尾</li><li>若每个数据元素为4B，每个游标为4B，则每个结点共8B；假设起始地址为<code>addr</code>，则数据下标为2的存放地址为：<code>addr+8*2</code></li><li>注意： 数组下标——物理顺序，位序——逻辑顺序；</li><li>优点：增、删操作不需要大量移动元素；</li><li>缺点：不能随机存取，只能从头结点开始依次往后查找，容量固定不变！</li></ul><p>定义代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用数组定义多个连续存放的结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">a</span>[<span class="title">MaxSize</span>];</span>  <span class="comment">//数组a作为静态链表, 每一个数组元素的类型都是struct Node</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价下面的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>           <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ELemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">    SLinkList a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10        <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;        <span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;             <span class="comment">//下一个元素的数组下标(游标)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">SLinkList</span>[<span class="title">MaxSize</span>];</span> <span class="comment">//重命名struct Node，用SLinkList定义“一个长度为MaxSize的Node型数组;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS: <code>SLinkList a</code> 强调a是静态链表；<code>struct Node a</code> 强调a是一个Node型数组；</p><h2 id="基本操作的实现"><a href="#基本操作的实现" class="headerlink" title="基本操作的实现"></a>基本操作的实现</h2><ul><li><p>初始化静态链表：把a[0]的next设为-1</p></li><li><p>查找某个位序（不是数组下标，位序是各个结点在逻辑上的顺序）的结点：从头结点出发挨个往后遍历结点，时间复杂度O&#x3D;(n)</p></li><li><p>在位序为i上插入结点：</p><ol><li>找到一个空的结点，存入数据元素；</li><li>从头结点出发找到位序为i-1的结点；</li><li>修改新结点的next；</li><li>修改i-1号结点的next；</li></ol></li><li><p>插入如下</p></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202202132203523.png" alt="image-20220213220301417"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202204212316893.gif"></p><blockquote><p>Q：如何判断结点为空？</p><p>A：在初始化时，将空闲结点的next设置为某个特殊值，eg：-2；</p></blockquote><blockquote><p>删除某个结点：</p><p>① 从头结点出发找到前驱结点；</p><p>② 修改前驱节点的游标；</p><p>③ 被删除节点next设为-2；</p></blockquote><h1 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><ul><li>顺序表和链表都属于线性表，都是线性结构</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><strong>顺序表</strong>：顺序存储</p><ul><li>优点：支持随机存取，存储密度高</li><li>缺点：大片连续空间分配不方便，改变容量不方便</li></ul><p><strong>链表</strong>：链式存储</p><ul><li>优点：离散的小空间分配方便，改变容量方便</li><li>缺点：不可随机存取，存储密度低</li></ul><h2 id="基本操作-创"><a href="#基本操作-创" class="headerlink" title="基本操作 - 创"></a>基本操作 - 创</h2><p> <strong>顺序表</strong></p><ol><li>需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源；</li><li>静态分配：静态数组，容量不可改变</li><li>动态分配：动态数组，容量可以改变，但是需要移动大量元素，时间代价高（<code>malloc(),free()</code>）</li></ol><p><strong>链表</strong></p><ul><li>只需要分配一个头结点或者只声明一个头指针</li></ul><h2 id="基本操作-销毁"><a href="#基本操作-销毁" class="headerlink" title="基本操作 - 销毁"></a>基本操作 - 销毁</h2><h3 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h3><p>修改 <code>Length = 0</code></p><ul><li>静态分配：静态数组——系统自动回收空间</li><li>动态分配：动态数组——需要手动free</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创</span></span><br><span class="line">L.data = (ELemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) *InitSize)</span><br><span class="line"><span class="comment">//销</span></span><br><span class="line"><span class="built_in">free</span>(L.data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//！malloc() 和 free() 必须成对出现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>链表</strong></p><ul><li>依次删除各个结点 <code>free()</code></li></ul><h2 id="基本操作-增-删"><a href="#基本操作-增-删" class="headerlink" title="基本操作 - 增&#x2F;删"></a>基本操作 - 增&#x2F;删</h2><p><strong>顺序表</strong></p><ul><li>插入&#x2F;删除元素要将后续元素后移&#x2F;前移；时间复杂度&#x3D;O(n)，时间开销主要来自于移动元素；</li></ul><p><strong>链表</strong></p><ul><li>插入&#x2F;删除元素只需要修改指针；时间复杂度&#x3D;O(n)，时间开销主要来自查找目标元素</li></ul><h2 id="基本操作-查"><a href="#基本操作-查" class="headerlink" title="基本操作 - 查"></a>基本操作 - 查</h2><p><strong>顺序表</strong></p><ul><li><p>按位查找：O(1)</p></li><li><p>按值查找：O(n)，若表内元素有序，可在O($log_2{n}$)时间内找</p></li></ul><p><strong>链表</strong></p><ul><li>按位查找：O(n)</li><li>按值查找：O(n)</li></ul><p><strong>开放式问题答题思路</strong></p><blockquote><p>Q: 请描述顺序表和链表的balabalabala…实现线性表时，用顺序表还是链表好？</p><p>A: 顺序表和链表的存储结构都是线性结构，都属于线性表；但是二者的存储结构不同，顺序表采用顺序存储…(特点，优缺点)；链表采用链式存储…(特点，优缺点)；由于采用不同的存储方式实现，因此基本操作的实现效率也不同；当初始化时…；当插入一个数据元素时…；当删除一个数据元素时…；当查找一个数据元素时…；</p></blockquote><h1 id="课后习题算法"><a href="#课后习题算法" class="headerlink" title="课后习题算法"></a>课后习题算法</h1><h2 id="顺序表-2"><a href="#顺序表-2" class="headerlink" title="顺序表"></a>顺序表</h2><p>将两个有序表合并成一个新的有序表，并由函数返回顺序表</p><p>算法思想：这种顺序表有序，可以利用归并排序(两个表归并成一个表)的写法。按顺序不断取下顺序表表头较小的结点存入顺序表，看那个表还有剩余，将剩下的部分加入到新的顺序表后面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">ElemType data[Maxsize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//题目需要返回顺序表，所以用引用去代替</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Merse</span><span class="params">(SqList A,SqList B,SqList &amp;C)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(A.length+B.length&gt;C.maxSize) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//需要判断是否长度是否合理</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//对比两个顺序表</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;A.length &amp;&amp; j&lt;B.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(A.data[i]&gt;B.data[j]) C.data[k++]=B.data[j++];</span><br><span class="line"><span class="keyword">else</span> C.data[k++]=A.data[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断剩下的顺序表</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;A.length) C.data[k++]=A.data[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;B.length) C.data[k++]=B.data[j++];</span><br><span class="line">C.length=k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知在一维数组A[m+n]中依次存放两个线性表(a1,a2,a3,…,am)和(b1,b2,b3,…,bn)。编写一个函数，将数组中两个顺序表的位置互换，即将(b1,b2,b3,…,bn)放在(a1,a2,a3,…,am)的前面。</p><p>解题思路：先将数组A[m+n]中的全部元素(a1,a2,a3,…,am,b1,b2,b3,…,bn)原地逆置，再对前n个元素和后m个元素分别使用逆置算法，即可得到所求，从而实现顺序表的位置互换。</p><ul><li>在不使用额外数组的条件下，用先整体逆置，然后分别左右表逆置</li><li>如使用额外数组，则用移动的方法去求</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> arraysize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r || r&gt;=arraysize) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mid-l;i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp=q[l+i];</span><br><span class="line">        q[l+i]=q[r-i];</span><br><span class="line">        q[r-i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Exchange</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> arraysize)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Reverse</span>(q,<span class="number">0</span>,m+n<span class="number">-1</span>,arraysize);<span class="comment">//整体逆转</span></span><br><span class="line">    <span class="built_in">Reverse</span>(q,<span class="number">0</span>,n<span class="number">-1</span>,arraysize);<span class="comment">//b逆转</span></span><br><span class="line">    <span class="built_in">Reverse</span>(q,n,m+n<span class="number">-1</span>,arraysize);<span class="comment">//a逆转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性表的元素递增有序且按顺序存储与计算机内，用最少的时间在表中查找数值为x的元素，若找到，则将其与后继元素位置交换位置，找不到则将其插入表中是表中元素递增有序</p><p>思想：用折半查找元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchExchangeInsert</span><span class="params">(ElemType A[],ElemType x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,h=n<span class="number">-1</span>,mid;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(A[mid]==x) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;x) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相等操作,注意与最后一个元素相等，不需要交换（容易忽略）</span></span><br><span class="line"><span class="keyword">if</span>(A[mid]==x &amp;&amp; mid != n<span class="number">-1</span>)&#123;</span><br><span class="line">        ElemType t=A[mid];</span><br><span class="line">A[mid]=A[mid+<span class="number">1</span>];</span><br><span class="line">A[mid+<span class="number">1</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//因为h指向的数据比x小，所有将h及h之后的数据后移动</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;h)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;hige;i--) A[i+<span class="number">1</span>]=A[i];<span class="comment">//后移动元素</span></span><br><span class="line">A[i+<span class="number">1</span>]=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找两个有序顺序表的中位数</p><ul><li>本题思想还是通过折半查找快速判断</li><li>通过舍弃序列元素来缩小所求中位数的范围<br><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209262145810.jpg"></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209262145443.jpg"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209262145533.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">M_Serch</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> B[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> s1=<span class="number">0</span>,d1=n<span class="number">-1</span>,m1,s2=<span class="number">0</span>,d1=n<span class="number">-1</span>,m2;</span><br><span class="line"><span class="comment">//分别表示序列A和B的首位数，末位数和中位数</span></span><br><span class="line"><span class="keyword">while</span>(s1!=d1 || s2!=d2)&#123;</span><br><span class="line"><span class="comment">//相当于折半查找</span></span><br><span class="line">m1=(s1+d1)/<span class="number">2</span>;</span><br><span class="line">m2=(s2+d2)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(A[m1]==B[m2]) <span class="keyword">return</span> A[m1];</span><br><span class="line"><span class="comment">//满足条件2</span></span><br><span class="line"><span class="keyword">if</span>(A[m1]&lt;B[m2])&#123;</span><br><span class="line"><span class="keyword">if</span>((s1+d1)%<span class="number">2</span>==<span class="number">0</span>)&#123;  <span class="comment">//元素个数为奇数,序号2,3,4满足(2+4)%2=0,但个数是3</span></span><br><span class="line">s1=m1;         <span class="comment">//舍弃A中间点以前部分且保留中间点</span></span><br><span class="line">d2=m2;        <span class="comment">//设计B中间点以后且保留中间点</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">s1=m1+<span class="number">1</span>;    <span class="comment">//舍弃A中间点及中间点以前的部分</span></span><br><span class="line">d2=m2;     <span class="comment">//舍弃B中间点以后部分且保留中间点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//满足条件3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((s2+d2)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">s2=m2;</span><br><span class="line">d2=m2;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">s1=m1;</span><br><span class="line">d2=m2+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> A[s1]&lt;B[s2] ? A[s1]:B[s2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.c++常用库及操作</title>
      <link href="/data.github.io/post/12d6828c.html"/>
      <url>/data.github.io/post/12d6828c.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-常用库及操作"><a href="#C-常用库及操作" class="headerlink" title="C++常用库及操作"></a>C++常用库及操作</h1><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h2><p>sort<a href="https://ac-fun.blog.csdn.net/article/details/105936466?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=2">排序</a></p><ul><li>需要声明<code># include &lt;algorithm&gt;；sort(begin,end)</code>，表示一个范围</li><li>sort()函数可以对给定区间所有元素进行排序。它有三个参数sort(begin, end, cmp)，其中begin<strong>为指向待sort()的</strong>数组的第一个元素的指针，end为指向待sort()的数组的最后一个元素的下一个位置的指针，cmp参数为排序准则，<mark style="background: #FF5582A6;">cmp参数可以不写</mark>，如果不写的话，<strong>默认从小到大进行排序</strong>。如果我们想从大到小排序可以将cmp参数写为<code>greater&lt;int&gt;()</code>就是对int数组进行排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组：<span class="built_in">sort</span>(num,num+<span class="number">10</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())</span><br><span class="line">字符串：<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">char</span>&gt;())</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;//万能头文件</span></span><br><span class="line"><span class="comment">//sort(首地址,首地址+长度)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(num,num+<span class="number">10</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//greater&lt;int&gt;()从大到小</span></span><br><span class="line">    <span class="comment">//sort(num,num+10)//从小到大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;<span class="comment">//输出结果:9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    string a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从小到大：&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">char</span>&gt;());</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从大到小：&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义字符串数组</span></span><br><span class="line">    <span class="type">char</span> b[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    <span class="comment">// cout&lt;&lt;a;不能直接输出</span></span><br><span class="line">    cout&lt;&lt;b[<span class="number">4</span>];<span class="comment">//输出第5个字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="built_in">empty</span>(); <span class="comment">// 判断是否为空字符串</span></span><br><span class="line">s1.<span class="built_in">size</span>(); <span class="comment">// 效果如s1.length(), O(1)</span></span><br><span class="line">s1.pop_back; <span class="comment">// 删掉最后一个字符</span></span><br><span class="line">ch=<span class="built_in">to_string</span>(a)<span class="comment">//将整数变为字符，a为整数</span></span><br></pre></td></tr></table></figure><h3 id="to-string"><a href="#to-string" class="headerlink" title="to_string()"></a>to_string()</h3><ul><li>将整数变为字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cun[<span class="number">5</span>]=&#123;<span class="number">133</span>,<span class="number">7236</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">string res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:cun)&#123;</span><br><span class="line">res=<span class="built_in">to_string</span>(i);</span><br><span class="line">        <span class="comment">//res+=to_string(i);将遍历到的字符加到res后面</span></span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字符串相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    a=<span class="string">&#x27;8&#x27;</span>+a+<span class="string">&#x27;9&#x27;</span>;<span class="comment">//在字符串首尾直接添加字符</span></span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h3><ul><li>substring (begin,end)方法用于提取字符串中介于两个指定下标之间的字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string a=<span class="string">&quot;012345678&quot;</span></span><br><span class="line"><span class="comment">//第一个参数为位置，第二个参数为截取的长度</span></span><br><span class="line">a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">5</span>)<span class="comment">//截取字符串第0到第5的位置，01234</span></span><br><span class="line">str=str.<span class="built_in">substr</span>(<span class="number">2</span>);<span class="comment">//表示从原串下标为2的字符开始截取到完。</span></span><br></pre></td></tr></table></figure><p><strong>substring(begin,end)</strong></p><ul><li>substring (begin,end)方法用于提取字符串中介于两个指定下标之间的字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin:开始索引（包括），索引从0开始</span><br><span class="line">end:结束索引（不包括）</span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul><li>vector是STL中最常见的容器，它是一种顺序容器，支持随机访问； 而vector是动态分配空间，随着元素的不断插入，它会按照自身的一套机制不断扩充自身的容量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">//必须包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//几种vector声明</span></span><br><span class="line">    <span class="comment">//&lt;&gt;里面是类型</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v1;        <span class="comment">//定义空的vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(<span class="number">10</span>);    <span class="comment">//产生大小为10的vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">-1</span>);    <span class="comment">//产生大小为10，并且每个元素都是-1的vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v4</span>(v3);        <span class="comment">//用一个vector产生一个vecotr</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v5</span>(arr,&amp;arr[<span class="number">5</span>]);    <span class="comment">//以区间[beg;end)做为初值的vector</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;当前元素数量&quot;</span>&lt;&lt;v5.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1大小是否为0:&quot;</span>&lt;&lt; (v1.<span class="built_in">empty</span>()?<span class="string">&quot;空&quot;</span>:<span class="string">&quot;不空&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2大小是否为0:&quot;</span>&lt;&lt; (v2.<span class="built_in">empty</span>()?<span class="string">&quot;空&quot;</span>:<span class="string">&quot;不空&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1可容纳的元素最大数量:&quot;</span>&lt;&lt;v1.<span class="built_in">max_size</span>()&lt;&lt;endl;    <span class="comment">//电脑内存4GB</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2可容纳的元素最大数量:&quot;</span>&lt;&lt;v2.<span class="built_in">max_size</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2重新分配前所能容纳的元素最大数:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">20</span>); <span class="comment">//给v2重新分配20个空间</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v2.reserve(20)后重新分配前所能容纳的元素最大数:&quot;</span>&lt;&lt;v2.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v3 v4是否相等:&quot;</span>&lt;&lt;(v3==v4 ? <span class="string">&quot;相等&quot;</span>:<span class="string">&quot;不等&quot;</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">11</span>);<span class="comment">//在尾部添加一个元素1</span></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">22</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器是随机存取迭代器，对vector来说就是指针，迭代器持续有效</span></span><br><span class="line">    <span class="comment">//除非在一个较小索引位置插入删除元素或者内存重新分配</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator ita; <span class="comment">//声明一个迭代器</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(), i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)<span class="comment">//v1.begin()指向v1的第一个元素，v1.end()指向最后元素的下一位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    v1.<span class="built_in">pop_back</span>();<span class="comment">//在尾部删除一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟v1.begin()和v1.end()对应的有v1.rbegin()和v1.rend(),</span></span><br><span class="line">    <span class="comment">//v1.begin()指向逆向的第一个元素，v1.end()指向逆向最后元素的下一位置，使用    vector&lt;int&gt;::reverse_iterator ita;</span></span><br><span class="line"></span><br><span class="line">    v2=v1; <span class="comment">//将v1的元素全部拷到v2</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v2.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v2.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v2中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v2[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//v2.clear();</span></span><br><span class="line">    v2.<span class="built_in">assign</span>(<span class="number">3</span>,<span class="number">44</span>);    </span><br><span class="line">    <span class="keyword">for</span>(ita=v2.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v2.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v2中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v2[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    v2.<span class="built_in">assign</span>(arr,&amp;arr[<span class="number">5</span>]);    </span><br><span class="line">    <span class="keyword">for</span>(ita=v2.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v2.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v2中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v2[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="comment">//swap(v1,v2);</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1第2个元素&quot;</span>&lt;&lt;v1.<span class="built_in">at</span>(<span class="number">1</span>)&lt;&lt;endl;    <span class="comment">//越界抛出异常</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;v1第6个元素&quot;&lt;&lt;v1[5]&lt;&lt;endl;  //越界，不检查</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1首个元素&quot;</span>&lt;&lt;v1.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;v1最后元素&quot;</span>&lt;&lt;v1.<span class="built_in">back</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos=v1.<span class="built_in">begin</span>();</span><br><span class="line">    v1.<span class="built_in">insert</span>(pos,<span class="number">11</span>);</span><br><span class="line">    <span class="comment">//v1.insert(pos,4,55); //如果直接用就是错的，因为迭代器失效了</span></span><br><span class="line">    <span class="comment">//v1.insert(pos,arr,&amp;arr[5]);</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    pos=v1.<span class="built_in">begin</span>(); <span class="comment">//因为直接用迭代器失效，所以重新声明下</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(++pos); <span class="comment">//删除制定位置</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    pos=v1.<span class="built_in">begin</span>(); </span><br><span class="line">    v1.<span class="built_in">erase</span>(pos,pos+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//v1.resize(5); //将元素数量改成5，如果v1变大，则多的按默认走</span></span><br><span class="line">    v1.<span class="built_in">resize</span>(<span class="number">5</span>,<span class="number">9</span>); <span class="comment">//将元素数量改成5，如果v1变大，则多的赋值成9</span></span><br><span class="line">    <span class="keyword">for</span>(ita=v1.<span class="built_in">begin</span>(),i=<span class="number">0</span>;ita != v1.<span class="built_in">end</span>();i++,ita++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v1中的&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;值:&quot;</span>&lt;&lt;v1[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">clear</span>(); <span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//几种vector声明</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;        <span class="comment">//定义空的vector,int类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(<span class="number">10</span>);    <span class="comment">//产生大小为10的vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>,<span class="number">-1</span>);    <span class="comment">//产生大小为10，并且每个元素都是-1的vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">v4</span>(v3);        <span class="comment">//用一个vector产生一个vecotr</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator new_end;<span class="comment">//相当定义了一个变量，上面为数组类型</span></span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">11</span>);<span class="comment">//在尾部添加一个元素1</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>();<span class="comment">//在尾部删除一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置函数命名</span></span><br><span class="line"><span class="comment">//vector&lt;基类型&gt; 变量名;</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fun1</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p><a href="https://blog.csdn.net/qq_40913465/article/details/109604616?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164672644716780265423095%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164672644716780265423095&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-109604616.pc_search_result_cache&utm_term=C++auto&spm=1018.2226.3001.4187">auto</a></p><ol><li>auto的原理就是根据后面的值，来自己推测前面的类型是什么。</li><li>auto的作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替</li></ol><p>注意</p><h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p>1.用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）</p><p>2.函数和模板参数不能被声明为auto（原因同上）</p><p>3.因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid</p><p>4.定义在一个auto序列的变量必须始终推导成同一类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="number">3.14</span>;  <span class="comment">//double</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">//const char*</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">9</span>);  <span class="comment">//int *</span></span><br><span class="line"><span class="keyword">auto</span> x1 = <span class="number">5</span>, x2 = <span class="number">5.0</span>, x3 = <span class="string">&#x27;r&#x27;</span>;   <span class="comment">//错误，必须是初始化为同一类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> au_a = a;<span class="comment">//自动类型推断，au_a为int类型</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(au_a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="循环中应用"><a href="#循环中应用" class="headerlink" title="循环中应用"></a>循环中应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    string a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:a)&#123;</span><br><span class="line">cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello,world&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// for(auto &amp;c:s);//s为字符串，对于s中的每个字符，c是一个引用，赋值语句将会改变s中字符的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可遍历数组和字符串</span></span><br></pre></td></tr></table></figure><h2 id="reverse-翻转"><a href="#reverse-翻转" class="headerlink" title="reverse 翻转"></a>reverse 翻转</h2><ul><li><p>头文件：<code>#include&lt;algorithm&gt;</code></p></li><li><p>翻转一个vector：</p><p><code>reverse(a.begin(), a.end());</code></p></li><li><p>翻转一个数组，元素存放在下标1~n：</p><p><code>reverse(a + 1, a + 1 + n);</code></p></li></ul><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>最大值比较max(a,b)</p><p>最小值比较min(a,b)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line">res=<span class="built_in">min</span>(a,b);</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">r=<span class="built_in">max</span>(a,b);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl&lt;&lt;r;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><ul><li>(默认)查找字符串中子串最开始出现所在的位置下标，没找到就返回-1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找最开始出现子串的下标</span></span><br><span class="line">string c=<span class="string">&quot;abcpb&quot;</span></span><br><span class="line"><span class="type">char</span> b=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="type">int</span> a=c.<span class="built_in">find</span>(b);<span class="comment">//下标为1，多个子串也是第一个字符出现的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找指定位置之后最开始出现的下标</span></span><br><span class="line">a=c.<span class="built_in">find</span>(b,<span class="number">4</span>)<span class="comment">//下标为4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他方式</span></span><br><span class="line">a=c.<span class="built_in">rfind</span>(b);</span><br><span class="line">a=c.<span class="built_in">find_first_of</span>(b);</span><br><span class="line">a=c.<span class="built_in">find_first_of</span>(b,<span class="number">3</span>);</span><br><span class="line">a=c.<span class="built_in">find_last_of</span>(b);</span><br><span class="line">a=c.<span class="built_in">find_first_not_of</span>(b);</span><br></pre></td></tr></table></figure><p><strong>rfind</strong>()</p><ul><li>反向查找字符串，即找到最后一个与子串匹配的位置</li></ul><p><strong>find_first_of()</strong></p><ul><li>查找子串中的某个字符最先出现的位置。find_first_of()不是全匹配，而find()是全匹配</li><li>find_first_of()也可以约定初始查找的位置：s1.find_first_of(s2, 2) ;</li></ul><p><strong>find_last_of()</strong></p><ul><li>这个函数与find_first_of()功能差不多，只不过find_first_of()是从字符串的前面往后面搜索，而find_last_of()是<strong>从字符串的后面往前面搜索</strong>。</li></ul><p><strong>find_first_not_of</strong>()</p><ul><li>找到第一个不与子串匹配的位置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string c=<span class="string">&quot;abcpb&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> a=c.<span class="built_in">find</span>(b,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="unique"><a href="#unique" class="headerlink" title="unique()"></a>unique()</h2><ul><li>unique函数的去重过程实际上就是<strong>不停的把后面不重复的元素移到前面来，也可以说是用不重复的元素占领重复元素的位置</strong>。</li><li>unique函数通常和erase函数一起使用，来达到删除重复元素的目的。(注：此处的删除是真正的删除，即从容器中去除重复的元素，<strong>容器的长度也发生了变换</strong>；</li><li>unique(a.begin(),a.end()):<strong>左闭右开</strong></li><li>也可以排下序，然后用unique()去重</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"><span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>())</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> a = <span class="built_in">unique</span>(p, p + n) - p;<span class="comment">//对p去重并返回数组长度</span></span><br></pre></td></tr></table></figure><h2 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h2><ul><li>将unique函数返回的值和容器末尾的区间用eraser函数抹除，就完成了去重</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a =&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator new_end;</span><br><span class="line"> </span><br><span class="line">    new_end = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//注意unique的返回值；unique后，数组顺序为：1,3,4,5,6,7,X(代表重复数字，具体哪个不重要）,X。他的返回值就是第一个重复数字的地址，所以，能用erase 实现彻底去重。</span></span><br><span class="line">    a.<span class="built_in">erase</span>(new_end,a.<span class="built_in">end</span>());<span class="comment">//然后将unique函数返回的值和容器末尾的区间用eraser函数抹除，就完成了去重</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;删除重复元素后的 a : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="pair"><a href="#pair" class="headerlink" title="pair()"></a>pair()</h1><p><a href="https://blog.csdn.net/sevenjoin/article/details/81937695?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164740820916780264057962%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164740820916780264057962&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81937695.142%5Ev2%5Epc_search_result_control_group,143%5Ev4%5Eregister&utm_term=c+++pair&spm=1018.2226.3001.4187">pair()</a></p><ul><li>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</li></ul><p>创建和初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// 创建一个空对象anon，两个元素类型都是string</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; word_count;     <span class="comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt; &gt; line;  <span class="comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于vector容器</span></span><br><span class="line">vector&lt; pair &lt;string,<span class="type">int</span>&gt; &gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问第一个元素</span></span><br><span class="line">a.first</span><br><span class="line"><span class="comment">//访问第一个元素</span></span><br><span class="line">a.second</span><br></pre></td></tr></table></figure><ol><li>用sort()排序说明</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>())<span class="comment">//优先排序第一个元素，第一个元素相同再看第二个元素</span></span><br></pre></td></tr></table></figure><p>2.对数组直接添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; a;<span class="comment">//创建</span></span><br><span class="line"><span class="type">int</span> c=<span class="number">1</span>,d=<span class="number">2</span>;</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;c,d&#125;);<span class="comment">//对pair直接后面添加内容</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>vector与pair联用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; a;<span class="comment">//创建</span></span><br><span class="line"><span class="type">int</span> c=<span class="number">1</span>,d=<span class="number">2</span>;</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123;c,d&#125;);<span class="comment">//对pair直接后面添加内容</span></span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; ::iterator iter;<span class="comment">//用iter访问</span></span><br><span class="line"><span class="keyword">for</span>(iter=a.<span class="built_in">begin</span>();iter!=a.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用autode</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter1=a.<span class="built_in">begin</span>();iter1!=a.<span class="built_in">end</span>();iter1++)&#123;</span><br><span class="line">    cout&lt;&lt;iter1-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter1-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><ul><li><h4 id="所有元素都会根据元素的减值自动被排序。"><a href="#所有元素都会根据元素的减值自动被排序。" class="headerlink" title="所有元素都会根据元素的减值自动被排序。"></a>所有元素都会根据元素的减值自动被排序。</h4></li><li><h4 id="map的所有元素都是pair，同时拥有实值-value-和键值-key-。"><a href="#map的所有元素都是pair，同时拥有实值-value-和键值-key-。" class="headerlink" title="map的所有元素都是pair，同时拥有实值(value)和键值(key)。"></a>map的所有元素都是pair，同时拥有实值(value)和键值(key)。</h4></li><li><h4 id="pair的第一个元素会被视为键值，第二个元素会被视为实值。"><a href="#pair的第一个元素会被视为键值，第二个元素会被视为实值。" class="headerlink" title="pair的第一个元素会被视为键值，第二个元素会被视为实值。"></a>pair的第一个元素会被视为键值，第二个元素会被视为实值。</h4></li><li><h4 id="map不允许两个元素拥有相同的键值。"><a href="#map不允许两个元素拥有相同的键值。" class="headerlink" title="map不允许两个元素拥有相同的键值。"></a>map不允许两个元素拥有相同的键值。</h4></li><li><p>键值对与python类似</p></li></ul><p><strong>与pair()区别：</strong>map()不允许有相同键值</p><p><strong>构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt; map &gt;</span><span class="comment">//头文件</span></span></span><br><span class="line">map&lt;string , <span class="type">int</span> &gt;strMap;</span><br><span class="line">map&lt;<span class="type">int</span> ,string &gt;intMap;</span><br><span class="line">map&lt;sring, <span class="type">char</span>&gt;strMap;</span><br><span class="line">map&lt; <span class="type">char</span> ,string&gt;charMap;</span><br><span class="line">map&lt;<span class="type">char</span> ,<span class="type">int</span>&gt;charMap;</span><br><span class="line">map&lt;<span class="type">int</span> ,<span class="type">char</span> &gt;intMap；</span><br></pre></td></tr></table></figure><p>基本操作函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>()     <span class="comment">//返回指向map头部的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>()    <span class="comment">//删除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">count</span>()     <span class="comment">//返回指定元素出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()     <span class="comment">//如果map为空则返回true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>()      <span class="comment">//返回指向map末尾的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">equal_range</span>()  <span class="comment">//返回特殊条目的迭代器对</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">erase</span>()     <span class="comment">//删除一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>()      <span class="comment">//查找一个元素。查的是 健</span></span><br><span class="line"><span class="comment">//当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end()函数的值相同。</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="built_in">get_allocator</span>() <span class="comment">//返回map的配置器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>()     <span class="comment">//插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">key_comp</span>()    <span class="comment">//返回比较元素key的函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lower_bound</span>()  <span class="comment">//返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max_size</span>()    <span class="comment">//返回可以容纳的最大元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rbegin</span>()     <span class="comment">//返回一个指向map尾部的逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rend</span>()      <span class="comment">//返回一个指向map头部的逆向迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()      <span class="comment">//返回map中元素的个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>()      <span class="comment">//交换两个map</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">upper_bound</span>()   <span class="comment">//返回键值&gt;给定元素的第一个位置</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">value_comp</span>()   <span class="comment">//返回比较元素value的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span> ,string&gt; maplive;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,string&gt; <span class="title">value</span><span class="params">(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>)</span></span>;</span><br><span class="line">maplive.<span class="built_in">insert</span>(value);</span><br><span class="line"><span class="comment">//等价于maplive.insert(pair&lt;int,string&gt;(1,&quot;a&quot;));</span></span><br><span class="line"></span><br><span class="line">maplive.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>));</span><br><span class="line">maplive[<span class="number">1</span>]=<span class="string">&quot;a&quot;</span>;<span class="comment">//map中最简单最常用的插入添加！</span></span><br><span class="line"></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; id=&#123;</span><br><span class="line">    &#123;<span class="string">&quot;long&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;ox&quot;</span>,<span class="number">2</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=id[<span class="string">&quot;long&quot;</span>];<span class="comment">//赋键的值1</span></span><br></pre></td></tr></table></figure><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; mapStudent;</span><br><span class="line">    mapStudent[<span class="number">1</span>] =  <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">    mapStudent[<span class="number">2</span>] =  <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">    mapStudent[<span class="number">3</span>] =  <span class="string">&quot;student_three&quot;</span>;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序输出</span></span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::reverse_iterator   iter1;</span><br><span class="line">    <span class="keyword">for</span>(iter1 = mapStudent.<span class="built_in">rbegin</span>(); iter1 != mapStudent.<span class="built_in">rend</span>(); iter1++)&#123;</span><br><span class="line">        cout&lt;&lt;iter1-&gt;first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;iter1-&gt;second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="建立基本数据类型的哈希表"><a href="#建立基本数据类型的哈希表" class="headerlink" title="建立基本数据类型的哈希表"></a>建立基本数据类型的哈希表</h2><p>1.建立基本数据类型的<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C%E8%A1%A8&spm=1001.2101.3001.7020">哈希表</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m; <span class="comment">//&lt;string,string&gt;,&lt;char,char&gt;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-向哈希表中添加元素"><a href="#2-向哈希表中添加元素" class="headerlink" title="2.向哈希表中添加元素"></a>2.向哈希表中添加元素</h2><h3 id="1）Insert函数"><a href="#1）Insert函数" class="headerlink" title="1）Insert函数"></a>1）Insert函数</h3><p><a href="https://so.csdn.net/so/search?q=insert&spm=1001.2101.3001.7020">insert</a> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="2）用数组方法直接添加"><a href="#2）用数组方法直接添加" class="headerlink" title="2）用数组方法直接添加"></a>2）用数组方法直接添加</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="number">3</span>]=<span class="number">30</span>;</span><br><span class="line">m[<span class="number">4</span>]=<span class="number">40</span>;</span><br></pre></td></tr></table></figure><h2 id="3-成员函数"><a href="#3-成员函数" class="headerlink" title="3.成员函数"></a>3.成员函数</h2><h3 id="begin-end-函数"><a href="#begin-end-函数" class="headerlink" title="begin(),end()函数"></a>begin(),end()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">begin</span>() <span class="comment">//指向哈希表的第一个容器</span></span><br><span class="line">m.<span class="built_in">end</span>()  <span class="comment">//指向哈希表的最后一个容器，实则超出了哈希表的范围，为空</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="find-查找函数"><a href="#find-查找函数" class="headerlink" title="find()查找函数"></a>find()查找函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">find</span>(<span class="number">2</span>)  <span class="comment">//查找key为2的键值对是否存在 ,若没找到则返回m.end()</span></span><br><span class="line"><span class="keyword">if</span>(m.<span class="built_in">find</span>(<span class="number">2</span>)!=m.<span class="built_in">end</span>()) <span class="comment">//判断找到了key为2的键值对</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="count-查找函数"><a href="#count-查找函数" class="headerlink" title="count() 查找函数"></a>count() 查找函数</h3><p>查找哈希表中key为3的键值对，返回其数量，为1，则找到，若没找到则返回0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">count</span>(<span class="number">3</span>)  <span class="comment">//返回 1</span></span><br><span class="line">m.<span class="built_in">count</span>(<span class="number">5</span>)   <span class="comment">//返回0</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="size-函数"><a href="#size-函数" class="headerlink" title="size()函数"></a>size()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">size</span>()   <span class="comment">//返回哈希表的大小</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="empty-函数"><a href="#empty-函数" class="headerlink" title="empty()函数"></a>empty()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">empty</span>()  <span class="comment">//判断哈希表是否为空，返回值为true/false</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="clear-函数"><a href="#clear-函数" class="headerlink" title="clear()函数"></a>clear()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">clear</span>()  <span class="comment">//清空哈希表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="swap-函数"><a href="#swap-函数" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>交换两个哈希表中的元素,整个哈希表的键值对全部都交换过去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m1;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m2;</span><br><span class="line">m1.<span class="built_in">swap</span>(m2);</span><br><span class="line"><span class="built_in">swap</span>(m1,m2);</span><br></pre></td></tr></table></figure><h2 id="哈希表的遍历"><a href="#哈希表的遍历" class="headerlink" title="哈希表的遍历"></a>哈希表的遍历</h2><p>哈希表的<a href="https://so.csdn.net/so/search?q=%E9%81%8D%E5%8E%86&spm=1001.2101.3001.7020">遍历</a></p><h3 id="第一种遍历"><a href="#第一种遍历" class="headerlink" title="第一种遍历"></a>第一种遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : count) &#123;</span><br><span class="line"><span class="type">int</span> front = p.first;   <span class="comment">//key</span></span><br><span class="line">    <span class="type">int</span> end = p.second;   <span class="comment">//value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h3 id="第二种遍历"><a href="#第二种遍历" class="headerlink" title="第二种遍历"></a>第二种遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> front = it-&gt;first;   <span class="comment">//key</span></span><br><span class="line">    <span class="type">int</span> end = it-&gt;second;   <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c-中map与unordered-map的区别"><a href="#c-中map与unordered-map的区别" class="headerlink" title="c++中map与unordered_map的区别"></a>c++中map与unordered_map的区别</h2><p><a href="https://blog.csdn.net/luolaihua2018/article/details/109412566?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164956749716780261913745%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164956749716780261913745&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-109412566.142%5Ev7%5Epc_search_result_control_group,157%5Ev4%5Econtrol&utm_term=c++%E5%93%88%E5%B8%8C%E8%A1%A8unordered_map%E4%B8%8Emap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%90%97&spm=1018.2226.3001.4187">c++中map与unordered_map的区别</a></p><ul><li>map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</li><li>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.python数据分析</title>
      <link href="/data.github.io/post/df468e0.html"/>
      <url>/data.github.io/post/df468e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="6、数据分析"><a href="#6、数据分析" class="headerlink" title="6、数据分析"></a>6、数据分析</h1><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="jupyter-代码编辑器"><a href="#jupyter-代码编辑器" class="headerlink" title="jupyter 代码编辑器"></a><a href="https://py.forchangecode.com/?app_id=17&app_type=formal#/scene/%2F%E4%B8%89%E6%AE%B5%E8%AF%BE%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F%E5%85%B3%E5%8D%A1%E4%B8%80%2F%E9%A1%B9%E7%9B%AE%E5%9C%BA%E6%99%AF_%E6%98%8E%E7%A1%AE%E7%9B%AE%E6%A0%87">jupyter 代码编辑器</a></h2><ul><li>专门为数据分析工作而打造的编辑器</li><li>代码的输入以及代码结果的输出都是在 Cell 中实现的</li><li>Cell 一共由两个部分组成：<code>In[]</code> 和 <code>Out[]</code>，即输入框和输出框</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建字典</span></span><br><span class="line">temp_dict = &#123;<span class="string">&#x27;性别&#x27;</span>: [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>], <span class="string">&#x27;年龄&#x27;</span>: [<span class="number">23</span>, <span class="number">22</span>, <span class="number">23</span>], <span class="string">&#x27;成绩&#x27;</span>: [<span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>]&#125;</span><br><span class="line"><span class="comment"># 查看 temp_dict</span></span><br><span class="line">temp_dict<span class="comment">#查看变量值的时候，只要输入变量名就可以了</span></span><br><span class="line">temp_dict[<span class="string">&#x27;成绩&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li><p>重新打开学习系统的时候，系统就会“忘记”之前运行过的变量的值。</p></li><li><p>这个时候就需要点击网页右上角的【运行全部 Cells】按钮，让系统重新“记住”我们所需要用到的变量的值。</p></li></ul><h2 id="pandas-库基础知识"><a href="#pandas-库基础知识" class="headerlink" title="pandas 库基础知识"></a>pandas 库基础知识</h2><ul><li>pandas 库是一个专门用来解决数据分析问题的库</li><li>一般会将 pandas 简化为 pd</li><li>速度快以及效率高。</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250370.png" alt="image-20210817210808985"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Series对象"><a href="#Series对象" class="headerlink" title="Series对象"></a>Series对象</h4><ul><li>主要由一组数据及其对应的索引组成</li><li>dtype: object:其中，dtype 指的是 pandas 库中的数据类型，object 就等价于之前 python 学过的字符串类</li></ul><p>创建Series对象</p><ul><li>格式：pd.Series()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建Series对象</span></span><br><span class="line">surname = pd.Series([<span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;钱&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;李&#x27;</span>])</span><br><span class="line"><span class="comment"># 查看surname</span></span><br><span class="line"><span class="built_in">print</span>(surname)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">surname = pd.Series([<span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;钱&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;李&#x27;</span>], index = [<span class="string">&#x27;学生1&#x27;</span>, <span class="string">&#x27;学生2&#x27;</span>, <span class="string">&#x27;学生3&#x27;</span>, <span class="string">&#x27;学生4&#x27;</span>])</span><br><span class="line"><span class="comment">#index人为设定对象索引</span></span><br><span class="line"><span class="built_in">print</span>(surname)</span><br></pre></td></tr></table></figure><table><thead><tr><th>备注</th><th>例子</th></tr></thead><tbody><tr><td>字典</td><td>pd.Series([‘赵’, ‘钱’, ‘孙’, ‘李’]）</td></tr><tr><td>标量</td><td>pd.Series(5)</td></tr><tr><td>n维数组</td><td>import numpy as np;pd.Series(np.array([1,2]))</td></tr><tr><td>字符串</td><td>pd.Series(“hello “)</td></tr></tbody></table><h4 id="DataFrame-对象"><a href="#DataFrame-对象" class="headerlink" title="DataFrame 对象"></a>DataFrame 对象</h4><ul><li>DataFrame对象是一种表格型的数据结构，包含行索引、列索引以及一组数据。</li></ul><p>创建DataFrame对象</p><ul><li>pd.DataFrame(data)</li><li>当我们给参数 data 传入字典的时候，<strong>字典的键</strong>会变成 DataFrame 对象的<strong>列索引</strong>，字典的<strong>键所对应的值</strong>会变成 DataFrame <strong>对象的数据</strong>。</li><li>传入的字典的各个键所对应的值长度一定相等；否则会报错</li><li>对象[‘键名’]：通过列索引——–是Series对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line">new_df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>: [<span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>],</span><br><span class="line">                       <span class="string">&#x27;岗位&#x27;</span>: [<span class="string">&#x27;客服&#x27;</span>, <span class="string">&#x27;运营&#x27;</span>, <span class="string">&#x27;公关&#x27;</span>],</span><br><span class="line">                       <span class="string">&#x27;年购买量&#x27;</span>: [<span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>]&#125;)<span class="comment">#键所对应得值长度都为3</span></span><br><span class="line"><span class="comment"># 查看 new_df</span></span><br><span class="line"><span class="built_in">print</span>(new_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_df[<span class="string">&#x27;年龄&#x27;</span>])<span class="comment">#通过列索引</span></span><br></pre></td></tr></table></figure><ul><li>n 维数组的方式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">class_df2 = pd.DataFrame(np.array([[<span class="number">25</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                                   [<span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                                   [<span class="number">23</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                                   [<span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>]]),</span><br><span class="line">                         columns = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>],</span><br><span class="line">                         index = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># 查看 class_df2</span></span><br><span class="line"><span class="built_in">print</span>(class_df2)</span><br></pre></td></tr></table></figure><ul><li>分析流程：明确目标、数据处理、数据分析、数据展现以及报告撰写</li></ul><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><ul><li>pd.read_csv(path, encoding) 就是其中一种高效读取 csv 文件的方法，返回的是一个 DataFrame 对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line"><span class="comment"># 导入 csv 数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_data)<span class="comment">#行数列数也看得到</span></span><br></pre></td></tr></table></figure><h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><ul><li><p>数据处理步骤：数据清洗、数据整理、数据写入</p></li><li><p>在 pandas 库中，NaN 代表缺失值，意思是这里的数据是空的。</p></li></ul><h4 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h4><ul><li>**df.info()**：可查看数据情况–数据总结</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line"><span class="comment"># 导入 csv 数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_data)</span><br><span class="line">my_data.info()<span class="comment">#查看数据情况</span></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250336.png" alt="image-20210817212424956"></p><h5 id="查找缺失值"><a href="#查找缺失值" class="headerlink" title="查找缺失值"></a>查找缺失值</h5><ul><li>isna() 方法来查找 DataFrame 对象以及 Series 对象中的缺失值</li><li>缺失数据会用 True 来表示，False 则代表这里的数据不缺失</li><li>，还可以使用<code>df.head()</code>或<code>df.tail()</code>方法查看数据。</li><li>DataFrame 对象使用 df.head() 方法默认可以查看数据的前 5 行，df.tail() 方法则默认可以查看数据的后 5 行；</li><li>df.head(i)中i代表常看前i行；df.tail(i) 中i代表常看后i行</li><li>NaN 代表的就是缺失数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_data.isna())<span class="comment">#查找缺失值</span></span><br><span class="line"><span class="built_in">print</span>(my_data.tail())<span class="comment">#查看数据后5行</span></span><br><span class="line"><span class="comment"># 删除所有缺失值</span></span><br><span class="line"><span class="built_in">print</span>(my_data.dropna())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看&#x27;明细&#x27;一列含有缺失值的数据</span></span><br><span class="line">exercise[exercise[<span class="string">&#x27;明细&#x27;</span>].isna()]</span><br></pre></td></tr></table></figure><h5 id="删除缺失值"><a href="#删除缺失值" class="headerlink" title="删除缺失值"></a>删除缺失值</h5><ul><li>只要执行 df.dropna() 这一代码方法，就可以将 DataFrame 对象中包含缺失值的每一行全部删掉</li><li>刚才我们运行的 <code>mask_data.dropna()</code> 代码返回的是一个删掉所有缺失数据的 DataFrame 对象，但这并不意味着它修改了 mask_data 数据。</li><li>我们需要将 mask_data.dropna() 的运行结果重新赋值给 mask_data 变量，这样就可以将运行结果保存下来</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 DataFrame 对象</span></span><br><span class="line"><span class="comment"># 导入 csv 数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\mask_data.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 删除所有缺失值</span></span><br><span class="line">my_data=my_data.dropna()<span class="comment">#删去缺失值重新赋值</span></span><br><span class="line"><span class="built_in">print</span>(my_data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>针对某几列的缺失数据进行删除</strong><ul><li>对象。dropna(subset&#x3D;[‘所删除列名’])</li><li>test_data 中’品牌’、’上牌时间’、 ‘里程数(km)’和 ‘保值率’四列数据缺失的行，可以如下书写代码：</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_data.dropna(subset=[<span class="string">&#x27;品牌&#x27;</span>, <span class="string">&#x27;上牌时间&#x27;</span>, <span class="string">&#x27;里程数(km)&#x27;</span>, <span class="string">&#x27;保值率&#x27;</span>])</span><br></pre></td></tr></table></figure><h5 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h5><ul><li>DataFrame对象和Series对象都可以使用**fillna()**的方法给缺失值填充数据。</li><li>只需要将要填充的数据作为参数写在括号内，就能把所有缺失值都替换成括号里的数据</li><li>有些缺失数据我们最好不要删除，因为它们依然有很强的分析价值，这时会用填充缺失值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换&#x27;明细&#x27;中的缺失值为&#x27;矿泉水&#x27;</span></span><br><span class="line">exercise[<span class="string">&#x27;明细&#x27;</span>] = exercise[<span class="string">&#x27;明细&#x27;</span>].fillna(<span class="string">&#x27;矿泉水&#x27;</span>)</span><br><span class="line"><span class="comment"># 查看exercise的基本信息总结</span></span><br><span class="line">exercise.info()</span><br></pre></td></tr></table></figure><h4 id="处理重复值"><a href="#处理重复值" class="headerlink" title="处理重复值"></a>处理重复值</h4><ul><li>查找重复行<ul><li>使用 <strong>df.duplicated()</strong> 方法会返回一个 Series 对象，找出所有重复值。重复为 True，不重复为 Falsel</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask_data.duplicated()<span class="comment">#查找重复行</span></span><br></pre></td></tr></table></figure><ul><li>可以将 **mask_data.duplicated()**返回的结果放入中括号 [] 中，用来索引 mask_data 数据，查看 mask_data 数据中重复的行。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 mask_data 中的重复数据</span></span><br><span class="line">mask_data[mask_data.duplicated()]<span class="comment">#用print打印</span></span><br></pre></td></tr></table></figure><ul><li>可以使用 pandas 库的 <strong>df.drop_duplicates()</strong> 方法直接删除 DataFrame 对象中重复出现的整行数据。<ul><li>df.drop_duplicates() 方法删除的也都是重复出现的行，因此所有重复数据的第一行都会保留</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接删除所有重复值</span></span><br><span class="line">mask_data = mask_data.drop_duplicates()</span><br><span class="line"><span class="comment"># 查看 mask_data 中的重复数据</span></span><br><span class="line">mask_data[mask_data.duplicated()]</span><br></pre></td></tr></table></figure><h4 id="处理异常值"><a href="#处理异常值" class="headerlink" title="处理异常值"></a>处理异常值</h4><ul><li>检查异常值 <strong>describe()</strong><ul><li>describe() 方法返回出来的统计信息分别代表数值型数据的频数统计、平均值、标准差、最小值、第一四分位数、中位数、第三四分位数以及最大值。</li><li>e+n 代表的是 10 的 n 次方</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask_data.describe()</span><br></pre></td></tr></table></figure><ul><li><h3 id="抽取数据范围"><a href="#抽取数据范围" class="headerlink" title="抽取数据范围"></a><strong>抽取数据范围</strong></h3><ul><li>单价一列小于等于 200 的数据，就可以设置条件表达式 mask_data[‘单价’] &lt;&#x3D; 200</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看单价小于等于 200 的数据</span></span><br><span class="line">mask_data[mask_data[<span class="string">&#x27;单价&#x27;</span>] &lt;= <span class="number">200</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h3><ul><li>指的是我们在数据分析前对所需字段进行数据排序、数据转换、数据抽取、数据合并、数据计算等准备操作</li><li><code>字段</code>指的是表格的列，像我们这次分析的数据就包含 ‘订单编号’、’日期’、’省’……等字段。</li></ul><h4 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h4><ul><li>专门储存时间日期的数据类型，可以直接从中提取想要的时间单位</li></ul><h5 id="转换日期数据"><a href="#转换日期数据" class="headerlink" title="转换日期数据"></a>转换日期数据</h5><ul><li>pandas 库中我们可以使用 <code>pd.to_datetime(arg, format)</code> 来将 <code>DataFrame</code> 对象或者 <code>Series</code> 对象的数据类型转换成 datetime 类型。</li><li><code>arg</code> 参数为我们要转换的数据，它可以是 DataFrame 对象或 Series 对象</li><li>mask_data 中的’日期’字段，所以对应的 arg 参数就是 mask_data[‘日期’]。</li><li>format 参数为 datetime 类型的日期格式，比如说这份数据，它是以年-月-日的形式出现的，那么它对应的 format 就是 ‘%Y-%m-%d’（year-month-day的缩写）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.to_datetime(mask_data[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span> = <span class="string">&#x27;%Y-%m-%d&#x27;</span>)<span class="comment">#提取mask_data中的日期</span></span><br></pre></td></tr></table></figure><ul><li>人提取日期信息<ul><li>获取这份数据的年、月、日的信息，可以通过 <strong>Series.dt.year</strong><code>、</code><strong>Series.dt.month</strong><code>以及</code><strong>Series.dt.day</strong>来获取</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换日期数据，并设置对应的日期格式</span></span><br><span class="line">date_data = pd.to_datetime(mask_data[<span class="string">&#x27;日期&#x27;</span>], <span class="built_in">format</span> = <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"><span class="comment"># 提取日期数据中的月份信息</span></span><br><span class="line">month_data = date_data.dt.month</span><br><span class="line"><span class="comment"># 查看 month_data</span></span><br><span class="line"><span class="built_in">print</span>(month_data)</span><br></pre></td></tr></table></figure><ul><li>添加新的一列<ul><li>df[‘colname’] &#x3D; Series的方式来为原数据添加新的一列：colname 指的是要添加的新列的列名</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask_data[<span class="string">&#x27;月份&#x27;</span>] = month_data<span class="comment">#month_data为提取的一列</span></span><br></pre></td></tr></table></figure><h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><ul><li>df.to_csv(‘路径’，编码)方法</li><li>可以生成新文件</li><li>pandas 库将 csv 文件读取为 DataFrame对象 时都会自动生成行索引。；默认值为 True，会让你写入的 csv 文件包含一列行索引</li><li>把这个参数设置为 index &#x3D; False 就可以取消写入行索引，不用将行索引那一列写入 csv 文件。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask_data.to_csv(<span class="string">&#x27;./工作/mask_data_clean.csv&#x27;</span>, encoding = <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存清洗干净的数据，并取消写入行索引</span></span><br><span class="line">mask_data.to_csv(<span class="string">&#x27;./工作/mask_data_clean.csv&#x27;</span>, index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250361.png" alt="image-20210818174059829"></p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><ul><li>分组聚合操作指的是按照某项规则对数据进行分组，接着对分完组的数据执行总结统计的操作（求和、平均值等）</li></ul><h3 id="单层分组聚合操作"><a href="#单层分组聚合操作" class="headerlink" title="单层分组聚合操作"></a>单层分组聚合操作</h3><ul><li><strong>df.groupby(by)[‘列索引’].mean()</strong></li><li>返回Series对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建DataFrame对象</span></span><br><span class="line">grade_df = pd.DataFrame(&#123;<span class="string">&#x27;班级&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">                         <span class="string">&#x27;性别&#x27;</span>: [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;眼镜&#x27;</span>: [<span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;成绩&#x27;</span>: [<span class="number">95</span>, <span class="number">90</span>, <span class="number">96</span>, <span class="number">92</span>, <span class="number">94</span>, <span class="number">85</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">86</span>]&#125;)</span><br><span class="line"><span class="comment"># 查看grade_df</span></span><br><span class="line"><span class="built_in">print</span>(grade_df)</span><br><span class="line">grade_df1 = grade_df.groupby(<span class="string">&#x27;班级&#x27;</span>)[<span class="string">&#x27;成绩&#x27;</span>].mean()<span class="comment">#求班级的平均分</span></span><br><span class="line"><span class="comment"># 查看grade_df1</span></span><br><span class="line"><span class="built_in">print</span>(grade_df1)</span><br></pre></td></tr></table></figure><ul><li>单层分组操作<ul><li>分组操作：dfgroupdy(by)</li><li>参数 <code>by</code> 代表了我们想要对哪一列数据进行分组操作</li></ul></li><li>聚合操作 <ul><li>[‘列索引’].mean</li><li>‘列索引’指的是需要对哪一列数据进行聚合操作</li><li>mean() 指的是求平均值</li></ul></li></ul><h4 id="常见聚合操作"><a href="#常见聚合操作" class="headerlink" title="常见聚合操作"></a>常见聚合操作</h4><table><thead><tr><th>流程</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>求最小值</td><td>min()</td><td>一组数据最小值</td></tr><tr><td>求最大值</td><td>max()</td><td>一组数据的最大值</td></tr><tr><td>求标准差</td><td>std()</td><td>一组数据的标准差</td></tr><tr><td>求平均值</td><td>mean()</td><td>一组数据的总和除以一组数据的个数</td></tr><tr><td>求中位数</td><td>mendian()</td><td>—组数据中处于中间位置的数</td></tr><tr><td>求总和</td><td>sum()</td><td>一组数据的总和</td></tr><tr><td>求数量</td><td>count()</td><td>一组数据的非空数据的个数</td></tr><tr><td>求频数分布</td><td>value_counts()</td><td>一组数据各个类别出现的次数</td></tr></tbody></table><h3 id="多层分组聚合操作"><a href="#多层分组聚合操作" class="headerlink" title="多层分组聚合操作"></a>多层分组聚合操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 获取不同班级下不同性别的学生的平均分</span></span><br><span class="line">grade_df3 = grade_df.groupby([<span class="string">&#x27;班级&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>])[<span class="string">&#x27;成绩&#x27;</span>].mean()</span><br><span class="line"><span class="comment"># 查看grade_df3</span></span><br><span class="line">grade_df3</span><br></pre></td></tr></table></figure><ul><li>格式：df.groupby(by)[‘列索引’].mean()。</li><li>多层分组聚合操作需要传多个列索引给参数 by</li></ul><h4 id="s-unstack-函数"><a href="#s-unstack-函数" class="headerlink" title="s.unstack() 函数"></a>s.unstack() 函数</h4><ul><li>可以将一个多层分组聚合后的 Series 对象转变成 DataFrame 对象</li><li>作用就是将其索引的最后一列转变成 DataFrame 对象的列索引，而剩下的索引则转变成 DataFrame 对象的行索引。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建DataFrame对象</span></span><br><span class="line">grade_df = pd.DataFrame(&#123;<span class="string">&#x27;班级&#x27;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">                         <span class="string">&#x27;性别&#x27;</span>: [<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;女&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;眼镜&#x27;</span>: [<span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;是&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>, <span class="string">&#x27;否&#x27;</span>],</span><br><span class="line">                         <span class="string">&#x27;成绩&#x27;</span>: [<span class="number">95</span>, <span class="number">90</span>, <span class="number">96</span>, <span class="number">92</span>, <span class="number">94</span>, <span class="number">85</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">86</span>]&#125;)</span><br><span class="line"><span class="comment"># 查看grade_df</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取不同班级、不同性别、戴与不戴眼镜的学生的最高分</span></span><br><span class="line">grade_df5 = grade_df.groupby([<span class="string">&#x27;班级&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;眼镜&#x27;</span>])[<span class="string">&#x27;成绩&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"><span class="comment"># 查看grade_df5</span></span><br><span class="line"><span class="built_in">print</span>(grade_df5)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(grade_df5.unstack())</span><br></pre></td></tr></table></figure><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="matplotlib-库"><a href="#matplotlib-库" class="headerlink" title="matplotlib 库"></a>matplotlib 库</h2><ul><li><p>pandas 库是根据一个更加底层的绘图库——matplotlib，封装而来</p></li><li><p>设置中文字体</p><ul><li>plt.rcParams[‘font.family’] 可以获取 matplotlib 库中的字体，’SimHei’ 指的是我们windows系统自带的中文字体</li><li>windows</li></ul><table><thead><tr><th>中文字体</th><th>英文名</th></tr></thead><tbody><tr><td>黑体</td><td>SimHei</td></tr><tr><td>宋体</td><td>SimSun</td></tr><tr><td>新宋体</td><td>NSimSun</td></tr><tr><td>仿宋</td><td>FangSong</td></tr><tr><td>楷体</td><td>KaiTI</td></tr></tbody></table></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line">li_jian = pd.Series([<span class="number">80</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">91</span>, <span class="number">88</span>, <span class="number">95</span>],</span><br><span class="line">                    index=[<span class="string">&#x27;2月&#x27;</span>, <span class="string">&#x27;3月&#x27;</span>, <span class="string">&#x27;4月&#x27;</span>, <span class="string">&#x27;5月&#x27;</span>, <span class="string">&#x27;6月&#x27;</span>, <span class="string">&#x27;7月&#x27;</span>])</span><br><span class="line"><span class="comment"># 绘制单条折线图</span></span><br><span class="line">li_jian.plot(kind=<span class="string">&#x27;line&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;李健月考成绩&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure><ul><li>windows</li></ul><table><thead><tr><th>中文字体</th><th>英文名</th></tr></thead><tbody><tr><td>黑体</td><td>SimHei</td></tr><tr><td>宋体</td><td>SimSun</td></tr><tr><td>新宋体</td><td>NSimSun</td></tr><tr><td>仿宋</td><td>FangSong</td></tr><tr><td>楷体</td><td>KaiTI</td></tr></tbody></table><h3 id="绘制单条折线图"><a href="#绘制单条折线图" class="headerlink" title="绘制单条折线图"></a>绘制单条折线图</h3><ul><li><strong>s.plot()</strong></li></ul><table><thead><tr><th>参数</th><th>说明</th><th>参数值类型（常用）</th><th>示例</th></tr></thead><tbody><tr><td>kind</td><td>设置图表类型</td><td>字符串</td><td>kind&#x3D;’line’</td></tr><tr><td>figsize</td><td>设置图标大小</td><td>元组</td><td>figsize&#x3D;(7,6)   注：左宽，右高</td></tr><tr><td>title</td><td>设置图标标题</td><td>字符串</td><td>title&#x3D;’中国’</td></tr><tr><td>use_indx</td><td>是否要用行索引作为x轴的刻度值</td><td>布尔值</td><td>use_index&#x3D;False</td></tr><tr><td>xticks</td><td>设置横坐标的值</td><td>序列</td><td>xticks&#x3D;[0]</td></tr><tr><td>yticks</td><td>设置做纵坐标的值</td><td>序列</td><td>yticks&#x3D;[90]</td></tr><tr><td>rot</td><td>设置刻度值的旋转角度</td><td>整数</td><td>rot&#x3D;30</td></tr><tr><td>fontsize</td><td>设置刻度值的字体大小</td><td>整数</td><td>fontsize&#x3D;20</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li_jian.plot(kind=<span class="string">&#x27;line&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;李健月考成绩&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="多条折线图"><a href="#多条折线图" class="headerlink" title="多条折线图"></a>多条折线图</h3><ul><li>多条折线图是针对一个 DataFrame 对象来绘制的，而单条折线图是针对一个 Series 对象来绘制的。</li><li>df.plot()</li><li>观察折线图，有三个要点，一是整体的走势，二是走势的规律性，三是走势的波动。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line"><span class="comment"># 创建三位学生成绩的df</span></span><br><span class="line">students_grade = pd.DataFrame(&#123;<span class="string">&#x27;李健&#x27;</span>: [<span class="number">80</span>, <span class="number">85</span>, <span class="number">89</span>, <span class="number">91</span>, <span class="number">88</span>, <span class="number">95</span>],</span><br><span class="line">                               <span class="string">&#x27;王聪&#x27;</span>: [<span class="number">95</span>, <span class="number">92</span>, <span class="number">90</span>, <span class="number">85</span>, <span class="number">75</span>, <span class="number">80</span>],</span><br><span class="line">                               <span class="string">&#x27;过凡&#x27;</span>: [<span class="number">90</span>, <span class="number">91</span>, <span class="number">92</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">91</span>]</span><br><span class="line">                              &#125;, index=[<span class="string">&#x27;2月&#x27;</span>, <span class="string">&#x27;3月&#x27;</span>, <span class="string">&#x27;4月&#x27;</span>, <span class="string">&#x27;5月&#x27;</span>, <span class="string">&#x27;6月&#x27;</span>, <span class="string">&#x27;7月&#x27;</span>])</span><br><span class="line"><span class="comment"># 绘制多条折线图</span></span><br><span class="line">students_grade.plot(kind=<span class="string">&#x27;line&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;月考成绩&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure><h3 id="其他图形拓展"><a href="#其他图形拓展" class="headerlink" title="其他图形拓展"></a>其他图形拓展</h3><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><ul><li>主要可以用来反映数据的占比情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;./工作/clean_data.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取行业的频率分布</span></span><br><span class="line">profession = my_data[<span class="string">&#x27;行业&#x27;</span>].value_counts()/my_data[<span class="string">&#x27;行业&#x27;</span>].value_counts().<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 绘制行业频率分布的饼图</span></span><br><span class="line">profession.plot(kind=<span class="string">&#x27;pie&#x27;</span>, autopct=<span class="string">&#x27;%.2f%%&#x27;</span>, figsize=(<span class="number">7</span>, <span class="number">7</span>), title=<span class="string">&#x27;行业频率分布图&#x27;</span>, label=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure><ul><li>函数plt.pie()函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置扇形面积值</span></span><br><span class="line">x = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"><span class="comment"># 设置百分比小数的位数：保留百分比小数点后两位</span></span><br><span class="line">autopct=<span class="string">&#x27;%.2f%%&#x27;</span></span><br><span class="line"><span class="comment"># 设置百分比字体大小和颜色</span></span><br><span class="line">textprops = &#123;<span class="string">&#x27;fontsize&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;black&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 设置饼图的“爆炸效果”：让扇形远离圆心</span></span><br><span class="line">explode = [<span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 设置不同扇形的颜色</span></span><br><span class="line">colors = [<span class="string">&#x27;cornflowerblue&#x27;</span>, <span class="string">&#x27;salmon&#x27;</span>, <span class="string">&#x27;yellowgreen&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line"><span class="comment"># 绘制饼图</span></span><br><span class="line">plt.pie(x, autopct=autopct, textprops=textprops,</span><br><span class="line">        explode=explode, colors=colors)</span><br><span class="line"><span class="comment"># 设置图表标题名及字体大小</span></span><br><span class="line">plt.title(<span class="string">&#x27;闪光科技2020年各季度研发费用占比饼图&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置图例</span></span><br><span class="line">plt.legend([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>]) </span><br><span class="line"></span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250229.png" alt="image-20210820215528507"></p><h4 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h4><ul><li>主要可以用来反映不同数据值的差异性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入matplotlib库的pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 设置中文字体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建李健的数据</span></span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">my_data = pd.read_csv(<span class="string">&#x27;./工作/clean_data.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取岗位的频率分布</span></span><br><span class="line">position = my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts()/my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts().<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 绘制岗位的频率分布条形图</span></span><br><span class="line">position.plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">13</span>, <span class="number">6</span>), title=<span class="string">&#x27;岗位频率分布条形图&#x27;</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"><span class="comment"># 获取岗位的频率分布</span></span><br><span class="line">position = my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts()/my_data[<span class="string">&#x27;岗位&#x27;</span>].value_counts().<span class="built_in">sum</span>()</span><br><span class="line"><span class="comment"># 绘制岗位的频率分布条形图</span></span><br><span class="line">position.plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">13</span>, <span class="number">6</span>), title=<span class="string">&#x27;岗位频率分布条形图&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250384.png" alt="image-20210820220044211"></p><ul><li>从应用范围上来看，在 python 数据分析领域，matplotlib 库是与 numpy 库、pandas 库并驾齐驱的三库之一，被称作 python 数据分析的“三剑客”，由此可见其应用范围之广。</li><li>个完整的图形除了图表，还包括一系列的图表元素：图表标题、坐标轴刻度、坐标轴标题、图例以及数据标签。</li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>设置画布大小 ：<strong>plt.figure()</strong></p><ul><li>元组形式:plt.figure(figsize&#x3D;(6,6))</li></ul><p>对画布进行保存：<strong>plt.savefig()</strong></p><ul><li>plt.savefig(‘路径’)</li></ul><h3 id="绘制折线图"><a href="#绘制折线图" class="headerlink" title="绘制折线图"></a>绘制折线图</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250815.png" alt="image-20210820221407062"></p><ul><li>颜色</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250816.png" alt="image-20210820221516449"></p><ul><li>marker参数</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250314.png" alt="image-20210820221620572"></p><ul><li><strong>plt.plot()函数</strong><ul><li>color 参数表示图表的颜色</li><li>plt.plot(x,y,color&#x3D;’颜色’)</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))<span class="comment">#设置画布大小</span></span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#plt.plot(x, y, color=&#x27;dodgerblue&#x27;)# 绘制折线图，并调整线条颜色为湖蓝色</span></span><br><span class="line">plt.plot(x, y,linewidth=<span class="number">2</span>,color=<span class="string">&#x27;dodgerblue&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,markerfacecolor=<span class="string">&#x27;red&#x27;</span>,markersize=<span class="number">8</span>)</span><br><span class="line"><span class="comment">#plt.savefig(&#x27;C:\\Users\\win10\\Desktop\\电工\\各月总订单量趋势图.png&#x27;)--保存图片</span></span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="柱状图绘制"><a href="#柱状图绘制" class="headerlink" title="柱状图绘制"></a>柱状图绘制</h3><ul><li><strong>plt.bar()函数</strong><ul><li>plt.bar()的参数是 x 和 height，height 表示柱子的高(对应 y 坐标值）； alpha 参数表示图表的透明度</li><li>plt.bar(x,height&#x3D;y,color&#x3D;’颜色’,alpha&#x3D;c)</li><li>c为0到1</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"><span class="comment"># 绘制柱状图，并调整颜色为深橘色，透明度为 60%</span></span><br><span class="line">plt.bar(x, height=y, color=<span class="string">&#x27;darkorange&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250770.png" alt="image-20210820223956663"></p><h3 id="设置图标标题，坐标轴"><a href="#设置图标标题，坐标轴" class="headerlink" title="设置图标标题，坐标轴"></a>设置图标标题，坐标轴</h3><h4 id="plt-title-函数"><a href="#plt-title-函数" class="headerlink" title="plt.title()函数"></a><strong>plt.title()函数</strong></h4><ul><li>plt.title(lable,fontsize&#x3D;None)</li><li>label表示标题，为字符串类型；fontsize为字体大小，为数值类型</li><li>还可用fontdict代替fontsize</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250818.png" alt="image-20210820164926230"></p><ul><li>width 则需要传入(0, 1]区间 (大于 0，小于等于 1) 内的浮点数，数值越大表示柱子的宽度越宽；当 width 的值为 1 时，柱子之间的间隙就为 0。</li><li>参数 alpha可以设置柱子颜色的透明度，需要传入(0, 1]区间内的浮点数，数值越小，表示柱子颜色越浅；相反，则越深。适当地调整颜色深浅，可以提升视觉舒适度。</li></ul><h4 id="设置坐标轴刻度"><a href="#设置坐标轴刻度" class="headerlink" title="设置坐标轴刻度"></a>设置坐标轴刻度</h4><ul><li>坐标轴刻度，设置 x、y 轴刻度的函数分别是 plt.xticks()和 plt.yticks()。</li><li>调用这两个函数，就可以根据 x、y 坐标值自动生成 x、y 轴刻度字体大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xticks(fontsize=<span class="number">12</span>, rotation=<span class="number">90</span>)<span class="comment"># 设置坐标轴的刻度字体大小，逆时针旋转x轴刻度90度</span></span><br><span class="line">plt.yticks(fontsize=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h4 id="坐标轴标题"><a href="#坐标轴标题" class="headerlink" title="坐标轴标题"></a>坐标轴标题</h4><ul><li><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251763.png" alt="image-20210820165429945"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;闪光科技2020年各季度研发费用分布图&#x27;</span>, fontdict=&#123;</span><br><span class="line">        <span class="string">&#x27;family&#x27;</span>: <span class="string">&#x27;SimHei&#x27;</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;size&#x27;</span>: <span class="number">16</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">plt.bar(x, height=y, color=<span class="string">&#x27;darkorange&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;季度&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line"><span class="comment"># 设置 x、y 轴标题分别为&#x27;季度&#x27;、&#x27;研发费用（百万元）&#x27;，字体大小均为 15</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;研发费用（百万元）&#x27;</span>,fontsize=<span class="number">15</span>)</span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br></pre></td></tr></table></figure><h4 id="设置图例"><a href="#设置图例" class="headerlink" title="设置图例"></a>设置图例</h4><ul><li>设置图例用到 **plt.legend()**函数，其中的参数labels表示图例名称，对应图中的多个条件，通常传入可迭代对象，比如列表、Series 对象等。</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251987.png" alt="image-20210820213925177"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.legend([<span class="string">&#x27;变化&#x27;</span>，<span class="string">&#x27;分布&#x27;</span>])</span><br></pre></td></tr></table></figure><h4 id="设置数据标签"><a href="#设置数据标签" class="headerlink" title="设置数据标签"></a>设置数据标签</h4><ul><li>调用 plt.text()函数可以在图表的指定位置添加文本，但是每次只能添加一个。</li><li>这里需要重点强调 x、y 的用法，x、<code>y</code> 表示所添加文本的位置，受到函数本身的属性限制，常见为数值或者字符串类型，这与绘图函数中 x、y 可以传入可迭代对象有很大的差异。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.text(<span class="string">&#x27;第三季度&#x27;</span>, <span class="number">68</span>, <span class="number">68</span>, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>, fontsize=<span class="number">12</span>)<span class="comment">#只给第三季度设置数据标签</span></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251708.png" alt="image-20210820214155006"></p><ul><li><p><strong>zip（）函数</strong></p><ul><li><p>zip(x,y)</p></li><li><p>你可以将 <code>zip()</code>函数理解为拉链，<code>x=(x1, x2, x3,……, xn)</code>为拉链的左边，<code>y=(y1, y2, y3,……, yn)</code>为拉链的右边，经过 <code>zip()</code>函数，就合并为<code>(x1, y1), (x2, y2), (x3, y3),……,(xn, yn)</code>。</p></li><li><p><code>zip()</code>函数可以从 x、y 元素序列中依次取出元素，按照顺序进行一对一匹配。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt<span class="comment"># 导入 matplotlib 库下的 pyplot 模块并且将其简化为 plt</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]<span class="comment"># 设置中文字体</span></span><br><span class="line"><span class="comment"># 设置 x/y 坐标值</span></span><br><span class="line">x = pd.Series([<span class="string">&#x27;第一季度&#x27;</span>, <span class="string">&#x27;第二季度&#x27;</span>, <span class="string">&#x27;第三季度&#x27;</span>, <span class="string">&#x27;第四季度&#x27;</span>])</span><br><span class="line">y = pd.Series([<span class="number">59</span>, <span class="number">70</span>, <span class="number">68</span>, <span class="number">56</span>])</span><br><span class="line"><span class="comment"># 生成画布，并设置画布的大小</span></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">plt.bar(x, height=y, color=<span class="string">&#x27;darkorange&#x27;</span>, alpha=<span class="number">0.6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置数据标签</span></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(x, y):<span class="comment">#x,y数据一一对应</span></span><br><span class="line">    plt.text(a, b, b, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>, fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">plt.show()<span class="comment">#图形展示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 x 坐标值</span></span><br><span class="line">x = order_number.index<span class="comment">#返回的是一个 index 对象，里面存储了月份信息。</span></span><br><span class="line"><span class="comment"># 设置 y 坐标值</span></span><br><span class="line">y = order_number.values  <span class="comment">#values返回的是一个 array 对象，里面存储了各月口罩订单总量的信息</span></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251010.png" alt="image-20210820223704165"></p></li></ul><h4 id="Series-对象排序"><a href="#Series-对象排序" class="headerlink" title="Series 对象排序"></a>Series 对象排序</h4><ul><li>在 pandas 中，我们可以使用<code>s.sort_values()</code>对 Series 对象的数值型数据进行排序。</li><li>默认为升序排列（从小到大），将 <strong>ascending</strong> 参数设置为 False 就可以让它降序排列（从大到小）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 降序排列sales_sum</span></span><br><span class="line">sales_sum = sales_sum.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="C:\Users\win10\Desktop\下载\43G6VFT71612681434803.png" alt="43G6VFT71612681434803"></p><h1 id="Apriori-算法"><a href="#Apriori-算法" class="headerlink" title="Apriori 算法"></a>Apriori 算法</h1><h2 id="设置列索引值"><a href="#设置列索引值" class="headerlink" title="设置列索引值"></a>设置列索引值</h2><ul><li>以<strong>字典</strong>作为数据传入时，字典的<strong>键</strong>会作为 DataFrame 对象的列名显示，而字典的<strong>值</strong>会作为对象的列数据显示。</li><li>以<strong>嵌套列表</strong>作为数据传入时，列表的元素会作为 DataFrame 对象的行数据显示，且会为数据默认生成从 0 开始的列名。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dict_1 = &#123;<span class="string">&#x27;年龄&#x27;</span>: [<span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>], <span class="string">&#x27;岗位&#x27;</span>: [<span class="string">&#x27;客服&#x27;</span>, <span class="string">&#x27;运营&#x27;</span>, <span class="string">&#x27;公关&#x27;</span>], <span class="string">&#x27;年购买量&#x27;</span>: [<span class="number">10</span>, <span class="number">15</span>, <span class="number">8</span>]&#125;</span><br><span class="line">jobs_df = pd.DataFrame(dict_1)</span><br><span class="line"><span class="built_in">print</span>(jobs_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========================&#x27;</span>)</span><br><span class="line">goods_info = [</span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">77.675</span>, <span class="string">&#x27;47箱&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">58.755</span>, <span class="string">&#x27;40箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">7.385</span>, <span class="string">&#x27;285盒&#x27;</span>, <span class="string">&#x27;广西南宁仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">34.823</span>, <span class="string">&#x27;20件&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">62.648</span>, <span class="string">&#x27;30箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">45.75</span>, <span class="string">&#x27;12箱&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">5.235</span>, <span class="string">&#x27;148盒&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">33.736</span>, <span class="string">&#x27;28件&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>]<span class="comment">#列表内一个列表代表一行</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">goods_df = pd.DataFrame(goods_info)</span><br><span class="line"><span class="built_in">print</span>(goods_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-----------------------&#x27;</span>)</span><br><span class="line">newgoods_df = pd.DataFrame(goods_info, columns=[<span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;单价&#x27;</span>, <span class="string">&#x27;库存&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>])<span class="comment">#colums可以设置列名</span></span><br><span class="line"><span class="built_in">print</span>(newgoods_df)</span><br></pre></td></tr></table></figure><ul><li><p>参数 columns 的值可以是一个列表，该列表的长度需与传入 DataFrame() 的列表的元素长度一致</p></li><li><p>已创建的DataFrame对象列表名修改</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goods_df.columns = [<span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;单价&#x27;</span>, <span class="string">&#x27;库存&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>]<span class="comment"># 修改 goods_df 的列名</span></span><br></pre></td></tr></table></figure><h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><h3 id="sort-values-by-方法"><a href="#sort-values-by-方法" class="headerlink" title="sort_values(by) 方法"></a>sort_values(by) 方法</h3><ul><li>该方法可以对指定列进行排序操作，默认升序排列;by可为列名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依照【单价】列的数据进行排序</span></span><br><span class="line">sorted_goods = newgoods_df.sort_values(by=<span class="string">&#x27;单价&#x27;</span>)</span><br><span class="line"><span class="comment"># 提取【单价】列的数据进行排序</span></span><br><span class="line">newgoods_df[<span class="string">&#x27;单价&#x27;</span>].sort_values()</span><br></pre></td></tr></table></figure><h3 id="重置行索引"><a href="#重置行索引" class="headerlink" title="重置行索引"></a>重置行索引</h3><ul><li>重置索引可以使用 reset_index() 方法<ul><li>drop的值为False时保留原来的索引；drop的值为True时重置索引（从0开始）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置数据 sorted_goods 的行索引</span></span><br><span class="line">reset_goods = sorted_goods.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line">reset_goods</span><br></pre></td></tr></table></figure><h3 id="数值的四舍五入"><a href="#数值的四舍五入" class="headerlink" title="数值的四舍五入"></a>数值的四舍五入</h3><ul><li>round()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset_goods[<span class="string">&#x27;单价&#x27;</span>] = <span class="built_in">round</span>(reset_goods[<span class="string">&#x27;单价&#x27;</span>], <span class="number">2</span>)<span class="comment">#2表示保留2位小数</span></span><br></pre></td></tr></table></figure><h3 id="去除数据单位"><a href="#去除数据单位" class="headerlink" title="去除数据单位"></a>去除数据单位</h3><ul><li>s.agg(func)<ul><li>agg() 中的参数 func 可以为自定义的函数名，如我们上方定义的 new_func()</li><li>传入自定义的函数时，<strong>只需要写上函数名</strong>，不需要加上括号以及函数的参数</li></ul></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251017.png" alt="image-20210827204737110"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_func</span>(<span class="params">data</span>):<span class="comment"># 定义函数 new_func()</span></span><br><span class="line">    number = data[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(number)</span><br><span class="line"></span><br><span class="line">goods_info = [</span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">77.675</span>, <span class="string">&#x27;47箱&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">58.755</span>, <span class="string">&#x27;40箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">7.385</span>, <span class="string">&#x27;285盒&#x27;</span>, <span class="string">&#x27;广西南宁仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">34.823</span>, <span class="string">&#x27;20件&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;巧克力&#x27;</span>, <span class="number">62.648</span>, <span class="string">&#x27;30箱&#x27;</span>, <span class="string">&#x27;广东揭阳仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;牛奶&#x27;</span>, <span class="number">45.75</span>, <span class="string">&#x27;12箱&#x27;</span>, <span class="string">&#x27;广西柳州仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;威化饼干&#x27;</span>, <span class="number">5.235</span>, <span class="string">&#x27;148盒&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>], </span><br><span class="line">    [<span class="string">&#x27;火腿肠&#x27;</span>, <span class="number">33.736</span>, <span class="string">&#x27;28件&#x27;</span>, <span class="string">&#x27;广东佛山仓&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">#给列赋值名称</span></span><br><span class="line"></span><br><span class="line">goods_df = pd.DataFrame(goods_info, columns=[<span class="string">&#x27;名称&#x27;</span>, <span class="string">&#x27;单价&#x27;</span>, <span class="string">&#x27;库存&#x27;</span>, <span class="string">&#x27;地址&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 agg() 方法对【库存】列的数据进行切片处理</span></span><br><span class="line">goods_df[<span class="string">&#x27;库存&#x27;</span>] = goods_df[<span class="string">&#x27;库存&#x27;</span>].agg(new_func)</span><br><span class="line"><span class="built_in">print</span>(goods_df)</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251747.png" alt="image-20210827204856980"></p><ul><li>同时输出多个内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义字典 dict_2</span></span><br><span class="line">dict_2 = &#123;</span><br><span class="line">    <span class="string">&#x27;单价&#x27;</span>: <span class="string">&#x27;mean&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;库存&#x27;</span>: <span class="string">&#x27;sum&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 同时计算各食品的平均单价和总库存量</span></span><br><span class="line">reset_goods.groupby(<span class="string">&#x27;名称&#x27;</span>).agg(dict_2)</span><br></pre></td></tr></table></figure><h2 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251931.png" alt="image-20210827211810206"></p><h3 id="Python-调用-apriori-函数"><a href="#Python-调用-apriori-函数" class="headerlink" title="Python 调用 apriori 函数"></a>Python 调用 apriori 函数</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041251193.png" alt="image-20210827212016647"></p><h2 id="实事绘图"><a href="#实事绘图" class="headerlink" title="实事绘图"></a>实事绘图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">ax = []                    <span class="comment"># 定义一个 x 轴的空列表用来接收动态的数据</span></span><br><span class="line">ay = []                    <span class="comment"># 定义一个 y 轴的空列表用来接收动态的数据</span></span><br><span class="line">a1=[]</span><br><span class="line">b1=[]</span><br><span class="line">j=<span class="number">0</span></span><br><span class="line">plt.ion()                  <span class="comment"># 开启一个画图的窗口</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):       <span class="comment"># 遍历0-99的值</span></span><br><span class="line">    ax.append(i)           <span class="comment"># 添加 i 到 x 轴的数据中</span></span><br><span class="line">    ay.append(i**<span class="number">2</span>)        <span class="comment"># 添加 i 的平方到 y 轴的数据中</span></span><br><span class="line">    a1.append(i*<span class="number">2</span>)</span><br><span class="line">    j=j+<span class="number">1</span></span><br><span class="line">    b1.append(i*<span class="number">3</span>)</span><br><span class="line">    plt.clf()              <span class="comment"># 清除之前画的图</span></span><br><span class="line">    plt.plot(ax,ay)        <span class="comment"># 画出当前 ax 列表和 ay 列表中的值的图形</span></span><br><span class="line">    plt.plot(a1,b1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(j)+<span class="string">&quot;次输出图像&quot;</span>)</span><br><span class="line">    plt.pause(<span class="number">0.5</span>)         <span class="comment"># 暂停一秒</span></span><br><span class="line">    plt.ioff()             <span class="comment">#</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python/python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.python基础自动画办公</title>
      <link href="/data.github.io/post/f405ebe7.html"/>
      <url>/data.github.io/post/f405ebe7.html</url>
      
        <content type="html"><![CDATA[<h1 id="自动化办公"><a href="#自动化办公" class="headerlink" title="自动化办公"></a>自动化办公</h1><h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="开-open（）"><a href="#开-open（）" class="headerlink" title="开-open（）"></a>开-open（）</h2><ul><li>绝对路径：<strong>绝对路径</strong>就是最完整的路径；将文件拖入VScode终端可以获得绝对路径</li><li>或者右键复制路劲</li><li>相对路径：指的就是【相对于当前文件夹】的路径</li><li>windows系统中\来表示绝对路径，&#x2F;表示相对路径</li><li><strong>格式：文件名&#x3D;(‘路径’，’模式’，encoding&#x3D;’utf-8’)</strong></li><li>sumlime text3要绝对路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\Ted\\Desktop\\test\\abc.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#将&#x27;\&#x27;替换成&#x27;\\&#x27;</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>)    <span class="comment">#相对路径</span></span><br><span class="line"><span class="comment">#相对路径也可以写成open(&#x27;./abc.txt&#x27;)</span></span><br></pre></td></tr></table></figure><ul><li>‘r’:表示以读得模式打开文件</li></ul><h3 id="模式汇总"><a href="#模式汇总" class="headerlink" title="模式汇总"></a>模式汇总</h3><table><thead><tr><th>r(read，读)</th><th>r只读，指针在开头文件不存在则报错</th><th>rb二进制只读，其余同左</th><th>r+读写，其余同左</th><th>rb+二进制读写，其余同左</th></tr></thead><tbody><tr><td>w(write,写)</td><td>w只写，文件不存在则新建，存在则覆盖</td><td>wb二进制只写，其余同左</td><td>w+读写，其余同左</td><td>wb+二进制读写，其余同左</td></tr><tr><td>a(append,追加)</td><td>a追加,文件存在指针放在末尾,文件不存在则新建</td><td>ab二进制追加，其余同左</td><td>a+追加且可读,其余同左</td><td>ab+二进制追加，且可读，其余同左</td></tr></tbody></table><ul><li>**’wb’**的模式，它的意思是以二进制的方式打开一个文件用于写入。因为图片和音频是以二进制的形式保存的，所以使用wb模式就好了</li></ul><h2 id="读-read（）"><a href="#读-read（）" class="headerlink" title="读-read（）"></a>读-read（）</h2><h3 id="直接读取"><a href="#直接读取" class="headerlink" title="直接读取"></a>直接读取</h3><p><strong>变量名&#x3D;文件名.read()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量名=文件名.read()</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;/Users/Ted/Desktop/test/abc.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">filecontent = file1.read()      </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ile1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure><h3 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h3><p><strong>方式1</strong></p><ul><li>格式：<strong>变量名&#x3D;文件名.readlines()</strong></li><li><strong>readlines()</strong> 会从txt文件取得一个列表，列表中的每个字符串就是文件中的每一行。而且每个字符串后面还有换行的<code>\n</code>**符号。</li><li><strong>for循环</strong>来遍历这个列表</li></ul><p><strong>方式2</strong></p><ul><li>这种方式可以将csv中的表格数据以列表的形式保存，每行也是列表形式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;score.csv&#x27;</span>, <span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">reader = csv.reader(f)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line"><span class="built_in">print</span>(row)<span class="comment">#按行读取并输出该行列表形式</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="写-write"><a href="#写-write" class="headerlink" title="写-write()"></a>写-write()</h2><h3 id="‘w’模式"><a href="#‘w’模式" class="headerlink" title="‘w’模式"></a>‘w’模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)</span><br><span class="line">file1.close()</span><br></pre></td></tr></table></figure><ul><li>‘w：表示写入文件’</li><li>参数为字符串</li><li>格式：<strong>文件名.write(‘内容’)</strong></li><li>**’w’写入模式会给你暴力清空掉文件</li><li>**write()**函数写入文本文件的也是字符串类型。</li><li>在**’w’<strong>和</strong>‘a’<strong>模式下，如果你打开的文件不存在，那么</strong>open()**函数会自动帮你创建一个</li></ul><h3 id="‘a’模式"><a href="#‘a’模式" class="headerlink" title="‘a’模式"></a>‘a’模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line"><span class="comment">#以追加的方式打开文件abc.txt</span></span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;张无忌&#x27;写入文件file1</span></span><br><span class="line">file1.write(<span class="string">&#x27;宋青书\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;宋青书&#x27;写入文件file1</span></span><br></pre></td></tr></table></figure><ul><li>追加模式：增加内容而不是覆盖原来的内容</li><li>如果不存在该文件，则会自动创建文件</li></ul><p>实例</p><ul><li>[[毕业设计#写入数据到csv表中|写入数据到csv表中]]</li></ul><h2 id="关-close"><a href="#关-close" class="headerlink" title="关-close()"></a>关-close()</h2><ul><li>关闭文件</li><li>计算机能够打开的文件数量是有限制的，open()过多而不close()的话，就不能再打开文件了。</li><li>能保证写入的内容已经在文件里被保存好了。</li><li><strong>文件名.close</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure><h2 id="关键字with"><a href="#关键字with" class="headerlink" title="关键字with"></a>关键字with</h2><ul><li>为了避免打开文件后忘记关闭，占用资源或当不能确定关闭文件的恰当时机的时候，我们可以用到关键字with</li><li>格式：with open(‘文件地址’,’读写模式’) as 变量名:</li><li>后面编码：encoding&#x3D;’utf-8’：如果要文件包括中文要加</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通写法</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用with关键字的写法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file1:</span><br><span class="line"><span class="comment">#with open(&#x27;文件地址&#x27;,&#x27;读写模式&#x27;,encoding=&#x27;utf-8&#x27;) as 变量名:</span></span><br><span class="line">    <span class="comment">#格式：冒号不能丢</span></span><br><span class="line">    file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">    <span class="comment">#格式：对文件的操作要缩进</span></span><br><span class="line">    <span class="comment">#格式：无需用close()关闭</span></span><br></pre></td></tr></table></figure><h2 id="split-分开字符串"><a href="#split-分开字符串" class="headerlink" title="split():分开字符串"></a>split():分开字符串</h2><ul><li>它会按空格把字符串里面的内容分开</li><li>最终组合成一个列表</li><li>格式：<strong>变量1&#x3D;变量2.split()</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;score.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file_lines = file1.readlines()</span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_lines:   <span class="comment">#用for...in...把每一行的数据遍历  </span></span><br><span class="line">    data =i.split()    <span class="comment">#把字符串切分成更细的一个个的字符串</span></span><br><span class="line">    <span class="built_in">print</span>(data)        <span class="comment">#打印出来看看</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">&quot;abc abc\ndef\t&quot;</span></span><br><span class="line"><span class="built_in">print</span>(string.split())</span><br><span class="line">打印结果：[<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>]</span><br></pre></td></tr></table></figure><h1 id="csv模块"><a href="#csv模块" class="headerlink" title="csv模块"></a>csv模块</h1><ul><li><a href="https://yiyibooks.cn/xx/python_352/library/csv.html#module-csv">官方文档</a>：看示例</li><li>注意;创建的excel文档是csv格式，另存</li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>-<code>#参数encoding</code>&#x3D; ‘utf-8’防止出现乱码；一般有中文要加;报错就删或者加</p><h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><h4 id="reader"><a href="#reader" class="headerlink" title="reader()"></a>reader()</h4><ul><li>读取的是列表格式</li><li>用于读取一般的csv文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\win10\\Desktop\\code\\.vscode\\python.csv&quot;</span>,newline = <span class="string">&#x27;&#x27;</span>)  <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    <span class="comment">#使用csv的reader()方法，创建一个reader对象</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader: </span><br><span class="line">    <span class="comment">#遍历reader对象的每一行</span></span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;读取完毕！&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>row：单元格所在行</li></ul><h5 id="相对路径说明"><a href="#相对路径说明" class="headerlink" title="相对路径说明"></a>相对路径说明</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">practice_wb = load_workbook(<span class="string">&#x27;./material/practice0.xlsx&#x27;</span>)<span class="comment">#material和py文件在同一目录文件夹，注意前面要加./代表同目录</span></span><br></pre></td></tr></table></figure><h4 id="DictReader类"><a href="#DictReader类" class="headerlink" title="DictReader类"></a>DictReader类</h4><ul><li><code>DictReader</code>类的操作类似于常规的<code>reader()</code>，但<code>DictReader</code>会将读取到的信息转换为字典形式</li><li>实例化<code>DictReader</code>类后，会得到一个<code>DictReader对象</code>，这是一个可迭代对象，我们可以使用循环来遍历它的每一个元素。但不同于<code>reader()</code>的是，该对象里面的每一个元素都是一个<strong>字典</strong>，每一个<strong>字典的值</strong>都可以对应csv文件中的一行，<strong>键</strong>对应csv文件的表头</li><li>属性<strong>fieldnames</strong>，该属性可以将csv文件（表格）的表头（第一行）读取出来，返回值是<strong>列表</strong>。这个<strong>表头也就是字典的键</strong>(key)。</li><li>通常读取第一行为表头的csv文件。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 打开csv文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./DictReader_demo.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csv_file:</span><br><span class="line">    <span class="comment"># 将文件对象转换为DictReader对象</span></span><br><span class="line">    csv_reader = csv.DictReader(csv_file)</span><br><span class="line">    <span class="comment"># 获取表头</span></span><br><span class="line">    headers = csv_reader.fieldnames</span><br><span class="line">    <span class="comment"># 打印表头</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表头：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(headers))</span><br><span class="line">    <span class="comment"># 遍历DictReader对象</span></span><br><span class="line">    <span class="keyword">for</span> csv_row <span class="keyword">in</span> csv_reader:</span><br><span class="line">        <span class="comment"># 打印数据</span></span><br><span class="line">        <span class="built_in">print</span>(csv_row)</span><br></pre></td></tr></table></figure><h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><h4 id="writer"><a href="#writer" class="headerlink" title="writer()"></a>writer()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">member_list = [</span><br><span class="line">    [<span class="string">&#x27;邱大仁&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;徐小刚&#x27;</span>, <span class="string">&#x27;陈知枫&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;王晴&#x27;</span>, <span class="string">&#x27;廖雨&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;writerow_demo.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>,newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># 打开并创建&#x27;writerow_demo.csv&#x27;文件，注意参数的设置，获取文件对象</span></span><br><span class="line">    writer=csv.writer(file)<span class="comment"># 将文件对象转换为writer对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> member_list:<span class="comment"># 循环遍历列表中的元素</span></span><br><span class="line">        writer.writerow(i)<span class="comment"># 将列表中的元素写入csv文件中</span></span><br><span class="line">        <span class="comment">#csv_demo.writerows(member_list)等价for循环上面两个语句</span></span><br></pre></td></tr></table></figure><ul><li>**对象名.writerow(row)**：要用for循环填入列表中</li><li>**对象名.writerows(row)**：参数rows也是可迭代对象，可以理解为由多个row组成。</li></ul><h4 id="DictWriter"><a href="#DictWriter" class="headerlink" title="DictWriter"></a>DictWriter</h4><ul><li><code>DictWriter</code>的操作类似于常规的<code>writer()</code>，但<code>DictWriter</code>会将字典写入（映射）到csv文件的行中</li><li>写入的行为字典形式</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249587.png" alt="image-20210813221044806"></p><ul><li>必须要传入该参数。</li><li>我们需要将一个列表传给参数<code>fieldnames</code>，它的作用是设置csv文件的第一行数据（即表头数据）。当我们要将字典通过<code>DictWriter对象</code>写入csv文件时，通常会把字典的键(key)存入一个列表，再把这个列表传给参数<code>fieldnames</code>。</li></ul><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ol><li><code>writeheader()</code>，该方法可将表头（即字典中的键(key)）写入csv的第一行。也就是说，<strong>如果要写入表头，不仅要在DictWriter中传入参数fieldnames，还需要调用writeheader()方法</strong>。这点很重要，一定要记住。</li><li><code>writerow(row)</code>，与writer对象调用writerow(row)不同的是，这里的参数<code>row</code>必须是字典形式的数据。</li><li>在写入时，该方法会根据字典的键，找到相应的表头，然后再将此键对应的值写入表头对应的列。</li><li><strong>writeheader()</strong></li><li><strong>writerow（）</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">info_dict = &#123;<span class="string">&#x27;姓名&#x27;</span>: <span class="string">&#x27;徐小刚&#x27;</span>, <span class="string">&#x27;工号&#x27;</span>: <span class="string">&#x27;1005&#x27;</span>, <span class="string">&#x27;员工发展基金&#x27;</span>: <span class="string">&#x27;100&#x27;</span>, <span class="string">&#x27;员工签字&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置表头</span></span><br><span class="line">headers = [<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;工号&#x27;</span>, <span class="string">&#x27;员工发展基金&#x27;</span>, <span class="string">&#x27;员工签字&#x27;</span>]</span><br><span class="line"><span class="comment"># 创建并打开&#x27;./徐小刚信息.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./徐小刚信息.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> target_file:</span><br><span class="line">    <span class="comment"># 将文件对象转换为DictWriter对象</span></span><br><span class="line">    target_writer = csv.DictWriter(target_file, fieldnames=headers)<span class="comment">#fieldnames是表头传参</span></span><br><span class="line">    <span class="comment"># 写入表头</span></span><br><span class="line">    target_writer.writeheader()</span><br><span class="line">    <span class="comment"># 将字典写入csv文件</span></span><br><span class="line">    target_writer.writerow(info_dict)</span><br></pre></td></tr></table></figure><h1 id="快速获得文件名"><a href="#快速获得文件名" class="headerlink" title="快速获得文件名"></a>快速获得文件名</h1><h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><ul><li>操作系统模块，标准库</li><li>它常用于处理文件和目录（文件夹）的操作。例如删除文件、判断文件目录是否存在等功能。</li></ul><h4 id="自动创建文件"><a href="#自动创建文件" class="headerlink" title="自动创建文件"></a>自动创建文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 打开结果文件</span></span><br><span class="line">result_file = <span class="built_in">open</span>(<span class="string">&#x27;./result.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#如果文件名不存在则自动创建，否则就直接可以打开</span></span><br></pre></td></tr></table></figure><h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><ol><li>将图片png格式改为jpg格式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dirName = <span class="string">&quot;C:\\Users\\win10\\Desktop\\图片\\&quot;</span>        <span class="comment"># 图片所在路径</span></span><br><span class="line"></span><br><span class="line">total_img = os.listdir(dirName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> total_img:                  <span class="comment"># 索引所有图像</span></span><br><span class="line">    newname = filename</span><br><span class="line">    newname = newname.split(<span class="string">&quot;.&quot;</span>)            <span class="comment"># 分离后缀</span></span><br><span class="line">    <span class="keyword">if</span> newname[-<span class="number">1</span>] == <span class="string">&quot;png&quot;</span>:                <span class="comment"># 假定原后缀为.png格式</span></span><br><span class="line">        newname[-<span class="number">1</span>] = <span class="string">&quot;jpg&quot;</span>                 <span class="comment"># 目标后缀为.jpg格式</span></span><br><span class="line">        newname = <span class="built_in">str</span>.join(<span class="string">&quot;.&quot;</span>, newname)    <span class="comment"># &#x27;.&#x27;与后缀名称相连接</span></span><br><span class="line">        filename = dirName + filename       <span class="comment"># 原始图片路径+名称</span></span><br><span class="line">        newname = dirName + newname         <span class="comment"># 新的图像路径+名称</span></span><br><span class="line">        os.rename(filename, newname)        <span class="comment"># 重命名</span></span><br><span class="line">        <span class="built_in">print</span>(newname, <span class="string">&quot;图片格式修改成功&quot;</span>)</span><br><span class="line"><span class="comment">#将png格式修改为jpg格式</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="listdir-函数"><a href="#listdir-函数" class="headerlink" title="listdir(函数)"></a>listdir(函数)</h3><ul><li>格式：<strong>变量名&#x3D;os.listdir(路径)</strong><br>目的：将某文件夹中，所有<strong>文件夹名</strong>和<strong>文件名</strong>获取到<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;文件夹路径&#x27;</span></span><br><span class="line">filenames = os.listdir(path)</span><br><span class="line"><span class="built_in">print</span>(filenames)<span class="comment">#输出为列表格式</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="保存网页图片"><a href="#保存网页图片" class="headerlink" title="保存网页图片"></a>保存网页图片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line">img_src=<span class="string">&#x27;http://sm-wick-question.oss-cn-zhangjiakou.aliyuncs.com/QuestionAnswerImage/521422ccc14b47ef94adc9d0f5240451-11-question.jpg&#x27;</span></span><br><span class="line">response = requests.get(img_src)</span><br><span class="line">image = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line">image.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\9.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="添加表格信息"><a href="#添加表格信息" class="headerlink" title="添加表格信息"></a>添加表格信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">question</span>(<span class="params">s</span>):</span><br><span class="line">    j=<span class="number">0</span></span><br><span class="line">    s=<span class="built_in">list</span>(s)</span><br><span class="line">    s[s.index(<span class="string">&#x27;q&#x27;</span>)]=<span class="string">&#x27;a&#x27;</span></span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span>.join(s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">url_img</span>(<span class="params">scr,path_name</span>):</span><br><span class="line">    response = requests.get(scr)</span><br><span class="line">    image = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line">    <span class="built_in">print</span>(path_name+<span class="string">&quot; 保存成功&quot;</span>)</span><br><span class="line">    image.save(path_name)</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;C:\\Users\\win10\\Desktop\\课程\\微机原理\\&#x27;</span></span><br><span class="line">filenames = os.listdir(path)</span><br><span class="line">new_path=path+<span class="built_in">str</span>(filenames[<span class="number">0</span>])</span><br><span class="line">img_path=<span class="string">&#x27;C:\\Users\\win10\\Desktop\\课程\\pic\\&#x27;</span></span><br><span class="line">staff_wb = load_workbook(new_path)</span><br><span class="line"></span><br><span class="line">staff_ws = staff_wb.active</span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">new_ws = new_wb.active</span><br><span class="line"><span class="comment">#获取名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row,name1 <span class="keyword">in</span> <span class="built_in">zip</span>(staff_ws.iter_rows( max_row=<span class="number">2000</span>, values_only=<span class="literal">True</span>),staff_ws[<span class="string">&#x27;H&#x27;</span>]):</span><br><span class="line">    <span class="comment"># 将数据写入新的工作表</span></span><br><span class="line">    <span class="keyword">if</span>(name1.value==<span class="string">&quot;王俊林&quot;</span>):</span><br><span class="line">        row=<span class="built_in">list</span>(row)</span><br><span class="line">        img_path1=img_path+row[<span class="number">2</span>]+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        url_img(row[<span class="number">3</span>],img_path1)</span><br><span class="line">        row.insert(<span class="number">8</span>,question(row[<span class="number">2</span>]))</span><br><span class="line">        new_ws.append(row)</span><br><span class="line">new_wb.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\表格.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成成功&quot;</span>)</span><br><span class="line"><span class="comment">#读取有王俊林表格的整个信息，并保存到一个表格中</span></span><br></pre></td></tr></table></figure><h2 id="文件筛选"><a href="#文件筛选" class="headerlink" title="文件筛选"></a>文件筛选</h2><p>流程<br><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249425.png" alt="image-20210812211800776"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件夹路径，获取文件夹下的所有文件名</span></span><br><span class="line">path = <span class="string">&#x27;./工作文件夹/&#x27;</span></span><br><span class="line">files_list = os.listdir(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置需要查找的关键词</span></span><br><span class="line">key_word = <span class="built_in">input</span>(<span class="string">&quot;请输入要查找的关键词：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开结果文件</span></span><br><span class="line">result_file = <span class="built_in">open</span>(<span class="string">&#x27;./result.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环处理每一个文件</span></span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> files_list:</span><br><span class="line">    <span class="comment"># 判断文件类型是否在文件名中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.txt&#x27;</span> <span class="keyword">in</span> file_name:</span><br><span class="line">        <span class="comment"># 找到文件时先打印提示</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到了文件：&quot;</span> + file_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将文件夹路径和文件名拼接成该文件的相对路径</span></span><br><span class="line">        target_file = path + file_name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开文件，读取文件内容，然后关闭文件</span></span><br><span class="line">        file = <span class="built_in">open</span>(target_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        content = file.read()</span><br><span class="line">        file.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断关键词是否在文件内容中</span></span><br><span class="line">        <span class="keyword">if</span> key_word <span class="keyword">in</span> content:</span><br><span class="line">            <span class="comment"># 匹配到关键词时先打印提示</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;妙啊，文件**&#123;&#125;**包含了关键词：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(target_file, key_word))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将包含关键词的文档的文件路径，写入结果文件。</span></span><br><span class="line">            result_file.write(target_file + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭结果文件</span></span><br><span class="line">result_file.close()</span><br></pre></td></tr></table></figure><ul><li><strong>相对路径</strong>使用两个特殊符号，点<code>.</code>和双点<code>..</code>，点<code>.</code>表示当前的目录，双点<code>..</code>表示当前目录的上一级目录。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#【工作文件夹】与【oa_01.py】都在【codes文件夹】中，所以【工作文件夹】和【codes文件夹】的相对路径就可以表示为：</span></span><br><span class="line"><span class="comment"># &#x27;工作文件夹&#x27;的相对路径</span></span><br><span class="line"><span class="string">&#x27;./工作文件夹/&#x27;</span></span><br><span class="line"><span class="comment"># &#x27;codes&#x27;的相对路径</span></span><br><span class="line"><span class="string">&#x27;./&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249064.png" alt="image-20210812213713336"></p><h1 id="对excel操作"><a href="#对excel操作" class="headerlink" title="对excel操作"></a>对excel<a href="https://blog.csdn.net/m0_59235508/article/details/122712465?ops_request_misc=&request_id=&biz_id=102&utm_term=pytoh%E5%AF%B9exce%E8%A1%A8%E6%A0%BC%E5%A4%8D%E5%88%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-122712465.142%5Ev10%5Econtrol,157%5Ev8%5Econtrol&spm=1018.2226.3001.4187">操作</a></h1><p>python操作excel主要用到xlrd和xlwt这两个库，即xlrd是读excel，xlwt是写excel的库</p><h2 id="xlrd模块"><a href="#xlrd模块" class="headerlink" title="xlrd模块"></a>xlrd模块</h2><p>读模块<br>有点问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="comment">#data = xlrd.open_workbook(filename)#文件名以及路径，如果路径或者文件名有中文给前面加一个 r</span></span><br><span class="line">xlsx = xlrd.open_workbook(<span class="string">&#x27;C:\\Users\\wjl\\Desktop\\表格.xlsx&#x27;</span>)<span class="comment">#读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过sheet名查找：xlsx.sheet_by_name(&quot;sheet1&quot;)</span></span><br><span class="line"><span class="comment"># 通过索引查找：xlsx.sheet_by_index(3)</span></span><br><span class="line">table = xlsx.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个表格值 (2,1)表示获取第3行第2列单元格的值</span></span><br><span class="line">value = table.cell_value(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第3行2列值为&quot;</span>,value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取表格行数</span></span><br><span class="line">nrows = table.nrows</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;表格一共有&quot;</span>,nrows,<span class="string">&quot;行&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第4列所有值（列表生成式）</span></span><br><span class="line">name_list = [<span class="built_in">str</span>(table.cell_value(i, <span class="number">3</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nrows)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第4列所有的值：&quot;</span>,name_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="xlwt模块操作"><a href="#xlwt模块操作" class="headerlink" title="xlwt模块操作"></a>xlwt模块操作</h2><p>写模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入xlwt模块</span></span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1.创建 Workbook</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.创建 worksheet</span></span><br><span class="line">ws = wb.add_sheet(<span class="string">&#x27;test_sheet&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.写入第一行内容  ws.write(a, b, c)  a：行，b：列，c：内容</span></span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;球队&#x27;</span>)</span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;号码&#x27;</span>)</span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&#x27;姓名&#x27;</span>)</span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&#x27;位置&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">wb.save(<span class="string">&#x27;C:\\Users\\wjl\\Desktop\\myExcel.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205241207709.png" alt="image-20220524120653747"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlst</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1.创建 Workbook</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.创建 worksheet</span></span><br><span class="line">ws = wb.add_sheet(<span class="string">&#x27;test_sheet&#x27;</span>)</span><br><span class="line">data = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;Team&#x27;</span>: <span class="string">&#x27;湖人&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Number&#x27;</span>: <span class="string">&#x27;34&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;奥尼尔&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Positions&#x27;</span>: <span class="string">&#x27;中锋&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;Team&#x27;</span>: <span class="string">&#x27;湖人&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Number&#x27;</span>: <span class="string">&#x27;24&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;科比&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Positions&#x27;</span>: <span class="string">&#x27;后卫&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;Team&#x27;</span>: <span class="string">&#x27;湖人&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Number&#x27;</span>: <span class="string">&#x27;23&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;詹姆斯&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Positions&#x27;</span>: <span class="string">&#x27;前锋&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">0</span>, item[<span class="string">&#x27;Team&#x27;</span>])</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">1</span>, item[<span class="string">&#x27;Number&#x27;</span>])</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">2</span>, item[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line">    ws.write(i+<span class="number">1</span>, <span class="number">3</span>, item[<span class="string">&#x27;Positions&#x27;</span>])</span><br><span class="line">wb.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\myExcel.xls&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205241207980.png" alt="image-20220524120730735"></p><h1 id="excel按照姓名分表"><a href="#excel按照姓名分表" class="headerlink" title="excel按照姓名分表"></a>excel按照姓名分表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置员工发展基金确认表路径</span></span><br><span class="line">source_path = <span class="string">&#x27;./员工发展基金确认表.csv&#x27;</span></span><br><span class="line"><span class="comment"># 设置存放拆分结果文件的文件夹路径</span></span><br><span class="line">result_path = <span class="string">&#x27;./员工发展基金文件夹_demo/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开员工发展基金确认表</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(source_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> source_file:<span class="comment">#newline=&#x27;&#x27;:这样可以避免一些不必要的空行</span></span><br><span class="line">    <span class="comment"># 将文件对象转换为DictReader对象</span></span><br><span class="line">    source_csv = csv.DictReader(source_file)</span><br><span class="line">    <span class="comment"># 将csv对象的表头读取出来</span></span><br><span class="line">    headers = source_csv.fieldnames</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环处理确认表中除表头外的每一行数据</span></span><br><span class="line">    <span class="keyword">for</span> csv_row <span class="keyword">in</span> source_csv:</span><br><span class="line">        <span class="comment"># 根据获取的员工名字拼接新文件名</span></span><br><span class="line">        file_name = csv_row[<span class="string">&#x27;姓名&#x27;</span>] + <span class="string">&#x27;.csv&#x27;</span></span><br><span class="line">        <span class="comment"># 拼接新文件路径</span></span><br><span class="line">        file_path = result_path + file_name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建新文件并添加数据</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> target_file:</span><br><span class="line">            <span class="comment"># 将文件对象转换为DictWriter对象</span></span><br><span class="line">            target_writer = csv.DictWriter(target_file, fieldnames=headers)</span><br><span class="line">            <span class="comment"># 写入表头</span></span><br><span class="line">            target_writer.writeheader()</span><br><span class="line">            <span class="comment"># 写入数据</span></span><br><span class="line">            target_writer.writerow(csv_row)</span><br></pre></td></tr></table></figure><h1 id="openpyxl库"><a href="#openpyxl库" class="headerlink" title="openpyxl库"></a>openpyxl库</h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249825.png" alt="image-20210814100038376"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249164.png" alt="image-20210817093103821"></p><ul><li>安装库：pip install openpyxl</li></ul><p>（Windows系统）cmd中输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 库/模块名</span><br></pre></td></tr></table></figure><ul><li>处理<code>xlsx</code>格式表格的相关内容。</li></ul><h2 id="获取对象及创建"><a href="#获取对象及创建" class="headerlink" title="获取对象及创建"></a>获取对象及创建</h2><ul><li>load_workbook(filename)</li><li>filename代表工作簿的路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="comment"># 通过文件路径，打开工作簿</span></span><br><span class="line">wb1 = openpyxl.load_workbook(<span class="string">&#x27;./demo_excel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 用 Workbook() 创建新工作簿</span></span><br><span class="line">wb2 = openpyxl.Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过文件路径，打开已有工作簿</span></span><br><span class="line">wb1 = load_workbook(<span class="string">&#x27;./demo_excel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 用 Workbook() 创建新工作簿</span></span><br><span class="line">wb2 = Workbook()</span><br></pre></td></tr></table></figure><h2 id="新建工作簿2"><a href="#新建工作簿2" class="headerlink" title="新建工作簿2"></a>新建工作簿2</h2><h3 id="Workbook"><a href="#Workbook" class="headerlink" title="Workbook()"></a><strong>Workbook()</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 打印工作簿对象</span></span><br><span class="line"><span class="built_in">print</span>(new_wb)</span><br></pre></td></tr></table></figure><h3 id="工作簿对象-save-filename"><a href="#工作簿对象-save-filename" class="headerlink" title="工作簿对象.save(filename)"></a>工作簿对象.save(filename)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 将新建的工作簿保存为【new_excel.xlsx】</span></span><br><span class="line">new_wb.save(<span class="string">&#x27;./new_excel.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>如果参数<code>filename</code>不变，即保存在原有路径，相当于修改原文件；若参数<code>filename</code>变化，即保存在新的路径，相当于另存为新的文件。</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249450.png" alt="image-20210814095339493"></p><h2 id="工作表对象"><a href="#工作表对象" class="headerlink" title="工作表对象"></a>工作表对象</h2><ul><li>Worksheet对象</li></ul><h3 id="获取工作表对象1"><a href="#获取工作表对象1" class="headerlink" title="获取工作表对象1"></a>获取工作表对象1</h3><ul><li><strong>active</strong>:active会获取到活动的工作表</li><li>建议单一工作表使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">active_ws = staff_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印工作簿对象</span></span><br><span class="line"><span class="built_in">print</span>(staff_wb)</span><br><span class="line"><span class="comment"># 打印工作表对象</span></span><br><span class="line"><span class="built_in">print</span>(active_ws)</span><br></pre></td></tr></table></figure><h3 id="按表名取表2"><a href="#按表名取表2" class="headerlink" title="按表名取表2"></a>按表名取表2</h3><ul><li>工作簿对象[‘表名’]</li><li>建议多张工作表使用，获取指定工作表对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 按表名取表</span></span><br><span class="line">fhy_ws = staff_wb[<span class="string">&#x27;上半年公司名单&#x27;</span>]  <span class="comment"># fhy为first half year（上半年）的缩写；工作表对象</span></span><br><span class="line">shy_ws = staff_wb[<span class="string">&#x27;下半年公司名单&#x27;</span>]  <span class="comment"># shy为second half year（下半年）的缩写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印工作簿对象</span></span><br><span class="line"><span class="built_in">print</span>(staff_wb)</span><br><span class="line"><span class="comment"># 打印工作表对象</span></span><br><span class="line"><span class="built_in">print</span>(fhy_ws)</span><br><span class="line"><span class="built_in">print</span>(shy_ws)</span><br></pre></td></tr></table></figure><h3 id="获取单行或单列"><a href="#获取单行或单列" class="headerlink" title="获取单行或单列"></a>获取单行或单列</h3><ul><li>数字代表行，英文字母代表列</li><li>通过<strong>工作表对象[行数]或</strong>工作表对象<code>[&#39;列名&#39;]</code><strong>的方式获取到一个</strong>元组，这个<strong>元组</strong>中包含了指定行或列中的所有数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">active_ws = staff_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印获取到的第五行数据</span></span><br><span class="line"><span class="built_in">print</span>(active_ws[<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 打印获取到的第二列数据</span></span><br><span class="line"><span class="built_in">print</span>(active_ws[<span class="string">&#x27;B&#x27;</span>])<span class="comment">#每一个元素均为&lt;Cell &#x27;工作表名称&#x27;.坐标&gt;</span></span><br></pre></td></tr></table></figure><ul><li>每一个元素均为&lt;Cell ‘工作表名称’.坐标&gt;</li></ul><h3 id="获取多行数据"><a href="#获取多行数据" class="headerlink" title="获取多行数据"></a>获取多行数据</h3><h4 id="iter-rows"><a href="#iter-rows" class="headerlink" title="iter_rows"></a>iter_rows</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">工作表对象.iter_rows(min_row, max_row, min_col, max_col, values_only=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#min_row是最小行索引</span></span><br><span class="line"><span class="comment">#max_row是最大行索引</span></span><br><span class="line"><span class="comment">#min_col是最小列索引</span></span><br><span class="line"><span class="comment">#max_col是最大列索引</span></span><br><span class="line"><span class="comment">#values_only=True:是否返回单元格的值</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取【&#x27;上半年公司名单&#x27;】工作表</span></span><br><span class="line">fhy_ws = staff_wb[<span class="string">&#x27;上半年公司名单&#x27;</span>]</span><br><span class="line"><span class="comment"># 返回第2行至第12行，第2列（B列）至第3列（C列）这个范围的单元格内的所有数据（值）</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> fhy_ws.iter_rows(min_row=<span class="number">2</span>, max_row=<span class="number">12</span>, min_col=<span class="number">2</span>, max_col=<span class="number">3</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>最小行索引的值默认为1，最大行索引的值默认为表格中有数据的最下面一行的行数；</li><li>参数<code>values_only</code>决定是否返回单元格的值，如果为True则返回<strong>单元格的值</strong>，如果为False则返回<strong>单元格对象</strong>。通常情况下，只读数据时，需要将该参数设置为True，要写入数据时，保持其为默认的False就好。</li><li>如果指定的行中没有数据，就会返回一个空的元组。(None, None)</li></ul><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><ul><li>语法：<strong>工作表对象.append(列表&#x2F;元组)</strong></li><li>使用后保存，用save（）函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">active_ws = staff_wb.active</span><br><span class="line">info_list = [<span class="string">&#x27;S1911&#x27;</span>, <span class="string">&#x27;萧爵瑟&#x27;</span>, <span class="number">3000</span>, <span class="string">&#x27;内容&#x27;</span>]</span><br><span class="line">info_tuple = (<span class="string">&#x27;S1912&#x27;</span>, <span class="string">&#x27;吴琐薇&#x27;</span>, <span class="number">5000</span>, <span class="string">&#x27;销售&#x27;</span>)</span><br><span class="line">active_ws.append(info_list)</span><br><span class="line">active_ws.append(info_tuple)</span><br><span class="line"><span class="comment"># 保存工作簿为【append_demo.xlsx】</span></span><br><span class="line">staff_wb.save(<span class="string">&#x27;./append_demo.xlsx&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单元格对象"><a href="#单元格对象" class="headerlink" title="单元格对象"></a>单元格对象</h2><ul><li>单元格对象代表工作表中的一个单元格。</li></ul><h3 id="获取单元格对象"><a href="#获取单元格对象" class="headerlink" title="获取单元格对象"></a>获取单元格对象</h3><p>1、通过for row in 工作表对象.iter_rows()来获取指定范围的行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#for cell in 工作表对象[行数]</span></span><br><span class="line"><span class="comment">#for cell in 工作表对象[&#x27;列名&#x27;]</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">staff_ws = staff_wb.active</span><br><span class="line"><span class="comment"># for循环遍历，取出第三行的所有单元格对象</span></span><br><span class="line"><span class="keyword">for</span> row_cell <span class="keyword">in</span> staff_ws[<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(row_cell)</span><br><span class="line"><span class="comment"># for循环遍历，取出第三列（C列）的所有单元格对象</span></span><br><span class="line"><span class="keyword">for</span> col_cell <span class="keyword">in</span> staff_ws[<span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(col_cell)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、<strong>工作表对象[‘单元格坐标’]</strong></p><ul><li>工作表对象[‘A1’]就会获取到表格中，A1那个单元格对应的单元格对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【公司人员名单.xlsx】工作簿</span></span><br><span class="line">staff_wb = load_workbook(<span class="string">&#x27;./codes/material/公司人员名单.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">staff_ws = staff_wb.active</span><br><span class="line"><span class="comment"># 打印单元格对象A1</span></span><br><span class="line"><span class="built_in">print</span>(staff_ws[<span class="string">&#x27;A1&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单元格对象的基本操作"><a href="#单元格对象的基本操作" class="headerlink" title="单元格对象的基本操作"></a>单元格对象的基本操作</h3><ul><li>借助单元格对象的属性value，我们就可以得到具体的数据；同时，我们也可以通过这个属性给单元格对象赋值（修改单元格的值或给单元格添加值）。</li><li>直接赋值操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取单元格的值单元格对象.value</span></span><br><span class="line"><span class="comment"># 给单元格对象赋值单元格对象.value = 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从openpyxl库导入load_workbook函数</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="comment"># 打开【10月员工绩效表】的工作簿，获取活动工作表</span></span><br><span class="line">performance_wb  = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"><span class="comment"># 取出[&#x27;A1&#x27;]单元格对象</span></span><br><span class="line">cell1 = performance_ws[<span class="string">&#x27;A1&#x27;</span>]</span><br><span class="line"><span class="comment"># 使用单元格对象的value属性取出单元格的值，并打印</span></span><br><span class="line"><span class="built_in">print</span>(cell1.value)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">performance = ws[<span class="string">&#x27;E11&#x27;</span>].value<span class="comment">#赋值</span></span><br><span class="line">ws[<span class="string">&#x27;H1&#x27;</span>].value = <span class="string">&#x27;总工资&#x27;</span> <span class="comment">#改写赋值</span></span><br></pre></td></tr></table></figure><h1 id="常见语法错误"><a href="#常见语法错误" class="headerlink" title="常见语法错误"></a>常见语法错误</h1><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><ul><li>语法错误(syntax errors)是初学者最容易犯的错误</li><li>当你的代码完全符合Python的语法规范后，就该尝试运行程序了。但在程序运行过程中，还是有可能会发生问题，我们把这类问题称为**异常(exceptions)**。</li><li>代码不符合Python的语法规范，比如漏了冒号，混用中英文符号等，就会出现这种错误。</li></ul><h3 id="SyntaxError"><a href="#SyntaxError" class="headerlink" title="SyntaxError"></a>SyntaxError</h3><ul><li><p><strong>SyntaxError: invalid syntax（无效语法）</strong></p><ul><li>遗漏了标点符号</li><li>关键字拼写错误或遗漏</li><li>变量名或函数名使用了关键字。</li></ul></li><li><p><strong>SyntaxError: invalid character in identifier（标识符中有无效字符）</strong></p><ul><li>代码里使用了大量中文符号</li></ul></li><li><p><strong>SyntaxError: EOL while scanning string literal（检查到不完整的字符串）</strong></p><ul><li>遗漏了字符串两边的引号，或者混用了引号</li></ul></li></ul><h3 id="IndentationError"><a href="#IndentationError" class="headerlink" title="IndentationError"></a>IndentationError</h3><ul><li><strong>缩进错误</strong><ul><li><strong>IndentationError: expected an indented block（需要缩进的代码块）</strong></li></ul></li><li><strong>IndentationError: unindent does not match any outer indentation level（缩进内容不匹配任何一个层级）</strong></li></ul><h2 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h2><h3 id="TypeError类型错误"><a href="#TypeError类型错误" class="headerlink" title="TypeError类型错误"></a>TypeError类型错误</h3><ul><li><strong>异常</strong>的“错误消息”会显示Traceback (most recent call last）<ul><li><strong>TypeError: unsupported operand type(s) for …（不支持的运算）</strong></li></ul></li><li><strong>TypeError: can only concatenate str (not “int”) to str （只能用字符串拼接字符串）</strong></li><li><strong>TypeError: ‘xxx’ object is not iterable（对象不可被迭代）</strong><ul><li>可迭代对象应该包括：字符串类型，列表，元组和字典。剩下的一些类型，比如：int类型，float类型，布尔类型和None就不是可迭代对象。</li></ul></li></ul><h3 id="IndexError"><a href="#IndexError" class="headerlink" title="IndexError"></a>IndexError</h3><ul><li>IndexError这个异常，和列表取值有关。</li><li><strong>索引错误</strong>是<strong>IndexError: list index out of range（索引超出了范围）</strong></li></ul><h3 id="操作文件异常"><a href="#操作文件异常" class="headerlink" title="操作文件异常"></a>操作文件异常</h3><h4 id="ModuleNotFoundError"><a href="#ModuleNotFoundError" class="headerlink" title="ModuleNotFoundError"></a>ModuleNotFoundError</h4><ul><li>ModuleNotFoundError 未找到模块错误，是一种有关模块的异常</li><li>检查模块名是否拼写正确</li></ul><h4 id="AttributeError"><a href="#AttributeError" class="headerlink" title="AttributeError"></a>AttributeError</h4><ul><li>检查模块是否使用了不存在的方法或属性</li><li>检查方法或属性是否正确</li></ul><h4 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError:"></a>FileNotFoundError:</h4><ul><li>检查文件路径是否正确</li></ul><h4 id="FileNotFoundError-1"><a href="#FileNotFoundError-1" class="headerlink" title="FileNotFoundError:"></a>FileNotFoundError:</h4><ul><li>检查encoding的编码类型和实际文件是否一致</li></ul><h1 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h1><ul><li>选取部分行：语法:new_row &#x3D; [row[1],row[3], row[5]]</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249975.png" alt="image-20210817102224209"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250249.png" alt="image-20210817115202085"></p><h2 id="获取个人工资信息"><a href="#获取个人工资信息" class="headerlink" title="获取个人工资信息"></a>获取个人工资信息</h2><ul><li>我们需要从【10月员工绩效表】中找到江宇的信息，然后写入【江宇工资信息表】中10月工资信息对应的行</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041250001.png" alt="image-20210817095621289"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">code_highlight_9.py</span><br><span class="line"><span class="comment"># 从openpyxl库导入load_workbook函数</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表】的工作簿，获取活动工作表</span></span><br><span class="line">performance_wb  = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【江宇工资信息表】的工作簿，获取活动工作表</span></span><br><span class="line">info_wb = load_workbook(<span class="string">&#x27;./material/江宇工资信息表.xlsx&#x27;</span>)</span><br><span class="line">info_ws = info_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取【绩效】值</span></span><br><span class="line">performance = performance_ws[<span class="string">&#x27;D14&#x27;</span>].value</span><br><span class="line"><span class="comment"># 获取【奖金】值</span></span><br><span class="line">bonus = performance_ws[<span class="string">&#x27;E14&#x27;</span>].value</span><br><span class="line"><span class="comment"># 获取【基本工资】值</span></span><br><span class="line">base = performance_ws[<span class="string">&#x27;F14&#x27;</span>].value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入【绩效】值</span></span><br><span class="line">info_ws[<span class="string">&#x27;E11&#x27;</span>].value = performance</span><br><span class="line"><span class="comment"># 写入【奖金】值</span></span><br><span class="line">info_ws[<span class="string">&#x27;F11&#x27;</span>].value = bonus</span><br><span class="line"><span class="comment"># 写入【基本工资】值</span></span><br><span class="line">info_ws[<span class="string">&#x27;G11&#x27;</span>].value = base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存对【江宇工资信息表】工作簿的写入</span></span><br><span class="line">info_wb.save(<span class="string">&#x27;./material/江宇工资信息表.xlsx&#x27;</span>)</span><br><span class="line">点击这里可以改变学习模式～</span><br></pre></td></tr></table></figure><h2 id="生成前十行绩效信息表"><a href="#生成前十行绩效信息表" class="headerlink" title="生成前十行绩效信息表"></a>生成前十行绩效信息表</h2><ul><li>是需要从【10月员工绩效表】中提取前十行信息，写入一个新的工作簿。这样，保存后可以用作员工绩效信息的模板表格。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从openpyxl库导入load_workbook和Workbook</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表.xlsx】工作簿</span></span><br><span class="line">performance_wb = load_workbook(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\code\\.vscode\\10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">new_ws = new_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取performance_ws的前十行数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> performance_ws.iter_rows(max_row=<span class="number">10</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 将数据写入新的工作表</span></span><br><span class="line">    new_ws.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存新工作簿为【员工绩效表-模板.xlsx】</span></span><br><span class="line">new_wb.save(<span class="string">&#x27;C:\\Users\\win10\\Desktop\\10月员工绩效表.xlsx员工绩效表-模板.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="计算并打印奖金信息"><a href="#计算并打印奖金信息" class="headerlink" title="计算并打印奖金信息"></a>计算并打印奖金信息</h2><ul><li>依然是从【10月员工绩效表】提取所有员工的工资信息，然后根据每行中员工的“绩效”与“提成”的数值之和，计算出奖金总额，最后按照固定格式输出每位员工的奖金信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从openpyxl库导入load_workbook和Workbook</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表.xlsx】工作簿</span></span><br><span class="line">performance_wb = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取performance_ws中除表头外的数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> performance_ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 读取【工号】</span></span><br><span class="line">    staff_id = row[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 读取【员工姓名】</span></span><br><span class="line">    staff_name = row[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 读取【绩效】</span></span><br><span class="line">    performance = row[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 读取【提成】</span></span><br><span class="line">    bonus = row[<span class="number">4</span>]</span><br><span class="line">    <span class="comment"># 计算“奖金”</span></span><br><span class="line">    award = performance + bonus</span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;工号：&#123;&#125;，姓名：&#123;&#125;，本月奖金为：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(staff_id, staff_name, award))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建薪资信息字典"><a href="#创建薪资信息字典" class="headerlink" title="创建薪资信息字典"></a>创建薪资信息字典</h2><ul><li>要从这个总的薪资表中，读取所需数据范围的行数据，然后取出部分信息，将其对应存储在字典中。</li><li>【10月薪资绩效表】中的员工信息比较多，如果要找到某位同事（比如找到江宇的绩效、基本工资等）得按行整个查找一遍。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从openpyxl库导入load_workbook函数</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月员工绩效表.xlsx】工作簿</span></span><br><span class="line">performance_wb = load_workbook(<span class="string">&#x27;./material/10月员工绩效表.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">performance_ws = performance_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建员工信息字典</span></span><br><span class="line">staff_info = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第二行开始读取工作表中的信息</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> performance_ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出工号</span></span><br><span class="line">    member_number = row[<span class="number">0</span>]<span class="comment">#某行对应的数列序号</span></span><br><span class="line">    <span class="comment"># 将信息存入员工信息字典</span></span><br><span class="line">    staff_info[member_number] = &#123;  <span class="comment">#staff_info[member_number]:以工号键；字典嵌套</span></span><br><span class="line">         <span class="string">&#x27;姓名&#x27;</span>: row[<span class="number">1</span>],<span class="comment">#row[1]元组索引</span></span><br><span class="line">         <span class="string">&#x27;部门&#x27;</span>: row[<span class="number">2</span>],</span><br><span class="line">         <span class="string">&#x27;绩效&#x27;</span>: row[<span class="number">3</span>],</span><br><span class="line">         <span class="string">&#x27;奖金&#x27;</span>: row[<span class="number">4</span>],</span><br><span class="line">         <span class="string">&#x27;基本工资&#x27;</span>: row[<span class="number">5</span>],</span><br><span class="line">         <span class="string">&#x27;是否确认&#x27;</span>: row[<span class="number">6</span>]</span><br><span class="line">     &#125;</span><br><span class="line"><span class="built_in">print</span>(staff_info)</span><br></pre></td></tr></table></figure><h1 id="筛选匹配"><a href="#筛选匹配" class="headerlink" title="筛选匹配"></a>筛选匹配</h1><ul><li>在【10月考勤统计.xlsx】工作簿中，保存了公司一百名员工的迟到信息，这些信息包含了<strong>迟到时间</strong>和<strong>迟到次数</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开【10月考勤统计.xlsx】工作簿</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;./material/10月考勤统计.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取活动工作表</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取表头</span></span><br><span class="line">late_header = []</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws[<span class="number">1</span>]:</span><br><span class="line">    late_header.append(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建工作簿</span></span><br><span class="line">new_wb = Workbook()</span><br><span class="line"><span class="comment"># 获取新工作簿中的工作表</span></span><br><span class="line">new_ws = new_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将表头写入新工作簿的工作表中</span></span><br><span class="line">new_ws.append(late_header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第二行开始遍历表格</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出姓名，迟到时间和迟到次数</span></span><br><span class="line">    name = row[<span class="number">1</span>]</span><br><span class="line">    time = row[<span class="number">3</span>]</span><br><span class="line">    number = row[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 判断是否迟到</span></span><br><span class="line">    <span class="keyword">if</span> time &gt; <span class="number">45</span> <span class="keyword">and</span> number &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;迟到了&#123;&#125;分钟，迟到了&#123;&#125;次&#x27;</span>.<span class="built_in">format</span>(name, time, number))</span><br><span class="line">        <span class="comment"># 将迟到人员信息写入新工作簿的工作表中</span></span><br><span class="line">        new_ws.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将新工作簿保存为【10月迟到人员信息.xlsx】</span></span><br><span class="line">new_wb.save(<span class="string">&#x27;./material/10月迟到人员信息.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="数据匹配"><a href="#数据匹配" class="headerlink" title="数据匹配"></a>数据匹配</h1><ul><li>使用字典，把可以<strong>连接</strong>表格的数据作为键，要匹配的数据作为值</li><li>再将另一个表格中要匹配的值与字典中对应的值关联起来，实现匹配逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开工作簿【10月考勤统计.xlsx】，获取活动工作表</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;./material/10月考勤统计.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建迟到人员字典</span></span><br><span class="line">info_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环读取除表头外的表格数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows(min_row=<span class="number">2</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出员工工号</span></span><br><span class="line">    staff_id = row[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取出迟到次数</span></span><br><span class="line">    staff_late = row[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 将信息添加入字典，字典格式为&#123;&#x27;员工工号&#x27;: &#x27;迟到次数&#x27;&#125;</span></span><br><span class="line">    info_dict[staff_id] = staff_late</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开工作簿【迟到次数月度统计（10月更新）.xlsx】，获取活动工作表</span></span><br><span class="line">monthly_wb = load_workbook(<span class="string">&#x27;./material/迟到次数月度统计（10月更新）.xlsx&#x27;</span>)</span><br><span class="line">monthly_ws = monthly_wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环读取出表头外的表格数据</span></span><br><span class="line"><span class="keyword">for</span> monthly_row <span class="keyword">in</span> monthly_ws.iter_rows(min_row=<span class="number">3</span>, max_col=<span class="number">13</span>, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 取出员工工号</span></span><br><span class="line">    member_id = monthly_row[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取出十月份的迟到次数</span></span><br><span class="line">    member_late = monthly_row[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 匹配迟到次数是否相等</span></span><br><span class="line">    <span class="keyword">if</span> member_late != info_dict[member_id]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;工号&#123;&#125;迟到情况不匹配，请核查后更新&#x27;</span>.<span class="built_in">format</span>(member_id))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python/python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.python模块</title>
      <link href="/data.github.io/post/3117290d.html"/>
      <url>/data.github.io/post/3117290d.html</url>
      
        <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><ul><li>用来存放一位0或1，就是计算机里最小的存储单位，叫做【位】，也叫【比特】（bit）。我们规定8个比特构成一个【字节】（byte），这是计算机里最常用的单位。</li><li>bit位：存放一位二进制数，0或1，最小得存储单位</li><li>byte字节：8个二进制为1字节，最常用单位</li></ul><h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h2><ul><li><strong>Unicode</strong>是内存编码的规范，而<strong>UTF-8</strong>是如何保存和传输Unicode的手段。</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041249105.png" alt="image-20210811224812268"></p><h2 id="encode-和decode"><a href="#encode-和decode" class="headerlink" title="encode()和decode()"></a>encode()和decode()</h2><ul><li>编码，即将人类语言转换为计算机语言，就是【编码】<strong>encode()<strong>；反之，就是【解码】</strong>decode()</strong></li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&#x27;编码内容&#x27;.encode(&#x27;使用得编码表&#x27;)</span></span><br><span class="line"><span class="comment">#&#x27;解码内容&#x27;.decode(&#x27;使用得编码表&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;吴枫&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;吴枫&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;\xe5\x90\xb4\xe6\x9e\xab&#x27;</span>.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;\xce\xe2\xb7\xe3&#x27;</span>.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br></pre></td></tr></table></figure><h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><h2 id="开-open（）"><a href="#开-open（）" class="headerlink" title="开-open（）"></a>开-open（）</h2><ul><li>绝对路径：<strong>绝对路径</strong>就是最完整的路径；将文件拖入VScode终端可以获得绝对路径</li><li>或者右键复制路径</li><li>相对路径：指的就是【相对于当前文件夹】的路径</li><li>windows系统中\来表示绝对路径，&#x2F;表示相对路径</li><li><strong>格式：文件名&#x3D;(‘路径’，’模式’，encoding&#x3D;’utf-8’)</strong></li><li>sumlime text3要绝对路径<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;C:\\Users\\Ted\\Desktop\\test\\abc.txt&#x27;</span>)</span><br><span class="line"><span class="comment">#将&#x27;\&#x27;替换成&#x27;\\&#x27;</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>)    <span class="comment">#相对路径</span></span><br><span class="line"><span class="comment">#相对路径也可以写成open(&#x27;./abc.txt&#x27;)</span></span><br></pre></td></tr></table></figure></li><li>‘r’:表示以读得模式打开文件</li></ul><h3 id="模式汇总"><a href="#模式汇总" class="headerlink" title="模式汇总"></a>模式汇总</h3><table><thead><tr><th>r(read，读)</th><th>r只读，指针在开头文件不存在则报错</th><th>rb二进制只读，其余同左</th><th>r+读写，其余同左</th><th>rb+二进制读写，其余同左</th></tr></thead><tbody><tr><td>w(write,写)</td><td>w只写，文件不存在则新建，存在则覆盖</td><td>wb二进制只写，其余同左</td><td>w+读写，其余同左</td><td>wb+二进制读写，其余同左</td></tr><tr><td>a(append,追加)</td><td>a追加,文件存在指针放在末尾,文件不存在则新建</td><td>ab二进制追加，其余同左</td><td>a+追加且可读,其余同左</td><td>ab+二进制追加，且可读，其余同左</td></tr></tbody></table><ul><li>**’wb’**的模式，它的意思是以二进制的方式打开一个文件用于写入。因为图片和音频是以二进制的形式保存的，所以使用wb模式就好了</li></ul><h2 id="读-read（）"><a href="#读-read（）" class="headerlink" title="读-read（）"></a>读-read（）</h2><h3 id="直接读取"><a href="#直接读取" class="headerlink" title="直接读取"></a>直接读取</h3><p><strong>变量名&#x3D;文件名.read()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#变量名=文件名.read()</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;/Users/Ted/Desktop/test/abc.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">filecontent = file1.read()      </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure><h3 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h3><ul><li>格式：<strong>变量名&#x3D;文件名.readlines()</strong></li><li><strong>readlines()</strong> 会从txt文件取得一个列表，列表中的每个字符串就是文件中的每一行。而且每个字符串后面还有换行的<strong>\n</strong>符号。</li><li><strong>for循环</strong>来遍历这个列表</li></ul><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="string">&quot;aaacde&quot;</span></span><br><span class="line">a=i.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="写-write"><a href="#写-write" class="headerlink" title="写-write()"></a>写-write()</h2><h3 id="‘w’模式"><a href="#‘w’模式" class="headerlink" title="‘w’模式"></a>‘w’模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)</span><br><span class="line">file1.close()</span><br></pre></td></tr></table></figure><ul><li>‘w：表示写入文件’</li><li>参数为字符串</li><li>格式：<strong>文件名.write(‘内容’)</strong></li><li>**’w’**写入模式会给你暴力清空掉文件</li><li>**write()**函数写入文本文件的也是字符串类型。</li><li>在**’w’<strong>和</strong>‘a’<strong>模式下，如果你打开的文件不存在，那么</strong>open()**函数会自动帮你创建一个</li></ul><h3 id="‘a’模式"><a href="#‘a’模式" class="headerlink" title="‘a’模式"></a>‘a’模式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line"><span class="comment">#以追加的方式打开文件abc.txt</span></span><br><span class="line">file1.write(<span class="string">&#x27;张无忌\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;张无忌&#x27;写入文件file1</span></span><br><span class="line">file1.write(<span class="string">&#x27;宋青书\n&#x27;</span>)     </span><br><span class="line"><span class="comment">#把字符串&#x27;宋青书&#x27;写入文件file1</span></span><br></pre></td></tr></table></figure><ul><li>追加模式：增加内容而不是覆盖原来的内容</li></ul><h2 id="关-close"><a href="#关-close" class="headerlink" title="关-close()"></a>关-close()</h2><ul><li>关闭文件</li><li>计算机能够打开的文件数量是有限制的，open()过多而不close()的话，就不能再打开文件了。</li><li>能保证写入的内容已经在文件里被保存好了。</li><li><strong>文件名.close</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file1=<span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#定义文件名</span></span><br><span class="line">file2=file1.read()<span class="comment">#读文件并复制给变量</span></span><br><span class="line"><span class="built_in">print</span>(file2)</span><br><span class="line">file1.close()<span class="comment">#关闭文件</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关键字with"><a href="#关键字with" class="headerlink" title="关键字with"></a>关键字with</h2><ul><li>为了避免打开文件后忘记关闭，占用资源或当不能确定关闭文件的恰当时机的时候，我们可以用到关键字with</li><li>格式：with open(‘文件地址’,’读写模式’) as 变量名:</li><li>后面编码：encoding&#x3D;’utf-8’：如果要文件包括中文要加<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通写法</span></span><br><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用with关键字的写法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;abc.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file1:</span><br><span class="line"><span class="comment">#with open(&#x27;文件地址&#x27;,&#x27;读写模式&#x27;,encoding=&#x27;utf-8&#x27;) as 变量名:</span></span><br><span class="line">    <span class="comment">#格式：冒号不能丢</span></span><br><span class="line">    file1.write(<span class="string">&#x27;张无忌&#x27;</span>) </span><br><span class="line">    <span class="comment">#格式：对文件的操作要缩进</span></span><br><span class="line">    <span class="comment">#格式：无需用close()关闭</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="split-分开字符串"><a href="#split-分开字符串" class="headerlink" title="split():分开字符串"></a>split():分开字符串</h2><ul><li>它会按空格把字符串里面的内容分开</li><li>最终组合成一个列表</li><li>格式：<strong>变量1&#x3D;变量2.split()</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file1 = <span class="built_in">open</span>(<span class="string">&#x27;score.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) </span><br><span class="line">file_lines = file1.readlines()</span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_lines:   <span class="comment">#用for...in...把每一行的数据遍历  </span></span><br><span class="line">    data =i.split()    <span class="comment">#把字符串切分成更细的一个个的字符串</span></span><br><span class="line">    <span class="built_in">print</span>(data)        <span class="comment">#打印出来看看</span></span><br></pre></td></tr></table></figure><h2 id="join-合并字符串"><a href="#join-合并字符串" class="headerlink" title="join():合并字符串"></a>join():合并字符串</h2><ul><li>格式：<strong>a.join(b)</strong></li><li>a：用什么连接</li><li>b：要组合字符串的列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;t&#x27;</span>]</span><br><span class="line">b=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b.join(a))</span><br><span class="line">c=<span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(c.join(a))</span><br></pre></td></tr></table></figure></li></ul><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><h3 id="调用模块"><a href="#调用模块" class="headerlink" title="调用模块"></a>调用模块</h3><p>1、导入模块</p><ul><li>导入多个模块时：比如<strong>import a,b,c</strong>可以同时导入“a.py，b.py，c.py”三个文件<br>2、调用模块时：</li><li>使用“模块.函数()”调用模块中的函数</li><li>使用“模块.变量”调用模块中的变量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是主程序main.py</span></span><br><span class="line"><span class="comment"># 请阅读代码注释</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test  <span class="comment"># 导入test模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test.a)  <span class="comment"># 使用“模块.变量”调用模块中的变量</span></span><br><span class="line"></span><br><span class="line">test.hi()  <span class="comment"># 使用“模块.函数()”调用模块中的函数</span></span><br><span class="line"></span><br><span class="line">A = test.Go2()  <span class="comment"># 使用“变量 = 模块.类()”实例化模块中的类</span></span><br><span class="line"><span class="built_in">print</span>(A.a)  <span class="comment"># 实例化后，不再需要“模块.”</span></span><br><span class="line">A.do2()  <span class="comment"># 实例化后，不再需要“模块.”</span></span><br></pre></td></tr></table></figure><h3 id="import…as"><a href="#import…as" class="headerlink" title="import…as.."></a>import…as..</h3><ul><li><strong>import story as s</strong>语句，意思是为“story”取个别名为“s”</li></ul><h2 id="from-…-import-…-语句"><a href="#from-…-import-…-语句" class="headerlink" title="from … import … 语句"></a>from … import … 语句</h2><ul><li>从模块中导入一个指定的部分到当前模块</li><li>格式：<strong>from (模块名) import(指定模块中的变量名&#x2F;函数名&#x2F;类名)</strong></li><li>效果：导入指定部分可以<strong>直接使用</strong>，不需要加入‘模块.’前缀</li><li>同模块多个指定内容：<strong>from xx模块 import a,b,c</strong></li><li>模块中指定所用内容分直接使用：<strong>from xx模块 import</strong> ;代表“模块中所有的变量、函数、类</li></ul><h2 id="if-name-‘main‘"><a href="#if-name-‘main‘" class="headerlink" title="if name &#x3D;&#x3D; ‘main‘"></a>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘</h2><ul><li>Python 模拟的程序入口<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#xx.py文件</span></span><br><span class="line">代码块<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">if</span> _name_ == <span class="string">&#x27;_main_&#x27;</span>:</span><br><span class="line">    代码块<span class="number">2.</span>..</span><br><span class="line"><span class="comment">#1、当xx.py文件被直接运行时，代码模块2将被运行</span></span><br><span class="line"><span class="comment">#2、当xx.py文件作为模块是被其他程序导入时，代码模块2不被执行</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="scv模块"><a href="#scv模块" class="headerlink" title="scv模块"></a>scv模块</h1><ul><li><a href="https://yiyibooks.cn/xx/python_352/library/csv.html#module-csv">官方文档</a>：看示例</li><li>注意;创建的excel文档是csv格式，另存</li></ul><h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><ul><li><code> #参数encoding</code>&#x3D; ‘utf-8’防止出现乱码；一般有中文要加;报错就删或者加</li></ul><h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\win10\\Desktop\\code\\.vscode\\python.csv&quot;</span>,newline = <span class="string">&#x27;&#x27;</span>)  <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    <span class="comment">#使用csv的reader()方法，创建一个reader对象</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader: </span><br><span class="line">    <span class="comment">#遍历reader对象的每一行</span></span><br><span class="line">        <span class="built_in">print</span>(row)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;读取完毕！&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\win10\\Desktop\\code\\.vscode\\python.csv&quot;</span>,<span class="string">&#x27;a&#x27;</span>,newline = <span class="string">&#x27;&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="keyword">as</span> f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    writer.writerow([<span class="number">832</span>,<span class="number">134</span>,<span class="number">1</span>,<span class="number">35</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python/python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.python进阶2</title>
      <link href="/data.github.io/post/9aab5b6a.html"/>
      <url>/data.github.io/post/9aab5b6a.html</url>
      
        <content type="html"><![CDATA[<h1 id="3、基础进阶2"><a href="#3、基础进阶2" class="headerlink" title="3、基础进阶2"></a>3、基础进阶2</h1><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="time模块——时间"><a href="#time模块——时间" class="headerlink" title="time模块——时间"></a>time模块——时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time   <span class="comment">#调用time模块</span></span><br><span class="line">time.sleep(secs)   </span><br><span class="line"><span class="comment">#使用time模块下面的sleep()函数，括号里填的是间隔的秒数（seconds，简称secs）</span></span><br><span class="line"><span class="comment">#time.sleep(1.5)就表示停留1.5秒再运行后续代码</span></span><br></pre></td></tr></table></figure><h2 id="random模块——随机生成数字"><a href="#random模块——随机生成数字" class="headerlink" title="random模块——随机生成数字"></a>random模块——随机生成数字</h2><h3 id="random-randint-a-b"><a href="#random-randint-a-b" class="headerlink" title="random.randint(a,b)"></a>random.randint(a,b)</h3><ul><li><strong>生成一个指定范围[a,b]内的整数</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random  <span class="comment"># 调用random模块</span></span><br><span class="line"></span><br><span class="line">a = random.random()  <span class="comment"># 随机从0-1之间（包括0不包括1）抽取一个小数</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = random.randint(<span class="number">0</span>,<span class="number">100</span>)  <span class="comment"># 随机从0-100（包括0和100）之间抽取一个数字</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = random.choice(<span class="string">&#x27;abcdefg&#x27;</span>)  <span class="comment"># 随机从字符串，列表等对象中抽取一个元素（可能会重复）</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = random.sample(<span class="string">&#x27;abcdefg&#x27;</span>, <span class="number">3</span>) <span class="comment"># 随机从字符串，列表等对象中抽取多个不重复的元素,不同位置</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]  <span class="comment"># “随机洗牌”，比如打乱列表</span></span><br><span class="line">random.shuffle(items)</span><br><span class="line"><span class="built_in">print</span>(items)</span><br></pre></td></tr></table></figure><h3 id="random-choice-函数"><a href="#random-choice-函数" class="headerlink" title="random.choice()函数"></a>random.choice()函数</h3><ul><li>random.choice(sequence)：从序列中获取一个随机元素</li></ul><h3 id="random-random"><a href="#random-random" class="headerlink" title="random.random()"></a>random.random()</h3><ul><li>生成一个0到1的随机浮点数<br>random.uniform(a,b)</li><li>生成一个指定范围(a,b)内的随机浮点数<br>random.randrange(start, stop, step)</li><li>从指定范围内，按指定基数递增的集合中 获取一个随机数<br>random.shuffle(AB)</li><li>用于将一个列表中的元素打乱<br>random.sample(sequence, k)</li><li>从指定序列中随机获取指定长度的片断</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数</span>):</span><br><span class="line">函数体</span><br><span class="line"><span class="keyword">return</span> 语句</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数名：1. 名字最好能体现函数的功能，一般用小写字母和单下划线、数字等组合</span></span><br><span class="line"><span class="comment">#      2. 不可与内置函数重名（内置函数不需要定义即可直接使用）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">math</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment"># 参数：根据函数功能，括号里可以有多个参数，也可以不带参数，命名规则与函数名相同</span></span><br><span class="line"><span class="comment"># 规范：括号是英文括号，后面的冒号不能丢</span></span><br><span class="line">    y = <span class="number">3</span>*x + <span class="number">5</span></span><br><span class="line"><span class="comment"># 函数体：函数的执行过程，体现函数功能的语句，要缩进，一般是四个空格</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"><span class="comment"># return语句：后面可以接多种数据类型，如果函数不需要返回值的话，可以省略</span></span><br></pre></td></tr></table></figure><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">math</span>(<span class="params">x</span>):</span><br><span class="line">    y = x ** <span class="number">2</span> + x</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">a = math(<span class="number">20</span>)<span class="comment">#调用函数</span></span><br><span class="line">b = math(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span>  <span class="title function_">menu</span>(<span class="params">appetizer, course, dessert = <span class="string">&#x27;绿豆沙&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;一份开胃菜：&#x27;</span> + appetizer)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;一份主食：&#x27;</span> + course)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;一份甜品：&#x27;</span> + dessert)</span><br><span class="line"></span><br><span class="line">menu(<span class="string">&#x27;话梅花生&#x27;</span>,<span class="string">&#x27;牛肉拉面&#x27;</span>)</span><br><span class="line"><span class="comment">#因为已经默认将&#x27;绿豆沙&#x27;传递给dessert，调用时无须再传递。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------&#x27;</span>)</span><br><span class="line"><span class="comment">#如果采用下面这种形式传递，就不需要理会参数位置</span></span><br><span class="line">menu(course = <span class="string">&#x27;牛肉拉面&#x27;</span>, appetizer = <span class="string">&#x27;话梅花生&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------&#x27;</span>)</span><br><span class="line">menu(<span class="string">&#x27;话梅花生&#x27;</span>,<span class="string">&#x27;牛肉拉面&#x27;</span>,<span class="string">&#x27;银耳羹&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><ul><li>格式：def  函数名（*参数）</li><li>参数返回值是<strong>元组类型</strong></li><li>不定长参数可以接收任意数量的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">*barbeque</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> barbeque:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;一份烤串：&#x27;</span> + i)</span><br><span class="line"></span><br><span class="line">menu(<span class="string">&#x27;烤香肠&#x27;</span>, <span class="string">&#x27;烤肉丸&#x27;</span>) <span class="comment">#括号里的这几个值都会传递给参数barbeque       </span></span><br><span class="line">menu(<span class="string">&#x27;烤鸡翅&#x27;</span>, <span class="string">&#x27;烤茄子&#x27;</span>, <span class="string">&#x27;烤玉米&#x27;</span>)</span><br><span class="line"><span class="comment"># 不定长参数可以接收任意数量的值</span></span><br></pre></td></tr></table></figure><h1 id="try…except-语句"><a href="#try…except-语句" class="headerlink" title="try…except..语句"></a>try…except..语句</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment">#尝试执行下列代码</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">except</span> ***:</span><br><span class="line"><span class="comment">#除非发生报错，***是报错类型，移到报错执行下列代码</span></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数：&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;要输入整数噢&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="python异常标准"><a href="#python异常标准" class="headerlink" title="python异常标准"></a>python异常标准</h2><table><thead><tr><th align="left">异常名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">BaseException</td><td align="left">所有异常的基类</td></tr><tr><td align="left">SystemExit</td><td align="left">解释器请求退出</td></tr><tr><td align="left">KeyboardInterrupt</td><td align="left">用户中断执行(通常是输入^C)</td></tr><tr><td align="left">Exception</td><td align="left">常规错误的基类</td></tr><tr><td align="left">StopIteration</td><td align="left">迭代器没有更多的值</td></tr><tr><td align="left">GeneratorExit</td><td align="left">生成器(generator)发生异常来通知退出</td></tr><tr><td align="left">StandardError</td><td align="left">所有的内建标准异常的基类</td></tr><tr><td align="left">ArithmeticError</td><td align="left">所有数值计算错误的基类</td></tr><tr><td align="left">FloatingPointError</td><td align="left">浮点计算错误</td></tr><tr><td align="left">OverflowError</td><td align="left">数值运算超出最大限制</td></tr><tr><td align="left">ZeroDivisionError</td><td align="left">除(或取模)零 (所有数据类型)</td></tr><tr><td align="left">AssertionError</td><td align="left">断言语句失败</td></tr><tr><td align="left">AttributeError</td><td align="left">对象没有这个属性</td></tr><tr><td align="left">EOFError</td><td align="left">没有内建输入,到达EOF 标记</td></tr><tr><td align="left">EnvironmentError</td><td align="left">操作系统错误的基类</td></tr><tr><td align="left">IOError</td><td align="left">输入&#x2F;输出操作失败</td></tr><tr><td align="left">OSError</td><td align="left">操作系统错误</td></tr><tr><td align="left">WindowsError</td><td align="left">系统调用失败</td></tr><tr><td align="left">ImportError</td><td align="left">导入模块&#x2F;对象失败</td></tr><tr><td align="left">LookupError</td><td align="left">无效数据查询的基类</td></tr><tr><td align="left">IndexError</td><td align="left">序列中没有此索引(index)</td></tr><tr><td align="left">KeyError</td><td align="left">映射中没有这个键</td></tr><tr><td align="left">MemoryError</td><td align="left">内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td align="left">NameError</td><td align="left">未声明&#x2F;初始化对象 (没有属性)</td></tr><tr><td align="left">UnboundLocalError</td><td align="left">访问未初始化的本地变量</td></tr><tr><td align="left">ReferenceError</td><td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td align="left">RuntimeError</td><td align="left">一般的运行时错误</td></tr><tr><td align="left">NotImplementedError</td><td align="left">尚未实现的方法</td></tr><tr><td align="left">SyntaxError</td><td align="left">Python 语法错误</td></tr><tr><td align="left">IndentationError</td><td align="left">缩进错误</td></tr><tr><td align="left">TabError</td><td align="left">Tab 和空格混用</td></tr><tr><td align="left">SystemError</td><td align="left">一般的解释器系统错误</td></tr><tr><td align="left">TypeError</td><td align="left">对类型无效的操作</td></tr><tr><td align="left">ValueError</td><td align="left">传入无效的参数</td></tr><tr><td align="left">UnicodeError</td><td align="left">Unicode 相关的错误</td></tr><tr><td align="left">UnicodeDecodeError</td><td align="left">Unicode 解码时的错误</td></tr><tr><td align="left">UnicodeEncodeError</td><td align="left">Unicode 编码时错误</td></tr><tr><td align="left">UnicodeTranslateError</td><td align="left">Unicode 转换时错误</td></tr><tr><td align="left">Warning</td><td align="left">警告的基类</td></tr><tr><td align="left">DeprecationWarning</td><td align="left">关于被弃用的特征的警告</td></tr><tr><td align="left">FutureWarning</td><td align="left">关于构造将来语义会有改变的警告</td></tr><tr><td align="left">OverflowWarning</td><td align="left">旧的关于自动提升为长整型(long)的警告</td></tr><tr><td align="left">PendingDeprecationWarning</td><td align="left">关于特性将会被废弃的警告</td></tr><tr><td align="left">RuntimeWarning</td><td align="left">可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td align="left">SyntaxWarning</td><td align="left">可疑的语法的警告</td></tr><tr><td align="left">UserWarning</td><td align="left">用户代码生成的警告</td></tr></tbody></table><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ul><li><strong>类</strong>:比如整数、字符串、浮点数等，不同的数据类型就属于不同的类</li><li>类有自己的属性和方法</li><li>类名要大写</li><li><strong>实例</strong>:类的个例就叫做<strong>实例</strong></li><li>对象:对象等于类和实例的集合：即类可以看作是对象，实例也可以看作是对象，比如列表list是个类对象，<code>[1,2]</code>是个实例对象，它们都是对象。</li></ul><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">赋值语句<span class="comment">#类的属性创建</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self</span>):<span class="comment">#类中定义的函数叫方法</span></span><br><span class="line">执行过程</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:<span class="comment">#</span></span><br><span class="line">screen = <span class="literal">True</span><span class="comment">## 用赋值语句，创建类的属性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;电脑正在开机中...&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="类的调用"><a href="#类的调用" class="headerlink" title="类的调用"></a>类的调用</h2><h3 id="调用语法"><a href="#调用语法" class="headerlink" title="调用语法"></a>调用语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实例名.属性</span><br><span class="line">实例名.方法（）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>:</span><br><span class="line">    screen = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;电脑正在开机中……&#x27;</span>)</span><br><span class="line">my_computer = Computer()<span class="comment">#类的实例化</span></span><br><span class="line"><span class="built_in">print</span>(my_computer.screen)<span class="comment">#调用属性属性</span></span><br><span class="line">my_computer.start()<span class="comment">#调用类中的方法（传参不用管self）</span></span><br></pre></td></tr></table></figure><h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><ul><li>self会接收实例化过程中传入的数据，当实例对象创建后，实例便会代替 self，在代码中运行。</li><li><code>self</code>的作用相当于先给实例占了个位置，等到实例创建好就“功成身退，退位让贤”。</li></ul><h4 id="在方法内调用类的属性"><a href="#在方法内调用类的属性" class="headerlink" title="在方法内调用类的属性"></a>在方法内调用类的属性</h4><p><strong>self.属性名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过self.属性名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    name = <span class="string">&#x27;吴枫&#x27;</span>  <span class="comment"># 类属性name</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):     </span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;是中国人&#x27;</span>)<span class="comment">#调用类中的属性</span></span><br><span class="line">person = Chinese()   <span class="comment"># 创建Chinese的实例person</span></span><br><span class="line">person.say()         <span class="comment"># 调用实例方法</span></span><br><span class="line"><span class="comment">#实例person会像参数一样传给self，替换掉self，第六行的self.name等价于person.name</span></span><br></pre></td></tr></table></figure><h4 id="在类方法调用其他方法"><a href="#在类方法调用其他方法" class="headerlink" title="在类方法调用其他方法"></a>在类方法调用其他方法</h4><p><strong>self.方法名（）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#self.方法名（）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;很高兴遇见你&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        self.greeting() </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我来自中国&#x27;</span>)</span><br><span class="line">person = Chinese()</span><br><span class="line"><span class="comment"># 创建实例person</span></span><br><span class="line">person.say()</span><br><span class="line"><span class="comment"># 调用say()方法</span></span><br></pre></td></tr></table></figure><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式__init__(self)</span></span><br></pre></td></tr></table></figure><ul><li>当每个实例<strong>对象创建</strong>时，该方法内的代码<strong>无须调用就会自动运行</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阅读代码后直接运行    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;很高兴遇见你，我是初始化方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person = Chinese()</span><br></pre></td></tr></table></figure><ul><li>利用这个特性，在编写习惯上，我们会在初始化方法内部完成类属性的创建，为类属性设置初始值，这样类中的其他方法就能直接、随时调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, birth, region</span>):</span><br><span class="line">        self.name = name   <span class="comment"># self.name = &#x27;吴枫&#x27; </span></span><br><span class="line">        self.birth = birth  <span class="comment"># self.birth = &#x27;广东&#x27;</span></span><br><span class="line">        self.region = region  <span class="comment"># self.region = &#x27;深圳&#x27;</span></span><br><span class="line">        <span class="comment">#self.不能丢</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">born</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;出生在&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name,self.birth))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">live</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;居住在&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name,self.region) )    </span><br><span class="line"></span><br><span class="line">person = Chinese(<span class="string">&#x27;吴枫&#x27;</span>,<span class="string">&#x27;广东&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>) <span class="comment"># 传入初始化方法的参数</span></span><br><span class="line">person.born()</span><br><span class="line">person.live()</span><br><span class="line"><span class="built_in">print</span>(person.birth)<span class="comment">#输出方法内的参数</span></span><br></pre></td></tr></table></figure><p>面向对象编程：类的创建和调用<br>面向过程编程：函数的创建和调用</p><h1 id="类的继承和定制"><a href="#类的继承和定制" class="headerlink" title="类的继承和定制"></a>类的继承和定制</h1><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ul><li>让子类拥有了父类拥有的所有属性和方法</li><li>A类为B的子类，B为A的父类</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><strong>class 子类名（父类名）</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    eye = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;吃饭，选择用筷子。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):  </span><br><span class="line"><span class="comment"># 通过继承，Chinese类有的，Cantonese类也有</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 验证子类可以继承父类的属性和方法，进而传递给子类创建的实例</span></span><br><span class="line">yewen = Cantonese()  </span><br><span class="line"><span class="comment"># 子类创建的实例，从子类那间接得到了父类的所有属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(yewen.eye)  </span><br><span class="line"><span class="comment"># 子类创建的实例，可调用父类的属性</span></span><br><span class="line">yewen.eat()  </span><br><span class="line"><span class="comment"># 子类创建的实例，可调用父类的方法</span></span><br></pre></td></tr></table></figure><ul><li><code>class Chinese:</code>在运行时相当于<code>class Chinese(object):</code>。而object，是所有类的父类</li></ul><h4 id="验证类"><a href="#验证类" class="headerlink" title="验证类"></a>验证类</h4><ul><li><strong>函数<code>isinstance(实例，类名)</code></strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阅读完代码再运行。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">gonger = Chinese()</span><br><span class="line"><span class="comment"># 宫二，电影《一代宗师》女主，生于东北</span></span><br><span class="line">yewen = Cantonese()</span><br><span class="line"><span class="comment"># 叶问，电影《一代宗师》男主，生于广东</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n验证1：子类创建的实例同时也属于父类&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(gonger,Chinese))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(yewen,Chinese))  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n验证2：父类创建的实例不属于子类。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(gonger,Cantonese))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n验证3：类创建的实例都属于根类。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(gonger,<span class="built_in">object</span>))  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(yewen,<span class="built_in">object</span>))</span><br></pre></td></tr></table></figure><h3 id="类的多层继承"><a href="#类的多层继承" class="headerlink" title="类的多层继承"></a>类的多层继承</h3><ul><li>继承不仅可以发生在两个层级之间（即父类-子类），还可以有父类的父类、父类的父类的父类……</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">B</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">B</span>)</span><br></pre></td></tr></table></figure><h3 id="类的多重继承"><a href="#类的多重继承" class="headerlink" title="类的多重继承"></a>类的多重继承</h3><ul><li><strong>语法为class A(B,C,D)</strong></li><li>一个类，可以同时继承多个类，语法为<code>class A(B,C,D):</code>。假设我们将“出生在江苏，定居在广东的人”设为一个类Yuesu，那么，它的创建语句则为<code>class Yuesu(Yue,Su)</code></li><li><strong>就近原则</strong>：越靠近子类（即越靠左）的父类，越亲近，越优先考虑。子类调用属性和方法时，会<strong>先在靠左的父类里找</strong>，找不到才往右找。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Su</span>:</span><br><span class="line">    born_city = <span class="string">&#x27;Jiangsu&#x27;</span></span><br><span class="line">    wearing = <span class="string">&#x27;thick&#x27;</span>  <span class="comment"># 穿得较厚</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们爱吃甜。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yue</span>:</span><br><span class="line">    settle_city = <span class="string">&#x27;Guangdong&#x27;</span></span><br><span class="line">    wearing = <span class="string">&#x27;thin&#x27;</span>  <span class="comment"># 穿得较薄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们吃得清淡。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yuesu</span>(Yue,Su):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">xiaoming = Yuesu()</span><br><span class="line"><span class="built_in">print</span>(xiaoming.wearing)</span><br><span class="line"><span class="built_in">print</span>(xiaoming.born_city)</span><br><span class="line">xiaoming.diet()</span><br></pre></td></tr></table></figure><h2 id="类的定制"><a href="#类的定制" class="headerlink" title="类的定制"></a>类的定制</h2><p>类的定制，不仅可以让子类拥有新的功能，还能让它有权修改继承到的代码</p><ul><li>新增代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    eye = <span class="string">&#x27;black&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;吃饭，选择用筷子。&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):  <span class="comment"># 类的继承</span></span><br><span class="line">    native_place = <span class="string">&#x27;guangdong&#x27;</span>  <span class="comment"># 类的定制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dialect</span>(<span class="params">self</span>):  <span class="comment"># 类的定制</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们会讲广东话。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yewen = Cantonese()</span><br><span class="line"><span class="built_in">print</span>(yewen.eye)</span><br><span class="line"><span class="comment"># 父类的属性能用</span></span><br><span class="line"><span class="built_in">print</span>(yewen.native_place)</span><br><span class="line"><span class="comment"># 子类的定制属性也能用</span></span><br><span class="line">yewen.eat()</span><br><span class="line"><span class="comment"># 父类的方法能用</span></span><br><span class="line">yewen.dialect()</span><br><span class="line"><span class="comment"># 子类的定制方法也能用</span></span><br></pre></td></tr></table></figure></li><li>重写代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">land_area</span>(<span class="params">self,area</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我们居住的地方，陆地面积是%d万平方公里左右。&#x27;</span>% area)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cantonese</span>(<span class="title class_ inherited__">Chinese</span>):</span><br><span class="line">    <span class="comment"># 间接对方法进行重写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">land_area</span>(<span class="params">self, area, rate = <span class="number">0.0188</span></span>):</span><br><span class="line">        Chinese.land_area(self, area * rate)</span><br><span class="line">        <span class="comment"># 直接继承父类方法，再调整参数。</span></span><br><span class="line"></span><br><span class="line">gonger = Chinese()</span><br><span class="line">yewen = Cantonese()</span><br><span class="line">gonger.land_area(<span class="number">960</span>)</span><br><span class="line">yewen.land_area(<span class="number">960</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python/python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.python基础进阶</title>
      <link href="/data.github.io/post/65cd25d3.html"/>
      <url>/data.github.io/post/65cd25d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="2、基础进阶"><a href="#2、基础进阶" class="headerlink" title="2、基础进阶"></a>2、基础进阶</h1><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表名=[数据<span class="number">1</span>，数据<span class="number">2</span>,..,数据n]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;小明&#x27;</span>,<span class="number">18</span>,<span class="number">1.70</span>]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求元素下标"><a href="#求元素下标" class="headerlink" title="求元素下标"></a>求元素下标</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;小明&#x27;</span>,<span class="number">18</span>,<span class="number">1.70</span>]</span><br><span class="line">list1.index(<span class="string">&#x27;小明&#x27;</span>)<span class="comment">#求元素下标</span></span><br></pre></td></tr></table></figure><h2 id="列表提取单个元素"><a href="#列表提取单个元素" class="headerlink" title="列表提取单个元素"></a>列表提取单个元素</h2><ul><li>偏移量：对列表元素的位置编号。 </li><li>列表的偏移量从0开始计算（从左到右）</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h4 id="列表名-索引"><a href="#列表名-索引" class="headerlink" title="列表名[索引]"></a>列表名[索引]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>]<span class="comment">#小明，小红，小刚的偏移量分别是0，1，2</span></span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">2</span>])  </span><br></pre></td></tr></table></figure><h2 id="提取多个元素"><a href="#提取多个元素" class="headerlink" title="提取多个元素"></a>提取多个元素</h2><h3 id="用冒号切片"><a href="#用冒号切片" class="headerlink" title="用冒号切片"></a>用冒号切片</h3><p>冒号：左右空，取到头；<strong>左取右不取</strong></p><h4 id="列表名-a-b"><a href="#列表名-a-b" class="headerlink" title="列表名[a:b]"></a>列表名[a:b]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list2 = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(list2[:])<span class="comment"># 打印出[5,6,7,8,9]</span></span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">2</span>:])<span class="comment"># 打印出[7,8,9]</span></span><br><span class="line"><span class="built_in">print</span>(list2[:<span class="number">2</span>])<span class="comment"># 打印出[5,6]</span></span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">1</span>:<span class="number">3</span>])<span class="comment">#打印出[6,7]</span></span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">2</span>:<span class="number">4</span>])<span class="comment">#打印出[7,8]</span></span><br></pre></td></tr></table></figure><h2 id="给列表添加或删除元素"><a href="#给列表添加或删除元素" class="headerlink" title="给列表添加或删除元素"></a>给列表添加或删除元素</h2><h3 id="添加格式"><a href="#添加格式" class="headerlink" title="添加格式"></a>添加格式</h3><h4 id="列表名-append-内容"><a href="#列表名-append-内容" class="headerlink" title="列表名.append(内容 )"></a>列表名.append(内容 )</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>]</span><br><span class="line">students.append(<span class="string">&#x27;小美&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(students)<span class="comment">#[&#x27;小明&#x27;, &#x27;小红&#x27;, &#x27;小刚&#x27;, &#x27;小美&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="删除格式"><a href="#删除格式" class="headerlink" title="删除格式"></a>删除格式</h3><h4 id="del-列表名-元素的索引"><a href="#del-列表名-元素的索引" class="headerlink" title="del 列表名[元素的索引]"></a>del 列表名[元素的索引]</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> students[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(students)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对中间段删除</span></span><br><span class="line">a=<span class="string">&#x27;1234567890&#x27;</span></span><br><span class="line">b=<span class="built_in">list</span>(a)<span class="comment">#转为list</span></span><br><span class="line"><span class="keyword">del</span> b[<span class="number">3</span>:<span class="number">5</span>]<span class="comment">#删除4,5  左取右不取</span></span><br></pre></td></tr></table></figure><h4 id="pop（）函数"><a href="#pop（）函数" class="headerlink" title="pop（）函数"></a>pop（）函数</h4><ul><li>list1.pop():默认删除最后一个元素，并返回该元素的值。</li><li>list1.pop(0):也可指定删除某个元素，并返回该元素的值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n移除（pop）又取又删：&#x27;</span>)</span><br><span class="line">list1 = [<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(list1.pop())  <span class="comment"># 默认删除最后一个元素，并返回该元素的值。</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(list1.pop(<span class="number">0</span>))  <span class="comment"># 也可指定删除某个元素，并返回该元素的值。</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure><h2 id="列表指定插入"><a href="#列表指定插入" class="headerlink" title="列表指定插入"></a>列表指定插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aList = [123, &#x27;xyz&#x27;, &#x27;zara&#x27;, &#x27;abc&#x27;]</span><br><span class="line"> </span><br><span class="line">aList.insert( 3, 2009)#下标为3的位置插入2009</span><br><span class="line">print(aList)</span><br></pre></td></tr></table></figure><h2 id="列表的修改"><a href="#列表的修改" class="headerlink" title="列表的修改"></a>列表的修改</h2><p>赋值语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>]</span><br><span class="line">students[<span class="number">1</span>]=<span class="string">&#x27;小&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(students)</span><br></pre></td></tr></table></figure><h2 id="列表的增加"><a href="#列表的增加" class="headerlink" title="列表的增加"></a>列表的增加</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;松&#x27;</span>] </span><br><span class="line">list2 = [<span class="string">&#x27;竹&#x27;</span>] </span><br><span class="line">list3 = [<span class="string">&#x27;梅&#x27;</span>] </span><br><span class="line"><span class="built_in">list</span> = list1 + list2 +list3<span class="comment">#符号&#x27;+&#x27;只能⽤在列表之间，不能⽤在列表和元素之间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字典名=&#123;键:值,...,键n:值n&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;小蓝&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;小红&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;小明&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(scores)</span><br></pre></td></tr></table></figure><h2 id="提取元素"><a href="#提取元素" class="headerlink" title="提取元素"></a>提取元素</h2><p><strong>字典名[字典的键]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(scores[<span class="string">&#x27;小红&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="删除字典键值对"><a href="#删除字典键值对" class="headerlink" title="删除字典键值对"></a>删除字典键值对</h2><p><strong>del 字典名[键]</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">album = &#123;<span class="string">&#x27;周杰伦&#x27;</span>:<span class="string">&#x27;七里香&#x27;</span>,<span class="string">&#x27;王力宏&#x27;</span>:<span class="string">&#x27;心中的日月&#x27;</span>&#125;</span><br><span class="line">del album[<span class="string">&#x27;周杰伦&#x27;</span>]</span><br><span class="line">print(album)</span><br></pre></td></tr></table></figure><h2 id="新增键值对"><a href="#新增键值对" class="headerlink" title="新增键值对"></a>新增键值对</h2><p><strong>字典名[键] &#x3D; 值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">90</span>&#125;</span><br><span class="line"><span class="keyword">del</span> scores[<span class="string">&#x27;小刚&#x27;</span>]</span><br><span class="line">scores[<span class="string">&#x27;小刚&#x27;</span>]=<span class="number">92</span></span><br><span class="line">scores[<span class="string">&#x27;小美&#x27;</span>]=<span class="number">85</span></span><br><span class="line"><span class="built_in">print</span>(scores)</span><br></pre></td></tr></table></figure><ul><li>列表有序，要用偏移量定位；字典无序，便通过唯一的键来取值。</li></ul><h3 id="提取字典所有的键"><a href="#提取字典所有的键" class="headerlink" title="提取字典所有的键"></a>提取字典所有的键</h3><p><strong>dict.key()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">group = &#123;<span class="string">&#x27;师父&#x27;</span>:<span class="string">&#x27;唐三藏&#x27;</span>, <span class="string">&#x27;大师兄&#x27;</span>:<span class="string">&#x27;孙行者&#x27;</span>, <span class="string">&#x27;二师兄&#x27;</span>:<span class="string">&#x27;猪八戒&#x27;</span>, <span class="string">&#x27;沙师弟&#x27;</span>:<span class="string">&#x27;沙和尚&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(group.keys())<span class="comment">#打印出dict_keys([&#x27;师父&#x27;, &#x27;大师兄&#x27;, &#x27;二师兄&#x27;, &#x27;沙师弟&#x27;])；元组形式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(group.keys()))<span class="comment">#打印出[&#x27;师父&#x27;, &#x27;大师兄&#x27;, &#x27;二师兄&#x27;, &#x27;沙师弟&#x27;]；通过list()函数将元组转化为列表的形式</span></span><br></pre></td></tr></table></figure><h3 id="提取字典中所有的值"><a href="#提取字典中所有的值" class="headerlink" title="提取字典中所有的值"></a>提取字典中所有的值</h3><p><strong>dict.values()</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group = &#123;<span class="string">&#x27;师父&#x27;</span>:<span class="string">&#x27;唐三藏&#x27;</span>, <span class="string">&#x27;大师兄&#x27;</span>:<span class="string">&#x27;孙行者&#x27;</span>, <span class="string">&#x27;二师兄&#x27;</span>:<span class="string">&#x27;猪八戒&#x27;</span>, <span class="string">&#x27;沙师弟&#x27;</span>:<span class="string">&#x27;沙和尚&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(group.values())<span class="comment">#打印出dict_values([&#x27;唐三藏&#x27;, &#x27;孙行者&#x27;, &#x27;猪八戒&#x27;, &#x27;沙和尚&#x27;])</span></span><br></pre></td></tr></table></figure><h3 id="提取字典中所有的键值对"><a href="#提取字典中所有的键值对" class="headerlink" title="提取字典中所有的键值对"></a>提取字典中所有的键值对</h3><p><strong>dict.items()</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group = &#123;<span class="string">&#x27;师父&#x27;</span>:<span class="string">&#x27;唐三藏&#x27;</span>, <span class="string">&#x27;大师兄&#x27;</span>:<span class="string">&#x27;孙行者&#x27;</span>, <span class="string">&#x27;二师兄&#x27;</span>:<span class="string">&#x27;猪八戒&#x27;</span>, <span class="string">&#x27;沙师弟&#x27;</span>:<span class="string">&#x27;沙和尚&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(group.items())<span class="comment">#打印出dict_items([(&#x27;师父&#x27;, &#x27;唐三藏&#x27;), (&#x27;大师兄&#x27;, &#x27;孙行者&#x27;), (&#x27;二师兄&#x27;, &#x27;猪八戒&#x27;), (&#x27;沙师弟&#x27;, &#x27;沙和尚&#x27;)])</span></span><br></pre></td></tr></table></figure><h2 id="存储为字典"><a href="#存储为字典" class="headerlink" title="存储为字典"></a>存储为字典</h2><ul><li>语法：dict[键]&#x3D;值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d=&#123;&#125;</span><br><span class="line">d[<span class="string">&#x27;班长&#x27;</span>]=&#123;<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小明&#x27;</span>:<span class="number">96</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure></li></ul><h1 id="字典列表嵌套"><a href="#字典列表嵌套" class="headerlink" title="字典列表嵌套"></a>字典列表嵌套</h1><h2 id="列表嵌套列表"><a href="#列表嵌套列表" class="headerlink" title="列表嵌套列表"></a>列表嵌套列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">students = [[<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>],[<span class="string">&#x27;小强&#x27;</span>,<span class="string">&#x27;小兰&#x27;</span>,<span class="string">&#x27;小伟&#x27;</span>,<span class="string">&#x27;小芳&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">1</span>][<span class="number">3</span>])<span class="comment">#提取小芳</span></span><br></pre></td></tr></table></figure><h2 id="字典嵌套字典"><a href="#字典嵌套字典" class="headerlink" title="字典嵌套字典"></a>字典嵌套字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;</span><br><span class="line">    <span class="string">&#x27;第一组&#x27;</span>:&#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;小美&#x27;</span>:<span class="number">85</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;第二组&#x27;</span>:&#123;<span class="string">&#x27;小强&#x27;</span>:<span class="number">99</span>,<span class="string">&#x27;小兰&#x27;</span>:<span class="number">89</span>,<span class="string">&#x27;小伟&#x27;</span>:<span class="number">93</span>,<span class="string">&#x27;小芳&#x27;</span>:<span class="number">88</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">print</span>(scores[<span class="string">&#x27;第一组&#x27;</span>][<span class="string">&#x27;小刚&#x27;</span>])<span class="comment">#提取小刚的成绩</span></span><br></pre></td></tr></table></figure><h2 id="字典列表相互嵌套"><a href="#字典列表相互嵌套" class="headerlink" title="字典列表相互嵌套"></a>字典列表相互嵌套</h2><p>提取键或者偏移量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最外层是大括号，所以是字典嵌套列表，先找到字典的键对应的列表，再判断列表中要取出元素的偏移量</span></span><br><span class="line">students = &#123;</span><br><span class="line">    <span class="string">&#x27;第一组&#x27;</span>:[<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;小美&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;第二组&#x27;</span>:[<span class="string">&#x27;小强&#x27;</span>,<span class="string">&#x27;小兰&#x27;</span>,<span class="string">&#x27;小伟&#x27;</span>,<span class="string">&#x27;小芳&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">print</span>(students[<span class="string">&#x27;第一组&#x27;</span>][<span class="number">3</span>])</span><br><span class="line"><span class="comment">#取出&#x27;第一组&#x27;对应列表偏移量为3的元素，即&#x27;小美&#x27;</span></span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line"><span class="comment"># 最外层是中括号，所以是列表嵌套字典，先判断字典是列表的第几个元素，再找出要取出的值相对应的键</span></span><br><span class="line">scores = [</span><br><span class="line">    &#123;<span class="string">&#x27;小明&#x27;</span>:<span class="number">95</span>,<span class="string">&#x27;小红&#x27;</span>:<span class="number">90</span>,<span class="string">&#x27;小刚&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;小美&#x27;</span>:<span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;小强&#x27;</span>:<span class="number">99</span>,<span class="string">&#x27;小兰&#x27;</span>:<span class="number">89</span>,<span class="string">&#x27;小伟&#x27;</span>:<span class="number">93</span>,<span class="string">&#x27;小芳&#x27;</span>:<span class="number">88</span>&#125;</span><br><span class="line">    ]</span><br><span class="line"><span class="built_in">print</span>(scores[<span class="number">1</span>][<span class="string">&#x27;小强&#x27;</span>])</span><br><span class="line"><span class="comment">#先定位到列表偏移量为1的元素，即第二个字典，再取出字典里键为&#x27;小强&#x27;对应的值，即99。</span></span><br></pre></td></tr></table></figure><h5 id="例子遍历"><a href="#例子遍历" class="headerlink" title="例子遍历"></a>例子遍历</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">movies = &#123;</span><br><span class="line"><span class="string">&#x27;妖猫传&#x27;</span>:[<span class="string">&#x27;黄轩&#x27;</span>,<span class="string">&#x27;染谷将太&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;无问西东&#x27;</span>:[<span class="string">&#x27;章子怡&#x27;</span>,<span class="string">&#x27;王力宏&#x27;</span>,<span class="string">&#x27;祖峰&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;超时空同居&#x27;</span>:[<span class="string">&#x27;雷佳音&#x27;</span>,<span class="string">&#x27;佟丽娅&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actor = <span class="built_in">input</span>(<span class="string">&#x27;你想查询哪个演员？&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>  movie <span class="keyword">in</span> movies:  <span class="comment"># 用 for 遍历字典</span></span><br><span class="line">    actors = movies[movie]  <span class="comment"># 读取各个字典的主演表</span></span><br><span class="line">    <span class="keyword">if</span> actor <span class="keyword">in</span> actors:</span><br><span class="line">       <span class="comment">#in 这里的作用等价于用循环遍历了一下</span></span><br><span class="line">        <span class="built_in">print</span>(actor + <span class="string">&#x27;出演了电影&#x27;</span> + movie)</span><br></pre></td></tr></table></figure><ul><li><strong>for遍历字典读取键</strong></li></ul><h1 id="for…in…循环"><a href="#for…in…循环" class="headerlink" title="for…in…循环"></a>for…in…循环</h1><h2 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]:<span class="comment">#i就是遍历列表的元素; i是“空房间”</span></span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;日本&#x27;</span>:<span class="string">&#x27;东京&#x27;</span>,<span class="string">&#x27;英国&#x27;</span>:<span class="string">&#x27;伦敦&#x27;</span>,<span class="string">&#x27;法国&#x27;</span>:<span class="string">&#x27;巴黎&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">dict</span>:<span class="comment">#发现i会逐个接待字典中的每一个【键】</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;吴承恩&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><ul><li>for循环遍历字典时，<strong>接待字典中的每一个【键】</strong></li><li>for循环遍历列表时，<strong>接待列表的元素</strong></li><li>for循环遍历字符串时，接待的是<strong>字符串的每个组成</strong></li><li>循环次数明确</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248817.png" alt="image-20210810144914136"></p><h2 id="range-x-函数"><a href="#range-x-函数" class="headerlink" title="range(x)函数"></a>range(x)函数</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li><code>range(a,b)</code> 函数，你可以生成了一个【取头不取尾】的整数序列</li><li>循环输出n句话</li><li><code>range(a,b,n)</code>的意思是：从a数到b（取头不取尾），步长为n</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>,<span class="number">17</span>):<span class="comment">#表示从13到16的整数列表</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):<span class="comment">#i从0到10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;书恒走的第&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;天，想他&#x27;</span>)<span class="comment">#循环11次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>):<span class="comment">#从0数到9（取头不取尾），步长为3</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>循环次数可不明确</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    内容</span><br><span class="line"><span class="comment">##########################################分割线 </span></span><br><span class="line">    </span><br><span class="line">a = <span class="number">0</span>                <span class="comment">#先定义变量a，并赋值</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">5</span>:         <span class="comment">#设定一个放行条件：a要小于5，才能办事</span></span><br><span class="line">    a = a + <span class="number">1</span>  <span class="comment"># 满足条件时，就办事：将a+1</span></span><br><span class="line">    <span class="built_in">print</span>(a)   <span class="comment"># 继续办事：将a+1的结果打印出来 </span></span><br><span class="line"><span class="comment">##########################################分割线</span></span><br><span class="line">password = <span class="string">&#x27;&#x27;</span>  <span class="comment"># 变量password用来保存输入的密码</span></span><br><span class="line"><span class="keyword">while</span> password != <span class="string">&#x27;816&#x27;</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;请尝试输入密码:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;欢迎回家&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><ul><li>计算机的逻辑判断，只有两种结果，就是<code>True</code>（英文意思是“真”）和<code>False</code>（英文意思是“假”），没有灰色地带。这个计算真假的过程，叫做【布尔运算】。</li><li>决定if语句和循环语句怎么运行</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>两个值作比较</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248347.png" alt="image-20210810165656378"></p><ul><li>数值作比较</li></ul><p>bool()函数</p><ul><li><code>bool()</code>函数来查看一个数据会被判断为真还是假。这个函数的用法与<code>type()</code>函数相似，在<code>bool()</code>函数括号中放入我们想要判断真假的数据，然后print出来即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请阅读代码后再直接运行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以下数据判断结果都是【假】：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;以下数据判断结果都是【真】：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="string">&#x27;abc&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="布尔值之间的运算"><a href="#布尔值之间的运算" class="headerlink" title="布尔值之间的运算"></a>布尔值之间的运算</h3><table><thead><tr><th>运算符</th><th>释义</th><th>作用</th></tr></thead><tbody><tr><td>in</td><td>属于</td><td>如果值在指定序列⾥，条件为真</td></tr><tr><td>not    in</td><td>不属于</td><td>如果值不在指定序列⾥，条件为真</td></tr><tr><td>and</td><td>且</td><td>连接两个布尔值，如果两个都为真，该条件才为真</td></tr><tr><td>or</td><td>或</td><td>连接两个布尔值，如果有⼀个为真，该条件即为真</td></tr><tr><td>not</td><td>非</td><td>反逻辑状态，a为True，not a则为False，反之亦然</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">in</span> a)<span class="comment">#判断为假</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> a)<span class="comment">#判断为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> a)<span class="comment">#判断为真</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> a)<span class="comment">#判断为假</span></span><br><span class="line">b=<span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> b)<span class="comment">#判断为假</span></span><br></pre></td></tr></table></figure><h1 id="4种语句"><a href="#4种语句" class="headerlink" title="4种语句"></a>4种语句</h1><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>break的意思是“打破”，是用来结束循环的，一般写作<code>if...break</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># break语句搭配for循环</span></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>...:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># break语句搭配while循环</span></span><br><span class="line"><span class="keyword">while</span>...(条件):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = <span class="built_in">input</span>(<span class="string">&#x27;请输入你的密码:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="string">&#x27;小龙女&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过啦&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>continue的意思是“继续”。这个子句也是在循环内部使用的。当某个条件被满足的时候，触发continue语句，将跳过之后的代码，直接回到循环的开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># continue语句搭配for循环</span></span><br><span class="line"><span class="keyword">for</span>...<span class="keyword">in</span>...:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># continue语句搭配while循环</span></span><br><span class="line"><span class="keyword">while</span>...(条件):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ...:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    q1 = <span class="built_in">input</span>(<span class="string">&#x27;第一问：你一生之中，在什么地方最是快乐逍遥？&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> q1 != <span class="string">&#x27;黑暗的冰窖&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;答对了，下面是第二问：&#x27;</span>)</span><br><span class="line">    q2 = <span class="built_in">input</span>(<span class="string">&#x27;你生平最爱之人，叫什么名字？&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> q2 != <span class="string">&#x27;梦姑&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;答对了，下面是第三问：&#x27;</span>)</span><br><span class="line">    q3 = <span class="built_in">input</span>(<span class="string">&#x27;你最爱的这个人相貌如何？&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> q3 == <span class="string">&#x27;不知道&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;都答对了，你是虚竹。&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h2><p>跳过,什么都不做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请体验一下报错，然后把pass语句加上</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个整数:&#x27;</span>))<span class="comment">#a&gt;=100的时候，跳过，什么都不做</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你输入了一个小于100的数字&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="else语句"><a href="#else语句" class="headerlink" title="else语句"></a>else语句</h2><ul><li>不仅可以和if语句搭配，也可以和for语句，while语句搭配（一般与）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入0来结束循环，你有5次机会:&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你触发了break语句，循环结束，导致else语句不会生效。&#x27;</span>)    </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;5次循环你都错过了，else语句生效了。&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python/python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.python基础1</title>
      <link href="/data.github.io/post/7387e15a.html"/>
      <url>/data.github.io/post/7387e15a.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入print-函数"><a href="#输入print-函数" class="headerlink" title="输入print()函数"></a>输入print()函数</h1><h2 id="输出几种形式"><a href="#输出几种形式" class="headerlink" title="输出几种形式"></a>输出几种形式</h2><h3 id="不带引号"><a href="#不带引号" class="headerlink" title="不带引号"></a>不带引号</h3><ul><li>让计算机读懂括号⾥的内容，打印最终的结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><ul><li>计算机⽆须理解，原样复述引号中的内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;秋水共长天一色&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><ul><li>作⽤和单引号⼀样；当打印内容中有单引号时，可以使⽤双引号</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Let&#x27;s go&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Let\&#x27;s go&#x27;</span>) <span class="comment">#也可以使用转义字符+单引号(\&#x27;)来实现单引号</span></span><br></pre></td></tr></table></figure><h3 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h3><ul><li>带三引号，实现换⾏</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;python </span></span><br><span class="line"><span class="string">我的世界&#x27;&#x27;&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python小课\n最好的python课程&quot;</span>)<span class="comment">#采用转义字符&quot;\n&quot;也可以换行</span></span><br></pre></td></tr></table></figure><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><table><thead><tr><th>转义字符</th><th>意义</th></tr></thead><tbody><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格，将当前位置前移一项</td></tr><tr><td>\f</td><td>换页，将当前位置移到下页开头</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车，将当前位danyihao置移到本行开头</td></tr><tr><td>\t</td><td>水平制表</td></tr><tr><td>\v</td><td>垂直制表</td></tr><tr><td>\\</td><td>代表一个斜线字符“\”</td></tr><tr><td>\0</td><td>空字符</td></tr><tr><td>\ddd</td><td>1到3位八进制所代表的任意字符</td></tr><tr><td>\xhh</td><td>1到2位十六进制所代表的任意字符</td></tr></tbody></table><h2 id="print-不换行"><a href="#print-不换行" class="headerlink" title="print()不换行"></a>print()不换行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>,end=<span class="string">&#x27;!&#x27;</span>)<span class="comment">#end实现不换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="print-完整参数"><a href="#print-完整参数" class="headerlink" title="print()完整参数"></a>print()完整参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(*objects, sep = <span class="string">&#x27; &#x27;</span>, end = <span class="string">&#x27;\n&#x27;</span>, file = sys.stdout, flush = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;金枪鱼&#x27;</span>, <span class="string">&#x27;三文鱼&#x27;</span>, <span class="string">&#x27;鲷鱼&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;金枪鱼&#x27;</span>, <span class="string">&#x27;三文鱼&#x27;</span>, <span class="string">&#x27;鲷鱼&#x27;</span>, sep = <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line"><span class="comment"># sep控制多个值之间的分隔符，默认是空格</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;金枪鱼&#x27;</span>, <span class="string">&#x27;三文鱼&#x27;</span>, <span class="string">&#x27;鲷鱼&#x27;</span>, sep = <span class="string">&#x27;+&#x27;</span>, end = <span class="string">&#x27;=?&#x27;</span>)</span><br><span class="line"><span class="comment"># end控制打印结果的结尾，默认是换行)</span></span><br></pre></td></tr></table></figure><h1 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名=<span class="string">&#x27;内容&#x27;</span></span><br><span class="line">name=<span class="string">&#x27;小千&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li>只能是一个词</li><li>只能包含数字、数字、下划线</li><li>不能以数字开头</li></ol><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248307.png" alt="image-20210808213821074"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li>常见：字符串，整数型，浮点数，列表，字典，布尔值，元组</li></ul><ol><li><p>字符串str:⽤括号括起来的⽂本（如：’python’、’123’、’程序’）</p></li><li><p>整数int：不带⼩数点的数字（如：-1、1、0、520、1314） </p></li><li><p>浮点数float：带⼩数点的数字，运算结果存在误差（如：-0.15、3.1415、1.0) </p></li><li><p>列表list:标识是中括号[]</p></li><li><p>元组tuple:与列表类似，不能修改，标识（）</p><ul><li>元组和列表一样，可以通过索引来提取当中的某个元素</li></ul></li><li><p>字典dict:标识大括号{}</p></li><li><p>布尔值bool：表示真假的数据类型，只有True和False</p></li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041248095.png" alt="image-20210808214239056"></p><h2 id="数据的拼接"><a href="#数据的拼接" class="headerlink" title="数据的拼接"></a>数据的拼接</h2><h3 id="用“-”号将数据进行拼接"><a href="#用“-”号将数据进行拼接" class="headerlink" title="用“+”号将数据进行拼接"></a>用“+”号将数据进行拼接</h3><ul><li>目的：数据整合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hero = <span class="string">&#x27;我&#x27;</span></span><br><span class="line">organization = <span class="string">&#x27;风变编程&#x27;</span></span><br><span class="line">identity = <span class="string">&#x27;学员&#x27;</span></span><br><span class="line">action = <span class="string">&#x27;是&#x27;</span></span><br><span class="line">ID = <span class="string">&#x27;007&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(hero+action+organization+identity+ID)</span><br></pre></td></tr></table></figure><h3 id="格式符"><a href="#格式符" class="headerlink" title="格式符%"></a>格式符%</h3><table><thead><tr><th>格式符+类型码</th><th>含义</th></tr></thead><tbody><tr><td>%s</td><td>字符串显示</td></tr><tr><td>%f</td><td>浮点数显示</td></tr><tr><td>%d</td><td>整数显示</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lucky = <span class="number">8</span></span><br><span class="line">n=<span class="string">&#x27;我的&#x27;</span></span><br><span class="line">year=<span class="number">21</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的幸运数字是%d&#x27;</span> % <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的幸运数字是%s&#x27;</span> % <span class="string">&#x27;小龙女的生日816&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s年龄是%s&#x27;</span> % (n,year))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s年龄是%d&#x27;</span> % (n,year))</span><br></pre></td></tr></table></figure><ul><li>%<code>后面的类型码用什么，取决于你希望这个</code>%<code>占住的这个位置的数据以什么类型展示出来，如果你希望它以字符串形式展示，那就写</code>%s<code>，如果你希望它以整数形式展示，那就写</code>%d</li></ul><h3 id="format函数"><a href="#format函数" class="headerlink" title="format函数"></a>format函数</h3><p>format()函数用来占位的是大括号{}，不用区分类型码（%+类型码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">player_life=<span class="number">742</span></span><br><span class="line">player_attack=<span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;【玩家】\n血量：&#123;&#125;\n攻击：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(player_life,player_attack))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;I am learning %s&#x27;</span>% name1)  <span class="comment"># 注：当只跟一个数据时，%后可不加括号，format()一定要有。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># format()格式化函数：str.format()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;数字：&#x27;</span>,<span class="number">0</span>))  <span class="comment"># 优势1：不用担心用错类型码。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;，&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0</span>,<span class="number">1</span>))  <span class="comment"># 不设置指定位置时，默认按顺序对应。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;1&#125;，&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0</span>,<span class="number">1</span>))  <span class="comment"># 优势2：当设置指定位置时，按指定的对应。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;，&#123;1&#125;，&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0</span>,<span class="number">1</span>))  <span class="comment"># 优势3：可多次调用format后的数据。</span></span><br><span class="line"></span><br><span class="line">name2 =  <span class="string">&#x27;Python基础语法&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我正在学&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name2))  <span class="comment"># format()函数也接受通过参数传入数据。</span></span><br></pre></td></tr></table></figure><h4 id="浮点数保留小数"><a href="#浮点数保留小数" class="headerlink" title="浮点数保留小数"></a>浮点数保留小数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1.2334</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">format</span>(a, <span class="string">&#x27;.6f&#x27;</span>))<span class="comment">#利用format函数达到保留6位小数的目的</span></span><br></pre></td></tr></table></figure><h3 id="数据类型查询type-函数"><a href="#数据类型查询type-函数" class="headerlink" title="数据类型查询type()函数"></a>数据类型查询type()函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">who = <span class="string">&#x27;我的&#x27;</span></span><br><span class="line">print(type(who))</span><br></pre></td></tr></table></figure><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><ol><li>str():将其他类型转换成字符串</li><li>int():将其他数据类型转换成整数</li><li>float():将其他数据类型转换成浮点数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">magic = <span class="string">&#x27;水仙花数&#x27;</span></span><br><span class="line">action = <span class="string">&#x27;是&#x27;</span></span><br><span class="line">unit = <span class="string">&#x27;个&#x27;</span></span><br><span class="line">expression = <span class="string">&#x27;1x1x1+5x5x5+3x3x3&#x27;</span></span><br><span class="line">number = <span class="number">153</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(number)+<span class="string">&#x27;=&#x27;</span>+<span class="built_in">str</span>(expression)+action+unit+magic)</span><br></pre></td></tr></table></figure><ul><li>文字类和小数类字符串无法转换成整数</li><li>文字类字符串无法转换成浮点数</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><a href="https://blog.csdn.net/m0_51769031/article/details/127322960?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167889045316782427417113%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167889045316782427417113&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-127322960-null-null.142%5Ev73%5Econtrol_1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8&spm=1018.2226.3001.4187">字符串的基本操作</a></p><ol><li>[[4、python模块#split():分开字符串|分开字符串]]</li><li>[[4、python模块#join():合并字符串|合并字符串]]</li></ol><h2 id="字符串访问"><a href="#字符串访问" class="headerlink" title="字符串访问"></a>字符串访问</h2><p>正向递增序号和反向递减序号：正向访问用正数、从后往前访问用负数</p><p><strong>索引访问</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;abc defg hijk&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">12</span>])<span class="comment">#k</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>])<span class="comment">#k</span></span><br><span class="line">img_name=<span class="string">&#x27;abcdf.jpg&#x27;</span></span><br><span class="line">img_name[<span class="number">0</span>:-<span class="number">4</span>]<span class="comment">#这样可以输出abcdf</span></span><br></pre></td></tr></table></figure><p><strong>切片访问</strong></p><ul><li><code>[a,b]</code>:左闭右开，取左不取右</li><li>【头下标：尾下标：步长】</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;abc defg hijk&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">9</span>:<span class="number">12</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解决字符串数字排序问题"><a href="#解决字符串数字排序问题" class="headerlink" title="解决字符串数字排序问题"></a>解决字符串数字排序问题</h3><ul><li>使用匿名函数，第一个参数用来排序字符串，第二个参数用来排序数字。数字排序必须转成int或者其他数字格式，不然字符串10还是排在2前面。</li><li>参数1和参数2根据实际判断，若是对数字排序则需要int强制转换</li><li>参数是对数组中字符串的长度进行截取排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#arrRes.sort(key=lambda arr: (arr[:2], int(arr[2:])))</span></span><br><span class="line">arrRes = [<span class="string">&#x27;学生2&#x27;</span>, <span class="string">&#x27;学生1&#x27;</span>, <span class="string">&#x27;学生10&#x27;</span>, <span class="string">&#x27;学生4&#x27;</span>, <span class="string">&#x27;学生3&#x27;</span>]</span><br><span class="line">arrRes.sort(key=<span class="keyword">lambda</span> arr: (arr[:<span class="number">2</span>], <span class="built_in">int</span>(arr[<span class="number">2</span>:])))</span><br><span class="line"><span class="built_in">print</span>(arrRes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path=<span class="string">&#x27;./data/jm/&#x27;</span>  <span class="comment">#返回当前进程的工作目录</span></span><br><span class="line">path_list=os.listdir(path)</span><br><span class="line">path_list.sort(key=<span class="keyword">lambda</span> x:<span class="built_in">int</span>(x[:-<span class="number">4</span>])) <span class="comment">#将‘.jpg’左边的字符转换成整数型进行排序</span></span><br><span class="line"><span class="built_in">print</span>(path_list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h2 id="单行判断if"><a href="#单行判断if" class="headerlink" title="单行判断if"></a>单行判断if</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:<span class="comment">#if后面要加冒号，同时执行语句要缩进四个空格</span></span><br><span class="line">执行语句</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stonenumber=<span class="number">6</span></span><br><span class="line"><span class="keyword">if</span> stonenumber&gt;=<span class="number">6</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;你拥有了毁灭宇宙的力量&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="双向判断if-else"><a href="#双向判断if-else" class="headerlink" title="双向判断if-else"></a>双向判断if-else</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">执行语句<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">执行语句<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">weight=<span class="number">60</span></span><br><span class="line"><span class="keyword">if</span> weight&gt;=<span class="number">100</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;不吃了&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;放心吃吧&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="多向判断if–elif–else"><a href="#多向判断if–elif–else" class="headerlink" title="多向判断if–elif–else"></a>多向判断if–elif–else</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">执行语句<span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">执行语句<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stonenumber=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> stonenumber&gt;=<span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你拥有了毁灭宇宙的力量&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">0</span>&lt;stonenumber&lt;=<span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;绯红女巫需要亲手毁掉幻视额头上的心灵宝石&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;需要惊奇队长逆转未来&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="if嵌套"><a href="#if嵌套" class="headerlink" title="if嵌套"></a>if嵌套</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">historyscore=<span class="number">26</span></span><br><span class="line"><span class="keyword">if</span> historyscore&gt;=<span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;你已经及格&#x27;</span>)  </span><br><span class="line">    <span class="keyword">if</span> historyscore&gt;=<span class="number">80</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你很优秀&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你只是一般般&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;不及格&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;程序结束&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="输入input-函数"><a href="#输入input-函数" class="headerlink" title="输入input()函数"></a>输入input()函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;请在以下四个选项【格兰芬多；斯莱特林；拉文克劳；赫奇帕奇】中，输入你想去的学院名字: &#x27;</span>)<span class="comment">#name为字符串型</span></span><br><span class="line"><span class="built_in">print</span>(name +<span class="string">&#x27;学院欢迎你，小萌新!&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>input函数的结果必须赋值</li><li>input()的数据类型是字符串，其他类型转成字符串</li></ul><p>强制转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">choice = <span class="type">int</span>(input(<span class="string">&#x27;请输入您的选择：&#x27;</span>))<span class="meta">#choice强制转换成整型</span></span><br><span class="line"><span class="keyword">if</span> choice == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">&#x27;霍格沃茨欢迎您的到来&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;您可是被梅林选中的孩子，我们不接受这个选项&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>Tab键和空格键不能同时混用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python/python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.结构体</title>
      <link href="/data.github.io/post/f9c74851.html"/>
      <url>/data.github.io/post/f9c74851.html</url>
      
        <content type="html"><![CDATA[<h1 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h1><ul><li>数组只能将相同类型的数据放在一起，结构体是可以将不同类型的数据放在一起</li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体模板</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生年</span></span><br><span class="line">        <span class="type">int</span> scoreMath;<span class="comment">//数学成绩</span></span><br><span class="line">        <span class="type">int</span> scoreEnglish;<span class="comment">//英语成绩</span></span><br><span class="line">        <span class="type">int</span> scoreComputer;<span class="comment">//计算机</span></span><br><span class="line">        <span class="type">int</span> scoreP;</span><br><span class="line">      <span class="comment">//int score[4];//等价上面成绩</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="定义结构体变量"><a href="#定义结构体变量" class="headerlink" title="定义结构体变量"></a>定义结构体变量</h2><p>1、先定义结构体类型，在定义变量名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span>//<span class="title">student</span>为标签名</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu1</span>;</span><span class="comment">//定义变量</span></span><br></pre></td></tr></table></figure><p>2、在定义结构体类型的同时定义变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生</span></span><br><span class="line">    &#125;stu1;</span><br></pre></td></tr></table></figure><p>3、直接定义结构体变量（不指定结构体标签）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生年</span></span><br><span class="line">    &#125;stu1;</span><br></pre></td></tr></table></figure><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><ul><li>用typedef给数据类型定义一个别名</li><li>别名用全部大写</li><li>struct student等价STUDENT</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;stu1;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">STUDENT</span>;</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">    &#125;STUDENT;<span class="comment">//结构体声明</span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>初始化列表成员必须与结构体类型定义的顺序一致</li><li>没给初始值就默认为0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName;<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> yearBirth;<span class="comment">//出生年分</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">STUDENT stu1=&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>，<span class="string">&quot;Man&quot;</span>,<span class="number">1991</span>,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><p>对于结构体来说，也有构造函数和西沟函数，与类有点类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> dou;</span><br><span class="line">    dou x;</span><br><span class="line">    student()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;测试&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;STU;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    STU s1;</span><br><span class="line">    s1.a=<span class="number">23</span>;</span><br><span class="line">    s1.x=<span class="number">2.32</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1.b&lt;&lt;<span class="built_in">endl</span>&lt;&lt;s1.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体与数组嵌套"><a href="#结构体与数组嵌套" class="headerlink" title="结构体与数组嵌套"></a>结构体与数组嵌套</h1><h2 id="嵌套的结构体"><a href="#嵌套的结构体" class="headerlink" title="嵌套的结构体"></a>嵌套的结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">    &#125;DATE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex[<span class="number">10</span>];<span class="comment">//性别</span></span><br><span class="line">        DATE yearBirth;<span class="comment">//出生年</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br></pre></td></tr></table></figure><p>初始化</p><ul><li>嵌套的结构体要用花括号表示内容–里面花括号</li><li>外面花括号—原结构体数组类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu1=&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><ul><li>前面结构体声明一样</li><li>数据就用花括号嵌套表示</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu1[<span class="number">3</span>]=&#123;&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;,</span><br><span class="line">                    &#123;<span class="number">13503</span>,<span class="string">&quot;小红&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;,</span><br><span class="line">                    &#123;<span class="number">1253</span>,<span class="string">&quot;小西南&quot;</span>,<span class="string">&quot;WOMan&quot;</span>,&#123;<span class="number">1983</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;</span><br><span class="line">                &#125;;</span><br></pre></td></tr></table></figure><h2 id="计算结构体内存数"><a href="#计算结构体内存数" class="headerlink" title="计算结构体内存数"></a>计算结构体内存数</h2><ul><li>sizeof(变量或表达式)</li><li>为满足内存地址要求，在较小的成员加入补位</li></ul><h1 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h1><ul><li>通过名字访问结构体成员</li><li><strong>成员选择运算符</strong>（原点运算符）</li><li><strong>结构体变量名.成员名</strong></li><li>对于嵌套体成员，必须以级联方式访问</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">    &#125;DATE;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex;<span class="comment">//性别</span></span><br><span class="line">        DATE Birth;</span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">    STUDENT stu1=&#123;<span class="number">12033</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&#x27;M&#x27;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//访问操作</span></span><br><span class="line">    stu1.studentID=<span class="number">101001</span>;<span class="comment">//访问id</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stu1.studentName,<span class="string">&quot;小&quot;</span>);<span class="comment">//访问，字符数组要用strcpy函数</span></span><br><span class="line">    stu1.studentSex=<span class="string">&#x27;M&#x27;</span>;<span class="comment">//若是定义单个字符，直接赋值</span></span><br><span class="line">    stu1.Birth.year=<span class="number">19</span>;<span class="comment">//级联方式访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名为%s\n性别是%c\n学号是%d\n&quot;</span>,stu1.studentName,stu1.studentSex,stu1.studentID);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><ul><li>只能在相同类型的结构体变量之间进行赋值<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> year;</span><br><span class="line">        <span class="type">int</span> month;</span><br><span class="line">        <span class="type">int</span> day;</span><br><span class="line">    &#125;DATE;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex[<span class="number">10</span>];<span class="comment">//性别</span></span><br><span class="line">        DATE yearBirth;<span class="comment">//出生年</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">    STUDENT stu1=&#123;<span class="number">1203</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;Man&quot;</span>,&#123;<span class="number">1991</span>,<span class="number">5</span>,<span class="number">19</span>&#125;,&#123;<span class="number">72</span>,<span class="number">90</span>,<span class="number">29</span>,<span class="number">28</span>&#125;&#125;;</span><br><span class="line">    STUDENT stu2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    stu2.studentID=stu1.studentID;<span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        stu2.score[i]=stu1.score[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,stu2.score[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="取地址操作"><a href="#取地址操作" class="headerlink" title="取地址操作"></a>取地址操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu2;</span><br><span class="line">stu1=stu2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;stu1=%p\n&quot;</span>,&amp;stu1 );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;stu2=%p&quot;</span>,&amp;stu2);</span><br></pre></td></tr></table></figure><h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ul><li>通过成员选择运算符访问<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pt).studentID=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li>通过指向运算符访问：**-&gt;**</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt -&gt; studentID=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>总体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">long</span> studentID;<span class="comment">//定义学号</span></span><br><span class="line">        <span class="type">char</span> studentName[<span class="number">10</span>];<span class="comment">//姓名</span></span><br><span class="line">        <span class="type">char</span> studentSex[<span class="number">10</span>];<span class="comment">//性别</span></span><br><span class="line">        <span class="type">int</span> score[<span class="number">4</span>];<span class="comment">//成绩</span></span><br><span class="line">    &#125;STUDENT;</span><br><span class="line">    <span class="comment">//定义结构体指针</span></span><br><span class="line">    STUDENT stu1;</span><br><span class="line">    STUDENT *pt;</span><br><span class="line"></span><br><span class="line">    pt = &amp;stu1;<span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//STUDENT *pt = &amp;stu1;//与上式等价</span></span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    (*pt).studentID=<span class="number">1</span>;</span><br><span class="line">    pt -&gt; studentID=<span class="number">1</span>;</span><br><span class="line">    stu1.studentID=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体数组-1"><a href="#结构体数组-1" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu[<span class="number">30</span>];</span><br><span class="line">STUDENT *pt;</span><br><span class="line">pt=stu;<span class="comment">//数组首地址指向指针</span></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">STUDENT *pt=stu;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">STUDENT *pt = &amp;stu[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">pt -&gt; studentID;<span class="comment">//等价于stu[0].studentID</span></span><br></pre></td></tr></table></figure><h2 id="结构体传参问题"><a href="#结构体传参问题" class="headerlink" title="结构体传参问题"></a>结构体传参问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MaxSize=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> Length;        </span><br><span class="line">&#125;SqList;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;*LinkList,LNode;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitLinkList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">//因为用LinkList定义首地址(传入的是地址，所以用L-&gt;next),传入参数定义(LinkList)要一样</span></span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));<span class="comment">//开辟新结点</span></span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;单链表定义的LinkList&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入参数用SqList定义的结构体</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L.data[i]=<span class="number">0</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    L.Length=<span class="number">0</span>;        </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;输出顺序表&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitListLNode</span><span class="params">(LNode &amp;L)</span></span>&#123;</span><br><span class="line">L.data=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//传入参数是用LNode定义的结构体(不是地址)，所以用L.data</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;单链表定义LNode的结点&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList2</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">L-&gt;data=<span class="number">8</span>;</span><br><span class="line"><span class="comment">//传入参数定义的LNode *L,用的指针,所以*L</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;单链表LNode *L&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqList L; </span><br><span class="line">    LNode Le;</span><br><span class="line">    LinkList Li;                         </span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="built_in">InitList2</span>(&amp;Le);</span><br><span class="line">    <span class="built_in">InitListLNode</span>(Le);  </span><br><span class="line">    <span class="built_in">InitLinkList</span>(Li);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="向函数传递结构体"><a href="#向函数传递结构体" class="headerlink" title="向函数传递结构体"></a>向函数传递结构体</h1><p><strong>传递单个成员</strong><br><strong>向函数传递结构体的完整结构</strong></p><ul><li>赋值结构体的所有成员</li></ul><p><strong>向函数传递结构体的首地址</strong></p><ul><li>仅复制一个地址值</li></ul><p>应用</p><ul><li>封装函数参数：精简参数个数、函数接口简洁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>//结构体声明</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="type">int</span> z;</span><br><span class="line">    &#125;POINT;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT *p)</span>;<span class="comment">//函数结构体指针定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    POINT position=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,position.x,position.y,position.z);</span><br><span class="line">    Func(&amp;position);<span class="comment">//传参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,position.x,position.y,position.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT *pt)</span></span><br><span class="line">&#123;</span><br><span class="line">    pt -&gt; x=<span class="number">1</span>;</span><br><span class="line">    pt -&gt; y=<span class="number">2</span>;</span><br><span class="line">    pt -&gt; z=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th>向函数传递结构体完整结构</th><th>向函数传递结构体的首地址</th></tr></thead><tbody><tr><td>用结构体变量做函数参数</td><td>用结构体数组&#x2F;结构指针做函数参数</td></tr><tr><td>复制整个结构体成员内容，一组数据</td><td>仅复制结构体的首地址，一个数据</td></tr><tr><td>参数传递直观，开销大，效率低</td><td>参数传递效率高</td></tr><tr><td>函数内对结构体内容的修改不影响原来结构体</td><td>可修改结构体指针所指向的结构体内容</td></tr></tbody></table><h1 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h1><ul><li>应用：当某些量仅由有限个整型数据值组成时</li><li>枚举常量是整型常量，用于限制变量的取值范围</li><li>增强程序看可读性：定义标志变量</li><li>MON后面常量依次加1，相当于宏定义</li></ul><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义的第一个给定初值，后面依次累计;若不给定初值则默认从0开始</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    MON=<span class="number">1</span>,</span><br><span class="line">    TUE,<span class="comment">//等价于TUE=2</span></span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">&#125;Week;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    Week today;</span><br><span class="line">    today=FRI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,today);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum weeks =&#123;SUN=7,MON=1,TUE,WED,THU,FRI,SAT&#125;//枚举类型声明</span></span><br><span class="line"><span class="comment">// typedef enum weeks =&#123;SUN=7,MON=1,TUE,WED,THU,FRI,SAT&#125; WEEKS;//定义别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //定义变量</span></span><br><span class="line"><span class="comment">// enum weeks today;</span></span><br><span class="line"><span class="comment">// WEEKS today;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h2><ul><li>这是c++11引入的新特性</li><li>默认底层是int，可以修改成char型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//声明变量初始化</span></span><br><span class="line">Color myColor = Color::Red;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="keyword">if</span> (myColor == Color::Green) &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示类型转换</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">int</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> colorValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Color::Red);</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制底层类型，改为char型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Flag</span> : <span class="type">char</span> &#123; Increase, Decrease, Reached &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><strong>作用域</strong>：enum 中定义的枚举值在同一作用域下是全局可见的，而 enum class 中定义的枚举值是由该枚举类限定作用域的，需要通过类名进行访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 全局可见</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 通过 Animal:: 访问</span></span><br></pre></td></tr></table></figure></li><li><strong>默认底层类型</strong>：enum 的枚举值使用整数类型作为底层类型，默认为int，而 enum class 的枚举值也使用整数类型作为底层类型，默认为无符号整数int<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 默认底层类型为 int</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 默认底层类型为 int</span></span><br></pre></td></tr></table></figure></li><li><strong>类型安全性</strong>：enum class 提供了更强的类型安全性。枚举值之间不会进行隐式的整数转换，不会与其他类型进行隐式转换，需要显式地进行类型转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> color = Red; <span class="comment">// 合法，隐式转换为 int</span></span><br><span class="line"><span class="type">int</span> animal = Animal::Cat; <span class="comment">// 非法，需要显式转换为 int</span></span><br><span class="line"><span class="type">int</span> cat = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Animal::Cat); <span class="comment">// 合法，显式转换为 int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><strong>命名空间污染</strong>：enum 中的枚举值会污染全局命名空间，可能会导致命名冲突，而 enum class 中的枚举值是由该枚举类限定作用域的，不会污染全局命名空间。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 可能会与其他全局变量或枚举值冲突</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 限定作用域，不会与其他变量或枚举值冲突</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><h2 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h2><ul><li>字节数取决于占空间最多的成员变量<ul><li>同一内存在每一瞬间只能保存一个成员；起作用的成员是最后一次赋值的成员</li></ul></li><li>与结构体类似</li><li>成员最好互斥</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">short</span> i;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sample</span> <span class="title">s</span>;</span><span class="comment">//定义变量</span></span><br><span class="line">    s.i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sample</span> <span class="title">u</span>=</span>&#123;<span class="number">1</span>&#125;;<span class="comment">//只能对共用体第一个成员进行初始化</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>构造混合的数据类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">float</span> f;</span><br><span class="line">    &#125;NUMBER;</span><br><span class="line">NUMBER <span class="built_in">array</span>[<span class="number">100</span>];<span class="comment">//既可以存储int型，也可以存储float型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>].i=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>].f=<span class="number">3.2</span>;</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>结构体</th><th>共用体</th></tr></thead><tbody><tr><td>关系紧密且逻辑相关的多种不同类型的数据的结集合</td><td>情形互斥但逻辑相关的多种不同类型的数据的集合</td></tr><tr><td>可以保存所有成员的值，用sizeof来计算占用内存的总字节数</td><td>内存重叠存储，每一瞬间只能保存一个成员，最后一次赋值的成员起作用</td></tr><tr><td>对所有成员初始化</td><td>只能对第一个成员初始化</td></tr></tbody></table><h1 id="C程序的内存映像"><a href="#C程序的内存映像" class="headerlink" title="C程序的内存映像"></a>C程序的内存映像</h1><p>变量的内存分配方式</p><ul><li>从静态存储区分配<ul><li>全局变量和静态变量</li></ul></li><li>从栈上分配</li><li>从堆上分配</li></ul><h2 id="动态内存分配函数"><a href="#动态内存分配函数" class="headerlink" title="动态内存分配函数"></a>动态内存分配函数</h2><ul><li><code>void*</code>型指针不指定其指向哪一种类型，可指向任意类型的变量</li><li>使用时，需强转（Type*）为其他类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//向系统申请大小为size的内存块；</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">calloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//向系统申请num个size大小的内存块</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *p,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//改变原来分配存储空间的大小</span></span><br><span class="line"><span class="comment">//指针p所指向存储空间的大小改为size个字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;<span class="comment">//释放内存</span></span><br><span class="line"></span><br><span class="line">p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//强制转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.数组与指针</title>
      <link href="/data.github.io/post/d80baa7c.html"/>
      <url>/data.github.io/post/d80baa7c.html</url>
      
        <content type="html"><![CDATA[<h1 id="七、数组与指针"><a href="#七、数组与指针" class="headerlink" title="七、数组与指针"></a>七、数组与指针</h1><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><ul><li>定义：基类型   <code>a[b]</code>;</li><li>a为数组名；b为数组长度，数组下标从0开始，取不到b</li><li>不能用变量来定义数组长度：<code>int  a[n]</code>;</li><li>使用宏定义可以：<code>int a[N]</code>;N已定义</li><li>占内存字节数：<code>数组长度*sizeof(基类型)</code></li></ul><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">60</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;<span class="comment">//花括号元素个数不能超过数组长度</span></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//根据花括号元素个数来确定数组大小</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>memset（a,0,sizeof(a))</code> 初始化</li><li>sizeof(a)获取数组a所占内存字节数</li><li>记得开头加<code>#include&lt;string.h&gt;</code></li></ul><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><ul><li><code>数组名[下标]</code></li><li>允许下标是整型变量或表达式</li></ul><h3 id="元素赋值"><a href="#元素赋值" class="headerlink" title="元素赋值"></a>元素赋值</h3><ul><li><p>通过循环语句赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[i] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过mencpy赋值</p><ul><li>记得开头加<code>#include&lt;string.h&gt;</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(b,a,<span class="keyword">sizeof</span>(a));<span class="comment">//数组a复制给数组b</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><ul><li>按行存放<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义：基类型   a[b][c];<span class="comment">//三维数组：基类型   a[b][c][d];n维数组依此类推</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]<span class="comment">//表示2行3列</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;<span class="comment">//第二位长度不能省略</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;<span class="comment">//等价第一行代码</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>&#125;,&#123;<span class="number">6</span>&#125;&#125;<span class="comment">//大花括号内的小花括号代表某行，4代表列数，即一行最多存储4个数</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;<span class="comment">//等价第三行代码</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//写法错误，不能判断几行几列</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="comment">//行判断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)<span class="comment">//列判断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>不要数组下标越界</li><li>字符数组要留意<code>&quot;\0&quot;</code></li></ul><h2 id="向函数传递数组"><a href="#向函数传递数组" class="headerlink" title="向函数传递数组"></a>向函数传递数组</h2><ul><li>数组作为函数参数：实参数组和形参数组占据同一存储单元</li><li><strong>传递地址</strong>:所以不用去返回数值,就是传入函数中的数组名是数组的首地址</li></ul><h3 id="传递一维数组"><a href="#传递一维数组" class="headerlink" title="传递一维数组"></a>传递一维数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadScore</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> score[N],aver,n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input n:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">ReadScore(score,n);</span><br><span class="line">aver = Average(score,n);<span class="comment">//用不带下标的数组名作为函数实参，不需要方括号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Average score is %d\n&quot;</span>,aver);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadScore</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//输入n位学生成绩</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input score:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;score[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//计算平均分</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += score[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用<strong>不带下标的数组名作为函数实参</strong></li></ul><h3 id="传递二维数组"><a href="#传递二维数组" class="headerlink" title="传递二维数组"></a>传递二维数组</h3><ul><li>声明<strong>二维数组形参</strong>时，不能省略数组<strong>第二维长度</strong></li><li>元素地址：首地址+偏移量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AverforStud</span><span class="params">(<span class="type">int</span> score[][COURSE_N],<span class="type">int</span> sum[],<span class="type">float</span> aver[],<span class="type">int</span> n)</span><span class="comment">//计算每门课程平均分</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;COURSE_N;j++)<span class="comment">//遍历每门课程</span></span><br><span class="line">&#123;</span><br><span class="line">sum[j]=<span class="number">0</span>;<span class="comment">//第j门课程总分</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//遍历每个学生</span></span><br><span class="line">&#123;</span><br><span class="line">sum[j]=sum[j]+score[i][j];</span><br><span class="line">&#125;</span><br><span class="line">aver[j]=(<span class="type">float</span>)sum[j]/COURSE_N;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AverforStud</span><span class="params">(<span class="type">int</span> score[][COURSE_N],<span class="type">int</span> sum[],<span class="type">float</span> aver[],<span class="type">int</span> n)</span><span class="comment">//计算每个学生的平均分</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//遍历每个学生</span></span><br><span class="line">&#123;</span><br><span class="line">sum[i]=<span class="number">0</span>;<span class="comment">//第i个学生总分</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;COURSE_N;j++)<span class="comment">//遍历每门课程</span></span><br><span class="line">&#123;</span><br><span class="line">sum[i]=sum[i]+score[i][j];</span><br><span class="line">&#125;</span><br><span class="line">aver[i]=(<span class="type">float</span>)sum[i]/COURSE_N;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>[[六、排序#冒泡排序|冒泡排序]]</p><ul><li>冒泡排序：比较相邻两个数据，顺序不对，则将其位置交换</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//排序算法（升序）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(score[j]&lt;score[j<span class="number">-1</span>])<span class="comment">//交换相邻元素</span></span><br><span class="line">&#123;</span><br><span class="line">temp = score[j];</span><br><span class="line">score[j] = score[j<span class="number">-1</span>];</span><br><span class="line">score[j<span class="number">-1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>交换排序：将第1个数与后面数进行比较，然后交换位置，然后第二个数开始比较<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ChangSort</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//交换法升序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>+i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(score[j]&lt;score[i])<span class="comment">//两个元素比较</span></span><br><span class="line">&#123;</span><br><span class="line">temp = score[j];</span><br><span class="line">score[j] = score[j<span class="number">-1</span>];</span><br><span class="line">score[j<span class="number">-1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>选择法排序：在每一遍比较中，在剩余的待比较的数中选择一个最小的数与这个剩余序列的第一个数交换位置<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span> score[],<span class="type">int</span> n)</span><span class="comment">//交换法升序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="comment">//第i个位置的元素</span></span><br><span class="line">&#123;</span><br><span class="line">k=i;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>+i;j&lt;n;j++)<span class="comment">//寻找最低分所在下标k的过程</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(score[j]&lt;score[k])</span><br><span class="line">&#123;</span><br><span class="line">k = j;<span class="comment">//记录最小数的下标位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k != i)<span class="comment">//最小数不在下标位置</span></span><br><span class="line">&#123;</span><br><span class="line">temp = score[j];</span><br><span class="line">score[j] = score[j<span class="number">-1</span>];</span><br><span class="line">score[j<span class="number">-1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul><li>内存编址：每个字节都有唯一的编号 （地址）</li><li>地址为无符号整数，16进制</li><li>指针不是地址，指针变量的值是一个地址</li><li>可以保存变量、数组、字符串的首地址，保存函数的入口</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><code>基类型  *变量</code>；</li><li>基类型：指针变量指向的数据类型</li><li>%p:输出变量地址</li><li>指针变量使用前必须初始化<ul><li>不知道指向那里，就指向NULL</li></ul></li><li>初始化:<ul><li><code>基类型  *变量1=&amp;变量2</code></li><li><code>基类型  *变量1；变量1=&amp;变量2</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int *pa;//定义指针</span></span><br><span class="line">    <span class="type">int</span> *pa=&amp;a;<span class="comment">//指针初始化；</span></span><br><span class="line">    <span class="comment">//int *pa=NULL;//指针初始化</span></span><br><span class="line">    <span class="comment">//pa=NULL;//指针初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=%p\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pa=%p\n&quot;</span>,pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><ul><li>值为NULL的指针</li></ul><h3 id="指针解引用"><a href="#指针解引用" class="headerlink" title="指针解引用"></a>指针解引用</h3><ul><li>通过间接寻址运算符访问指针指针指向变量的值</li><li><code>基类型 *变量=&amp;变量1</code>；<ul><li><code>*变量=变量2</code>；</li><li>说明：<code>*变量为变量1的别名，可以赋值</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *pa=&amp;a;<span class="comment">//指针初始化；</span></span><br><span class="line">    *pa=<span class="number">1</span>;<span class="comment">//给a赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*pa);<span class="comment">//等价上一条语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041243431.png" alt="image-20210904092305525"></p><ul><li>可以通过实参变量的地址，进而改变指针形参的值</li><li>这样函数可以返回多个值。</li><li>提供了修改实参值得方法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> *par)</span>;<span class="comment">//函数指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span> ,a);</span><br><span class="line">    Fun(&amp;a);<span class="comment">//传递地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> *par)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,*par);</span><br><span class="line">    *par=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li><h4 id="两数交换"><a href="#两数交换" class="headerlink" title="两数交换"></a>两数交换</h4><ul><li>可以直接将值传给实参</li><li>不能借助一个未初始化得指针变量进行两数交换<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">9</span>;</span><br><span class="line">    Swap(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d&quot;</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span><span class="comment">//两数交换</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp=*x;</span><br><span class="line">    *x=*y;</span><br><span class="line">    *y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li>格式：<code>数据类型 （*指针变量名）（形参列表）</code>；</li><li>作用<ul><li>编写 通用性更强的函数</li><li>实例1：通用计算任意函数定积分得函数</li><li>实例2：通用的排序函数</li><li>方便直接在主函数调用其他函数</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//声明了函数名为f，返回值是整型指针类型得函数；在main里面</span></span><br><span class="line">f=Max;<span class="comment">//Max是定义得函数名</span></span><br><span class="line">result=(*f)(a,b);<span class="comment">//调用赋值</span></span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,result;</span><br><span class="line">    <span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    Fun(a,b,Max);</span><br><span class="line">    Fun(a,b,Min);</span><br><span class="line">    Fun(a,b,Add);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>))</span><span class="comment">//直接输出</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result=(*f)(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,result );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//判断最大数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//判断最小数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//计算总和</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>先看下面的<a href="https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E&spm=1001.2101.3001.7020">函数声明</a>，注意，此函数有返回值，<strong>返回值为int</strong> *，即<strong>返回值是指针类型的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mystring</span><span class="params">()</span><span class="comment">//指针函数声明</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mystring());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指针符号情况"><a href="#指针符号情况" class="headerlink" title="指针符号情况"></a>指针符号情况</h2><ul><li>在不同类型赋值地址时，有的需要加&amp;，有的不需要加&amp;<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*p为定义的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要加&amp;,给的首地址</span></span><br><span class="line">p=num<span class="comment">//str为数组</span></span><br><span class="line">p=str<span class="comment">//str为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要加&amp;</span></span><br><span class="line">p=&amp;a<span class="comment">//一般为整型，浮点型等</span></span><br><span class="line">p=&amp;str[<span class="number">2</span>]<span class="comment">//字符串,指定某个字符时</span></span><br><span class="line">p=&amp;struc<span class="comment">//struc为结构体</span></span><br><span class="line">p=&amp;num[<span class="number">2</span>]<span class="comment">//数组,指定某个元素</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h2><h3 id="用scanf-输入"><a href="#用scanf-输入" class="headerlink" title="用scanf()输入"></a>用scanf()输入</h3><ul><li>不能输入带空格的字符串</li><li>%s:输入字符</li><li>不读走回车，留在缓冲区中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[STR_LEN+<span class="number">1</span>];<span class="comment">//定义字符串数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符：\n&quot;</span> );</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用gets输入"><a href="#用gets输入" class="headerlink" title="用gets输入"></a>用gets输入</h3><ul><li>以回车换行作为终止符，可以带入空格字符串，应为空和制表符都是字符串的一部分<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[STR_LEN+<span class="number">1</span>];<span class="comment">//定义字符串数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入字符：\n&quot;</span> );</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="表示与存储"><a href="#表示与存储" class="headerlink" title="表示与存储"></a>表示与存储</h2><h3 id="字符数组的定义"><a href="#字符数组的定义" class="headerlink" title="字符数组的定义"></a>字符数组的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR_LEN 80</span></span><br><span class="line"><span class="type">char</span> str[STR_LEN+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//字符常量的初始化列表对数组初始化</span></span><br><span class="line"><span class="comment">//用字符串常量直接对数组初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=&#123;<span class="string">&quot;China&quot;</span>&#125;;<span class="comment">//用字符串常量直接对数组初始化</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">6</span>]=<span class="string">&quot;China&quot;</span>;<span class="comment">//一般选择</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;China&quot;</span>;<span class="comment">//后面的元素会自动处理成ACSII码值为0</span></span><br></pre></td></tr></table></figure><h3 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h3><ul><li>字符指针就是字符串首地址的指针</li><li>pstr的值可被修改，他所指向的字符串也可被修改</li><li>原则<ol><li>明确字符串被保存哪里</li><li>字符指针指向哪里</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//char *pstr[6]=&quot;China&quot;;</span></span><br><span class="line">    <span class="comment">//将字符指针指向一个字符数组</span></span><br><span class="line">    <span class="type">char</span> str[]=<span class="string">&quot;China&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *pstr;</span><br><span class="line">    pstr = str;<span class="comment">//地址保存，字符指针指向数组; 等价pstr = &amp;str[0];</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    *pstr=<span class="string">&#x27;w&#x27;</span>;<span class="comment">//地址指向的是首地址，等价str[0]=&#x27;w&#x27;或pstr[0]=&#x27;w&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    str[<span class="number">3</span>]=<span class="string">&#x27;D&#x27;</span>;<span class="comment">//修改字符数组的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><ul><li>开头要加<code># include&lt;string.h&gt;</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(字符串);<span class="comment">//计算字符串长度,实际长度</span></span><br><span class="line"><span class="built_in">strcpy</span>(目的字符数组，源字符串);<span class="comment">//将源字符串复制到目的字符数组;目的字符数组要比元字符串大</span></span><br><span class="line"><span class="built_in">strncpy</span>(目的字符数组，源字符串,n);<span class="comment">//将源字符串的前n个字符复制到目的字符数组;更安全</span></span><br><span class="line"><span class="built_in">strcat</span>(目的字符数组，源字符串);<span class="comment">//将源字符串添加到目的字符数组</span></span><br><span class="line"><span class="built_in">strcmp</span>(字符串<span class="number">1</span>，字符串<span class="number">2</span>);</span><br><span class="line"><span class="comment">//字符串的比较是比较字符串中各对字符的ASCII码</span></span><br><span class="line"><span class="comment">//自左向右逐个按照ASCII码值进行比较，直到出现不同的字符或遇’\0’为止。</span></span><br><span class="line"><span class="comment">//第一个字符串大于第二个字符串，则返回大于0的数字</span></span><br><span class="line"><span class="comment">//第一个字符串等于第二个字符串，则返回0</span></span><br><span class="line"><span class="comment">//第一个字符串小于第二个字符串，则返回小于0的数字</span></span><br><span class="line"><span class="built_in">strncmp</span>(字符串<span class="number">1</span>，字符串<span class="number">2</span>,n);</span><br></pre></td></tr></table></figure></li></ul><p>案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#define N 100</span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    char <span class="built_in">str</span>[<span class="number">10</span>]=<span class="string">&quot;China&quot;</span>;</span><br><span class="line">    char str1[N];</span><br><span class="line">    char str2[N];</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>,strlen(<span class="built_in">str</span>));//输出字符串长度</span><br><span class="line">    strcpy(str1,<span class="built_in">str</span>);</span><br><span class="line">    printf(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    strcat(str1,strcpy(<span class="built_in">str</span>,<span class="string">&quot;  hello&quot;</span>));</span><br><span class="line">    printf(<span class="string">&quot;%s\n&quot;</span>,str1);</span><br><span class="line">    strcmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>strcmp</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;start&quot;</span>) 是一个C语言的字符串比较函数，用于判断传入的第一个命令行参数 argv[<span class="number">1</span>] 是否与字符串 <span class="string">&quot;start&quot;</span> 相等。<span class="built_in">strcmp</span> 函数返回值为 <span class="number">0</span> 表示两个字符串相等。</span><br></pre></td></tr></table></figure><h3 id="向函数传递字符串"><a href="#向函数传递字符串" class="headerlink" title="向函数传递字符串"></a>向函数传递字符串</h3><ul><li>用字符数组作为函数参数</li><li>也可用字符指针做函数参数</li><li>传字符串的首地址，不是全部地址<br><strong>计算实际字符个数</strong></li><li>const作用：保护指针变量指向的内容不被改变</li><li>若只向函数传数据，则把形参定义为const，防止他被意外修改<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">MyStrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pstr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch[N];</span><br><span class="line">    gets(ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>,MyStrlen(ch));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">MyStrlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pstr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;*pstr!=<span class="string">&#x27;\0&#x27;</span>;pstr++)<span class="comment">//pstr++:地址加1</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>函数返回字符串方法</strong></p><ul><li>数组和指针作为函数形参</li><li>从函数返回指向字符串的指针</li><li>数组不能作为函数的返回值</li></ul><p>缓冲区溢出和溢出攻击</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">Ex</span><span class="params">(<span class="type">char</span> *str)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,Ex(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">Ex</span><span class="params">(<span class="type">char</span> *str)</span><span class="comment">//返回字符串需要用到指针函数（函数名前加*）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s3[N];<span class="comment">//static将s3变为静态变量，不加则不能返回函数内定义的字符串</span></span><br><span class="line">    <span class="type">int</span> i,k;</span><br><span class="line">    k=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s3[k<span class="number">-1</span>-i]=str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><ul><li>可以用指针代替数组下标操作</li></ul><h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><ul><li>加上整数，减去整数，两个指针相减</li><li>参与运算：加，减整数，自增，自减，关系，赋值</li></ul><p>指针指向数组元素才有意义</p><ul><li>p+j不是加j个字节，而是取决于p的基类型</li><li>指向同一数组时，还可以比较</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p,*q;</span><br><span class="line">    p=&amp;a[i];</span><br><span class="line">    q=p+j;</span><br><span class="line">    q=p-j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h2><p>首地址<code>&amp;a[0]</code></p><ul><li><code>&amp;a[i]</code>等价于（a+i）</li><li>a+1指的是：<code>a+i*sizeof(基类型)</code></li><li>数组地址的相差取决于基类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>],*p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=a;p&lt;a+<span class="number">5</span>;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p=a;p&lt;a+<span class="number">5</span>;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d\n&quot;</span>,*p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自加区别"><a href="#自加区别" class="headerlink" title="自加区别"></a>自加区别</h3><ul><li><code>*p++</code>是指下一个地址</li><li><code>(*p)++</code> 是指将 <code>*p</code>所指的数据的值加一</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*p++与（*p）++区别</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,*p=a,*q=a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p );</span><br><span class="line">    x=*p++;<span class="comment">//执行这一句后x=a[0]=1，p=a+1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    y=(*q)++;<span class="comment">//执行这一句后，y=a[0]+1=2，q仍然=a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><h3 id="指向二维数组的行指针"><a href="#指向二维数组的行指针" class="headerlink" title="指向二维数组的行指针"></a>指向二维数组的行指针</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><code>int (*p)[3];//行指针，基类型int[3]类型</code> </li><li><code>int *q[3];//指针数组</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//a[i][j]的元素值等价于*(*(p+i)+j)</span></span><br><span class="line"><span class="comment">//*(p+i),即a[i]，指向第i行第0列的int型元素</span></span><br><span class="line"><span class="comment">//*(p+i)+j指向第i行第j列的int型元素</span></span><br><span class="line"><span class="comment">//*(*(p+i)+j)取出第i行第j列的内容，即a[i][j]</span></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041243909.png" alt="image-20210912172323876"></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li>按行查找，再按列查找<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">3</span>];<span class="comment">//行指针，基类型int[3]类型 </span></span><br><span class="line">    p=a;<span class="comment">//&amp;a[0]指向第0行的int[3]型元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="comment">//行下标变化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)<span class="comment">//列下标变化</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*(p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="指向二维数组的列指针"><a href="#指向二维数组的列指针" class="headerlink" title="指向二维数组的列指针"></a>指向二维数组的列指针</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li><code>int *p;//列指针，基类型是int 型</code></li><li>将二维看成一维数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//*(a+0)+0)即&amp;a[0][0],指向a[0][0]的int元素</span></span><br><span class="line">*(p+i*<span class="number">3</span>+j)<span class="comment">//代表着第一个元素，i代表前i行,j代表着本行第j个元素</span></span><br></pre></td></tr></table></figure><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041243194.png" alt="image-20210912172246480"></p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//*(a+0)+0)即&amp;a[0][0],指向a[0][0]的int元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p+i*<span class="number">3</span>+j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二维数组输入"><a href="#二维数组输入" class="headerlink" title="二维数组输入"></a>二维数组输入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> q[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;q[i]);<span class="comment">//对于一维相当字符串，二维输入字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,q[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><h2 id="二维字符数组"><a href="#二维字符数组" class="headerlink" title="二维字符数组"></a>二维字符数组</h2><ul><li>第二维下标不能省略</li><li>相对字符指针数组空间浪费</li><li>定义：<code>char country[][10]=&#123;&quot;A&quot;,&quot;E&quot;,&quot;A&quot;,&quot;C&quot;,&quot;j&quot;&#125;;</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> country[][<span class="number">10</span>]=&#123;<span class="string">&quot;America&quot;</span>,<span class="string">&quot;England&quot;</span>,<span class="string">&quot;Australia&quot;</span>,<span class="string">&quot;China&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;<span class="comment">//定义二维字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,country[i]);<span class="comment">//访问数组，输出每行的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符指针数组"><a href="#字符指针数组" class="headerlink" title="字符指针数组"></a>字符指针数组</h2><ul><li>每个数组元素都是一个指向字符串的指针</li><li>定义：<code>char *country[]=&#123;&quot;A&quot;,&quot;E&quot;,&quot;A&quot;,&quot;C&quot;,&quot;j&quot;&#125;;</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *country[]=&#123;<span class="string">&quot;America&quot;</span>,<span class="string">&quot;England&quot;</span>,<span class="string">&quot;Australia&quot;</span>,<span class="string">&quot;China&quot;</span>,<span class="string">&quot;jsf&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,country[i]);<span class="comment">//输出每行的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>用数组指针的基类型—–指向数组的指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li>用指针作数组的基类型——指针数组<ul><li>元素维指针类型的数组</li><li>定义：<code>数据类型 *数组名[数组长度]</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul><li>这个是在c++中使用，<a href="https://blog.csdn.net/qq_56673429/article/details/124837626?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170099894116800211556860%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170099894116800211556860&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124837626-null-null.142%5Ev96%5Epc_search_result_base6&utm_term=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88c++11&spm=1018.2226.3001.4187">智能指针</a><blockquote><p>在C++中没有垃圾回收机制，<strong>必须自己释放分配的内</strong>存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。智能指针是<strong>存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象</strong>，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</p></blockquote></li></ul><p>C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<code>&lt;memory&gt;</code></p><p><strong>主要三种指针</strong></p><ul><li>std::shared_ptr：共享的智能指针</li><li>std::unique_ptr：独占的智能指针</li><li>std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ul><h2 id="共享的智能指针shared-ptr"><a href="#共享的智能指针shared-ptr" class="headerlink" title="共享的智能指针shared_ptr"></a>共享的智能指针shared_ptr</h2><ul><li><a href="https://blog.csdn.net/weixin_41504987/article/details/124396989?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170099845016800197097620%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170099845016800197097620&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124396989-null-null.142%5Ev96%5Epc_search_result_base6&utm_term=%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187">解释1</a><br><strong>初始化</strong><blockquote><p>指多个智能指针可以<strong>同时管理同一块有效的内存</strong>，共享智能指针shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数use_count</p></blockquote></li></ul><p><strong>获取原始指针</strong></p><blockquote><p> 对应基础数据类型来说，通过操作智能指针和操作智能指针管理的内存效果是一样的，可以直接完成数据的读写。但是如果共享智能指针管理的是一个对象，那么就需要取出原始内存的地址再操作，可以调用共享智能指针类提供的get()方法得到原始地址</p></blockquote><p><strong>指定删除器</strong></p><blockquote><p> 当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p></blockquote><p>特点</p><ul><li><strong>基本原理</strong>:就是记录对象被引用的次数，当引用次数为 0 的时候，也就是最后一个指向该对象的共享指针析构的时候，共享指针的析构函数就把指向的内存区域释放掉。</li><li><strong>特点</strong>:它所指向的资源具有共享性，即多个shared_ptr可以指向同一份资源，并在内部使用引用计数机制来实现这一点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>shared_ptr&lt;T&gt; ptr;<span class="comment">//ptr 的意义就相当于一个 NULL 指针</span></span><br><span class="line"><span class="number">2.</span><span class="function">shared_ptr&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T())</span></span>;<span class="comment">//从new操作符的返回值构造</span></span><br><span class="line"><span class="number">3.</span><span class="function">shared_ptr&lt;T&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;    <span class="comment">// 使用拷贝构造函数的方法，会让引用计数加 1</span></span><br><span class="line">                               <span class="comment">//shared_ptr 可以当作函数的参数传递，或者当作函数的返回值返回，这个时候其实也相当于使用拷贝构造函数。</span></span><br><span class="line"><span class="number">4.</span><span class="comment">/*假设B是A的子类*/</span></span><br><span class="line"><span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">( dynamic_pointer_cast&lt;A&gt;(ptrb) )</span></span>;<span class="comment">//从 shared_ptr 提供的类型转换 (cast) 函数的返回值构造</span></span><br><span class="line"><span class="number">5.</span><span class="comment">/* shared_ptr 的“赋值”*/</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br><span class="line">a = b;  <span class="comment">// 此后 a 原先所指的对象会被销毁，b 所指的对象引用计数加 1</span></span><br><span class="line"><span class="comment">//shared_ptr 也可以直接赋值，但是必须是赋给相同类型的 shared_ptr 对象，而不能是普通的 C 指针或 new 运算符的返回值。</span></span><br><span class="line"><span class="comment">//当共享指针 a 被赋值成 b 的时候，如果 a 原来是 NULL, 那么直接让 a 等于 b 并且让它们指向的东西的引用计数加 1;</span></span><br><span class="line"><span class="comment">// 如果 a 原来也指向某些东西的时候，如果 a 被赋值成 b, 那么原来 a 指向的东西的引用计数被减 1, 而新指向的对象的引用计数加 1。</span></span><br><span class="line"><span class="number">6.</span><span class="comment">/*已定义的共享指针指向新的new对象————reset()*/</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">T</span>()); <span class="comment">// 原来所指的对象会被销毁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;memory&gt;</span> <span class="comment">// 共享指针必须要包含的头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 最好使用make_shared创建共享指针，</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();<span class="comment">//make_shared 创建空对象，</span></span><br><span class="line">*p1 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl; <span class="comment">// 输出10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印引用个数：1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2个 shared_ptr 对象指向同一个指针</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2 count = &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较智能指针，p1 等于 p2</span></span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">std::cout&lt;&lt; <span class="string">&quot;p1 and p2 are pointing to same pointer\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p1.<span class="built_in">reset</span>();<span class="comment">// 无参数调用reset，无关联指针，引用个数为0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 Count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">p1.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">11</span>));<span class="comment">// 带参数调用reset，引用个数为1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 Count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">p1 = <span class="literal">nullptr</span>;<span class="comment">// 把对象重置为NULL，引用计数为0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1  Reference Count = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (!p1) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 is NULL&quot;</span> &lt;&lt; endl; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.函数</title>
      <link href="/data.github.io/post/796dd667.html"/>
      <url>/data.github.io/post/796dd667.html</url>
      
        <content type="html"><![CDATA[<h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><ul><li>函数：构成C语言的基本模块<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数返回值类型 函数名(形参)</span><br><span class="line">&#123;</span><br><span class="line">函数体；</span><br><span class="line"><span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetMax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//形参也是局部变量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  result;<span class="comment">//局部变量，只能在函数体内访问它</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">result = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;<span class="comment">//函数的出口，只能返回一个值；要与返回值类型一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMax</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//表示无返回值省略默认为int;后面表示无参数可省略,明确告诉编译器不需要从外界接受数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  result,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,x,y)</span><br><span class="line"><span class="keyword">if</span>(x&gt;y)</span><br><span class="line">result = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result = y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, result);</span><br><span class="line"><span class="keyword">return</span> ;<span class="comment">//没有return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h2><ol><li>主调函数通过函数名调用被调函数</li><li>函数无返回值时，单独作为一个函数调用语句</li></ol><ul><li>函数定义的参数称为形式参数</li><li>函数调用的参数称为实际参数</li><li>实参和形参的位置一一对应</li></ul><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><p><strong>合并成完整程序</strong></p><h2 id="1-函数定义放在函数调用前"><a href="#1-函数定义放在函数调用前" class="headerlink" title="1.函数定义放在函数调用前"></a>1.函数定义放在函数调用前</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">result = (x+y)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,ave;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">ave = Average(a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ave);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数定义放在函数调用后"><a href="#2-函数定义放在函数调用后" class="headerlink" title="2.函数定义放在函数调用后"></a>2.函数定义放在函数调用后</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,ave;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">ave = Average(a,b);<span class="comment">//调用函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ave);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Average</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">result = (x+y)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数设计原则"><a href="#函数设计原则" class="headerlink" title="函数设计原则"></a>函数设计原则</h3><ol><li>函数规模小</li><li>函数功能单一</li><li>函数接口定义要清楚</li></ol><h1 id="断言与防御性程序设计"><a href="#断言与防御性程序设计" class="headerlink" title="断言与防御性程序设计"></a>断言与防御性程序设计</h1><h2 id="断言：assert"><a href="#断言：assert" class="headerlink" title="断言：assert"></a>断言：assert</h2><ul><li>测试程序中假设的正确性</li><li>如果假设被违反，则中断程序执行</li><li>程序开头要加#include&lt;assert.h&gt;——-他是在&lt;assert.h&gt;中定义的宏</li><li>仅用于调试，不能作为程序功能</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Iput m(m&gt;0):\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">&#125;<span class="keyword">while</span>(m &lt;= <span class="number">0</span>);</span><br><span class="line">assert(m &gt;= <span class="number">0</span>);<span class="comment">//为假时，终止程序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d != %lu\n&quot;</span>,m,Fact(m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">result *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="好代码风格"><a href="#好代码风格" class="headerlink" title="好代码风格"></a>好代码风格</h2><ol><li>代码行内空格<ul><li>赋值、算数、关系、逻辑等二元运算符前后各加一个空格</li><li>关键字之后加空格</li></ul></li><li>空行—–隔程序段落的作用<ul><li>每个函数定义之后加空行</li><li>一个函数体内，相邻两组密切相关的语句之间加空格，语句块内不加空格</li></ul></li><li>对齐</li><li>命名</li></ol><ul><li>变量名形式：小写字母开头</li><li>函数名形式：大写字母开头</li><li>宏和const常量全用大写字母，并用下划线分割单词</li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h1 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h1><ul><li>函数不能嵌套定义</li><li>但可以嵌套调用<br>求组合数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">Comb</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> k)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m,k;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Iput m,k(m&gt;=k&gt;0):\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;m,&amp;k);</span><br><span class="line">&#125;<span class="keyword">while</span>(m&lt;k || m&lt;<span class="number">0</span> || k&lt;<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,Comb(m,k) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">Comb</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> k)</span><span class="comment">//计算组合数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Fact(m)/(Fact(k)*Fact(m-k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//计算阶乘</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">result *= i; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数递归调用"><a href="#函数递归调用" class="headerlink" title="函数递归调用"></a>函数递归调用</h2><ul><li>递归调用：函数直接或者间接调用自己———递归函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n*Fact(n<span class="number">-1</span>);<span class="comment">//调用自己</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h2><ol><li>数学定义是递归：计算阶乘、最大公约数和数列等</li><li>数据结构是递归：队列、链表等</li><li>问题解法是递归的</li></ol><h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><ol><li>数学归纳法</li><li>将n个圆盘看作1个和n-1个圆盘<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Move</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input the number of disks:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;steps of moving %d disks from A to B by means of C:\n&quot;</span>,n);</span><br><span class="line">Hanoi(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Move(n,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Hanoi(n<span class="number">-1</span>,a,c,b);<span class="comment">//将n-1个圆盘从A移到C</span></span><br><span class="line">Move(n,a,b);<span class="comment">//将第n个圆盘从A移到B</span></span><br><span class="line">Hanoi(n<span class="number">-1</span>,c,b,a);<span class="comment">//将上面n-1个圆盘从C移到B</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Move</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Move %d:从%c移到%c\n&quot;</span>,n,a,b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="递归执行2个阶段"><a href="#递归执行2个阶段" class="headerlink" title="递归执行2个阶段"></a>递归执行2个阶段</h3><ul><li>递推阶段：有终止条件</li><li>回归阶段<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span>;<span class="comment">//计算阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入n\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u的阶乘为%u&quot;</span>,n,Fact(n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n*Fact(n<span class="number">-1</span>);<span class="comment">//F（n-1）是递推阶段，return n*Fact(n-1)为回归阶段</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="C程序的内存映像"><a href="#C程序的内存映像" class="headerlink" title="C程序的内存映像"></a>C程序的内存映像</h3><p>只读存储区：代码区、常量存储区（内存低地址端）<br>静态存储区<br>动态存储区：</p><ul><li>堆：从内存低地址向内存高地址端进行扩展</li><li>栈：从内存高地址向内存低地址端进行扩展</li><li>堆栈溢出：往堆栈中存入的数据超过预先给堆栈分配的容量<br><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242957.png" alt="image-20210815100547318"></li></ul><h3 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h3><ul><li>优点：结构清晰、易懂等</li><li>缺点：调用开销大。耗费更多时间和栈空间</li></ul><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> a)</span>;<span class="comment">//计算阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入n\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u的阶乘为%u&quot;</span>,n,Fact(n,<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fact</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Fact(n<span class="number">-1</span>,n*a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回归时不需要任何操作</li></ul><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><ul><li>变量的作用范围</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul><li>在语句块内定义（函数、复合语句）的变量</li><li>只能在语句块内使用</li><li>作用域较小的局部变量隐藏作用域较大的局部变量</li><li>函数内定义的变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y=<span class="number">2</span>;</span><br><span class="line">x=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );<span class="comment">//y为复合语句定义的y</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在大花括号定义的只能在花括号内使用</span></span><br><span class="line"><span class="comment">//作用域较小的局部变量隐藏作用域较大的局部变量</span></span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul><li>在函数之外定义的变量</li><li>作用范围：定义变量的位置开始到程序结束<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>局部变量和全局变量同名时</p><ul><li>局部变量隐藏全局变量，互不干扰</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">3</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Fun();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );<span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">2</span>,y=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>,x,y );<span class="comment">//局部变量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量存储类型"><a href="#变量存储类型" class="headerlink" title="变量存储类型"></a>变量存储类型</h2><h3 id="C程序的内存映像-1"><a href="#C程序的内存映像-1" class="headerlink" title="C程序的内存映像"></a>C程序的内存映像</h3><p>只读存储区：代码区、常量存储区（内存低地址端）<br>静态存储区：存放程序中全局变量和静态变量等；静态发生在程序编译时<br>动态存储区：</p><ul><li>堆：从内存低地址向内存高地址端进行扩展</li><li>栈：从内存高地址向内存低地址端进行扩展；用于保存函数 调用时的返回地址、函数形参、局部变量等信息</li><li>堆栈溢出：往堆栈中存入的数据超过预先给堆栈分配的容量</li><li>动态发生在程序载入和运行时</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242268.png" alt="image-20210815100547318"></p><ul><li>存储类型决定变量的生存期<ul><li>静态存储区变量，全程占据内存</li><li>动态存储区变量，生存期与语句块共存亡</li></ul></li></ul><h4 id="声明变量存储类型"><a href="#声明变量存储类型" class="headerlink" title="声明变量存储类型"></a>声明变量存储类型</h4><ul><li>格式：存储类型    数据类型    变量名；</li><li>存储类型关键字<ul><li>auto:自动变量</li><li>static:静态变量</li><li>extern：外部变量——全局变量</li><li>register:寄存器变量</li></ul></li></ul><h1 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h1><ol><li>静态全局变量</li></ol><ul><li>使用：全局变量前加static，修饰全局变量为静态全局变量。</li><li>作用：改变全局变量的可见性。静态全局变量的存储位置在静态存储区，未被初始化的静态全局变量会被自动初始化为0。静态全局变量在声明它的文件之外是不可见的，仅在从定义该变量的开始位置到文件结尾可见。</li></ul><ol start="2"><li>静态局部变量<ul><li>使用：局部变量前加static，修饰局部变量为静态局部变量。</li><li>作用：改变局部变量的销毁时期。静态局部变量的作用域和局部变量的作用域一样，当定义它的函数或语句块结束的时候，作用域结束。不同的是，静态局部变量存储在静态存储区，当静态局部变量离开作用域后，并没有被销毁。当该函数再次被调用的时候，该变量的值为上次函数调用结束时的值。</li></ul></li><li>静态函数<ul><li>使用：函数返回类型前加static，修饰函数为静态函数。</li><li>作用：改变函数的可见性。函数的定义和声明在默认情况下都是extern的，但静态函数只在声明它的文件中可见，不能被其他文件使用。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.循环控制</title>
      <link href="/data.github.io/post/1de4b612.html"/>
      <url>/data.github.io/post/1de4b612.html</url>
      
        <content type="html"><![CDATA[<h1 id="五、循环控制"><a href="#五、循环控制" class="headerlink" title="五、循环控制"></a>五、循环控制</h1><h2 id="计数控制循环"><a href="#计数控制循环" class="headerlink" title="计数控制循环"></a>计数控制循环</h2><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><ul><li>主要用于计数循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)<span class="comment">//表达式1初始条件，表达式2控制条件，表达式3转换条件</span></span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;</span><br><span class="line">语句n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行顺序：表达式1，表达式2，语句,表达式3</span></span><br></pre></td></tr></table></figure><p><strong>逗号运算符</strong><br>表达式1，表达式2，…，表达式n</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>,表达式n;表达式<span class="number">2</span>;表达式<span class="number">3</span>,表达式m)<span class="comment">//逗号表达式主要用在循环语句中，同时对多个变量赋初值</span></span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>;</span><br><span class="line">语句n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span>；<span class="comment">//表达式1循环初始条件</span></span><br><span class="line"><span class="keyword">while</span>(表达式<span class="number">2</span>)<span class="comment">//表达式2循环控制条件</span></span><br><span class="line">&#123;</span><br><span class="line">语句;</span><br><span class="line">表达式<span class="number">3</span>；<span class="comment">//表达式3循环转换条件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行顺序：从上往下</span></span><br></pre></td></tr></table></figure><ul><li>当型循环</li><li>循环次数已知</li></ul><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表达式<span class="number">1</span>；<span class="comment">//表达式1循环初始条件</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">语句；</span><br><span class="line">表达式<span class="number">3</span>；<span class="comment">//表达式3循环转换条件</span></span><br><span class="line">&#125;<span class="keyword">while</span>(表达式<span class="number">2</span>)；<span class="comment">//表达式2循环控制条件,表达式成立时继续循环</span></span><br></pre></td></tr></table></figure><ul><li>循环至少执行一次</li><li>直到型循环</li><li>循环次数可以不已知</li></ul><p><strong>选择循环语句一般原则</strong></p><table><thead><tr><th>循环次数已知</th><th>for语句</th></tr></thead><tbody><tr><td>循环次数未知，循环次数由一个给定条件控制</td><td>while语句和do-while语句</td></tr><tr><td>循环体至少执行一次</td><td>do-while语句</td></tr></tbody></table><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><ol><li>正向递推</li><li>反向逆推</li></ol><h2 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h2><ul><li>列举所有的可能，逐一试探</li><li>根据问题的部分已知条件预估解的范围</li><li>直到找到满足已知条件的解为止</li></ul><h1 id="函数分文件编写头文件"><a href="#函数分文件编写头文件" class="headerlink" title="函数分文件编写头文件:"></a>函数分文件编写头文件:</h1><ol><li>头文件 (.h) 需要包含的头文件，指定命名空间，声明全局变量，函数的声明，数据结构和类的声明等。</li></ol><ul><li>源文件 (. cpp&#x2F;. c)：函数的定义、类的定义。</li><li>主程序：main 函数，程序的核心流程，需要用 <code>#include &quot;头文件名&quot;</code> 把头文件包含来</li></ul><p>创建 MyClass. h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myInt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInt</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getInt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MYCLASS_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyClass.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    myInt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::setInt</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    myInt = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myInt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">setInt</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="type">int</span> value = obj.<span class="built_in">getInt</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;My integer value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="VSCODE分文件编写"><a href="#VSCODE分文件编写" class="headerlink" title="VSCODE分文件编写"></a>VSCODE分文件编写</h3><ul><li><p>对于vscode来说，使用catkin_ws工作区</p></li><li><p>在src中有main.c函数，我需要编写MyClass.cpp和MyClass.h</p></li><li><p>需要在src中新建include文件夹，将MyClass.cpp和MyClass.h放在该文件夹中</p></li><li><p>在main.c中添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/MyClass.h&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>在CmakeLists.txt中添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(test1 src/main.cpp src/include/MyClass.cpp)</span><br><span class="line"><span class="comment">//下面的情况是嵌套包含cpp文件offboard.cpp包含Uav_info.h，Uav_info.h包含Pid_control.h和arm_info.h，对于执行文件都要包含头文件</span></span><br><span class="line"><span class="comment">//add_executable(offboard src/offboard.cpp src/include/Uav_info.cpp src/include/Pid_control.cpp src/include/arm_info.cpp)</span></span><br><span class="line"><span class="built_in">target_link_libraries</span>(test1 $&#123;catkin_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure></li><li><p>接着编译就就行了<br>![[Pasted image 20240108092520.png]]</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.无处不在的抉择</title>
      <link href="/data.github.io/post/af3b6a0f.html"/>
      <url>/data.github.io/post/af3b6a0f.html</url>
      
        <content type="html"><![CDATA[<h1 id="四、无处不在的抉择"><a href="#四、无处不在的抉择" class="headerlink" title="四、无处不在的抉择"></a>四、无处不在的抉择</h1><h2 id="关系运算符与逻辑运算符"><a href="#关系运算符与逻辑运算符" class="headerlink" title="关系运算符与逻辑运算符"></a>关系运算符与逻辑运算符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242252.png" alt="image-20210803224119840"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>&amp;&amp;</th><th>与：当2个操作数都为真结果为真</th></tr></thead><tbody><tr><td>||</td><td>或：两个操作数至少一个为真结果为真</td></tr><tr><td>！</td><td>非：操作数为真结果为假</td></tr></tbody></table><p><strong>短路特性</strong> </p><ul><li>表达式的值可先有计算的左操作数的值推导出来，就不会计算右操作数的值</li><li>可以使除0运算不发生</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>逻辑非   &gt;   算数运算符   &gt;   关系运算符   &gt;   逻辑与   &gt;   逻辑或</li><li>也可以通过添加小括号提高优先级</li></ul><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="单分支选择结构（if语句）"><a href="#单分支选择结构（if语句）" class="headerlink" title="单分支选择结构（if语句）"></a>单分支选择结构（if语句）</h3><ul><li>结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式P)</span><br><span class="line">语句A</span><br></pre></td></tr></table></figure><h3 id="双分支结构（if-else）"><a href="#双分支结构（if-else）" class="headerlink" title="双分支结构（if-else）"></a>双分支结构（if-else）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式P)</span><br><span class="line">&#123;</span><br><span class="line">语句A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">语句B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用花括号内可以表达多个语句</li></ul><h3 id="多分支结构（else-if）"><a href="#多分支结构（else-if）" class="headerlink" title="多分支结构（else-if）"></a>多分支结构（else-if）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">语句A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">语句B</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">语句C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><ul><li>表达式1？表达式2：表达式3；</li><li>含义：表达式1为真时，输出表达式2的值，否则输出表达式3的值</li></ul><h2 id="开关语句"><a href="#开关语句" class="headerlink" title="开关语句"></a>开关语句</h2><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)<span class="comment">//表达式是int型或char型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">语句序列<span class="number">1</span>；</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//break跳出switch语句结构</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">语句序列<span class="number">2</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//上面case都不能执行时，执行这个语句</span></span><br><span class="line">语句序列n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数值溢出和损失问题"><a href="#数值溢出和损失问题" class="headerlink" title="数值溢出和损失问题"></a>数值溢出和损失问题</h2><h3 id="数值溢出"><a href="#数值溢出" class="headerlink" title="数值溢出"></a>数值溢出</h3><ul><li>自动类型转换会发生的问题</li><li>取值范围大的类型转换成取值范围小的类型发生数值溢出</li><li>类型表数范围有限</li></ul><h4 id="整数的数值溢出"><a href="#整数的数值溢出" class="headerlink" title="整数的数值溢出"></a>整数的数值溢出</h4><p><strong>上溢出</strong></p><ul><li>一个数值运算&gt;类型能表示的最大数</li><li>进位超过最高位发生进位丢失</li><li>进位达到最高位改变符号位</li></ul><h4 id="浮点数的数值溢出"><a href="#浮点数的数值溢出" class="headerlink" title="浮点数的数值溢出"></a>浮点数的数值溢出</h4><p><strong>上溢出</strong></p><ul><li>浮点数运算结果&gt;类型能表示的最大数<br><strong>下溢出</strong></li><li>浮点数运算结构&lt;类型能表示的最小数</li></ul><h3 id="精度损失"><a href="#精度损失" class="headerlink" title="精度损失"></a>精度损失</h3><ul><li>高精度向低精度转换时发生精度损失</li><li>float到int(丢失小数部分)</li><li>二进制小数与十进制小数之间很多不是一一对应的关系</li><li>float能表示的有效数字为7位，double能表示的有效数字为16位</li></ul><h1 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h1><ul><li><a href="https://blog.csdn.net/qq_50119037/article/details/124336378?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168992957916800227434316%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168992957916800227434316&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124336378-null-null.142%5Ev90%5Econtrol,239%5Ev3%5Econtrol&utm_term=%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91&spm=1018.2226.3001.4187">C&#x2F;C++ 的条件编译</a><blockquote><p>条件编译是一种在程序编译过程中根据条件选择性地编译不同代码块的技术。它可以根据预定义的条件判断是否包含或排除某段代码，使得程序在不同的编译环境或平台上具有不同的行为。<br>条件编译是指预处理的时候根据条件编译的指令有条件的选择源程序中的一部分代码送给编译器进行编译，进行有选择性的操作，防止宏替换的内容重复包含</p></blockquote></li></ul><p><strong>条件编译指令操作</strong></p><table><thead><tr><th align="left">指令</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left"><code> #elif</code></td><td align="left">如果前面条件为假，而该条件为真，则执行相应操作</td></tr><tr><td align="left"><code>#else</code></td><td align="left">如果前面条件均为假，则执行相应操作</td></tr><tr><td align="left"><code> #endif</code></td><td align="left">结束相应的条件编译指令</td></tr><tr><td align="left"><code> #ifdef</code></td><td align="left">如果该宏已定义，则执行相应操作</td></tr><tr><td align="left"><code> #ifndef</code></td><td align="left">如果该宏没有定义，则执行相应操作</td></tr><tr><td align="left"><code>#if</code></td><td align="left">如果条件为真则执行相应操作</td></tr></tbody></table><h2 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h2><h3 id="if-else-endif"><a href="#if-else-endif" class="headerlink" title="#if   #else   #endif"></a><code>#if   #else   #endif</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 4</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> (PI==4)</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式为真则#if后程序段被调用，会执行输出1</span></span><br></pre></td></tr></table></figure><h3 id="if-elif-else-endif"><a href="#if-elif-else-endif" class="headerlink" title="#if   #elif   #else   #endif"></a><code>#if   #elif   #else   #endif</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 条件表达式1</span></span><br><span class="line"><span class="comment">// code1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 条件表达式2 </span></span><br><span class="line">    <span class="comment">//code 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>     </span></span><br><span class="line">    <span class="comment">//code 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>功能为：先判断条件 1 的值，如果为真，则程序段 1 被选中编译；<br>如果为假，而条件表达式 2 的值为真，则程序段 2 被选中编译；<br>其他情况，程序段 3 被选中编译。</p><h3 id="ifdef-else-endif"><a href="#ifdef-else-endif" class="headerlink" title="#ifdef #else  #endif"></a><code>#ifdef #else  #endif</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符   </span></span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符 </span></span><br><span class="line"><span class="comment">//程序段 1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="comment">//程序段 2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>它的功能是如果标识符已被 <code>#define</code> 命令定义过则对程序段 1 进行编译;否则对程序段 2 进行编译；否则，该程序段会被忽略。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PI <span class="comment">//检测到存在才执行</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;PI 已经宏定义&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果检测到PI以定义，则输出“PI 已经被取消宏”和`测试`，没检测到则输出`测试`</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="ifndef-else-endif"><a href="#ifndef-else-endif" class="headerlink" title="#ifndef   #else   #endif"></a><code>#ifndef   #else   #endif</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 标识符 </span></span><br><span class="line"><span class="comment">//程序段 1 </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="comment">//程序段 2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>它的功能是如果<strong>标识符未被 <code>#define</code> 命令定义过</strong>则对程序段 1 进行编译, 否则对程序段 2 进行编译。这与第一种形式的功能正好相反<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// #define I 3.14</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PI    <span class="comment">//检测到存在不执行</span></span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;dfokokjgi&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ifndef、-define、-endif"><a href="#ifndef、-define、-endif" class="headerlink" title="#ifndef、#define、#endif"></a><code>#ifndef、#define、#endif</code></h3><p>该条件编译指令更重要的一个应用是<strong>防止头文件重复包含</strong>。</p><ul><li>如果 f.c 源文件中包含 f1.h 和 f2.h 和两个头文件，而 f1.h 头文件及 f2.h 头文件中均包含 h3.h 头文件，则 f.c 源文件因为包含了 f1.h 和 f2.h 两个头文件，所以中重复包含 f3.h 头文件。可采用条件编译指令，来避免头文件的重复包含问题。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEADNAME_H_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEADNAME_H_</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//头文件内容</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>当该头文件第一次被包含时，由于没检测到该头文件名对应的宏名，则定义该头文件名对应的宏，其值为该系统默认。并且，该条件编译指令选中 <code>#endif</code> 之前的头文件内容；<br>如果该头文件再次被包含时，由于检测到已存在以该头文件名对应的宏名，则忽略该条件编译指令之间的所有代码，从而避免了重复包含。</p></blockquote></li></ul><blockquote><p>在上面的预处理块中，当第一次引用（include）头文件时，由于“__HEADERNAME_H__”还没有被宏定义（define）过，即满足“ <code>#ifndef__HEADERNAME_H__</code> ”，从而执行“ <code>#define__HEADERNAME_H__</code> ”以及其他内容。</p><p>如果因为编码者的不小心或者嵌套包含等原因造成了这个头文件被多次引用（include），那么“#ifndef__HEADERNAME_H__”判断条件将在第二次引用（include）头文件时得不到满足，因此不执行后面的内容，直接跳到“#endif”。</p></blockquote><blockquote><p>通过“#ifndef&#x2F;#define&#x2F;#endif”结构产生预处理块，虽然能够避免同一个头文件被多次包含和重复引用，但也存在一个致命的缺点，那就是一旦一不小心在不同头文件中定义了相同的宏名，问题就比较麻烦了。比如，可能会导致明明看到存在头文件，而编译器却硬说找不到声明等问题。为了避免这种情况，保证宏名的唯一性命名格式为：</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span><br></pre></td></tr></table></figure><p>其中，PROJECT 表示项目名称，PATH 表示头文件相对路径，FILE 表示文件名，再以“<code>_H_</code>”作为后缀</p><h3 id="妙用“defined”"><a href="#妙用“defined”" class="headerlink" title="妙用“defined”"></a>妙用“defined”</h3><p>在 C 语言中，除了“#ifdef”和“#ifndef”指令之外，还可以使用 defined 判断标识符是否定义过。实际上，“#if defined”等价于“#ifdef”，而“#if！defined”等价于“#ifndef”。例如，下面的示例代码就演示了如何使用 defined 来避免重复包含头文件引起的重复定义问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_CASHREGISTER_XML_PARSER_H_)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CASHREGISTER_XML_PARSER_H_</span></span><br><span class="line"><span class="comment">/*声明、定义语句*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>它实际上等价于下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CASHREGISTER_XML_PARSER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CASHREGISTER_XML_PARSER_H_</span></span><br><span class="line"><span class="comment">/*声明、定义语句*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.输入与输出</title>
      <link href="/data.github.io/post/34c8630d.html"/>
      <url>/data.github.io/post/34c8630d.html</url>
      
        <content type="html"><![CDATA[<h1 id="二、数字间关系"><a href="#二、数字间关系" class="headerlink" title="二、数字间关系"></a>二、数字间关系</h1><h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><h3 id="算数优先级"><a href="#算数优先级" class="headerlink" title="算数优先级"></a>算数优先级</h3><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041241962.png" alt="image-20210801231244413"></p><h3 id="求余运算"><a href="#求余运算" class="headerlink" title="求余运算"></a>求余运算</h3><ul><li>判断某数是否被整除</li><li>操作数是整数</li></ul><h3 id="常见数学运算"><a href="#常见数学运算" class="headerlink" title="常见数学运算"></a>常见数学运算</h3><ol><li>注：要在开头加<code>#include&lt;math.h&gt;</code></li><li>随机函数rand()</li></ol><ul><li>生成一个在0~32767之间的随机数</li><li>问题:如何生成一个指定范围（如1<del>100)内的随机数?   &#96;magic &#x3D; rand() % 100 ;    &#x2F;&#x2F;0</del>99&#96;</li></ul><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041241530.png" alt="image-20210801231948222"></p><h2 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h2><ul><li>变量&#x3D;表达式；</li><li>变量1&#x3D;变量2&#x3D;表达式；</li><li>变量1运算符op&#x3D;表达式；</li><li>类型   变量&#x3D;表达式</li></ul><h2 id="增1和减1运算符（-，–）"><a href="#增1和减1运算符（-，–）" class="headerlink" title="增1和减1运算符（++，–）"></a>增1和减1运算符（++，–）</h2><h3 id="前缀与后缀区别"><a href="#前缀与后缀区别" class="headerlink" title="前缀与后缀区别"></a>前缀与后缀区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m=n++；<span class="comment">//先赋值再加1——等价m=n;n=n+1;</span></span><br><span class="line">m=++n;<span class="comment">//先加1在赋值——等价n=n+1;m=n;</span></span><br></pre></td></tr></table></figure><h2 id="自动转换类型"><a href="#自动转换类型" class="headerlink" title="自动转换类型"></a>自动转换类型</h2><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041241643.png" alt="image-20210802161900920"></p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul><li>类型（表达式）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> total,number;</span><br><span class="line"><span class="type">float</span> aver1,aver2;</span><br><span class="line">total = <span class="number">15</span>;</span><br><span class="line">number = <span class="number">2</span>;</span><br><span class="line">aver1 = total/number;<span class="comment">//无强制性转换</span></span><br><span class="line">aver2 = (<span class="type">float</span>)total/number;<span class="comment">//强制性转化</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;aver1=%f\n&quot;</span>,aver1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;aver2=%f\n&quot;</span>,aver2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><h2 id="屏幕输出printf（）"><a href="#屏幕输出printf（）" class="headerlink" title="屏幕输出printf（）"></a>屏幕输出printf（）</h2><h3 id="输出字符"><a href="#输出字符" class="headerlink" title="输出字符"></a>输出字符</h3><table><thead><tr><th>%d</th><th>输出十进制有符号int型</th></tr></thead><tbody><tr><td>%u</td><td>输出十进制无符号int型</td></tr><tr><td>%f</td><td>以小数形式(6位小数)输出float , double型以标准指数形式输出float , double型</td></tr><tr><td>%e</td><td>以标准指数形式输出float , double型</td></tr><tr><td>%c</td><td>以字符形式输出单个字符</td></tr><tr><td>l</td><td>加d、u前输出long型</td></tr><tr><td>h</td><td>加d、u前输出short型</td></tr></tbody></table><h5 id="long-long-的输入和输出"><a href="#long-long-的输入和输出" class="headerlink" title="long long 的输入和输出"></a>long long 的输入和输出</h5><ul><li>输入：<code>scanf(&quot;%Ild&quot;,&amp;a)；</code></li><li>输出：<code>printf(&quot;%Ild&quot;,a)</code>；</li></ul><p>或者还有一版本</p><ul><li>输入：<code>scanf(&quot;%I64d&quot;,&amp;a)；</code></li><li>输出：<code>printf(&quot;%I64d&quot;,a)；</code></li><li><strong>注意I为大写的i</strong></li></ul><h3 id="printf-的格式修饰符"><a href="#printf-的格式修饰符" class="headerlink" title="printf()的格式修饰符"></a>printf()的格式修饰符</h3><h4 id="m-输出数据最小域宽"><a href="#m-输出数据最小域宽" class="headerlink" title="m:输出数据最小域宽"></a>m:输出数据最小域宽</h4><ul><li>数据位宽大于m时，按实际位宽输出</li><li>小于m时，右对齐，左补空格</li><li>-m:左对齐，右补空格</li></ul><h4 id="显示精度-n"><a href="#显示精度-n" class="headerlink" title="显示精度.n:"></a>显示精度.n:</h4><ul><li>对浮点数表示输出n位小数</li><li>格式：<code>%.nf</code></li></ul><p>其他</p><ul><li>一般格式：<code>%m.nf</code></li><li>屏幕输出%：<code>%%</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> a;</span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">a=<span class="number">7.4848</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10.2f\n&quot;</span>,a );<span class="comment">//整个输出占10位，小数点后保留两位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%%\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="键盘输入scanf"><a href="#键盘输入scanf" class="headerlink" title="键盘输入scanf()"></a>键盘输入scanf()</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li><code>scanf(&quot;%d%f&quot;,&amp;a,&amp;b);</code><br>分隔多个输入数据</li></ul><ol><li>空格、Tab或回车</li><li>达到输入位宽</li><li>遇到非法字符<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);<span class="comment">//输入格式正确，返回数值1;遇到非法数字则是返回0</span></span><br><span class="line">c = <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,b);<span class="comment">//scanf的返回值是参数被成功赋值的个数；也可作为输入非法数值判断</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    b=<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="scanf-的格式字符"><a href="#scanf-的格式字符" class="headerlink" title="scanf()的格式字符"></a>scanf()的格式字符</h3><table><thead><tr><th>%d</th><th>输入十进制int型</th></tr></thead><tbody><tr><td>%f,%e</td><td>输入float型（不能指定输入数据精度）</td></tr><tr><td>%c</td><td>输入一个字符（包括空白字符）</td></tr><tr><td>m</td><td>输入数据位宽</td></tr><tr><td>l</td><td>加d,u前输入long型；加f,e前输入double型</td></tr><tr><td>L</td><td>加f,e前输入long double型</td></tr><tr><td>h</td><td>加d前输入short型</td></tr></tbody></table><h2 id="单个字符输入输出"><a href="#单个字符输入输出" class="headerlink" title="单个字符输入输出"></a>单个字符输入输出</h2><p>字符常量</p><ul><li>用单引号括起来的一个字符：  ‘98’</li></ul><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202201041242590.png" alt="image-20210803185142670"></p><h4 id="ACSII码值"><a href="#ACSII码值" class="headerlink" title="ACSII码值"></a><a href="http://c.biancheng.net/c/ascii/">ACSII码值</a></h4><ul><li>字符在内存存储：对应的ASCII码的二进制值</li><li>不管是字符、数字、还是非法数值都有对应的ASCII码值，可以通过ASCII码值来判断是哪种类型</li></ul><h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><ol><li>定义：<code>char ch = &#39;B&#39;</code></li><li>字符型变量的值</li></ol><ul><li>ASCII码值可做算数运算<ol><li>字母小写的ASCII码值总比大写ASCII大32</li></ol></li></ul><h3 id="单个字符输入输出-1"><a href="#单个字符输入输出-1" class="headerlink" title="单个字符输入输出"></a>单个字符输入输出</h3><h4 id="输出函数putchar"><a href="#输出函数putchar" class="headerlink" title="输出函数putchar()"></a>输出函数putchar()</h4><ul><li><code>putchar(ch)</code></li><li>向屏幕输出一个字符–（类似printf）</li></ul><h4 id="输入函数getchar（）"><a href="#输入函数getchar（）" class="headerlink" title="输入函数getchar（）"></a>输入函数getchar（）</h4><ul><li><code>ch = getchar()</code></li><li>键盘输入字符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入字符\n&quot;</span>);<span class="comment">//最好大写好判断</span></span><br><span class="line">ch = getchar();</span><br><span class="line">ch = ch+<span class="number">32</span>;</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//执行结果是将光标执行到下一行的起始位置处</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;作为判断\n&quot;</span>);<span class="comment">//可删去上一行代码作为判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以用printf()输出 </li><li>字符型变量可以%c和%d两种格式输出</li></ul><h2 id="getchar-存在的问题"><a href="#getchar-存在的问题" class="headerlink" title="getchar()存在的问题"></a>getchar()存在的问题</h2><ul><li>输入字符时，将所有的用户输入，包括回车符号，都放在输入缓冲区中</li><li>当一行输入结束后，<code>getchar</code>才开始从输入缓冲队列中读取字符，而在函数没有读走的数据，留在缓冲区被下个<code>getchar()</code>函数读取</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch1,ch2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入字符\n&quot;</span>);</span><br><span class="line">ch1 = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch1=%c\n&quot;</span>,ch1 );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请再次输入字符\n&quot;</span>);</span><br><span class="line">ch2 = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch2=%d\n&quot;</span>,ch2 );<span class="comment">//%d输出的是10，对应的换行符的ASCII码值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-c格式输入存在的问题"><a href="#用-c格式输入存在的问题" class="headerlink" title="用%c格式输入存在的问题"></a>用%c格式输入存在的问题</h3><ul><li>用%c格式读入字符时，空格和回车等空白字符都会被当作有效字符读入</li></ul><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul><li>第一种:用gerchar调用语句将用户输入的回车字符读走</li><li>第二种：在%c前加一个空格忽略缓冲区的空白字符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入整数\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数是%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符\n&quot;</span>);</span><br><span class="line">    getchar();<span class="comment">//用gerchar调用语句将用户输入的回车字符读走</span></span><br><span class="line">    <span class="comment">//scanf(&quot; %c&quot;,&amp;b);//在%c前加一个空格忽略缓冲区的空白字符</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);<span class="comment">//上一行代码运行时记得注销</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符是%c\n&quot;</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入小数\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;小数是%f\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.数据类型</title>
      <link href="/data.github.io/post/6f76074c.html"/>
      <url>/data.github.io/post/6f76074c.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>（<a href="https://www.runoob.com/cprogramming/c-tutorial.html">菜鸟教程</a>）</p><h3 id="基本组成要素"><a href="#基本组成要素" class="headerlink" title="基本组成要素"></a>基本组成要素</h3><table><thead><tr><th>自然语言</th><th>程序设计语言</th></tr></thead><tbody><tr><td>字</td><td>字母，数字、标识符</td></tr><tr><td>词或词组</td><td>关键字、标识符、常量</td></tr><tr><td>句子或段落</td><td>语句</td></tr><tr><td>篇章</td><td>程序</td></tr></tbody></table><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul><li>也称保留字，是C语言预先定义的、具有特殊意义的单词;例如if、long、for等</li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>大小写字母，数字和下划线构成的一个字符序列</li><li>系统预定义标识符</li><li>用户自定义标识符：用来标识变量名、符号常量名、数组名、函数名等</li></ul><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul><li>首字符必须是字母或下划线</li><li>见名知意，不要使用汉语拼音</li><li>不能与关键字及系统预定义的标识符相同</li></ul><h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><ul><li>类型关键字      变量名；<code>int  a;</code></li><li>类型关键字      变量名1，变量名2….;<code>int  a,b.....;</code></li></ul><h4 id="变量属性"><a href="#变量属性" class="headerlink" title="变量属性"></a>变量属性</h4><ul><li>变量名</li><li>变量的值</li><li>变量的地址</li><li>变量的类型</li></ul><h2 id="变量决定什么"><a href="#变量决定什么" class="headerlink" title="变量决定什么"></a>变量决定什么</h2><h3 id="变量决定"><a href="#变量决定" class="headerlink" title="变量决定"></a>变量决定</h3><ul><li>占用内存空间的大小</li><li>数据的存储形式</li><li>合法的表数范围</li><li>可参与的运算种类</li></ul><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>计算变量或类型占内存的大小<br>语法形式</p><ul><li>sizeof(类型)</li><li>sizeof(变量或表达式)</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define 标识符  字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R   4</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;area=%f\n&quot;</span>,PI*R*R );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORB_ID(_name) &amp;__orb_##_name</span></span><br><span class="line"><span class="comment">//这行代码定义了一个名为 `ORB_ID` 的宏，它接受一个参数 `_name`</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&amp;__orb_##_name</code> 是一个合并运算符（也称为连接运算符或者粘贴运算符），使用 <code>##</code> 符号。这个运算符会把 <code>_name</code> 直接附加到 <code>__orb_</code> 后面，形成一个新的标识符。然后前面的 <code>&amp;</code> 符号取的是这个标识符的地址。例如，如果 <code>_name</code> 是 <code>foo</code>，那么这段代码将被替换为 <code>&amp;__orb_foo</code></p></blockquote><ul><li>字符串后不要有分号</li></ul><h3 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h3><ul><li>const double  标识符   &#x3D;    数值；</li><li>const常量具有数据类型—-double类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> R = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;area=%f\n&quot;</span>,PI*R*R );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td>char</td><td>1 字节</td><td>-128 到 127 或 0 到 255</td></tr><tr><td>short</td><td>2 字节</td><td>-32,768 到 32,767</td></tr><tr><td>int</td><td>4 字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td>long</td><td>4 字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td>long long</td><td>8字节</td><td>-9223372036854775807到9223372036854775807</td></tr><tr><td>unsigned long long</td><td>8字节</td><td>0到1844674407370955161</td></tr><tr><td>unsigned char</td><td>1 字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 字节</td><td>-128 到 127</td></tr><tr><td>unsigned short</td><td>2 字节</td><td>0 到 65,535</td></tr><tr><td>unsigned long</td><td>4 字节</td><td>0 到 4,294,967,295</td></tr></tbody></table><ul><li><p>size_t:它是一种“整型”类型，里面保存的是一个整数, 无符号整型，就像 int, long 那样。这种整数用来记录一个大小(size)。size_t 的全称应该是 size type，就是说“一种用来记录大小的数据类型”。</p></li><li><p>unsigned无符号</p></li><li><p>字节（Byte ）：是计算机用于计量存储容量的一种计量单位，一个字节通常8位长；一字节&#x3D;8位</p></li><li><p>32位机和64位机，int类型都是占用4个字节。</p></li><li><p>16位机int类型占2个字节</p></li></ul><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4 字节</td><td align="left">$1.2E^{-38} 到 3.4E^{+38}$</td><td align="left">6 位有效位（6-7）</td></tr><tr><td align="left">double</td><td align="left">8 字节</td><td align="left">$2.3E^{-308} 到 1.7E^{+308}$</td><td align="left">15 位有效位</td></tr><tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">$3.4E^{-4932} 到 1.1E^{+4932}$</td><td align="left">19 位有效位</td></tr></tbody></table><h1 id="数据范围时间复杂度和空间复杂度"><a href="#数据范围时间复杂度和空间复杂度" class="headerlink" title="数据范围时间复杂度和空间复杂度"></a>数据范围时间复杂度和空间复杂度</h1><table><thead><tr><th>数据类型</th><th>数据范围</th><th>数量级</th></tr></thead><tbody><tr><td>unsigned int</td><td>0～42 9496 7295</td><td>42亿 10位</td></tr><tr><td><code>int</code></td><td>-21 4748 3648～21 4748 3647</td><td>$2*10^9$</td></tr><tr><td>unsigned long</td><td>0～42 9496 7295</td><td>42亿 10位</td></tr><tr><td>long (32位系统)</td><td>-21 4748 3648～21 4748 3647</td><td>21亿</td></tr><tr><td>long long的最小值</td><td>-922 3372 0368 5477 5808</td><td>19位</td></tr><tr><td><code>long long</code>的最大值</td><td>922 3372 0368 5477 5807</td><td>$9∗10^{18}$</td></tr><tr><td>unsigned long long</td><td>0～1844 6744 0737 0955 1615</td><td>20位</td></tr><tr><td>float（浮点型）</td><td>$3.402823E^{-38}~3.402823E^{+38}$</td><td>38位</td></tr><tr><td>double（浮点型）</td><td>$1.79769313486232E^{-308} ~1.79769313486232E^{+308}$</td><td>308位</td></tr></tbody></table><p>计算机存储浮点数的方式：<a href="https://img-blog.csdnimg.cn/982711c7878c4aeba70777adec5b1cec.png">1</a>, <a href="https://img-blog.csdnimg.cn/0df71418c8fe4da497f7bddad84ea5d9.png">2</a></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071254887.jpg"></p><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071255814.jpg"></p><p>long long内的最大阶乘20 !<br>int内的最大阶乘12 !</p><p><strong>long和int的大小跟系统位数有关</strong></p><ul><li>16位系统：long是4字节，int是2字节</li><li>32位系统：long是4字节，int是4字节</li><li>64位系统：long是8字节，int是4字节</li></ul><p><strong>时间复杂度 &gt; 空间复杂度</strong></p><ul><li><p>申请25万大小的vector型数组大约需要1MB内存</p></li><li><p>具有4GB内存的电脑可以开10^9^的int型数组</p></li><li><p>C++ 1秒内一般能算$10^7$到$10^8$（比较紧）<br><a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020">时间复杂度</a>一般是10^7比较稳，有的时候能到10^8^次，但时间就会比较紧，题目如果放宽到2ms，可能可以将好能AC</p></li><li><p>一般情况下时间复杂度比<a href="https://so.csdn.net/so/search?q=%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&spm=1001.2101.3001.7020">空间复杂度</a>更加重要</p></li></ul><h2 id="memset常用赋值"><a href="#memset常用赋值" class="headerlink" title="memset常用赋值"></a>memset常用赋值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">头文件 &lt;cstring&gt;</span><br><span class="line">memset(f, 0, sizeof(f));</span><br></pre></td></tr></table></figure><h1 id="其他小常识"><a href="#其他小常识" class="headerlink" title="其他小常识"></a><a href="https://www.acwing.com/blog/content/32/">其他小常识</a></h1><p><img src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202205071302821.png" alt="image-20220507130220424"></p><h1 id="∇-nabla∇-互联网笔试题通常的限制"><a href="#∇-nabla∇-互联网笔试题通常的限制" class="headerlink" title="∇ \nabla∇ 互联网笔试题通常的限制"></a>∇ \nabla∇ 互联网笔试题通常的限制</h1><p><img src="https://img-blog.csdnimg.cn/20191011190557639.png" alt="img"></p><ul><li><strong>时间限制1秒</strong>：说明时间复杂度一个在$10^7 ~10^7$左右</li><li><strong>空间限制32768K &#x3D; 32 MB</strong>：说明可以申请800万左右的vector型数组<br>注意：上面说的是vector型数组，如果是普通数组<code>int array[N]</code>，基本上可以开到很大很大，因为vector是动态开数组，<code>STL容器一般都是比较花时间的，所以能用数组模拟尽量用数组</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序语言/c语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
