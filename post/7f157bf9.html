<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2.c++基础语法2 | 醉卿枫の博客</title><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数组 数组是一组数据类型相同的变量，可以存放一组数据。创建数组 声明数组的语法：数据类型 数组名[数组长度]; 注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。 C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量  数组的使用  可以通过下标访问数组中元素，数组下标从0开始。 数">
<meta property="og:type" content="article">
<meta property="og:title" content="2.c++基础语法2">
<meta property="og:url" content="https://github.com/wjl-a/data.github.io/post/7f157bf9.html">
<meta property="og:site_name" content="醉卿枫の博客">
<meta property="og:description" content="数组 数组是一组数据类型相同的变量，可以存放一组数据。创建数组 声明数组的语法：数据类型 数组名[数组长度]; 注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。 C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量  数组的使用  可以通过下标访问数组中元素，数组下标从0开始。 数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2022/06/05/629c5257753d1.png">
<meta property="article:published_time" content="2023-06-11T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-04T05:34:13.339Z">
<meta property="article:author" content="醉卿枫">
<meta property="article:tag" content="程序语言&#x2F;cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2022/06/05/629c5257753d1.png"><link rel="shortcut icon" href="/data.github.io/img/favicon.png"><link rel="canonical" href="https://github.com/wjl-a/data.github.io/post/7f157bf9.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/data.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/data.github.io/',
  algolia: undefined,
  localSearch: {"path":"/data.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2.c++基础语法2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-04 13:34:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bu.dusays.com/2022/06/05/629c5257753d1.png')"><nav id="nav"><span id="blog-info"><a href="/data.github.io/" title="醉卿枫の博客"><span class="site-name">醉卿枫の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2.c++基础语法2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-11T16:00:00.000Z" title="发表于 2023-06-12 00:00:00">2023-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-04T05:34:13.339Z" title="更新于 2024-03-04 13:34:13">2024-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/data.github.io/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2.c++基础语法2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>数组是一组数据类型相同的变量，可以存放一组数据。<br><strong>创建数组</strong></li>
<li>声明数组的语法：<code>数据类型 数组名[数组长度];</code></li>
<li>注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。</li>
<li>C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量</li>
</ul>
<p><strong>数组的使用</strong></p>
<ul>
<li>可以通过下标访问数组中元素，数组下标从0开始。</li>
<li>数组中每个元素的特征和使用方法与单个变量完全相同。</li>
<li>语法：<code>数组名[数组下标]</code></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>数组下标也必须是整数，可以是常量，也可以是变量。</li>
<li>合法的数组下标取值是：0~(数组长度-1)。</li>
</ul>
<p><strong>数组占用内存的情况</strong></p>
<ul>
<li>数组在内存中占用的空间是连续的。</li>
<li>用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。</li>
</ul>
<p><strong>数组的初始化</strong><br>声明的时候初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[数组长度] = &#123; 值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>, ...... , 值n&#125;;</span><br><span class="line">数据类型 数组名[ ] = &#123; 值<span class="number">1</span>，值<span class="number">2</span>，值<span class="number">3</span>, ...... , 值n&#125;;</span><br><span class="line">数据类型 数组名[数组长度] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 把全部的元素初始化为0。</span></span><br><span class="line">数据类型 数组名[数组长度] = &#123; &#125;;    <span class="comment">// 把全部的元素初始化为0。</span></span><br></pre></td></tr></table></figure>

<p>注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填</p>
<p><strong>清空数组</strong></p>
<ul>
<li>用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）</li>
<li>函数原型：<code>void *memset(void *s, int c, size_t n);</code></li>
<li>注意，在Linux下，使用memcpy()函数需要包含头文件<code>#include &lt;string.h&gt;</code></li>
</ul>
<p><strong>复制数组</strong><br>用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）<br>函数原型：<code>void *memcpy(void *dest, const void *src, size_t n);</code></p>
<h2 id="一维数组与指针"><a href="#一维数组与指针" class="headerlink" title="一维数组与指针"></a>一维数组与指针</h2><p><strong>指针的算术</strong></p>
<ul>
<li>将一个整型变量加1后，其值将增加1。</li>
<li>但是，将指针变量（地址的值）加1后，<strong>增加的量等于它指向的数据类型的字节数</strong>。</li>
</ul>
<p><strong>数组的地址</strong></p>
<ul>
<li>a）数组在内存中占用的空间是连续的。</li>
<li>b）C++<strong>将数组名解释为数组第0个元素的地址</strong>。</li>
<li>c）<strong>数组第0个元素的地址和数组首地址的取值是相同的</strong>。</li>
<li>d）数组第n个元素的地址是：数组首地址+n</li>
<li>e）C++编译器把   <code>数组名[下标]</code>  解释为  <code>*(数组首地址+下标)</code></li>
</ul>
<p><strong>数组的本质</strong></p>
<ul>
<li>数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的。</li>
</ul>
<p><strong>数组名不一定会被解释为地址</strong></p>
<ul>
<li>在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数。</li>
<li>可以修改指针的值，但数组名是常量，不可修改。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> b;      cout &lt;&lt; <span class="string">&quot;sizeof(char)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;            <span class="comment">// 1字节</span></span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span> *)&amp; b &lt;&lt; endl;<span class="comment">//c++形式取地址，(void*)是一种类型转换操作符，将&amp;d的返回类型转换为void类型的指针</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b的地址+1是：&quot;</span> &lt;&lt; (<span class="type">void</span>*)( &amp; b + <span class="number">1</span>) &lt;&lt; endl&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b的地址：%p\n\n\n&quot;</span>,&amp;b);<span class="comment">//c语言形式取地址</span></span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> a[<span class="number">5</span>]=&#123; <span class="number">1.3</span> , <span class="number">6</span> , <span class="number">5</span> , <span class="number">8</span> , <span class="number">9</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a的值是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;a的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)&amp;a &lt;&lt; endl;<span class="comment">//longlong是把地址转为整型方便对比看</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a[0]的地址是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>) &amp;a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a[1]的地址是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>) &amp;a[<span class="number">1</span>] &lt;&lt; endl&lt;&lt;endl;</span><br><span class="line">	<span class="type">double</span>* p = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p+0的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)(p+  <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p+1的值是：&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>)(p + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*(p+0)的值是：&quot;</span> &lt;&lt; *(p+  <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*(p+1)的值是：&quot;</span> &lt;&lt; *(p + <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一维数组用于函数的参数"><a href="#一维数组用于函数的参数" class="headerlink" title="一维数组用于函数的参数"></a>一维数组用于函数的参数</h2><p><strong>指针的数组表示</strong></p>
<ul>
<li>在C++内部，用指针来处理数组。</li>
<li>C++编译器把   <code>数组名[下标]  解释为  *(数组首地址+下标)</code></li>
<li>C++编译器把   <code>地址[下标]  解释为  *(地址+下标)</code></li>
</ul>
<p><strong>一维数组用于函数的参数</strong></p>
<ul>
<li>一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。<br>书写方法有两种： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：</p>
<ul>
<li>在函数中，可以用数组表示法，也可以用指针表示法。</li>
<li>在函数中，不要对指针名用sizeof运算符，它不是数组名。<br>![[Pasted image 20231223144029.png]]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(int *arr,int len)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; len; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]的值是：&quot;</span> &lt;&lt; arr[ii] &lt;&lt; endl;              <span class="comment">// 用数组表示法操作指针。</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*(arr+&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;)的值是：&quot;</span> &lt;&lt; *(arr + ii) &lt;&lt; endl;   <span class="comment">// 地址[下标]  解释为  *(地址+下标)。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> b[<span class="number">20</span>];             <span class="comment">// 这是一个长度为20的字符型数组。</span></span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span> *)b;        <span class="comment">// 让整型指针p指向数组a的内存。强制转换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">6</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[ii] = ii + <span class="number">300</span>;     <span class="comment">// 用数组表示法操作指针。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">6</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;*(p+&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;)的值是：&quot;</span> &lt;&lt; *(p + ii) &lt;&lt; endl;    <span class="comment">// 地址[下标]  解释为  *(地址+下标)。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;	</span><br><span class="line">	<span class="built_in">func</span>(a, <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="new动态创建数组"><a href="#new动态创建数组" class="headerlink" title="new动态创建数组"></a>new动态创建数组</h2><ul>
<li>普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存</li>
<li>动态创建一维数组的语法：<code>数据类型 *指针=new 数据类型[数组长度];</code></li>
<li>释放一维数组的语法：<code>delete [] 指针;</code></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>动态创建的数组没有数组名，不能用sizeof运算符。</li>
<li>可以用数组表示法和指针表示法两种方式使用动态创建的数组。</li>
<li>必须使用delete[]来释放动态数组的内存（不能只用delete）：这是因为动态数组是通过<code>new[]</code>来分配内存的，而不是通过普通的new操作符。使用delete[]来释放不是通过<code>new[]</code>分配的内存是不安全的，可能导致未定义行为。</li>
<li>不要用<code>delete[]</code>来释放不是new[]分配的内存。</li>
<li>不要用<code>delete[]</code>释放同一个内存块两次（否则等同于操作野指针）。</li>
<li>对空指针用<code>delete[]</code>是安全的（释放内存后，<strong>应该把指针置空nullptr</strong>）。</li>
<li>声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。</li>
<li>如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。</li>
<li>为什么用<code>delete[]</code>释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 注意区别</span></span><br><span class="line">	<span class="comment">// int *ptr = new int; // 分配一个int大小的内存空间，并将地址赋给指针ptr</span></span><br><span class="line">	<span class="comment">// int *arr = new int[10]; // 分配一个包含10个int类型元素的数组，并将地址赋给指针arr</span></span><br><span class="line">	<span class="comment">// delete ptr; // 释放通过new分配的单个变量的内存</span></span><br><span class="line">	<span class="comment">// delete[] arr; // 释放通过new[]分配的数组的内存</span></span><br><span class="line">	<span class="type">int</span> *arr=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">8</span>];          <span class="comment">// 创建8个元素的整型数组。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[ii] = <span class="number">100</span> + ii;                                                                  <span class="comment">// 数组表示法。</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; *(arr + ii) &lt;&lt; endl;        <span class="comment">// 指针表示法。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一维数组的排序qsort"><a href="#一维数组的排序qsort" class="headerlink" title="一维数组的排序qsort"></a>一维数组的排序qsort</h2><ul>
<li>qsort()函数用于对各种数据类型的数组进行排序。</li>
<li>函数的原型：<code>void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</code></li>
<li>第一个参数：数组的起始地址。</li>
<li>第二个参数：数组元素的个数（数组长度）。</li>
<li>第三个参数：数组元素的大小（sizeof(数组的数据类型)）。</li>
<li>第四个参数：回调函数的地址,<strong>它是函数指针</strong></li>
</ul>
<p>回调函数决定了排序的顺序，声明如下：</p>
<ul>
<li><code>int compar(const void *p1, const void *p2);</code></li>
</ul>
<ol>
<li>如果函数的返回值&lt; 0 ，那么p1所指向元素会被排在p2所指向元素的前面。</li>
<li>如果函数的返回值等于0，那么p1所指向元素与p2所指向元素的顺序不确定。</li>
<li>如果函数的返回值&gt; 0 ，那么p1所指向元素会被排在p2所指向元素的后面。</li>
</ol>
<p>qsort()函数的其它细节：</p>
<ul>
<li>形参中的地址用void是为了支持任意数据类型，在回调函数中必须具体化。</li>
</ul>
<p>为什么需要第三个形参size_t size？</p>
<ul>
<li>size_t是C标准库中定义的，在64位系统中是8字节无符号整型（unsigned long long）。</li>
<li>typedef unsigned long long size_t</li>
<li>排序的需求除了升序和降序，还有很多不可预知的情况，只能用回调函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compasc</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span>         <span class="comment">// 升序的回调函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *((<span class="type">int</span>*)p1) - *((<span class="type">int</span>*)p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compdesc</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2)</span>       <span class="comment">// 降序的回调函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//void指针p1和p2分别转换为int指针，然后取出其指向的值，即将指针所指向的整数值进行比较。</span></span><br><span class="line">	<span class="comment">//这里使用了类型转换操作符*来获取指针所指向的整数值。然后将这两个整数值进行相减，得到的结果即为降序排列所需的比较值。</span></span><br><span class="line">	<span class="comment">// cout&lt;&lt;p2&lt;&lt;endl&lt;&lt;(int*)p2&lt;&lt;endl&lt;&lt;*((int*)p2)&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">return</span> *((<span class="type">int</span>*)p2) - *((<span class="type">int</span>*)p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="built_in">qsort</span>(a,<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="built_in">sizeof</span>(<span class="type">int</span>),compasc);                   <span class="comment">// 对数组a进行升序排序。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; a[ii] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">qsort</span>(a, <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="built_in">sizeof</span>(<span class="type">int</span>), compdesc);            <span class="comment">// 对数组a进行降序排序。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">8</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; a[ii] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>C语言约定：如果字符型（char）数组的<strong>末尾包含了空字符\0</strong>（也就是0），那么该数组中的内容就是一个<strong>字符串</strong>。<br>![[Pasted image 20231223194336.png]]</p>
<ul>
<li>因为字符串需要用0结尾，所以在声明字符数组的时候，要预留多一个字节用来存放0。</li>
<li><code>char name[21];</code>  &#x2F;&#x2F; 声明一个最多存放20个英文字符或十个中文的字符串。<br><strong>初始化方法</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">11</span>];                 <span class="comment">// 可以存放10个字符，没有初始化，里面是垃圾值。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">11</span>] = <span class="string">&quot;hello&quot;</span>;         <span class="comment">// 初始内容为hello，系统会自动添加0。</span></span><br><span class="line"><span class="type">char</span> name[]   = &#123; <span class="string">&quot;hello&quot;</span> &#125;;      <span class="comment">// 初始内容为hello，系统会自动添加0，数组长度是6。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">11</span>]   &#123; <span class="string">&quot;hello&quot;</span> &#125;;      <span class="comment">// 初始内容为hello，系统会自动添加0。C++11标准。</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;          <span class="comment">// 把全部的元素初始化为0。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>清空字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="built_in">sizeof</span>(name));   <span class="comment">// 把全部的元素置为0。</span></span><br><span class="line">name[<span class="number">0</span>]=<span class="number">0</span>;       <span class="comment">// 不规范，有隐患，不推荐。</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串复制或赋值strcpy()</strong></p>
<ul>
<li><code>char *strcpy(char* dest, const char* src);</code></li>
<li>功能: 将参数src字符串拷贝至参数dest所指的地址。</li>
<li>返回值: 返回参数dest的字符串起始地址。</li>
<li>复制完字符串后，会在dest后追加0。</li>
<li>如果参数dest所指的内存空间不够大，会导致数组的越界。</li>
</ul>
<p><strong>字符串复制或赋值strncpy()</strong></p>
<ul>
<li><code>char * strncpy(char* dest,const char* src, const size_t n);</code></li>
<li>功能：<strong>把src前n个字符的内容复制到dest中</strong>。</li>
<li>返回值：dest字符串起始地址。</li>
<li>如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。</li>
<li>如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。</li>
<li>如果参数dest所指的内存空间不够大，会导致数组的越界。</li>
</ul>
<p><strong>获取字符串的长度strlen()</strong></p>
<ul>
<li><code>size_t  strlen( const char*  str);</code></li>
<li>功能：计算字符串的有效长度，<strong>不包含0</strong>。</li>
<li>返回值：返回字符串的字符数。</li>
<li>strlen()函数计算的是字符串的实际长度，遇到0结束</li>
</ul>
<p><strong>字符串拼接strcat(）</strong></p>
<ul>
<li><code>char *strcat(char* dest,const char* src);</code></li>
<li>功能：将src字符串拼接到dest所指的字符串尾部</li>
<li>返回值：返回dest字符串起始地址</li>
<li>dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0</li>
<li>如果参数dest所指的内存空间不够大，会导致数组的越界</li>
</ul>
<p><strong>字符串拼接strncat()</strong></p>
<ul>
<li><code>char *strncat (char* dest,const char* src, const size_t n);</code></li>
<li>功能：将src字符串的前n个字符拼接到dest所指的字符串尾部</li>
<li>返回值：返回dest字符串的起始地址</li>
<li>如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n小于字符串src的长度，只追加src的前n个字符。</li>
<li>strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。</li>
<li>如果参数dest所指的内存空间不够大，会导致数组的越界</li>
</ul>
<p><strong>字符串比较strcmp()和strncmp()</strong></p>
<ul>
<li><code>int strcmp(const char *str1, const char *str2 );</code><ul>
<li>功能：比较str1和str2的大小。</li>
<li>返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</li>
</ul>
</li>
<li><code>int strncmp(const char *str1,const char *str2 ,const size_t n);</code><ul>
<li>功能：比较str1和str2前n个字符的大小。</li>
<li>返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；</li>
<li>两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。</li>
</ul>
</li>
<li>在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。</li>
</ul>
<p><strong>查找字符strchr()和strrchr()</strong></p>
<ul>
<li><code>const char *strchr(const char *s, int c);</code><ul>
<li>返回在字符串s中第一次出现c的位置，如果找不到，返回0。</li>
</ul>
</li>
<li><code>const char *strrchr(const char *s, int c);</code><ul>
<li>返回在字符串s中最后一次出现c的位置，如果找不到，返回0。</li>
</ul>
</li>
</ul>
<p><strong>查找字符串strstr()</strong></p>
<ul>
<li><code>char *strstr(const char* str,const char* substr);</code></li>
<li>功能：检索子串在字符串中首次出现的位置。</li>
<li>返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。</li>
</ul>
<p><strong>用于string的表达式</strong></p>
<ul>
<li>可以把C风格的字符串用于包含了string类型的赋值拼接等表达式中。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>字符串的结尾标志是0，按照约定，在处理字符串的时候，会从起始位置开始搜索0，一直找下去，找到为止（不会判断数组是否越界）。</li>
<li>结尾标志0后面的都是垃圾内容。</li>
<li><strong>字符串在每次使用前都要初始化</strong>，减少入坑的可能，是每次，不是第一次。</li>
<li>不要在子函数中对字符指针用sizeof运算，所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul>
<li>一维数组的数学概念是线性表，二维数组的数学概念是矩阵。<br><strong>创建二维数组</strong></li>
<li>声明二维数组的语法：<code>数据类型 数组名[行数][列数];</code></li>
<li>注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。</li>
</ul>
<p><strong>二维数组的使用</strong></p>
<ul>
<li>可以通过行下标和列下标访问二维数组中元素，下标从0开始。</li>
<li>二维数组中每个元素的特征和使用方法与单个变量完全相同。</li>
<li>语法：<code>数组名[行下标][列下标]</code></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>二维数组下标也必须是整数，可以是常量，也可以是变量。</li>
<li>合法的行下标取值是：0~(行数-1)。</li>
<li>合法的列下标取值是：0~(列数-1)。</li>
</ul>
<p><strong>二维数组占用内存的情况</strong></p>
<ul>
<li>用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）</li>
<li>二维数组在内存中占用的空间是连续的</li>
</ul>
<p><strong>二维数组的初始化</strong><br>声明的时候初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名[行数][列数] = &#123; &#123;数据<span class="number">1</span>，数据<span class="number">2</span> &#125; ，&#123;数据<span class="number">3</span>，数据<span class="number">4</span> &#125;,...... &#125;;</span><br><span class="line">数据类型 数组名[行数][列数] = &#123; 数据<span class="number">1</span>，数据<span class="number">2</span>，数据<span class="number">3</span>，数据<span class="number">4</span>, ......&#125;;</span><br><span class="line">数据类型 数组名[ ][列数] = &#123; 数据<span class="number">1</span>，数据<span class="number">2</span>，数据<span class="number">3</span>，数据<span class="number">4</span>,......&#125;;</span><br><span class="line">数据类型 数组名[行数][列数] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 把全部的元素初始化为0。</span></span><br><span class="line">数据类型 数组名[行数][列数] = &#123; &#125;;    <span class="comment">// 把全部的元素初始化为0。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中<strong>全部的元素初始化为0，可以在{}内只填一个0或什么也不填。</strong></li>
</ul>
<p><strong>清空二维数组</strong></p>
<ul>
<li>用memset()函数可以把二维数组中全部的元素清零。（只适用于C++基本数据类型）</li>
<li>函数原型：<code>void *memset(void *s, int c, size_t n);</code></li>
<li>注意，在Linux下，使用memcpy()函数需要包含头文件<code>#include &lt;string.h&gt;</code></li>
</ul>
<p><strong>复制二维数组</strong></p>
<ul>
<li>用memcpy()函数可以把二维数组中全部的元素复制到另一个相同大小的数组）。（只适用于C++基本数据类型）</li>
<li>函数原型：<code>void *memcpy(void *dest, const void *src, size_t n);</code></li>
<li>注意，在Linux下，使用memcpy()函数需要包含头文件#include &lt;string.h&gt;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// int bh[2][3] = &#123; &#123;11,12,13&#125;,&#123;21,22,23&#125; &#125;;                              // 声明一个两行三列的二维数组，存放超女的编号。</span></span><br><span class="line">	<span class="comment">// int bh[2][3] = &#123; 11,12,13,21,22,23 &#125;;</span></span><br><span class="line">	<span class="type">int</span> bh[][<span class="number">3</span>] = &#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*bh[0][0] = 11;		bh[0][1] = 12;    bh[0][2] = 13;</span></span><br><span class="line"><span class="comment">	bh[1][0] = 21; 	bh[1][1] = 22;    bh[1][2] = 23;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*cout &lt;&lt; &quot;bh[0][0] = &quot; &lt;&lt; bh[0][0] &lt;&lt; &quot;  bh[0][1] = &quot; &lt;&lt; bh[0][1] &lt;&lt; &quot;  bh[0][2] = &quot; &lt;&lt; bh[0][2] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;bh[1][0] = &quot; &lt;&lt; bh[1][0] &lt;&lt; &quot;  bh[1][1] = &quot; &lt;&lt; bh[1][1] &lt;&lt; &quot;  bh[1][2] = &quot; &lt;&lt; bh[1][2] &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++)                 <span class="comment">// 第一层循环表示行数，循环继续的条件是计数器小于行数。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; <span class="number">3</span>; jj++)              <span class="comment">// 第二层循环表示列数，循环继续的条件是计数器小于列数。</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;&amp;bh[&quot;</span>&lt;&lt;ii&lt;&lt;<span class="string">&quot;][&quot;</span>&lt;&lt;jj&lt;&lt;<span class="string">&quot;] = &quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span>) &amp; bh[ii][jj] &lt;&lt; <span class="string">&quot;  &quot;</span>;          <span class="comment">// 处理二维数组的每个元素。</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;          <span class="comment">// 每处理一行数据后，输出一个换行。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span> *)bh;<span class="comment">//将一个二维数组bh强制类型转换为int指针p。这么写的主要目的可能是想要将二维数组以一维数组的形式进行处理或操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">6</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;p[&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; p[ii] &lt;&lt; endl;     <span class="comment">// 一维数组的数组表示法。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二维数组用于函数的参数"><a href="#二维数组用于函数的参数" class="headerlink" title="二维数组用于函数的参数"></a>二维数组用于函数的参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;      <span class="comment">// 整型指针。</span></span><br><span class="line"><span class="type">int</span>* p[<span class="number">3</span>];   <span class="comment">// 一维整型指针数组，元素是3个整型指针（p[0]、p[1]、p[2]）。</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">p</span><span class="params">()</span></span>;    <span class="comment">// 函数p的返回值类型是整型的地址。</span></span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span> ,<span class="type">int</span>);   <span class="comment">// p是函数指针，函数的返回值是整型。</span></span><br></pre></td></tr></table></figure>
<p><strong>行指针（数组指针）</strong></p>
<ul>
<li>声明行指针的语法：<code>数据类型 (*行指针名)[行的大小];</code>  &#x2F;&#x2F; 行的大小即数组长度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p1)[<span class="number">3</span>];  <span class="comment">// p1是行指针，用于指向数组长度为3的int型数组。</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">5</span>];  <span class="comment">// p2行指针，用于指向数组长度为5的int型数组。</span></span><br><span class="line"><span class="built_in">double</span> (*p3)[<span class="number">5</span>];  <span class="comment">// p3是行指针，用于指向数组长度为5的double型数组。</span></span><br></pre></td></tr></table></figure></li>
<li>一维数组名被解释为数组第0个元素的地址。</li>
<li>对一维数组名取地址得到的是数组的地址，是行地址。</li>
</ul>
<p><strong>二维数组名是行地址</strong><br><code>int bh[2][3] = &#123; &#123;11,12,13&#125;,&#123;21,22,23&#125; &#125;;</code></p>
<ul>
<li>bh是二维数组名，该数组有2元素，每一个元素本身又是一个数组长度为3的整型数组。</li>
<li>bh被解释为数组长度为3的整型数组类型的行地址。</li>
<li>如果存放bh的值，要用数组长度为3的整型数组类型的行指针：<code>int (*p)[3]=bh;</code></li>
</ul>
<p><code>int bh[4][2][3];</code></p>
<ul>
<li>bh是三维数组名，该数组有4元素，每一个元素本身又是一个2行3列的二维数组。</li>
<li>bh被解释为2行3列的二维数组类型的二维地址</li>
<li>如果存放bh的值，要用2行3列的二维数组类型的二维指针：<code>int (*p)[2][3]=bh;</code></li>
</ul>
<p><strong>把二维数组传递给函数</strong><br>如果要把bh传给函数，函数的声明如下：</p>
<ul>
<li><code>void func(int (*p)[3],int len);</code></li>
<li><code>void func(int p[][3],int len);</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="comment">// void func(int p[][2][3])等价于void func(int (*p)[2][3])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">2</span>][<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ii = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 遍历三维数组p，给它的每个元素赋值。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">4</span>; a++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">2</span>; b++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)</span><br><span class="line">				p[a][b][c] = ii++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> bh[<span class="number">4</span>][<span class="number">2</span>][<span class="number">3</span>];        <span class="comment">// 假设有4个超女方阵，每个方阵有2行，每行有3个超女。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(bh, <span class="number">0</span>, <span class="built_in">sizeof</span>(bh));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(bh);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; <span class="number">4</span>; a++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">2</span>; b++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)</span><br><span class="line">				cout &lt;&lt; bh[a][b][c] &lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; endl;    <span class="comment">// 每显示一行后，输出一个换行符。</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl&lt;&lt;endl;    <span class="comment">// 每显示一个方阵后，输出两个换行符。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="结构体，共同体和枚举"><a href="#结构体，共同体和枚举" class="headerlink" title="结构体，共同体和枚举"></a>结构体，共同体和枚举</h1><ul>
<li>结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。<br>使用结构体有两个步骤：1）定义结构体描述（类型）；2）创建结构体变量。<br><strong>定义结构体描述</strong><br>定义结构体描述的语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名</span><br><span class="line">&#123;</span><br><span class="line">成员一的数据类型  成员名一;</span><br><span class="line">成员二的数据类型  成员名二;</span><br><span class="line">成员三的数据类型  成员名三;</span><br><span class="line">......</span><br><span class="line">成员n的数据类型  成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：</p>
<ul>
<li>结构体名是标识符。</li>
<li>结构体的成员可以是任意数据类型。</li>
<li>定义结构体描述的代码可以放在程序的任何地方，一般放在main函数的上面或头文件中。</li>
<li>结构体成员可以用C++的类（如string），但是不提倡：默认的访问控制权限是public，结构体更适合用于只包含数据成员而不包含函数成员的情况</li>
<li>在C++中，结构体中可以有函数，但是不提倡。</li>
<li>在C++11中，定义结构体的时候可以指定缺省值。</li>
</ul>
<p><strong>创建结构体变量</strong><br>创建结构体变量的语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名 结构体变量名;</span><br><span class="line"><span class="keyword">struct</span> 结构体名 结构体变量名=&#123;成员一的值, 成员二的值,......, 成员n的值&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为0：<code>struct 结构体名 结构体变量名=&#123;0&#125;;</code></li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>在C++中，struct关键字可以不写</li>
<li>可以在定义结构体的时候创建结构体变量</li>
</ul>
<p><strong>使用结构体</strong></p>
<ul>
<li>用成员运算符（.）来访问结构体的每个成员。结构体中的每个成员具备普通变量的全部特征。<br>语法：<code>结构体变量名.结构体成员名;</code></li>
</ul>
<p><strong>占用内存的大小</strong></p>
<ul>
<li>用sizeof运算符可以得到整个结构体占用内存的大小。</li>
<li>注意：整个结构体占用内存的大小不一定等于全部成员占用内存之和：<strong>因为在内存布局中可能存在内存对齐的问题</strong></li>
<li>内存对齐：<code>#pragma pack(字节数)</code>，sizeof计算的与这个有关系</li>
<li>合理使用内存对齐规则，某些节省内存的做法可能毫无意义。</li>
</ul>
<p><strong>清空结构体</strong></p>
<ul>
<li>创建的结构体变量如果没有初始化，成员中有垃圾值。</li>
<li>用memset()函数可以把结构体中全部的成员清零。（只适用于C++基本数据类型）</li>
</ul>
<p><strong>复制结构体</strong></p>
<ul>
<li>用memcpy()函数把结构体中全部的元素复制到另一个相同类型的结构体（只适用于C++基本数据类型）。</li>
<li>也可以直接用等于号（只适用于C++基本数据类型）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)<span class="comment">//指定了结构体成员的对齐方式为8字节。这意味着结构体的成员在内存中的存储位置将会按照8字节对齐，即结构体成员的起始地址相对于结构体起始地址的偏移量必须是8的倍数</span></span></span><br><span class="line"><span class="comment">// 成员name是一个字符数组，占用21个字节，对齐后起始地址为0，偏移量为0。</span></span><br><span class="line"><span class="comment">// 成员age是一个int类型，占用4个字节，需要对齐到8的倍数，因此在name后补齐3个字节，偏移量为24。</span></span><br><span class="line"><span class="comment">// 成员weight是一个double类型，占用8个字节，对齐后起始地址为32，偏移量为32。</span></span><br><span class="line"><span class="comment">// 成员sex是一个char类型，占用1个字节，需要对齐到8的倍数，因此在weight后补齐7个字节，偏移量为40。</span></span><br><span class="line"><span class="comment">// 超女基本信息结构体st_girl，存放了超女全部的数据项。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">21</span>];        <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">int</span> age;                     <span class="comment">// 年龄。</span></span><br><span class="line">    <span class="type">double</span> weight;        <span class="comment">// 体重（kg）。</span></span><br><span class="line">    <span class="type">char</span> sex;                   <span class="comment">// 性别：X-女；Y-男。</span></span><br><span class="line">    <span class="type">bool</span> yz;                    <span class="comment">// 颜值：true-漂亮；false-不漂亮。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st_girl stgirl&#123;<span class="string">&quot;西施&quot;</span>,<span class="number">26</span>,<span class="number">33.8</span>,<span class="string">&#x27;X&#x27;</span>,<span class="literal">true</span>&#125;;        <span class="comment">// 创建结构体变量。</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(st_girl)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(st_girl) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;stgirl, <span class="number">0</span>, <span class="built_in">sizeof</span>(stgirl));<span class="comment">//与#pragma pack(4)有关系</span></span><br><span class="line">	</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stgirl.name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; stgirl.age &lt;&lt; <span class="string">&quot;，体重：&quot;</span> &lt;&lt; stgirl.weight</span><br><span class="line">        &lt;&lt; <span class="string">&quot;，性别：&quot;</span> &lt;&lt; stgirl.sex &lt;&lt; <span class="string">&quot;，颜值：&quot;</span> &lt;&lt; stgirl.yz &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><ul>
<li><p>结构体是一种自定义的数据类型，用结构体可以创建结构体变量。</p>
</li>
<li><p>在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> girl;         <span class="comment">// 声明结构体变量girl。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span> *pst=&amp;girl;  <span class="comment">// 声明结构体指针，指向结构体变量girls。</span></span><br><span class="line"><span class="comment">//通过结构体指针访问结构体成员，有两种方法：</span></span><br><span class="line"> (*指针名).成员变量名    <span class="comment">// (*pst).name和(*pst).age </span></span><br><span class="line">指针名-&gt;成员变量名    <span class="comment">// pst-&gt;name和*pst-&gt;age </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在第一种方法中，圆点.的优先级<code>高于*</code>，<code>(*指针名)</code>两边的括号不能少。如果去掉括号写成<code>(*指针名)</code>.成员变量名，那么相当于<code>*(指针名.成员变量名</code>)，意义就完全不一样了</p>
</li>
<li><p>在第二种方法中，-&gt;是一个新的运算符</p>
</li>
<li><p>上面的两种方法是等效的，程序员通常采用第二种方法，更直观</p>
</li>
<li><p>注意：与数组不一样，结构体变量名没有被解释为地址</p>
</li>
</ul>
<p><strong>用于函数的参数</strong></p>
<ul>
<li>如果要把结构体传递给函数，实参取结构体变量的地址，函数的形参用结构体指针。</li>
<li>如果不希望在函数中修改结构体变量的值，<strong>可以对形参加const约束</strong>。</li>
</ul>
<p><strong>用于动态分配内存</strong></p>
<ul>
<li>用结构体指针指向动态分配的内存的地址</li>
</ul>
<h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><ul>
<li><p>结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。</p>
</li>
<li><p>声明结构体数组的语法：<code>struct 结构体类型 数组名[数组长度];</code></p>
</li>
<li><p>初始化结构体数组，要结合使用初始化数组的规则和初始化结构体的规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">struct</span> <span class="title class_">st_girl</span> girls[<span class="number">2</span>]`=&#123;&#123;<span class="string">&quot;西施&quot;</span>,<span class="number">26</span>,<span class="number">43.8</span>,<span class="string">&#x27;X&#x27;</span>,<span class="literal">true</span>&#125;,&#123;<span class="string">&quot;西瓜&quot;</span>,<span class="number">25</span>,<span class="number">52.8</span>,<span class="string">&#x27;X&#x27;</span>,<span class="literal">false</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用结构体数组可以用数组表示法，也可以用指针表示法。</p>
</li>
</ul>
<h3 id="结构体指针-1"><a href="#结构体指针-1" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>如果结构体中的指针指向的是动态分配的内存地址：</p>
<ul>
<li>对结构体用sizeof运算可能没有意义。</li>
<li>对结构体用memset()函数可能会造成内存泄露。</li>
<li>C++的字符串string中有一个指针，指向了动态分配内存的地址<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *ptr;   <span class="comment">// 指向动态分配内存的地址。</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="共同体"><a href="#共同体" class="headerlink" title="共同体"></a>共同体</h2><p>共同体（共用体、联合体）是一种数据格式，它能存储不同的数据类型，但是，在同一时间只能存储其中的一种类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 共同体名</span><br><span class="line">&#123;</span><br><span class="line">成员一的数据类型  成员名一;</span><br><span class="line">成员二的数据类型  成员名二;</span><br><span class="line">成员三的数据类型  成员名三;</span><br><span class="line">......</span><br><span class="line">成员n的数据类型  成员名n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><strong>共同体占用内存的大小是它最大的成员占用内存的大小</strong>（内存对齐）。</li>
<li>全部的成员使用同一块内存。</li>
<li>共同体中的值为最后被赋值的那个成员的值。</li>
<li>匿名共同体没有名字，可以在定义的时候创建匿名共同体变量（VS和Linux有差别），也可以嵌入结构体中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>       <span class="comment">// 声明超女结构体。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> no;             <span class="comment">// 超女编号。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span>              <span class="comment">// 声明匿名共同体。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>        a;</span><br><span class="line">		<span class="type">double</span> b;</span><br><span class="line">		<span class="type">char</span>     c[<span class="number">21</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">st_girl</span> girl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;girl.a的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) &amp;girl.a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;girl.b的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) &amp;girl.b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;girl.c的地址是：&quot;</span> &lt;&lt; (<span class="type">void</span>*) &amp;girl.c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	girl.a = <span class="number">3</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;girl.a=&quot;</span> &lt;&lt; girl.a &lt;&lt; endl;</span><br><span class="line">	girl.b = <span class="number">8.8</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;girl.a=&quot;</span> &lt;&lt; girl.a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">strcpy</span>(girl.c, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;girl.c=&quot;</span> &lt;&lt; girl.c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ul>
<li>应用：当某些量仅由有限个整型数据值组成时</li>
<li>枚举常量是整型常量，用于限制变量的取值范围</li>
<li>增强程序看可读性：定义标志变量</li>
<li>MON后面常量依次加1，相当于宏定义</li>
</ul>
<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义的第一个给定初值，后面依次累计;若不给定初值则默认从0开始</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    MON=<span class="number">1</span>,</span><br><span class="line">    TUE,<span class="comment">//等价于TUE=2</span></span><br><span class="line">    WED,</span><br><span class="line">    THU,</span><br><span class="line">    FRI,</span><br><span class="line">    SAT,</span><br><span class="line">    SUN</span><br><span class="line">&#125;Week;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    Week today;</span><br><span class="line">    today=FRI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,today);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum weeks =&#123;SUN=7,MON=1,TUE,WED,THU,FRI,SAT&#125;//枚举类型声明</span></span><br><span class="line"><span class="comment">// typedef enum weeks =&#123;SUN=7,MON=1,TUE,WED,THU,FRI,SAT&#125; WEEKS;//定义别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //定义变量</span></span><br><span class="line"><span class="comment">// enum weeks today;</span></span><br><span class="line"><span class="comment">// WEEKS today;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h3><ul>
<li>这是c++11引入的新特性</li>
<li>默认底层是int，可以修改成char型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//声明变量初始化</span></span><br><span class="line">Color myColor = Color::Red;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="keyword">if</span> (myColor == Color::Green) &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示类型转换</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">int</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> colorValue = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Color::Red);</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制底层类型，改为char型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Flag</span> : <span class="type">char</span> &#123; Increase, Decrease, Reached &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><strong>作用域</strong>：enum 中定义的枚举值在同一作用域下是全局可见的，而 enum class 中定义的枚举值是由该枚举类限定作用域的，需要通过类名进行访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 全局可见</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 通过 Animal:: 访问</span></span><br></pre></td></tr></table></figure></li>
<li><strong>默认底层类型</strong>：enum 的枚举值使用整数类型作为底层类型，默认为int，而 enum class 的枚举值也使用整数类型作为底层类型，默认为无符号整数int<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 默认底层类型为 int</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 默认底层类型为 int</span></span><br></pre></td></tr></table></figure></li>
<li><strong>类型安全性</strong>：enum class 提供了更强的类型安全性。枚举值之间不会进行隐式的整数转换，不会与其他类型进行隐式转换，需要显式地进行类型转换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> color = Red; <span class="comment">// 合法，隐式转换为 int</span></span><br><span class="line"><span class="type">int</span> animal = Animal::Cat; <span class="comment">// 非法，需要显式转换为 int</span></span><br><span class="line"><span class="type">int</span> cat = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Animal::Cat); <span class="comment">// 合法，显式转换为 int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><strong>命名空间污染</strong>：enum 中的枚举值会污染全局命名空间，可能会导致命名冲突，而 enum class 中的枚举值是由该枚举类限定作用域的，不会污染全局命名空间。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; Red, Green, Blue &#125;; <span class="comment">// 可能会与其他全局变量或枚举值冲突</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Animal</span> &#123; Cat, Dog, Bird &#125;; <span class="comment">// 限定作用域，不会与其他变量或枚举值冲突</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li>引用变量是C++新增的复合类型。</li>
<li>引用是已定义的变量的别名。</li>
<li>引用的主要用途是用作函数的形参和返回值。<br>声明&#x2F;创建引用的语法：<strong>数据类型 &amp;引用名&#x3D;原变量名;</strong></li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>引用的数据类型要与原变量名的数据类型相同</li>
<li>引用名和原变量名可以互换，它们值和内存单元是相同的</li>
<li><strong>必须在声明引用的时候初始化</strong>，初始化后不可改变</li>
<li>C和C++用&amp;符号来指示&#x2F;取变量的地址，C++给&amp;符号赋予了另一种含义<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 声明 / 创建引用的语法：数据类型 &amp; 引用名 = 原变量名;</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;          <span class="comment">// 声明普通的整型变量。</span></span><br><span class="line">	<span class="type">int</span>&amp; ra = a;      <span class="comment">// 创建引用ra，ra是a的别名。</span></span><br><span class="line">	<span class="comment">// 语法：数据类型 * const 变量名;</span></span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> rb = &amp;a;         <span class="comment">//声明指针常量rb，让它指向变量a。</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a  &lt;&lt; <span class="string">&quot;， a的值是：&quot;</span> &lt;&lt;  a  &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra的值是：&quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	ra = <span class="number">5</span>;    </span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;， a的值是：&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra的值是：&quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h2><p><strong>引用是指针常量的伪装。</strong></p>
<ul>
<li>引用是编译器提供的一个有用且安全的工具，去除了指针的一些缺点，禁止了部分不安全的操作。</li>
<li>变量：变量就是一个在程序执行过程中可以改变的量。</li>
<li>换一个角度，变量是一块内存区域的名字，它代表了这块内存区域，当我们对变量进行修改的时候，会引起内存区域中内容的改变。</li>
<li>在计算机看来，内存区域根本就不存在什么名字，它仅有的标志就是它的地址，因此我们若想修改一块内存区域的内容，只有知道他的地址才能实现。</li>
<li>所谓的变量只不过是编译器给我们进行的一种抽象，让我们不必去了解更多的细节，降低我们的思维跨度而已。</li>
<li>程序员拥有引用，但编译器仅拥有指针（地址）。</li>
<li>引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，<strong>编译器还是会把引用解释为指针</strong>。</li>
<li>引用和指针本质上没有区别。</li>
</ul>
<h2 id="引用用于函数的参数"><a href="#引用用于函数的参数" class="headerlink" title="引用用于函数的参数"></a>引用用于函数的参数</h2><ul>
<li>把函数的形参声明为引用，调用函数的时候，形参将成为实参的别名。</li>
<li>这种方法也叫按引用传递或传引用。（传值、传地址、传引用只是说法不同，其实都是传值。）</li>
<li>引用的本质是指针，传递的是变量的地址，在函数中，修改形参会影响实参。<br>1）传引用的代码更简洁。<br>2）传引用不必使用二级指针。<br>3）引用的属性和特别之处。<br><strong>示例1</strong>：普通变量引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st_girl</span>      <span class="comment">// 定义超女结构体。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> no;            <span class="comment">// 超女编号。</span></span><br><span class="line">	string str;      <span class="comment">// 表白内容。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func1(st_girl girl)    // 传值。</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	girl.no = 8;</span></span><br><span class="line"><span class="comment">// 	girl.str = &quot;我有一只小小鸟。&quot;;</span></span><br><span class="line"><span class="comment">// 	cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; girl.no &lt;&lt; &quot;号：&quot; &lt;&lt; girl.str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void func2(st_girl *girl)    // 传地址。</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	girl-&gt;no = 8;</span></span><br><span class="line"><span class="comment">// 	girl-&gt;str = &quot;我有一只小小鸟。&quot;;</span></span><br><span class="line"><span class="comment">// 	cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; girl-&gt;no &lt;&lt; &quot;号：&quot; &lt;&lt; girl-&gt;str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void func3(st_girl &amp; girl)    // 传引用。</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	girl.no = 8;</span></span><br><span class="line"><span class="comment">// 	girl.str = &quot;我有一只小小鸟。&quot;;</span></span><br><span class="line"><span class="comment">// 	cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; girl.no &lt;&lt; &quot;号：&quot; &lt;&lt; girl.str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> no, string str)</span>    <span class="comment">// 传值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	no = <span class="number">8</span>; </span><br><span class="line">	str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>* no, string* str)</span>    <span class="comment">// 传地址。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*no = <span class="number">8</span>;</span><br><span class="line">	*str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; *no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; *str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> &amp;no, string &amp;str)</span>    <span class="comment">// 传引用。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	no = <span class="number">8</span>;</span><br><span class="line">	str = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> bh = <span class="number">3</span>;      <span class="comment">// 超女的编号。</span></span><br><span class="line">	string message = <span class="string">&quot;我是一只傻傻鸟。&quot;</span>;          <span class="comment">// 向超女表白的内容。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func1(bh, message);                  // 传值。</span></span><br><span class="line">	<span class="comment">//func2(&amp;bh, &amp;message);            // 传地址。</span></span><br><span class="line">	<span class="built_in">func3</span>(bh, message);                  <span class="comment">// 传引用。</span></span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>示例2</strong>：对二级指针的引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>** p)</span>      <span class="comment">// 传地址，实参是指针的地址，形参是二级指针。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);       <span class="comment">// p是二级指针，存放指针的地址。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func1内存的地址是：&quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>*&amp; p)</span>     <span class="comment">// 传引用，实参是指针，形参是指针的别名。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);         <span class="comment">// p是指针的别名。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2内存的地址是：&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* p = <span class="literal">nullptr</span>;    <span class="comment">// 存放在子函数中动态分配内存的地址。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">func1</span>(&amp;p);      <span class="comment">// 传地址，实参填指针p的地址。</span></span><br><span class="line">	<span class="comment">//func2(p);      // 传引用，实参填指针p。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main 内存的地址是：&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;，内存中的值是：&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="引用的形参与const"><a href="#引用的形参与const" class="headerlink" title="引用的形参与const"></a>引用的形参与const</h2><ul>
<li>如果引用的数据对象类型不匹配，当引用为const时，C++将创建临时变量，让引用指向临时变量</li>
</ul>
<p><strong>创建临时变量情况</strong></p>
<ul>
<li>引用是const</li>
<li>数据对象的类型是<strong>正确的，但不是左值</strong><ul>
<li>左值：左值（value）是一个表达式，可以出现在赋值运算符的左边或右边。通俗地讲，就是可以被赋值的表达式</li>
<li>在C++中，左值指的是具有存储地址的表达式，或者说是“可寻址”的表达式。比如，变量、数组元素、解引用指针等都是左值。简单地说，如果你能够取得一个表达式的地址，那么这个表达式就是左值</li>
</ul>
</li>
<li>数据对象的<strong>类型不正确，但可以转换为正确的类型</strong></li>
<li>结论：如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 引用是const，且实参不是左值</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">42</span>); <span class="comment">// 此时会创建一个临时变量int，值为42，然后const引用value指向这个临时变量；42不是左值。在C++中，42是一个整数常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 引用是const，且实参的类型不匹配，但可以转换</span></span><br><span class="line">    <span class="type">double</span> number = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(number); <span class="comment">// 此时会创建一个临时变量int，值为3，然后const引用value指向这个临时变量</span></span><br><span class="line">	std::cout&lt;&lt;number;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>引用形参声明为const</strong>的理由有三个：</li>
</ul>
<ol>
<li>使用const可以避免无意中修改数据的编程错误</li>
<li>使用const使函数能够处理const和非const实参，否则将只能接受非const实参</li>
<li>使用const，函数能正确生成并使用临时变量</li>
</ol>
<ul>
<li>左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针</li>
<li>非左值包括字面常量（用双引号包含的字符串除外）和包含多项的表达式</li>
</ul>
<h2 id="引用用于函数的返回值"><a href="#引用用于函数的返回值" class="headerlink" title="引用用于函数的返回值"></a>引用用于函数的返回值</h2><ul>
<li>传统的函数返回机制与值传递类似</li>
<li>函数的返回值被拷贝到一个临时位置（寄存器或栈），然后调用者程序再使用这个值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m=<span class="built_in">sqrt</span>(<span class="number">36</span>);      <span class="comment">// sqrt()是求平方根函数。</span></span><br><span class="line"><span class="comment">//sqrt(36)的返回值6被拷贝到临时的位置，然后赋值给m。</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">25</span>);</span><br><span class="line"><span class="comment">//sqrt(25)的返回值5被拷贝到临时的位置，然后传递给cout。</span></span><br></pre></td></tr></table></figure></li>
<li>如果返回的是一个结构体，将把整个结构体拷贝到临时的位置</li>
<li>如果返回引用不会拷贝内存</li>
</ul>
<p><strong>语法</strong></p>
<ul>
<li><strong>返回值的数据类型&amp; 函数名(形参列表);</strong><br>注意：</li>
<li>如果<strong>返回局部变量的引用，其本质是野指针</strong>，后果不可预知。</li>
<li>可以返回<strong>函数的引用形参、类的成员、全局变量、静态变量</strong>。</li>
<li>返回引用的函数是被引用的变量的别名，将const用于引用的返回类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> &amp;<span class="title">func2</span><span class="params">(<span class="type">int</span> &amp;ra)</span>    <span class="comment">// 返回的是引用。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ra的地址是：&quot;</span> &lt;&lt; &amp;ra &lt;&lt; <span class="string">&quot;，ra=&quot;</span> &lt;&lt; ra &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; b = <span class="built_in">func2</span>(a);      <span class="comment">// 返回的是引用。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; a的地址是：&quot;</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot;， a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; b的地址是：&quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&quot;， b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// func2(a) = 10;             // 返回引有的函数是被引用的变量的别名。</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot; a的地址是：&quot; &lt;&lt; &amp;a &lt;&lt; &quot;， a=&quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot; b的地址是：&quot; &lt;&lt; &amp;b &lt;&lt; &quot;， b=&quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="各种形参的使用场景"><a href="#各种形参的使用场景" class="headerlink" title="各种形参的使用场景"></a>各种形参的使用场景</h2><p>如果<strong>不需要在函数中修改实参</strong></p>
<ul>
<li>如果实参很小，如C++内置的数据类型或小型结构体，则按值传递。</li>
<li>如果实参是数组，则使用const指针，因为这是唯一的选择（没有为数组建立引用的说法）。</li>
<li>如果实参是较大的结构，则使用const指针或const引用。</li>
<li>如果<strong>实参是类，则使用const引用</strong>，传递类的标准方式是按引用传递（类设计的语义经常要求使用引用）。</li>
</ul>
<p><strong>如果需要在函数中修改实参</strong></p>
<ul>
<li>实参是内置数据类型，则使用指针。只要看到func(&amp;x)的调用，表示函数将修改x。</li>
<li><strong>实参是数组</strong>，则只能使用指针。</li>
<li>实参是结构体，则使用指针或引用。</li>
<li>实参是类，则使用引用。</li>
</ul>
<h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><ul>
<li>默认参数是指调用函数的时候，如果不书写实参，<strong>那么将使用的一个缺省值</strong>。</li>
<li>语法：返回值 函数名(数据类型 参数&#x3D;值, 数据类型 参数&#x3D;值,……);<br>注意</li>
<li>如果函数的声明和定义是分开书写的，在函数声明中书写默认参数，函数的定义中不能书写默认参数。</li>
<li>函数必须从右到左设置默认参数。也就是说，如果要为某个参数设置默认值，则必须为它后面所有的参数设置默认值。</li>
<li>调用函数的时候，如果指定了某个参数的值，那么该参数前面所有的参数都必须指定。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"><span class="comment">// void func(int bh,string name=&quot;西施&quot;)  //按值传递，修改不会影响实参</span></span><br><span class="line"><span class="comment">// void func(int bh,const string&amp; name=&quot;西施&quot;)  //函数内部只能读取参数值而不能修改它。</span></span><br><span class="line"><span class="comment">// void func(int bh,string&amp; name=&quot;西施&quot;)   //这样会报错,在调用函数时传递一个非引用的字符串，例如string s = &quot;Hello&quot;; P(s);，会导致编译错误。因为非引用的字符串无法绑定到引用参数,所以需要修改为上面的代码</span></span><br><span class="line"><span class="comment">// const string&amp; name=&quot;西施&quot;中的西施相当于非引用字符串，用string&amp; name=&quot;西施&quot;会报错</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh,<span class="type">const</span> string&amp; name=<span class="string">&quot;西施&quot;</span>, <span class="type">const</span> string&amp; message=<span class="string">&quot;我喜欢你。&quot;</span>)</span>    <span class="comment">// 向超女表白的函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;（&quot;</span>&lt;&lt;bh&lt;&lt;<span class="string">&quot;)：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(string&amp; name)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3</span>,<span class="string">&quot;shdfj&quot;</span>,<span class="string">&quot;我是一只傻傻鸟。&quot;</span>); </span><br><span class="line">	<span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	string s=<span class="string">&quot;sdj&quot;</span>;</span><br><span class="line">	<span class="comment">// func1(&quot;sd&quot;);//这种要报错，因为这是非引用字符串</span></span><br><span class="line">	<span class="built_in">func1</span>(s);<span class="comment">//这种不会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul>
<li>函数重载（函数多态）<strong>是指设计一系列同名函数</strong>，让它们完成相同（似）的工作。</li>
<li>C++允许定义名称相同的函数，条件是它们的特征（<strong>形参的个数、数据类型和排列顺序）不同</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">short</span> a  ,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a    ,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,string b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a    ,string b, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(string b , <span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。</li>
<li>在实际开发中，视需求重载各种数据类型，不要重载功能不同的函数。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错</li>
<li>引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征</li>
<li>如果重载函数有默认参数，调用函数时，可能导致匹配失败</li>
<li><strong>const不能作为函数重载的特征</strong></li>
<li>返回值的数据类型不同不能作为函数重载的特征<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span>     <span class="comment">// 交换两个整型变量的值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(string&amp; a, string&amp; b)</span>     <span class="comment">// 交换两个字符串变量的值。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string tmp = a; a = b; b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">myswap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string c = <span class="string">&quot;西施&quot;</span>, d = <span class="string">&quot;西瓜&quot;</span>;</span><br><span class="line">	<span class="built_in">myswap</span>(c, d);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;,d=&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><ul>
<li>C++<strong>将内联函数的代码组合到程序中</strong>，可以提高程序运行的速度。</li>
<li>语法：<strong>在函数声明和定义前加上关键字inline</strong>。</li>
<li>通常的做法是将函数声明和定义写在一起</li>
<li>相当于将函数以代码的形式写在主函数，避免函数函数调用<br>注意：</li>
<li>内联函数节省时间，但消耗内存。</li>
<li>如果函数过大，编译器可能不将其作为内联函数。</li>
<li>内联函数不能递归。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>通过避免函数调用所带来保存现场、变量弹栈压栈、跳转新函数、存储函数返回值、执行完返回原现场等开销，提高了程序的运行速度</li>
<li><strong>缺点</strong>：对程序执行性能有要求且函数不超过10行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> <span class="type">short</span> bh, <span class="type">const</span> string message)</span>   <span class="comment">// 表白函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//show(3, &quot;我是一只傻傻鸟。&quot;);等价下面的函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> bh = <span class="number">3</span>;</span><br><span class="line">		string message = <span class="string">&quot;我是一只傻傻鸟。&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// show(8, &quot;我有一只小小鸟。&quot;);</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> bh = <span class="number">8</span>;</span><br><span class="line">		string message = <span class="string">&quot;我有一只小小鸟。&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// show(5, &quot;我是一只小小鸟。&quot;);</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> bh = <span class="number">5</span>;</span><br><span class="line">		string message = <span class="string">&quot;我是一只小小鸟。&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io/post/7f157bf9.html">https://github.com/wjl-a/data.github.io/post/7f157bf9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/wjl-a/data.github.io" target="_blank">醉卿枫の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/data.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-cpp/">程序语言/cpp</a></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2022/06/05/629c5257753d1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/data.github.io/post/7148eefc.html" title="模板1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="title">模板1</div></div></a></div><div><a href="/data.github.io/post/f145b64d.html" title="1.c++类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">1.c++类</div></div></a></div><div><a href="/data.github.io/post/2bc4fa53.html" title="2.c++类2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">2.c++类2</div></div></a></div><div><a href="/data.github.io/post/c010a565.html" title="3.c++模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++模板</div></div></a></div><div><a href="/data.github.io/post/36e8e938.html" title="3.c++类_基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++类_基础</div></div></a></div><div><a href="/data.github.io/post/9ceaa80f.html" title="4.c++类_继承"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-09</div><div class="title">4.c++类_继承</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="this.onerror=null;this.src='/data.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">qq:2771329872</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">1.1.</span> <span class="toc-text">一维数组与指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">一维数组用于函数的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">new动态创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8Fqsort"><span class="toc-number">1.4.</span> <span class="toc-text">一维数组的排序qsort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.5.</span> <span class="toc-text">C风格字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">二维数组用于函数的参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%85%B1%E5%90%8C%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.</span> <span class="toc-text">结构体，共同体和枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">结构体指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">结构体数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88-1"><span class="toc-number">2.1.2.</span> <span class="toc-text">结构体指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E4%BD%93"><span class="toc-number">2.2.</span> <span class="toc-text">共同体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#enum"><span class="toc-number">2.3.1.</span> <span class="toc-text">enum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum-class"><span class="toc-number">2.3.2.</span> <span class="toc-text">enum class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.3.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.1.</span> <span class="toc-text">引用本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">引用用于函数的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%BD%A2%E5%8F%82%E4%B8%8Econst"><span class="toc-number">3.3.</span> <span class="toc-text">引用的形参与const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.4.</span> <span class="toc-text">引用用于函数的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%BD%A2%E5%8F%82%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.</span> <span class="toc-text">各种形参的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">函数的默认参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">内联函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/52d1a938.html" title="8.c++_线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="8.c++_线程"/></a><div class="content"><a class="title" href="/data.github.io/post/52d1a938.html" title="8.c++_线程">8.c++_线程</a><time datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="7.c+++_智能指针_文件操作"/></a><div class="content"><a class="title" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作">7.c+++_智能指针_文件操作</a><time datetime="2023-12-23T16:00:00.000Z" title="发表于 2023-12-24 00:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="6.c++_STL"/></a><div class="content"><a class="title" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL">6.c++_STL</a><time datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="变结构无人机仿真"/></a><div class="content"><a class="title" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真">变结构无人机仿真</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/5d3e3d8b.html" title="soildworks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="soildworks"/></a><div class="content"><a class="title" href="/data.github.io/post/5d3e3d8b.html" title="soildworks">soildworks</a><time datetime="2023-10-27T13:01:00.000Z" title="发表于 2023-10-27 21:01:00">2023-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bu.dusays.com/2022/06/05/629c5257753d1.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/data.github.io/js/utils.js"></script><script src="/data.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/data.github.io/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/data.github.io/js/search/local-search.js"></script></div></div></body></html>