<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6.c++_STL | 醉卿枫の博客</title><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STL容器string容器 string是字符容器，内部维护了一个动态的字符数组。 与普通的字符数组相比，string容器有三个优点： 使用的时候，不必考虑内存分配和释放的问题； 动态管理内存（可扩展）； 提供了大量操作容器的API。缺点是效率略有降低，占用的资源也更多。   string类是std::basic_string类模板的一个具体化版本的别名。 using std::string&#x3D;st">
<meta property="og:type" content="article">
<meta property="og:title" content="6.c++_STL">
<meta property="og:url" content="https://github.com/wjl-a/data.github.io/post/6ad37afc.html">
<meta property="og:site_name" content="醉卿枫の博客">
<meta property="og:description" content="STL容器string容器 string是字符容器，内部维护了一个动态的字符数组。 与普通的字符数组相比，string容器有三个优点： 使用的时候，不必考虑内存分配和释放的问题； 动态管理内存（可扩展）； 提供了大量操作容器的API。缺点是效率略有降低，占用的资源也更多。   string类是std::basic_string类模板的一个具体化版本的别名。 using std::string&#x3D;st">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png">
<meta property="article:published_time" content="2023-12-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-14T03:20:19.874Z">
<meta property="article:author" content="醉卿枫">
<meta property="article:tag" content="程序语言&#x2F;cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png"><link rel="shortcut icon" href="/data.github.io/img/favicon.png"><link rel="canonical" href="https://github.com/wjl-a/data.github.io/post/6ad37afc.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/data.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/data.github.io/',
  algolia: undefined,
  localSearch: {"path":"/data.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.c++_STL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-14 11:20:19'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><nav id="nav"><span id="blog-info"><a href="/data.github.io/" title="醉卿枫の博客"><span class="site-name">醉卿枫の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6.c++_STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T03:20:19.874Z" title="更新于 2024-01-14 11:20:19">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/data.github.io/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>77分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6.c++_STL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><ul>
<li>string是字符容器，内部维护了一个动态的字符数组。</li>
<li>与普通的字符数组相比，string容器有三个优点：<ul>
<li>使用的时候，不必考虑内存分配和释放的问题；</li>
<li>动态管理内存（可扩展）；</li>
<li>提供了大量操作容器的API。缺点是效率略有降低，占用的资源也更多。</li>
</ul>
</li>
<li>string类是std::basic_string类模板的一个具体化版本的别名。</li>
<li><code>using std::string=std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;</code></li>
</ul>
<h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><ul>
<li>静态常量成员string::npos为字符数组的最大长度（通常为unsigned int的最大值）；</li>
<li>NBTS（null-terminated string）：C风格的字符串（以空字符0结束的字符串）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string类有七个构造函数（C++<span class="number">11</span>新增了两个）：</span><br><span class="line"><span class="number">1</span>）<span class="built_in">string</span>(); <span class="comment">// 创建一个长度为0的string对象（默认构造函数）。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *s); <span class="comment">// 将string对象初始化为s指向的NBTS（转换函数）。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">string</span>(<span class="type">const</span> string &amp;str); <span class="comment">// 将string对象初始化为str（拷贝构造函数）。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">size_t</span> n); <span class="comment">// 将string对象初始化为s指向的地址后n字节的内容。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">string</span>(<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos=<span class="number">0</span>,<span class="type">size_t</span> n=npos); <span class="comment">// 将sring对象初始化为str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">string</span><span class="params">(T begin,T end)</span></span>; <span class="comment">// 将string对象初始化为区间[begin,end]内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">string</span>(<span class="type">size_t</span> n,<span class="type">char</span> c); <span class="comment">// 创建一个由n个字符c组成的string对象。</span></span><br><span class="line">析构函数~<span class="built_in">string</span>()释放内存空间。</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增加</span></span><br><span class="line"><span class="number">1</span>）<span class="built_in">string</span>(string &amp;&amp; str) <span class="keyword">noexcept</span>：它将一个string对象初始化为string对象str，并可能修改str（移动构造函数）。</span><br><span class="line"><span class="number">2</span>）<span class="built_in">string</span>(initializer_list&lt;<span class="type">char</span>&gt; il)：它将一个string对象初始化为初始化列表il中的字符。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
示例1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1）string()：创建一个长度为0的string对象（默认构造函数）。</span></span><br><span class="line">    string s1;        <span class="comment">// 创建一个长度为0的string对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1=&quot;</span> &lt;&lt; s1 &lt;&lt; endl;       <span class="comment">// 将输出s1=</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.capacity()=&quot;</span> &lt;&lt; s1.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size()=&quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;容器动态数组的首地址=&quot;</span> &lt;&lt; (<span class="type">void</span> *)s1.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line">    s1 = <span class="string">&quot;xxxxxxxxxxxxxxxxxxxx&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.capacity()=&quot;</span> &lt;&lt; s1.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1.size()=&quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;容器动态数组的首地址=&quot;</span> &lt;&lt; (<span class="type">void</span> *)s1.<span class="built_in">c_str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2）string(const char *s)：将string对象初始化为s指向的NBTS（转换函数）。</span></span><br><span class="line">    <span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s2=&quot;</span> &lt;&lt; s2 &lt;&lt; endl;       <span class="comment">// 将输出s2=hello world</span></span><br><span class="line">    string s3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s3=&quot;</span> &lt;&lt; s3 &lt;&lt; endl;       <span class="comment">// 将输出s3=hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3）string(const string &amp; str)：将string对象初始化为str（拷贝构造函数）。</span></span><br><span class="line">    <span class="function">string <span class="title">s4</span><span class="params">(s3)</span></span>;                                     <span class="comment">// s3 = &quot;hello world&quot;;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s4=&quot;</span> &lt;&lt; s4 &lt;&lt; endl;       <span class="comment">// 将输出s4=hello world</span></span><br><span class="line">    string s5 = s3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s5=&quot;</span> &lt;&lt; s5 &lt;&lt; endl;       <span class="comment">// 将输出s5=hello world</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4）string(const char* s, size_t n)：将string对象初始化为s指向的NBTS的前n个字符，即使超过了NBTS结尾。</span></span><br><span class="line">    <span class="function">string <span class="title">s6</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s6=&quot;</span> &lt;&lt; s6 &lt;&lt; endl;       <span class="comment">// 将输出s6=hello</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s6.capacity()=&quot;</span> &lt;&lt; s6.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s6.size()=&quot;</span> &lt;&lt; s6.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    <span class="function">string <span class="title">s7</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">50</span>)</span></span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s7=&quot;</span> &lt;&lt; s7 &lt;&lt; endl;       <span class="comment">// 将输出s7=hello未知内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s7.capacity()=&quot;</span> &lt;&lt; s7.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s7.size()=&quot;</span> &lt;&lt; s7.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5）string(const string &amp; str, size_t pos = 0, size_t n = npos)：</span></span><br><span class="line">    <span class="comment">// 将string对象初始化为str从位置pos开始到结尾的字符，或从位置pos开始的n个字符。</span></span><br><span class="line">    <span class="function">string <span class="title">s8</span><span class="params">(s3, <span class="number">3</span>, <span class="number">5</span>)</span></span>;                               <span class="comment">// s3 = &quot;hello world&quot;;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s8=&quot;</span> &lt;&lt; s8 &lt;&lt; endl;         <span class="comment">// 将输出s8=lo wo</span></span><br><span class="line">    <span class="function">string <span class="title">s9</span><span class="params">(s3, <span class="number">3</span>)</span></span>;          </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s9=&quot;</span> &lt;&lt; s9 &lt;&lt; endl;         <span class="comment">// 将输出s9=lo world</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s9.capacity()=&quot;</span> &lt;&lt; s9.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s9.size()=&quot;</span> &lt;&lt; s9.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// 返回容器中数据的大小。</span></span><br><span class="line">    <span class="function">string <span class="title">s10</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s10=&quot;</span> &lt;&lt; s10 &lt;&lt; endl;       <span class="comment">// 将输出s10=lo wo</span></span><br><span class="line">    <span class="function">string <span class="title">s11</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">3</span>)</span></span>;                <span class="comment">// 注意：不会用构造函数5），而是用构造函数4）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s11=&quot;</span> &lt;&lt; s11 &lt;&lt; endl;       <span class="comment">// 将输出s11=hel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6）template&lt;class T&gt; string(T begin, T end)：将string对象初始化为区间[begin, end]内的字符，</span></span><br><span class="line">    <span class="comment">//      其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7）string(size_t n, char c)：创建一个由n个字符c组成的string对象。</span></span><br><span class="line">    <span class="function">string <span class="title">s12</span><span class="params">(<span class="number">8</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s12=&quot;</span> &lt;&lt; s12 &lt;&lt; endl;       <span class="comment">// 将输出s12=xxxxxxxx</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s12.capacity()=&quot;</span> &lt;&lt; s12.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// s12.capacity()=15</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s12.size()=&quot;</span> &lt;&lt; s12.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// s12.size()=8</span></span><br><span class="line">    <span class="function">string <span class="title">s13</span><span class="params">(<span class="number">30</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s13=&quot;</span> &lt;&lt; s13 &lt;&lt; endl;       <span class="comment">// 将输出s13=</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s13.capacity()=&quot;</span> &lt;&lt; s13.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// s13.capacity()=31</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s13.size()=&quot;</span> &lt;&lt; s13.<span class="built_in">size</span>() &lt;&lt; endl;                   <span class="comment">// s12.size()=30 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>示例2：将字符空间用于字符串，int型等</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> cc[<span class="number">8</span>];   <span class="comment">// 在栈上分配8字节的内存空间。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把cc的内存空间用于字符串。</span></span><br><span class="line">	<span class="built_in">strcpy</span>(cc, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;cc=&quot;</span> &lt;&lt; cc &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把cc的内存空间用于int型整数。</span></span><br><span class="line">	<span class="type">int</span>* a, * b;</span><br><span class="line">	a = (<span class="type">int</span> *)cc;          <span class="comment">// 前4个字节的空间用于整数a。</span></span><br><span class="line">	b = (<span class="type">int</span> *)cc + <span class="number">4</span>;   <span class="comment">// 后4个字节的空间用于整数b。</span></span><br><span class="line">	*a = <span class="number">12345</span>;</span><br><span class="line">	*b = <span class="number">54321</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*a=&quot;</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*b=&quot;</span> &lt;&lt; *b &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把cc的内存空间用于double。</span></span><br><span class="line">	<span class="type">double</span>* d = (<span class="type">double</span>*)cc;</span><br><span class="line">	*d = <span class="number">12345.7</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*d=&quot;</span> &lt;&lt; *d &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把cc的内存空间用于结构体。</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stt</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		<span class="type">char</span> b[<span class="number">4</span>];</span><br><span class="line">	&#125;*st;</span><br><span class="line">	st = (<span class="keyword">struct</span> stt*)cc;</span><br><span class="line">	st-&gt;a = <span class="number">38</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(st-&gt;b, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st-&gt;a=&quot;</span> &lt;&lt; st-&gt;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st-&gt;b=&quot;</span> &lt;&lt; st-&gt;b &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// void* malloc(size_t size);</span></span><br><span class="line">	<span class="comment">//char* cc1 = (char*)malloc(8);</span></span><br><span class="line">	<span class="comment">//int* cc1 = (int*)malloc(8);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>示例3：将结构体信息添加到字符串中</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">st_girl</span> &#123;   <span class="comment">// 超女结构体。</span></span><br><span class="line">        <span class="type">int</span>    bh;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">        <span class="type">bool</span> yz;</span><br><span class="line">        <span class="type">double</span> weight;</span><br><span class="line">        string memo;</span><br><span class="line">    &#125; girl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;超女结构体的大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string buffer;  <span class="comment">// 创建一个空的string容器buffer。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成10名超女的信息，存入buffer中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对超女结构体成员赋值。    </span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;girl, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));  </span><br><span class="line">        girl.bh = ii;</span><br><span class="line">        <span class="built_in">sprintf</span>(girl.name, <span class="string">&quot;西施%02d&quot;</span>, ii);</span><br><span class="line">        girl.yz = <span class="literal">true</span>;</span><br><span class="line">        girl.weight = <span class="number">48.5</span> + ii;</span><br><span class="line">        girl.memo = <span class="string">&quot;中国历史第一美女。&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把超女结构追加到buffer中。</span></span><br><span class="line">        buffer.<span class="built_in">append</span>((<span class="type">char</span>*)&amp;girl, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;buffer.capacity()=&quot;</span> &lt;&lt; buffer.<span class="built_in">capacity</span>() &lt;&lt; endl;  <span class="comment">// 显示容量。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;buffer.size()=&quot;</span> &lt;&lt; buffer.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 显示实际大小。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个循环，把buffer容器中全部的数据取出来。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; buffer.<span class="built_in">size</span>() / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl); ii++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;girl, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));  <span class="comment">// 初始化超女结构体。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把容器中的数据复制到超女结构体。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;girl , buffer.<span class="built_in">data</span>() + ii * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl), <span class="built_in">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line">        <span class="comment">// buffer.copy((char*)&amp;girl, sizeof(struct st_girl), ii * sizeof(struct st_girl));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示超女结构体成员的值。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bh=&quot;</span> &lt;&lt; girl.bh &lt;&lt;  <span class="string">&quot;,name=&quot;</span> &lt;&lt; girl.name &lt;&lt; <span class="string">&quot;,yz=&quot;</span> &lt;&lt; girl.yz &lt;&lt; <span class="string">&quot;,weight=&quot;</span> </span><br><span class="line">                &lt;&lt; girl.weight &lt;&lt; <span class="string">&quot;,memo=&quot;</span> &lt;&lt; girl.memo &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="特性操作"><a href="#特性操作" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// 返回string对象的最大长度string::npos，此函数意义不大。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回当前容量，可以存放字符的总数。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 返回容器中数据的大小（字符串语义）。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">// 返回容器中数据的大小（容器语义）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器，清空后，size()将返回0。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;	      <span class="comment">// 将容器的容量降到实际大小（需要重新分配内存）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">( <span class="type">size_t</span> size=<span class="number">0</span>)</span></span>;  <span class="comment">// 将容器的容量设置为至少size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> len,<span class="type">char</span> c=<span class="number">0</span>)</span></span>;  <span class="comment">// 把容器的实际大小置为len，如果len&lt;实际大小，</span></span><br><span class="line"><span class="comment">//截断多出的部分；如果len&gt;实际大小，就用字符c填充。resize()后，length()和size()将返回len。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n); </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;  <span class="comment">// 只读。</span></span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;          <span class="comment">// 只读。</span></span><br><span class="line"><span class="comment">//operator[]和at()返回容器中的第n个元素，但at函数提供范围检查，当越界时会抛出out_of_range异常，operator[]不提供范围检查。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回容器中动态数组的首地址，语义：寻找以null结尾的字符串。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回容器中动态数组的首地址，语义：只关心容器中的数据。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">// 把当前容器中的内容，从pos开始的n个字节拷贝到s中，返回实际拷贝的数目。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给已存在的容器赋值，将覆盖容器中原有的内容。</span></span><br><span class="line"><span class="number">1</span>）string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;str); <span class="comment">// 把容器str赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>; <span class="comment">// 将string对象赋值为s指向的NBTS。</span></span><br><span class="line"><span class="number">3</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>; <span class="comment">// 将string对象赋值为str。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">size_t</span> n)</span></span>; <span class="comment">// 将string对象赋值为s指向的地址后n字节的内容。</span></span><br><span class="line"><span class="number">5</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos=<span class="number">0</span>,<span class="type">size_t</span> n=npos)</span></span>; <span class="comment">// 将sring对象赋值为str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; string &amp;<span class="title">assign</span><span class="params">(T begin,T end)</span></span>; <span class="comment">// 将string对象赋值为区间[begin,end]内的字符。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">size_t</span> n,<span class="type">char</span> c)</span></span>; <span class="comment">// 将string对象赋值为由n个字符c。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">把内容追加到已存在容器的后面。</span><br><span class="line"><span class="number">1</span>）string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> string &amp;str); <span class="comment">//把容器str连接到当前容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>; <span class="comment">// 把指向s的NBTS连接到当前容器。</span></span><br><span class="line"><span class="number">3</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>; <span class="comment">// 把容器str连接到当前容器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">size_t</span> n)</span></span>; <span class="comment">// 将s指向的地址后n字节的内容连接到当前容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos=<span class="number">0</span>,<span class="type">size_t</span> n=npos)</span></span>; <span class="comment">// 将str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）连接到当前容器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; string &amp;<span class="title">append</span> <span class="params">(T begin,T end)</span></span>; <span class="comment">// 将区间[begin,end]内的字符连接到容器。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">size_t</span> n,<span class="type">char</span> c)</span></span>; <span class="comment">// 将n个字符c连接到当前容器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h3><ul>
<li><code>void swap(string &amp;str);    // 把当前容器与str交换。</code></li>
<li>如果数据量很小，交换的是动态数组中的内容，如果数据量比较大，交换的是动态数组的地址。</li>
</ul>
<h3 id="截取操作"><a href="#截取操作" class="headerlink" title="截取操作"></a>截取操作</h3><ol>
<li><code>string substr(size_t pos = 0,size_t n = npos) const; // 返回pos开始的n个字节组成的子容器。</code></li>
</ol>
<h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> string &amp;str1,<span class="type">const</span> string &amp;str2) <span class="type">const</span>; <span class="comment">// 比较两个字符串是否相等。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;str)</span> <span class="type">const</span></span>; <span class="comment">// 比较当前字符串和str1的大小。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> string &amp;str)</span> <span class="type">const</span></span>; <span class="comment">// 比较当前字符串从pos开始的n个字符组成的字符串与str的大小。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> string &amp;str,<span class="type">size_t</span> pos2,<span class="type">size_t</span> n2)</span><span class="type">const</span></span>; <span class="comment">// 比较当前字符串从pos开始的n个字符组成的字符串与str中pos2开始的n2个字符组成的字符串的大小。</span></span><br><span class="line">以下几个函数用于和C风格字符串比较。</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n,<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> pos2)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="built_in">compre</span>()函数有异常，慎用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen = npos)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; str)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen = npos)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><code>string &amp;erase(size_t pos = 0, size_t n = npos); // 删除pos开始的n个字符。</code></li>
</ul>
<h2 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h2><ul>
<li>vector容器封装了动态数组。</li>
<li>包含头文件： <code>#include&lt;vector&gt;</code></li>
</ul>
<p>类模板声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = allocator&lt;T&gt;&gt;<span class="comment">//类型 Alloc 表示我们要使用的内存分配器类型。默认情况下，使用 allocator&lt;T&gt; 作为内存分配器</span></span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *start_; </span><br><span class="line">	T *finish_;</span><br><span class="line">	T *end_;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分配器</strong>：各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存</li>
<li>如果省略该模板参数的值，将默认使用<code>allocator&lt;T&gt;</code>，用new和delete分配和释放内存。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">vector</span>();  <span class="comment">// 创建一个空的vector容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">vector</span>(initializer_list&lt;T&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; v);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">vector</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建vector容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">vector</span>(vector&lt;T&gt;&amp;&amp; v);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;   <span class="comment">// 创建vector容器，元素个数为n（容量和实际大小都是n）。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">vector</span>(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value);  <span class="comment">// 创建vector容器，元素个数为n，值均为value。</span></span><br><span class="line">析构函数~<span class="built_in">vector</span>()释放内存空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="特性操作-1"><a href="#特性操作-1" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回容器的最大长度，此函数意义不大。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 返回容器的容量。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 返回容器的实际大小（已使用的空间）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;               <span class="comment">// 清空容器。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> size)</span></span>;   <span class="comment">// 将容器的容量设置为至少size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;	       <span class="comment">// 将容器的容量降到实际大小（需要重新分配内存）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;    <span class="comment">// 把容器的实际大小置为size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size,<span class="type">const</span> T &amp;value)</span></span>;  <span class="comment">// 把容器的实际大小置为size，如果size&lt;实际大小，会截断多出的部分；如果size&gt;实际大小，就用value填充。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n); </span><br><span class="line"><span class="type">const</span> T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;  <span class="comment">// 只读。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;          <span class="comment">// 只读。</span></span><br><span class="line"><span class="function">T *<span class="title">data</span><span class="params">()</span></span>;            <span class="comment">// 返回容器中动态数组的首地址。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回容器中动态数组的首地址。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;        <span class="comment">// 第一个元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;  <span class="comment">// 第一个元素，只读。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;  <span class="comment">// 最后一个元素，只读。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;        <span class="comment">// 最后一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="赋值操作-1"><a href="#赋值操作-1" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给已存在的容器赋值，将覆盖容器中原有的内容。</span><br><span class="line"><span class="number">1</span>）vector &amp;<span class="keyword">operator</span>=(<span class="type">const</span> vector&lt;T&gt; &amp;v);    <span class="comment">// 把容器v赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）vector &amp;<span class="keyword">operator</span>=(initializer_list&lt;T&gt; il); <span class="comment">// 用统一初始化列表给当前容器赋值。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(initializer_list&lt;T&gt; il)</span></span>;        <span class="comment">// 使用统一初始化列表赋值。</span></span><br><span class="line"><span class="number">4</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(Iterator first, Iterator last)</span></span>;  <span class="comment">// 用迭代器赋值。</span></span><br><span class="line"><span class="number">5</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 把n个value给容器赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	v1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;     <span class="comment">// 使用统一初始化列表赋值。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; v1.<span class="built_in">size</span>(); ii++) cout &lt;&lt; v1[ii] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	v2 = v1;                    <span class="comment">// 把容器v1赋值给当前容器。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; v2.<span class="built_in">size</span>(); ii++) cout &lt;&lt; v2[ii] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">	v3.<span class="built_in">assign</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;);   <span class="comment">// 用assign()函数给当前容器赋值，参数是统一初始化列表。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; v3.<span class="built_in">size</span>(); ii++) cout &lt;&lt; v3[ii] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="交换操作-1"><a href="#交换操作-1" class="headerlink" title="交换操作"></a>交换操作</h3><ul>
<li><code>void swap(vector&lt;T&gt; &amp;v);    // 把当前容器与v交换</code>。</li>
<li>交换的是动态数组的地址</li>
</ul>
<h3 id="比较操作-1"><a href="#比较操作-1" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> vector&lt;T&gt; &amp; v) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> vector&lt;T&gt; &amp; v) <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在容器的尾部追加一个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(…)</span></span>;           <span class="comment">// 在容器的尾部追加一个元素，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">3</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在指定位置插入一个元素，返回指向插入元素的迭代器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">iterator <span class="title">emplace</span> <span class="params">(iterator pos, …)</span></span>;  <span class="comment">// 在指定位置插入一个元素，…用于构造元素，返回指向插入元素的迭代器。C++11</span></span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, iterator first, iterator last)</span></span>;  <span class="comment">// 在指定位置插入一个区间的元素，返回指向第一个插入元素的迭代器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;                      <span class="comment">// 从容器尾部删除一个元素。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;             <span class="comment">// 删除指定位置的元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 删除指定区间的元素，返回下一个有效的迭代器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_bh;               <span class="comment">// 编号。</span></span><br><span class="line">	string m_name;     <span class="comment">// 姓名。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">AA</span>()      <span class="comment">// 默认构造函数。</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;默认构造函数AA()。\n&quot;; </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> <span class="type">int</span> &amp;bh,<span class="type">const</span> string&amp; name) : <span class="built_in">m_bh</span>(bh),<span class="built_in">m_name</span>(name)   <span class="comment">// 有两个参数的构造函数。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;构造函数，name=&quot; &lt;&lt; m_name &lt;&lt; &quot;。\n&quot;; </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> AA&amp; g) :<span class="built_in">m_bh</span>(g.m_bh), <span class="built_in">m_name</span>(g.m_name)                       <span class="comment">// 拷贝构造函数。</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;拷贝构造函数，name=&quot; &lt;&lt; m_name &lt;&lt; &quot;。\n&quot;; </span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//~AA() &#123; cout &lt;&lt; &quot;析构函数。\n&quot;; &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;AA&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt;endl&lt;&lt; v.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//AA a(18,&quot;西施&quot;); </span></span><br><span class="line">	<span class="comment">//v.push_back(a);</span></span><br><span class="line">	<span class="comment">//v.emplace_back(a);</span></span><br><span class="line">	v.<span class="built_in">emplace_back</span>(<span class="number">18</span>,<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bh=&quot;</span> &lt;&lt; v[<span class="number">10</span>].m_bh &lt;&lt; <span class="string">&quot;,name=&quot;</span> &lt;&lt; v[<span class="number">10</span>].m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vector嵌套"><a href="#vector嵌套" class="headerlink" title="vector嵌套"></a>vector嵌套</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vv;   <span class="comment">// 创建一个vector容器vv，元素的数据类型是vector&lt;int&gt;。</span></span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;        <span class="comment">// 创建一个容器v，它将作为容器vv的元素。</span></span><br><span class="line"></span><br><span class="line">	v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;      <span class="comment">// 用统一初始化列表给v赋值。</span></span><br><span class="line">	vv.<span class="built_in">push_back</span>(v);    <span class="comment">// 把容器v作为元素追加到vv中。</span></span><br><span class="line"></span><br><span class="line">	v = &#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span> &#125;;   <span class="comment">// 用统一初始化列表给v赋值。</span></span><br><span class="line">	vv.<span class="built_in">push_back</span>(v);                      <span class="comment">// 把容器v作为元素追加到vv中。</span></span><br><span class="line"></span><br><span class="line">	v = &#123; <span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span> &#125;;     <span class="comment">// 用统一初始化列表给v赋值。</span></span><br><span class="line">	vv.<span class="built_in">push_back</span>(v);    <span class="comment">// 把容器v作为元素追加到vv中。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用嵌套的循环，把vv容器中的数据显示出来。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; vv.<span class="built_in">size</span>(); ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; vv[ii].<span class="built_in">size</span>(); jj++)</span><br><span class="line">			cout &lt;&lt; vv[ii][jj] &lt;&lt; <span class="string">&quot; &quot;</span>;      <span class="comment">// 像二维数组一样使用容器vv。</span></span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>迭代器失效的问题：resize()、reserve()、assign()、push_back()、pop_back()、insert()、erase()等函数会引起vector容器的动态数组发生变化，可能导致vector迭代器失效。</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>迭代器是访问容器中元素的通用方法。</li>
<li>如果使用迭代器，不同的容器，访问元素的方法是相同的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代器支持的基本操作：赋值（=）、解引用（*）、比较（==和!=）、从左向右遍历（++）。</span><br></pre></td></tr></table></figure></li>
<li>一般情况下，迭代器是指针和移动指针的方法。</li>
</ul>
<h3 id="正向迭代器"><a href="#正向迭代器" class="headerlink" title="正向迭代器"></a>正向迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能使用++运算符从左向右遍历容器，每次沿容器向右移动一个元素。</span></span><br><span class="line">容器名&lt;元素类型&gt;::iterator 迭代器名;        <span class="comment">// 正向迭代器。</span></span><br><span class="line">容器名&lt;元素类型&gt;::const_iterator 迭代器名;  <span class="comment">// 常正向迭代器。</span></span><br><span class="line"><span class="comment">//相关的成员函数：</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span></span>;  <span class="comment">// 配合auto使用。</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">cend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用正向迭代器遍历 vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h3><p>具备正向迭代器的功能，还可以反向（从右到左）遍历容器（也是用++），不管是正向还是反向遍历，都可以用–让迭代器后退一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">容器名&lt;元素类型&gt;:: reverse_iterator 迭代器名;        <span class="comment">// 反向迭代器。</span></span><br><span class="line">容器名&lt;元素类型&gt;:: const_reverse_iterator 迭代器名;  <span class="comment">// 常反向迭代器。</span></span><br><span class="line">相关的成员函数：</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">crbegin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">crend</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">具备双向迭代器的功能，还支持以下操作：</span><br><span class="line">用于比较两个迭代器相对位置的关系运算（&lt;、&lt;=、&gt;、&gt;=）。</span><br><span class="line">迭代器和一个整数值的加减法运算（+、+=、-、-=）。</span><br><span class="line">支持下标运算（iter[n]）。</span><br><span class="line">数组的指针是纯天然的随机访问迭代器。</span><br></pre></td></tr></table></figure>
<h3 id="输入和输出迭代器"><a href="#输入和输出迭代器" class="headerlink" title="输入和输出迭代器"></a>输入和输出迭代器</h3><p>这两种迭代器比较特殊，它们不是把容器当做操作对象，而是把输入&#x2F;输出流作为操作对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>   <span class="comment">// 单链表的结点。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> item;</span><br><span class="line">	Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">find_</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span>&amp; val)</span>  <span class="comment">// 在整型数组arr中查找值为val的元素。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; n; ii++)                     <span class="comment">// 遍历数组。</span></span><br><span class="line">		<span class="keyword">if</span> (arr[ii] == val) <span class="keyword">return</span> &amp;arr[ii];       <span class="comment">// 如果找到了，返回数组中元素的地址。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">find_</span><span class="params">(<span class="type">int</span>* begin, <span class="type">int</span>* end, <span class="type">const</span> <span class="type">int</span>&amp; val)</span>  <span class="comment">// 在整型数组的区间中查找值为val的元素。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span>* iter = begin; iter != end; iter++)      <span class="comment">// 遍历查找区间。</span></span><br><span class="line">		<span class="keyword">if</span> (*iter == val) <span class="keyword">return</span> iter;                         <span class="comment">// 如果找到了元素，返回区间中的位置。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">find_</span><span class="params">(Node* begin, Node* end, <span class="type">const</span> Node&amp; val)</span>         <span class="comment">// 在单链表中查找值为val的元素。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Node * iter = begin; iter != end; iter = iter-&gt;next)     <span class="comment">// 遍历链表。</span></span><br><span class="line">		<span class="keyword">if</span> (iter-&gt;item == val.item) <span class="keyword">return</span> iter;           <span class="comment">// 如果找到了，返回链表中结点的地址。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素的算法。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  </span><br><span class="line"><span class="comment">// begin-查找区间开始的位置；end-查找区间结束的位置；val-待查找的值。</span></span><br><span class="line"><span class="function">T1 <span class="title">find_</span><span class="params">(T1 begin, T1 end, <span class="type">const</span> T2 &amp;val)</span>      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (T1 iter = begin; iter != end; iter++)     <span class="comment">// 遍历查找区间。</span></span><br><span class="line">		<span class="keyword">if</span> (*iter == val) <span class="keyword">return</span> iter;                       <span class="comment">// 如果找到了元素，返回区间中的位置。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在vector容器中查找元素。</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;      <span class="comment">// 初始化vector容器。</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it2 = <span class="built_in">find_</span>(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line">	<span class="keyword">if</span> (it2 != vv.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;查找成功。\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在list容器中查找元素。</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; ll = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;               <span class="comment">// 初始化vector容器。</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;::iterator it3 = <span class="built_in">find_</span>(ll.<span class="built_in">begin</span>(), ll.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (it3 != ll.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;查找成功。\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><ul>
<li>对于一个有范围的集合来说，在程序代码中指定循环的范围有时候是多余的，还可能犯错误</li>
<li>C++11中引入了基于范围的for循环<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (迭代的变量 : 迭代的范围)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 循环体。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1</span>）迭代的范围可以是数组名、容器名、初始化列表或者可迭代的对象（支持<span class="built_in">begin</span>()、<span class="built_in">end</span>()、++、==）</span><br><span class="line"><span class="number">2</span>）数组名传入函数后，已退化成指针，不能作为容器名</span><br><span class="line"><span class="number">3</span>）如果容器中的元素是结构体和类，迭代器变量应该申明为引用，加<span class="type">const</span>约束表示只读</span><br><span class="line"><span class="number">4</span>）注意迭代器失效的问题</span><br></pre></td></tr></table></figure>
例子<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;默认构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;构造函数，name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> AA&amp; a) : <span class="built_in">m_name</span>(a.m_name) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数，name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">	AA&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AA&amp; a) &#123; m_name = a.m_name;  cout &lt;&lt; <span class="string">&quot;赋值函数，name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;。\n&quot;</span>;  <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数，name=&quot;</span> &lt;&lt; m_name&lt;&lt;<span class="string">&quot;。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (auto it = vv.begin(); it != vv.end(); it++)     // 用迭代器遍历容器vv。</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> val : vv)      <span class="comment">// 用基于范围的for循环遍历数组vv。</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		vv.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*vector&lt;AA&gt; v;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;1111，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">	v.emplace_back(&quot;西施&quot;);</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;2222，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">	v.emplace_back(&quot;冰冰&quot;);</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;3333，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">	v.emplace_back(&quot;幂幂&quot;);</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;4444，v.capacity()=&quot; &lt;&lt; v.capacity() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	for (const auto &amp;a : v)</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; a.m_name &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; endl;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h2><ul>
<li>list容器封装了双链表。</li>
<li>包含头文件： <code>#include&lt;list&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> list&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	iterator head;</span><br><span class="line">	iterator tail;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">list</span>();  <span class="comment">// 创建一个空的list容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">list</span>(initializer_list&lt;T&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">list</span>(<span class="type">const</span> list&lt;T&gt;&amp; l);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">list</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建list容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">list</span>(list&lt;T&gt;&amp;&amp; l);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="keyword">explicit</span> <span class="title">list</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n)</span></span>;   <span class="comment">// 创建list容器，元素个数为n。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">list</span>(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value);  <span class="comment">// 创建list容器，元素个数为n，值均为value。</span></span><br><span class="line">析构函数~<span class="built_in">list</span>()释放内存空间。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1）list();  // 创建一个空的list容器。</span></span><br><span class="line">	list&lt;<span class="type">int</span>&gt; l1;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot;li.capacity()=&quot; &lt;&lt; l1.capacity() &lt;&lt; endl;  // 链表没有容量说法。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;li.size()=&quot;</span> &lt;&lt; l1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2）list(initializer_list&lt;T&gt; il); // 使用统一初始化列表。</span></span><br><span class="line">	<span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l2</span><span class="params">(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;)</span></span>;</span><br><span class="line">	<span class="comment">// list&lt;int&gt; l2=&#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span></span><br><span class="line">	<span class="comment">// list&lt;int&gt; l2  &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : l2)       <span class="comment">// 用基于范围的for循环遍历容器。</span></span><br><span class="line">		cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3）list(const list&lt;T&gt;&amp; l);  // 拷贝构造函数。</span></span><br><span class="line">	<span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l3</span><span class="params">(l2)</span></span>;</span><br><span class="line">	<span class="comment">// list&lt;int&gt; l3=l2;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : l3)    </span><br><span class="line">		cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4）list(Iterator first, Iterator last);  // 用迭代器创建list容器。</span></span><br><span class="line">	<span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l4</span><span class="params">(l3.begin(), l3.end())</span></span>;      <span class="comment">// 用list容器的迭代器。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : l4)  </span><br><span class="line">		cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;  <span class="comment">// 创建vector容器。</span></span><br><span class="line">	<span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l5</span><span class="params">(v1.begin() + <span class="number">2</span>, v1.end() - <span class="number">3</span>)</span></span>;          <span class="comment">// 用vector容器的迭代器创建list容器。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : l5)   </span><br><span class="line">		cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a1[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;   <span class="comment">// 创建数组。</span></span><br><span class="line">	<span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l6</span><span class="params">(a1 + <span class="number">2</span>, a1 + <span class="number">10</span> - <span class="number">3</span>)</span></span>;           <span class="comment">// 用数组的指针作为迭代器创建list容器。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : l6)     </span><br><span class="line">		cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;         <span class="comment">// 定义C风格字符串。</span></span><br><span class="line">	<span class="function">string <span class="title">s1</span><span class="params">(str + <span class="number">1</span>, str + <span class="number">7</span>)</span></span>;          <span class="comment">// 用C风格字符串创建string容器。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> value : s1)                   <span class="comment">// 遍历string容器。</span></span><br><span class="line">		cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; endl;                 <span class="comment">// 以字符串的方式显示string容器。</span></span><br><span class="line"></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(l3.begin(), l3.end())</span></span>;   <span class="comment">// 用list迭代器创建vector容器。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> value : v2)                               <span class="comment">// 遍历vector容器。</span></span><br><span class="line">		cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="特性操作-2"><a href="#特性操作-2" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">// 返回容器的最大长度，此函数意义不大。</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 返回容器的实际大小（已使用的空间）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size)</span></span>;   <span class="comment">// 把容器的实际大小置为size。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> size,<span class="type">const</span> T &amp;value)</span></span>;  <span class="comment">// 把容器的实际大小置为size，如果size&lt;实际大小，会截断多出的部分；如果size&gt;实际大小，就用value填充。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="元素操作-1"><a href="#元素操作-1" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;        <span class="comment">// 第一个元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;  <span class="comment">// 第一个元素，只读。</span></span><br><span class="line"><span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;  <span class="comment">// 最后一个元素，只读。</span></span><br><span class="line"><span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;        <span class="comment">// 最后一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="赋值操作-2"><a href="#赋值操作-2" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给已存在的容器赋值，将覆盖容器中原有的内容。</span></span><br><span class="line"><span class="number">1</span>）list &amp;<span class="keyword">operator</span>=(<span class="type">const</span> list&lt;T&gt; &amp;l);         <span class="comment">// 把容器l赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）list &amp;<span class="keyword">operator</span>=(initializer_list&lt;T&gt; il);  <span class="comment">// 用统一初始化列表给当前容器赋值。</span></span><br><span class="line"><span class="number">3</span>）<span class="function">list <span class="title">assign</span><span class="params">(initializer_list&lt;T&gt; il)</span></span>;        <span class="comment">// 使用统一初始化列表赋值。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">list <span class="title">assign</span><span class="params">(Iterator first, Iterator last)</span></span>;  <span class="comment">// 用迭代器赋值。</span></span><br><span class="line"><span class="number">5</span>）<span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 把n个value给容器赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="交换、反转、排序、归并"><a href="#交换、反转、排序、归并" class="headerlink" title="交换、反转、排序、归并"></a>交换、反转、排序、归并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(list&lt;T&gt; &amp;l)</span></span>;   <span class="comment">// 把当前容器与l交换，交换的是链表结点的地址。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>;           <span class="comment">// 反转链表。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;              <span class="comment">// 对容器中的元素进行升序排序。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(_Pr2 _Pred)</span></span>;    <span class="comment">// 对容器中的元素进行排序，排序的方法由_Pred决定（二元函数）。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&lt;T&gt; &amp;l)</span></span>;  <span class="comment">// 采用归并法合并两个已排序的list容器，合并后的list容器仍是有序的。</span></span><br></pre></td></tr></table></figure>


<h3 id="比较操作-2"><a href="#比较操作-2" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> vector&lt;T&gt; &amp; l) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> vector&lt;T&gt; &amp; l) <span class="type">const</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在链表的尾部追加一个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(…)</span></span>;           <span class="comment">// 在链表的尾部追加一个元素，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">3</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 在指定位置插入一个元素，返回指向插入元素的迭代器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">iterator <span class="title">emplace</span> <span class="params">(iterator pos, …)</span></span>;  <span class="comment">// 在指定位置插入一个元素，…用于构造元素，返回指向插入元素的迭代器。C++11</span></span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, iterator first, iterator last)</span></span>;  <span class="comment">// 在指定位置插入一个区间的元素，返回指向第一个插入元素的迭代器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;                      <span class="comment">// 从链表尾部删除一个元素。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;             <span class="comment">// 删除指定位置的元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 删除指定区间的元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">9</span>）<span class="built_in">push_front</span>(<span class="type">const</span> T&amp; value);  <span class="comment">// 在链表的头部插入一个元素。</span></span><br><span class="line"><span class="number">10</span>）<span class="built_in">emplace_front</span>(…);          <span class="comment">// 在链表的头部插入一个元素，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">11</span>）<span class="built_in">splice</span>(iterator pos, <span class="type">const</span> vector&lt;T&gt; &amp; l);	  <span class="comment">// 把另一个链表连接到当前链表。</span></span><br><span class="line"><span class="number">12</span>）<span class="built_in">splice</span>(iterator pos, <span class="type">const</span> vector&lt;T&gt; &amp; l, iterator first, iterator last);	<span class="comment">// 把另一个链表指定的区间连接到当前链表。</span></span><br><span class="line"><span class="number">13</span>）<span class="built_in">splice</span>(iterator pos, <span class="type">const</span> vector&lt;T&gt; &amp; l, iterator first);	<span class="comment">// 把另一个链表从first开始的结点连接到当前链表。</span></span><br><span class="line"><span class="number">14</span>）<span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;	 <span class="comment">// 删除链表中所有值等于value的元素。</span></span><br><span class="line"><span class="number">15</span>）<span class="function"><span class="type">void</span> <span class="title">remove_if</span><span class="params">(_Pr1 _Pred)</span></span>;    <span class="comment">// 删除链表中满足条件的元素，参数_Pred是一元函数。</span></span><br><span class="line"><span class="number">16</span>）<span class="function"><span class="type">void</span> <span class="title">unique</span><span class="params">()</span></span>;                 <span class="comment">// 删除链表中相邻的重复元素，只保留一个。</span></span><br><span class="line"><span class="number">17</span>）<span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;              <span class="comment">// 从链表头部删除一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;<span class="type">int</span>&gt;  la = &#123; <span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : la) 	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	list&lt;<span class="type">int</span>&gt;  lb = &#123; <span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : lb) 	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> first = lb.<span class="built_in">begin</span>();</span><br><span class="line">	first++;</span><br><span class="line">	<span class="keyword">auto</span> last = lb.<span class="built_in">end</span>();</span><br><span class="line">	last--;</span><br><span class="line"></span><br><span class="line">	la.<span class="built_in">splice</span>(la.<span class="built_in">begin</span>(), lb, first, last);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : la) 	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;lb.size()=&quot;</span> &lt;&lt; lb.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : lb) 	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pair键值对"><a href="#pair键值对" class="headerlink" title="pair键值对"></a>pair键值对</h2><ul>
<li>pair是类模板，一般用于表示key&#x2F;value数据，其实是结构体。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pair结构模板的定义如下：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span> </span><br><span class="line">&#123; </span><br><span class="line">    T1 first;     <span class="comment">// 第一个成员，一般表示key。</span></span><br><span class="line">    T2 second;  <span class="comment">// 第二个成员，一般表示value。</span></span><br><span class="line">	<span class="built_in">pair</span>();       <span class="comment">// 默认构造函数。</span></span><br><span class="line">	<span class="built_in">pair</span>(<span class="type">const</span> T1 &amp;val1,<span class="type">const</span> T2 &amp;val2);   <span class="comment">// 有两个参数的构造函数。</span></span><br><span class="line">	<span class="built_in">pair</span>(<span class="type">const</span> pair&lt;T1,T2&gt; &amp;p);           <span class="comment">// 拷贝构造函数。</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(pair&lt;T1,T2&gt; &amp;p)</span></span>;           <span class="comment">// 交换两个pair。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//make_pair函数模板的定义如下：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="built_in">make_pair</span>(<span class="type">const</span> T1 &amp;first,<span class="type">const</span> T2 &amp;second)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;T1,T2&gt;(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
例子<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line">	T1 first;        <span class="comment">// 第一个成员，一般表示key。</span></span><br><span class="line">	T2 second;  <span class="comment">// 第二个成员，一般表示value。</span></span><br><span class="line">	<span class="built_in">Pair</span>()  &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了有默认的构造函数。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Pair</span>(<span class="type">const</span> T1&amp; val1, <span class="type">const</span> T2&amp; val2) :<span class="built_in">first</span>(val1), <span class="built_in">second</span>(val2)  &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了有两个参数的构造函数。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Pair</span>(<span class="type">const</span> Pair&lt;T1, T2&gt;&amp; p) : <span class="built_in">first</span>(p.first),<span class="built_in">second</span>(p.second)  &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了拷贝构造函数。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function">Pair&lt;T1, T2&gt; <span class="title">make_Pair</span><span class="params">(<span class="type">const</span> T1&amp; first, <span class="type">const</span> T2&amp; second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Pair&lt;T1, T2&gt; p(first, second);</span></span><br><span class="line">	<span class="comment">// return p;        // 返回局部对象。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Pair</span>&lt;T1, T2&gt;(first, second);  <span class="comment">// 返回临时对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//pair&lt;int, string&gt; p0;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p0 first=&quot; &lt;&lt; p0.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p0.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//pair&lt;int, string&gt; p1(1, &quot;西施1&quot;);    // 两个参数的构造函数。</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p1 first=&quot; &lt;&lt; p1.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p1.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//pair&lt;int, string&gt; p2 = p1;             // 拷贝构造。</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p2 first=&quot; &lt;&lt; p2.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p2.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//pair&lt;int, string&gt; p3 = &#123; 3, &quot;西施3&quot; &#125;;   // 两个参数的构造函数。</span></span><br><span class="line">	<span class="comment">//// pair&lt;int, string&gt; p3 &#123; 3, &quot;西施3&quot; &#125;;   // 两个参数的构造函数，省略了等于号。</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p3 first=&quot; &lt;&lt; p3.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p3.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> p4 = <span class="built_in">Pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;西施4&quot;</span>);   <span class="comment">// 匿名对象（显式调用构造函数）。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p4 first=&quot;</span> &lt;&lt; p4.first &lt;&lt; <span class="string">&quot;,second=&quot;</span> &lt;&lt; p4.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> p5 = <span class="built_in">make_Pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">5</span>, <span class="string">&quot;西施5&quot;</span>);   <span class="comment">// make_pair()返回的临时对象。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p5 first=&quot;</span> &lt;&lt; p5.first &lt;&lt; <span class="string">&quot;,second=&quot;</span> &lt;&lt; p5.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//pair&lt;int, string&gt; p6 = make_pair(6, &quot;西施6&quot;);  // 慎用，让make_pair()函数自动推导，再调用拷贝构造，再隐式转换。</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p6 first=&quot; &lt;&lt; p6.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p6.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//auto p7 = make_pair(7, &quot;西施7&quot;);    // 慎用，让make_pair()函数自动推导，再调用拷贝构造。</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p7 first=&quot; &lt;&lt; p7.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p7.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//p5.swap(p4);   // 交换两个pair。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p4 first=&quot; &lt;&lt; p4.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p4.second &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p5 first=&quot; &lt;&lt; p5.first &lt;&lt; &quot;,second=&quot; &lt;&lt; p5.second &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//struct st_girl</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	string name;</span></span><br><span class="line">	<span class="comment">//	int   age;</span></span><br><span class="line">	<span class="comment">//	double height;</span></span><br><span class="line">	<span class="comment">//&#125;;</span></span><br><span class="line">	<span class="comment">//// 用pair存放结构体数据。</span></span><br><span class="line">	<span class="comment">//pair&lt;int, st_girl&gt; p = &#123; 3,&#123;&quot;西施&quot;,23,48.6&#125; &#125;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p first=&quot; &lt;&lt; p.first &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p second.name=&quot; &lt;&lt; p.second.name &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p second.age=&quot; &lt;&lt; p.second.age &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p second.height=&quot; &lt;&lt; p.second.height &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h2><ul>
<li>map 容器封装了红黑树（平衡二叉排序树），用于查找。</li>
<li>包含头文件： <code>#include&lt;map&gt;</code></li>
<li>map容器的元素是pair键值对。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map类模板的声明：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">P</span> = less&lt;K&gt;, <span class="keyword">class</span> _Alloc = allocator&lt;pair&lt;<span class="type">const</span> K, V &gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> map : <span class="keyword">public</span> _Tree&lt;_Tmap_traits&lt; K, V, P, _Alloc, <span class="literal">false</span>&gt;&gt; </span><br><span class="line">&#123;</span><br><span class="line">   	… </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>第一个模板参数K：key的数据类型（pair.first）。</li>
<li>第二个模板参数V：value的数据类型（pair.second）。</li>
<li>第三个模板参数P：排序方法，缺省按key升序。</li>
<li>第四个模板参数_Alloc：分配器，缺省用new和delete。</li>
<li>map提供了双向迭代器。</li>
</ul>
<h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">map</span>();  <span class="comment">// 创建一个空的map容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">map</span>(initializer_list&lt;pair&lt;K,V&gt;&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">map</span>(<span class="type">const</span> map&lt;K,V&gt;&amp; m);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">map</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建map容器。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">map</span>(map&lt;K,V&gt;&amp;&amp; m);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1）map();  // 创建一个空的map容器。</span></span><br><span class="line">	map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2）map(initializer_list&lt;pair&lt;K, V&gt;&gt; il); // 使用统一初始化列表。</span></span><br><span class="line">	<span class="function">map&lt;<span class="type">int</span>, string&gt; <span class="title">m2</span><span class="params">( &#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="number">7</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line">	<span class="comment">// map&lt;int, string&gt; m2=&#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line">	<span class="comment">// map&lt;int, string&gt; m2   &#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m2)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3）map(const map&lt;K, V&gt;&amp;m);  // 拷贝构造函数。</span></span><br><span class="line">	map&lt;<span class="type">int</span>, string&gt; m3 = m2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m3)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4）map(Iterator first, Iterator last);  // 用迭代器创建map容器。</span></span><br><span class="line">	<span class="keyword">auto</span> first = m3.<span class="built_in">begin</span>();  first++;</span><br><span class="line">	<span class="keyword">auto</span> last = m3.<span class="built_in">end</span>();  last--;</span><br><span class="line">	<span class="function">map&lt;<span class="type">int</span>, string&gt; <span class="title">m4</span><span class="params">(first,last)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m4)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 5）map(map&lt;K, V&gt; &amp;&amp; m);  // 移动构造函数（C++11标准）。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="特性操作-3"><a href="#特性操作-3" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 返回容器的实际大小（已使用的空间）。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="元素操作-2"><a href="#元素操作-2" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K key);             <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="type">const</span> V &amp;<span class="keyword">operator</span>[](K key) <span class="type">const</span>;  <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K key)</span></span>;                     <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> V &amp;<span class="title">at</span><span class="params">(K key)</span> <span class="type">const</span></span>;         <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong><br>1）<code>[ ]</code>运算符：如果指定键不存在，会向容器中添加新的键值对；如果指定键不存在，则读取或修改容器中指定键的值。<br>2）at()成员函数：如果指定键不存在，不会向容器中添加新的键值对，而是直接抛出out_of_range 异常<br>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">map&lt;string, string&gt; <span class="title">m</span><span class="params">( &#123; &#123; <span class="string">&quot;08&quot;</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="string">&quot;03&quot;</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="string">&quot;01&quot;</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="string">&quot;07&quot;</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="string">&quot;05&quot;</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m[08]=&quot;</span> &lt;&lt; m[<span class="string">&quot;08&quot;</span>] &lt;&lt; endl;     <span class="comment">// 显示key为08的元素的value。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m[09]=&quot;</span> &lt;&lt; m[<span class="string">&quot;09&quot;</span>] &lt;&lt; endl;    <span class="comment">// 显示key为09的元素的value。key为09的元素不存在，将添加新的键值对。</span></span><br><span class="line">	m[<span class="string">&quot;07&quot;</span>] = <span class="string">&quot;花花&quot;</span>;                                          <span class="comment">// 把key为07的元素的value修改为花花。</span></span><br><span class="line">	m[<span class="string">&quot;12&quot;</span>] = <span class="string">&quot;小乔&quot;</span>;                                          <span class="comment">// 将添加新的键值对。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="赋值操作-3"><a href="#赋值操作-3" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给已存在的容器赋值，将覆盖容器中原有的内容。</span><br><span class="line"><span class="number">1</span>）map&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> map&lt;K,V&gt;&amp; m);         <span class="comment">// 把容器m赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）map&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  <span class="comment">// 用统一初始化列表给当前容器赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="交换操作-2"><a href="#交换操作-2" class="headerlink" title="交换操作"></a>交换操作</h3><ul>
<li><code>void swap(map&lt;K,V&gt;&amp; m);    // 把当前容器与m交换。</code></li>
<li>交换的是树的根结点。</li>
</ul>
<h3 id="比较操作-3"><a href="#比较操作-3" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> map&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> map&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h3><p><strong>查找键值为key的键值对</strong></p>
<ul>
<li>在map容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span>; </span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>查找键值&gt;&#x3D;key的键值对</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在map容器中查找第一个键值&gt;=key的键值对，成功返回迭代器；失败返回<span class="built_in">end</span>()。</span><br><span class="line">iterator <span class="built_in">lower_bound</span>(<span class="type">const</span> K &amp;key); </span><br><span class="line"><span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure>

<p><strong>查找键&gt;key的键值对</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在map容器中查找第一个键值&gt;key的键值对，成功返回迭代器；失败返回<span class="built_in">end</span>()。</span><br><span class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span>; </span><br><span class="line"><span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure>

<p><strong>统计键值对的个数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">统计map容器中键值为key的键值对的个数。</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">map&lt;string, string&gt; <span class="title">m</span><span class="params">( &#123; &#123; <span class="string">&quot;08&quot;</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="string">&quot;03&quot;</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="string">&quot;01&quot;</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="string">&quot;07&quot;</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="string">&quot;05&quot;</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在map容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。</span></span><br><span class="line">	<span class="keyword">auto</span> it1 = m.<span class="built_in">find</span>(<span class="string">&quot;05&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (it1 != m.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; it1-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it1-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在map容器中查找第一个键值 &gt;= key的键值对，成功返回迭代器；失败返回end()。</span></span><br><span class="line">	<span class="keyword">auto</span> it2 = m.<span class="built_in">lower_bound</span>(<span class="string">&quot;05&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (it2 != m.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; it2-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it2-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	在map容器中查找第一个键值 &gt; key的键值对，成功返回迭代器；失败返回end()。</span></span><br><span class="line">	<span class="keyword">auto</span> it3 = m.<span class="built_in">upper_bound</span>(<span class="string">&quot;05&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (it3 != m.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找成功：&quot;</span> &lt;&lt; it3-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it3-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;查找失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	统计map容器中键值为key的键值对的个数。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count(05)=&quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;05&quot;</span>) &lt;&lt; endl;   <span class="comment">// 返回1。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count(06)=&quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&quot;06&quot;</span>) &lt;&lt; endl;   <span class="comment">// 返回0。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="插入和删除-2"><a href="#插入和删除-2" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(initializer_list&lt;pair&lt;K,V&gt;&gt; il)</span></span>;  <span class="comment">// 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K,V&gt; &amp;value)</span></span>;  <span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器插入一个区间的元素。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">emplace</span> <span class="params">(...)</span></span>;  <span class="comment">// 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">例：mm.<span class="built_in">emplace</span>(piecewise_construct, forward_as_tuple(<span class="number">8</span>), forward_as_tuple(<span class="string">&quot;冰冰&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator pos,...)</span></span>; <span class="comment">// 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义，如果提示的位置是正确的，对性能有提升，如果提示的位置不正确，性能反而略有下降，但是，插入是否成功与该参数元关。该参数常用end()和begin()。成功返回新插入元素的迭代器；如果元素已经存在，则插入失败，返回现有元素的迭代器。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K &amp; key)</span></span>;  <span class="comment">// 从容器中删除指定key的元素，返回已删除元素的个数。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;  <span class="comment">// 用迭代器删除元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器删除一个区间的元素，返回下一个有效的迭代器。</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>        <span class="comment">// 超女类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;   <span class="comment">// 超女姓名。</span></span><br><span class="line">	<span class="type">int</span>      m_age;       <span class="comment">// 超女年龄。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*CGirl() : m_age(0) &#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;默认构造函数。\n&quot;;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="built_in">CGirl</span>(<span class="type">const</span> string name, <span class="type">const</span> <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;两个参数的构造函数。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp; g) : <span class="built_in">m_name</span>(g.m_name), <span class="built_in">m_age</span>(g.m_age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//map&lt;int, CGirl&gt; mm;</span></span><br><span class="line">	<span class="comment">//mm.insert     (pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">//mm.insert     (make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">//mm.emplace(pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">//mm.emplace(make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">//mm.emplace(8, CGirl(&quot;冰冰&quot;, 18));                                             // 一次构造函数，一次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">//mm.emplace(8, &quot;冰冰&quot;, 18);                                                        // 错误。</span></span><br><span class="line">	<span class="comment">//mm.emplace(piecewise_construct, forward_as_tuple(8), forward_as_tuple(&quot;冰冰&quot;, 18));  // 一次构造函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (const auto&amp; val : mm)</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; val.first &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;  &quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//return 0;</span></span><br><span class="line"></span><br><span class="line">	map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1）void insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  // 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line">	m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125;&#125;);</span><br><span class="line">	m.<span class="built_in">insert</span>(&#123; <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span>), <span class="built_in">make_pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;金莲&quot;</span>), &#123;<span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span>&#125;&#125;);</span><br><span class="line">	m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">18</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2）pair&lt;iterator,bool&gt; insert(const pair&lt;K,V&gt; &amp;value);  </span></span><br><span class="line">	<span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">	<span class="keyword">auto</span> ret = m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">18</span>, <span class="string">&quot;花花&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (ret.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3）void insert(iterator first, iterator last);  // 用迭代器插入一个区间的元素。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4）pair&lt;iterator, bool&gt; emplace(...);  </span></span><br><span class="line">	<span class="comment">// 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。</span></span><br><span class="line">	<span class="comment">// 返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">	<span class="keyword">auto</span> ret1 = m.<span class="built_in">emplace</span>(<span class="number">20</span>, <span class="string">&quot;花花&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret1.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret1.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret1.first-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5）iterator emplace_hint(const_iterator pos, ...); </span></span><br><span class="line">	<span class="comment">// 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义，如果提示的位置是正确的，</span></span><br><span class="line">	<span class="comment">// 对性能有提升，如果提示的位置不正确，性能反而略有下降，但是，插入是否成功与该参数元关。</span></span><br><span class="line">	<span class="comment">// 该参数常用end()和begin()。成功返回新插入元素的迭代器；如果元素已经存在，则插入失败，返回现</span></span><br><span class="line">	<span class="comment">// 有元素的迭代器。</span></span><br><span class="line">	m.<span class="built_in">emplace_hint</span>(m.<span class="built_in">begin</span>(), piecewise_construct, forward_as_tuple(<span class="number">23</span>), forward_as_tuple(<span class="string">&quot;冰棒&quot;</span>)); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="unordered-map容器"><a href="#unordered-map容器" class="headerlink" title="unordered_map容器"></a>unordered_map容器</h2><ul>
<li>unordered_map容器封装了哈希表，查找、插入和删除元素时，只需要比较几次key的值。</li>
<li>包含头文件： <code>#include&lt;unordered_map&gt;</code></li>
<li>unordered_map容器的元素是pair键值对。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unordered_map类模板的声明：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">_Hasher</span> = hash&lt;K&gt;, <span class="keyword">class</span> _Keyeq = equal_to&lt;K&gt;,</span><br><span class="line">    <span class="keyword">class</span> _Alloc = allocator&lt;pair&lt;<span class="type">const</span> K, V&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_map : <span class="keyword">public</span> _Hash&lt;_Umap_traits&lt;K, V, _Uhash_compare&lt;K, _Hasher, _Keyeq&gt;, _Alloc, <span class="literal">false</span>&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建std::unordered_map类模板的别名：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> K,<span class="keyword">class</span> V&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>第一个模板参数K：key的数据类型（pair.first）</li>
<li>第二个模板参数V：value的数据类型（pair.second）</li>
<li>第三个模板参数_Hasher：哈希函数，默认值为<code>std::hash&lt;K&gt;</code></li>
<li>第四个模板参数_Keyeq：比较函数，用于判断两个key是否相等，默认值是<code>std::equal_to&lt;K&gt;</code></li>
<li>第五个模板参数_Alloc：分配器，缺省用new和delete</li>
</ul>
<h3 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">umap</span>();  <span class="comment">// 创建一个空的umap容器。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">umap</span>(<span class="type">size_t</span> bucket);  <span class="comment">// 创建一个空的umap容器，指定了桶的个数，下同。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">umap</span>(initializer_list&lt;pair&lt;K,V&gt;&gt; il); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">umap</span>(initializer_list&lt;pair&lt;K,V&gt;&gt; il, <span class="type">size_t</span> bucket); <span class="comment">// 使用统一初始化列表。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">umap</span>(Iterator first, Iterator last);  <span class="comment">// 用迭代器创建umap容器。</span></span><br><span class="line"><span class="number">6</span>）<span class="built_in">umap</span>(Iterator first, Iterator last, <span class="type">size_t</span> bucket);  <span class="comment">// 用迭代器创建umap容器。</span></span><br><span class="line"><span class="number">7</span>）<span class="built_in">umap</span>(<span class="type">const</span> umap&lt;K,V&gt;&amp; m);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">8</span>）<span class="built_in">umap</span>(umap&lt;K,V&gt;&amp;&amp; m);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1）umap();  // 创建一个空的map容器。</span></span><br><span class="line">	umap&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2）umap(initializer_list&lt;pair&lt;K, V&gt;&gt; il); // 使用统一初始化列表。</span></span><br><span class="line">	<span class="function">umap&lt;<span class="type">int</span>, string&gt; <span class="title">m2</span><span class="params">(&#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="number">7</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125;)</span></span>;</span><br><span class="line">	<span class="comment">// umap&lt;int, string&gt; m2=&#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line">	<span class="comment">// umap&lt;int, string&gt; m2   &#123; &#123; 8,&quot;冰冰&quot; &#125;, &#123; 3,&quot;西施&quot; &#125;, &#123; 1,&quot;幂幂&quot; &#125;, &#123; 7,&quot;金莲&quot; &#125;, &#123; 5,&quot;西瓜&quot; &#125; &#125;;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m2)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3）umap(const map&lt;K, V&gt;&amp;m);  // 拷贝构造函数。</span></span><br><span class="line">	umap&lt;<span class="type">int</span>, string&gt; m3 = m2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m3)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4）umap(Iterator first, Iterator last);  // 用迭代器创建map容器。</span></span><br><span class="line">	<span class="keyword">auto</span> first = m3.<span class="built_in">begin</span>();  first++;</span><br><span class="line">	<span class="keyword">auto</span> last = m3.<span class="built_in">end</span>();  last--;</span><br><span class="line">	<span class="function">umap&lt;<span class="type">int</span>, string&gt; <span class="title">m4</span><span class="params">(first, last)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m4)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5）umap(map&lt;K, V&gt; &amp;&amp; m);  // 移动构造函数（C++11标准）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特性操作-4"><a href="#特性操作-4" class="headerlink" title="特性操作"></a>特性操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 返回容器中元素的个数。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;      <span class="comment">// 判断容器是否为空。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;             <span class="comment">// 清空容器。</span></span><br><span class="line"><span class="number">4</span>）<span class="function"><span class="type">size_t</span> <span class="title">max_bucket_count</span><span class="params">()</span></span>;     <span class="comment">// 返回容器底层最多可以使用多少桶，无意义。</span></span><br><span class="line"><span class="number">5</span>）<span class="function"><span class="type">size_t</span> <span class="title">bucket_count</span><span class="params">()</span></span>;          <span class="comment">// 返回容器桶的数量，空容器有8个桶。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">float</span> <span class="title">load_factor</span><span class="params">()</span></span>;   <span class="comment">// 返回容器当前的装填因子，load_factor() = size() / bucket_count()。</span></span><br><span class="line"><span class="number">7</span>）<span class="function"><span class="type">float</span> <span class="title">max_load_factor</span><span class="params">()</span></span>;        <span class="comment">// 返回容器的最大装填因子，达到该值后，容器将扩充，缺省为1。</span></span><br><span class="line"><span class="number">8</span>）<span class="function"><span class="type">void</span> <span class="title">max_load_factor</span> <span class="params">(<span class="type">float</span> z )</span></span>; <span class="comment">// 设置容器的最大装填因子。</span></span><br><span class="line"><span class="number">9</span>）<span class="function">iterator <span class="title">begin</span><span class="params">(<span class="type">size_t</span> n)</span></span>;        <span class="comment">// 返回第n个桶中第一个元素的迭代器。</span></span><br><span class="line"><span class="number">10</span>）<span class="function">iterator <span class="title">end</span><span class="params">(<span class="type">size_t</span> n)</span></span>;          <span class="comment">// 返回第n个桶中最后一个元素尾后的迭代器。</span></span><br><span class="line"><span class="number">11</span>）<span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span>;          <span class="comment">// 将容器设置为至少n个桶。</span></span><br><span class="line"><span class="number">12</span>）<span class="function"><span class="type">void</span> <span class="title">rehash</span><span class="params">(<span class="type">size_t</span> n)</span></span>;           <span class="comment">// 将桶的数量调整为&gt;=n。如果n大于当前容器的桶数，该方法会将容器重新哈希；如果n的值小于当前容器的桶数，该方法可能没有任何作用。</span></span><br><span class="line"><span class="number">13</span>）<span class="function"><span class="type">size_t</span> <span class="title">bucket_size</span><span class="params">(<span class="type">size_t</span> n)</span></span>;     <span class="comment">// 返回第n个桶中元素的个数，0 &lt;= n &lt; bucket_count()。</span></span><br><span class="line"><span class="number">14</span>）<span class="function"><span class="type">size_t</span> <span class="title">bucket</span><span class="params">(K &amp;key)</span></span>;          <span class="comment">// 返回值为key的元素对应的桶的编号。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="元素操作-3"><a href="#元素操作-3" class="headerlink" title="元素操作"></a>元素操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V &amp;<span class="keyword">operator</span>[](K key);             <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="type">const</span> V &amp;<span class="keyword">operator</span>[](K key) <span class="type">const</span>;  <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"><span class="function">V &amp;<span class="title">at</span><span class="params">(K key)</span></span>;                     <span class="comment">// 用给定的key访问元素。</span></span><br><span class="line"><span class="function"><span class="type">const</span> V &amp;<span class="title">at</span><span class="params">(K key)</span> <span class="type">const</span></span>;         <span class="comment">// 用给定的key访问元素，只读。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">umap&lt;string, string&gt; <span class="title">m</span><span class="params">( &#123; &#123; <span class="string">&quot;08&quot;</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="string">&quot;03&quot;</span>,<span class="string">&quot;西施&quot;</span> &#125;, &#123; <span class="string">&quot;01&quot;</span>,<span class="string">&quot;幂幂&quot;</span> &#125;, &#123; <span class="string">&quot;07&quot;</span>,<span class="string">&quot;金莲&quot;</span> &#125;, &#123; <span class="string">&quot;05&quot;</span>,<span class="string">&quot;西瓜&quot;</span> &#125; &#125; )</span></span>;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m[08]=&quot;</span> &lt;&lt; m[<span class="string">&quot;08&quot;</span>] &lt;&lt; endl;     <span class="comment">// 显示key为08的元素的value。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m[09]=&quot;</span> &lt;&lt; m[<span class="string">&quot;09&quot;</span>] &lt;&lt; endl;    <span class="comment">// 显示key为09的元素的value。key为09的元素不存在，将添加新的键值对。</span></span><br><span class="line">	m[<span class="string">&quot;07&quot;</span>] = <span class="string">&quot;花花&quot;</span>;                                          <span class="comment">// 把key为07的元素的value修改为花花。</span></span><br><span class="line">	m[<span class="string">&quot;12&quot;</span>] = <span class="string">&quot;小乔&quot;</span>;                                          <span class="comment">// 将添加新的键值对。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="赋值操作-4"><a href="#赋值操作-4" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给已存在的容器赋值，将覆盖容器中原有的内容。</span><br><span class="line"><span class="number">1</span>）umap&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> umap&lt;K,V&gt;&amp; m);       <span class="comment">// 把容器m赋值给当前容器。</span></span><br><span class="line"><span class="number">2</span>）umap&lt;K,V&gt; &amp;<span class="keyword">operator</span>=(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  <span class="comment">// 用统一初始化列表给容器赋值。</span></span><br></pre></td></tr></table></figure>
<h3 id="交换操作-3"><a href="#交换操作-3" class="headerlink" title="交换操作"></a>交换操作</h3><ul>
<li><code>void swap(umap&lt;K,V&gt;&amp; m);</code>    &#x2F;&#x2F; 把当前容器与m交换。</li>
<li>交换的是树的根结点。</li>
</ul>
<h3 id="比较操作-4"><a href="#比较操作-4" class="headerlink" title="比较操作"></a>比较操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> umap&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> umap&lt;K,V&gt;&amp; m) <span class="type">const</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="查找操作-2"><a href="#查找操作-2" class="headerlink" title="查找操作"></a>查找操作</h3><p><strong>查找键值为key的键值对</strong><br>在umap容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span>; </span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K &amp;key)</span> <span class="type">const</span></span>;  <span class="comment">// 只读。</span></span><br></pre></td></tr></table></figure>

<p><strong>统计键值对的个数</strong><br>统计umap容器中键值为key的键值对的个数。</p>
<ul>
<li><code>size_t count(const K &amp;key) const;</code></li>
</ul>
<h3 id="插入和删除-3"><a href="#插入和删除-3" class="headerlink" title="插入和删除"></a>插入和删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(initializer_list&lt;pair&lt;K,V&gt;&gt; il)</span></span>;  <span class="comment">// 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line"><span class="number">2</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K,V&gt; &amp;value)</span></span>;  <span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器插入一个区间的元素。</span></span><br><span class="line"><span class="number">4</span>）<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">emplace</span> <span class="params">(...)</span></span>;  <span class="comment">// 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">例：mm.<span class="built_in">emplace</span>(piecewise_construct, forward_as_tuple(<span class="number">8</span>), forward_as_tuple(<span class="string">&quot;冰冰&quot;</span>, <span class="number">18</span>));</span><br><span class="line"><span class="number">5</span>）<span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator pos,...)</span></span>; <span class="comment">// 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义。对哈希容器来说，此函数意义不大。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K &amp; key)</span></span>;  <span class="comment">// 从容器中删除指定key的元素，返回已删除元素的个数。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;  <span class="comment">// 用迭代器删除元素，返回下一个有效的迭代器。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>;  <span class="comment">// 用迭代器删除一个区间的元素，返回下一个有效的迭代器。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">using</span> umap = std::unordered_map&lt;K, V&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>        <span class="comment">// 超女类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;   <span class="comment">// 超女姓名。</span></span><br><span class="line">	<span class="type">int</span>      m_age;       <span class="comment">// 超女年龄。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*CGirl() : m_age(0) &#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;默认构造函数。\n&quot;;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="built_in">CGirl</span>(<span class="type">const</span> string name, <span class="type">const</span> <span class="type">int</span> age) : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;两个参数的构造函数。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; g) : <span class="built_in">m_name</span>(g.m_name), <span class="built_in">m_age</span>(g.m_age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//umap&lt;int, CGirl&gt; mm;</span></span><br><span class="line">	<span class="comment">////mm.insert     (pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">////mm.insert     (make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">////mm.emplace(pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));                // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">////mm.emplace(make_pair&lt;int, CGirl&gt;(8, CGirl(&quot;冰冰&quot;, 18)));     // 一次构造函数，两次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">////mm.emplace(8, CGirl(&quot;冰冰&quot;, 18));                                             // 一次构造函数，一次拷贝构造函数。</span></span><br><span class="line">	<span class="comment">////// mm.emplace(8, &quot;冰冰&quot;, 18);                                                        // 错误。</span></span><br><span class="line">	<span class="comment">//mm.emplace(piecewise_construct, forward_as_tuple(8), forward_as_tuple(&quot;冰冰&quot;, 18));  // 一次构造函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (const auto&amp; val : mm)</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; val.first &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;,&quot; &lt;&lt; val.second.m_name &lt;&lt; &quot;  &quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//return 0;</span></span><br><span class="line"></span><br><span class="line">	umap&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1）void insert(initializer_list&lt;pair&lt;K,V&gt;&gt; il);  // 用统一初始化列表在容器中插入多个元素。</span></span><br><span class="line">	m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">8</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125; &#125;);</span><br><span class="line">	m.<span class="built_in">insert</span>(&#123; <span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;幂幂&quot;</span>), <span class="built_in">make_pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;金莲&quot;</span>), &#123;<span class="number">5</span>,<span class="string">&quot;西瓜&quot;</span>&#125; &#125;);</span><br><span class="line">	m.<span class="built_in">insert</span>(&#123; &#123; <span class="number">18</span>,<span class="string">&quot;冰冰&quot;</span> &#125;, &#123; <span class="number">3</span>,<span class="string">&quot;西施&quot;</span> &#125; &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2）pair&lt;iterator,bool&gt; insert(const pair&lt;K,V&gt; &amp;value);  </span></span><br><span class="line">	<span class="comment">// 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">	<span class="keyword">auto</span> ret = m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">18</span>, <span class="string">&quot;花花&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (ret.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3）void insert(iterator first, iterator last);  // 用迭代器插入一个区间的元素。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4）pair&lt;iterator, bool&gt; emplace(...);  </span></span><br><span class="line">	<span class="comment">// 将创建新键值对所需的数据作为参数直接传入，umap容器将直接构造元素。</span></span><br><span class="line">	<span class="comment">// 返回值pair：first是已插入元素的迭代器，second是插入结果。</span></span><br><span class="line">	<span class="keyword">auto</span> ret1 = m.<span class="built_in">emplace</span>(<span class="number">20</span>, <span class="string">&quot;花花&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret1.second == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;插入成功：&quot;</span> &lt;&lt; ret1.first-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ret1.first-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;插入失败。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5）iterator emplace_hint(const_iterator pos, ...); </span></span><br><span class="line">	m.<span class="built_in">emplace_hint</span>(m.<span class="built_in">begin</span>(), piecewise_construct, forward_as_tuple(<span class="number">23</span>), forward_as_tuple(<span class="string">&quot;冰棒&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : m)</span><br><span class="line">		cout &lt;&lt; val.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; val.second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h2><ul>
<li>queue容器的逻辑结构是队列，物理结构可以是数组或链表，主要用于多线程之间的数据共享。</li>
<li>包含头文件： <code>#include&lt;queue&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue类模板的声明：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">_Container</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue&#123;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个模板参数T：元素的数据类型。</li>
<li>第二个模板参数_Container：底层容器的类型，缺省是std::deque，可以用std::list，还可以用自定义的类模板。</li>
<li>queue容器不支持迭代器</li>
</ul>
<h3 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">queue</span>();  <span class="comment">// 创建一个空的队列。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">queue</span>(<span class="type">const</span> queue&lt;T&gt;&amp; q);  <span class="comment">// 拷贝构造函数。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">queue</span>(queue&lt;T&gt;&amp;&amp; q);  <span class="comment">// 移动构造函数（C++11标准）。</span></span><br><span class="line">析构函数~<span class="built_in">queue</span>()释放内存空间。</span><br></pre></td></tr></table></figure>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;  <span class="comment">// 元素入队。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">emplace</span><span class="params">(…)</span></span>;           <span class="comment">// 元素入队，…用于构造元素。C++11</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">// 返回队列中元素的个数。</span></span><br><span class="line"><span class="number">4</span>）<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 判断队列是否为空。</span></span><br><span class="line"><span class="number">5</span>）<span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;                 <span class="comment">// 返回队头元素。</span></span><br><span class="line"><span class="number">6</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;           <span class="comment">// 返回队头元素，只读。</span></span><br><span class="line"><span class="number">7</span>）<span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;                 <span class="comment">// 返回队尾元素。</span></span><br><span class="line"><span class="number">8</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;           <span class="comment">// 返回队头元素，只读。</span></span><br><span class="line"><span class="number">9</span>）<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;                <span class="comment">// 出队，删除队头的元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">girl</span>       <span class="comment">// 超女类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_bh;             <span class="comment">// 编号。</span></span><br><span class="line">	string m_name;  <span class="comment">// 姓名。</span></span><br><span class="line">	<span class="built_in">girl</span>(<span class="type">const</span> <span class="type">int</span>&amp; bh, <span class="type">const</span> string&amp; name) : <span class="built_in">m_bh</span>(bh), <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// template &lt;class T, class _Container = deque&lt;T&gt;&gt;</span></span><br><span class="line">	<span class="comment">// class queue &#123;</span></span><br><span class="line">	<span class="comment">//	 ……</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// 第一个模板参数T：元素的数据类型。</span></span><br><span class="line">	<span class="comment">// 第二个模板参数_Container：底层容器的类型，缺省是std::deque，可以用std::list，还可以用自定义的类模板。</span></span><br><span class="line"></span><br><span class="line">	queue&lt;girl, list&lt;girl&gt;&gt; q;          <span class="comment">// 物理结构为链表。</span></span><br><span class="line">	<span class="comment">//queue&lt;girl, deque&lt;girl&gt;&gt; q;    // 物理结构为数组。</span></span><br><span class="line">	<span class="comment">//queue&lt;girl&gt; q;                           // 物理结构为数组。</span></span><br><span class="line">	<span class="comment">//queue&lt;girl, vector&lt;girl&gt;&gt; q;    // 物理结构为vector，不可以。	</span></span><br><span class="line"></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">girl</span>(<span class="number">3</span>, <span class="string">&quot;西施&quot;</span>));   <span class="comment">// 效率不高。</span></span><br><span class="line">	q.<span class="built_in">emplace</span>(<span class="number">8</span>, <span class="string">&quot;冰冰&quot;</span>);     <span class="comment">// 效率更高。</span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">girl</span>(<span class="number">5</span>, <span class="string">&quot;幂幂&quot;</span>));</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">girl</span>(<span class="number">2</span>, <span class="string">&quot;西瓜&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;编号：&quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_bh &lt;&lt; <span class="string">&quot;，姓名：&quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_name &lt;&lt; endl;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）queue &amp;<span class="keyword">operator</span>=(<span class="type">const</span> queue&lt;T&gt; &amp;q);    <span class="comment">// 赋值。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(queue&lt;T&gt; &amp;q)</span></span>;    <span class="comment">// 交换。</span></span><br><span class="line"><span class="number">3</span>）<span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> queue&lt;T&gt; &amp; q) <span class="type">const</span>; <span class="comment">// 重载==操作符。</span></span><br><span class="line"><span class="number">4</span>）<span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> queue&lt;T&gt; &amp; q) <span class="type">const</span>; <span class="comment">// 重载!=操作符。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="STL其它容器"><a href="#STL其它容器" class="headerlink" title="STL其它容器"></a>STL其它容器</h2><h3 id="array（静态数组）"><a href="#array（静态数组）" class="headerlink" title="array（静态数组）"></a>array（静态数组）</h3><p><strong>物理结构</strong><br>在栈上分配内存，创建数组的时候，数组长度必须是常量，创建后的数组大小不可变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">array</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T elems_[size]; </span><br><span class="line">	……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>迭代器</strong>：随机访问迭代器。<br><strong>特点</strong>：部分场景中，比常规数组更方便（能用于模板），可以代替常规数组。<br><strong>各种操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="function"><span class="type">void</span> <span class="title">fill</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span>;     <span class="comment">// 给数组填充值（清零）。</span></span><br><span class="line"><span class="number">2</span>）<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;               <span class="comment">// 返回数组的大小。</span></span><br><span class="line"><span class="number">3</span>）<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// 无意义。</span></span><br><span class="line"><span class="number">4</span>）T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n); </span><br><span class="line"><span class="number">5</span>）<span class="type">const</span> T &amp;<span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>;  <span class="comment">// 只读。</span></span><br><span class="line"><span class="number">6</span>）<span class="function">T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="number">7</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;          <span class="comment">// 只读。</span></span><br><span class="line"><span class="number">8</span>）<span class="function">T *<span class="title">data</span><span class="params">()</span></span>;            <span class="comment">// 返回数组的首地址。</span></span><br><span class="line"><span class="number">9</span>）<span class="function"><span class="type">const</span> T *<span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 返回数组的首地址。</span></span><br><span class="line"><span class="number">10</span>）<span class="function">T &amp;<span class="title">front</span><span class="params">()</span></span>;          <span class="comment">// 第一个元素。</span></span><br><span class="line"><span class="number">11</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">front</span><span class="params">()</span></span>;    <span class="comment">// 第一个元素，只读。</span></span><br><span class="line"><span class="number">12</span>）<span class="function"><span class="type">const</span> T &amp;<span class="title">back</span><span class="params">()</span></span>;    <span class="comment">// 最后一个元素，只读。</span></span><br><span class="line"><span class="number">13</span>）<span class="function">T &amp;<span class="title">back</span><span class="params">()</span></span>;        <span class="comment">// 最后一个元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">////void func(int arr[][6],int len)</span></span><br><span class="line"><span class="comment">//void func(int (* arr)[6], int len)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	for (int ii = 0; ii &lt; len; ii++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		for (int jj = 0; jj &lt; 6; jj++)</span></span><br><span class="line"><span class="comment">//			cout &lt;&lt; arr[ii][jj] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void func(const array &lt; array&lt;int, 5&gt;, 10 &gt;&amp; arr)  </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	for (int ii = 0; ii &lt; arr.size(); ii++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		for (int jj = 0; jj &lt; arr[ii].size(); jj++)</span></span><br><span class="line"><span class="comment">//			cout &lt;&lt; arr[ii][jj] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; arr.<span class="built_in">size</span>(); ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; arr[ii].<span class="built_in">size</span>(); jj++)</span><br><span class="line">			cout &lt;&lt; arr[ii][jj] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int aa[11] = &#123;1,2,3,4,5,6,7,8,9,10,11&#125;;         // 一维数组。</span></span><br><span class="line">	<span class="comment">//array&lt;int, 10&gt; aa = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;         // 一维数组。</span></span><br><span class="line">	<span class="comment">//for (int ii = 0; ii &lt; 10; ii++)            // 传统的方法。</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; aa[ii] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//for (int ii = 0; ii &lt; aa.size(); ii++)  // 利用array的size()方法。</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; aa[ii] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//for (auto it= aa.begin(); it &lt; aa.end(); it++)      // 使用迭代器。</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (auto val : aa)                           // 基于范围的for循环。</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; val &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//int bb[10][6];</span></span><br><span class="line">	<span class="comment">//for (int ii = 0; ii &lt; 10; ii++)  // 对二维数组赋值。</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	for (int jj = 0; jj &lt; 6; jj++)</span></span><br><span class="line">	<span class="comment">//		bb[ii][jj] = jj * 10 + ii;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func(bb,10);  // 把二维数组传给函数。</span></span><br><span class="line"></span><br><span class="line">	array&lt; array&lt;<span class="type">int</span>, 5&gt;, 10 &gt; bb;  <span class="comment">// 二维数组，相当于int bb[10][5]。</span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; bb.<span class="built_in">size</span>(); ii++)  <span class="comment">// 对二维数组赋值。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; bb[ii].<span class="built_in">size</span>(); jj++)</span><br><span class="line">			bb[ii][jj] = jj * <span class="number">10</span> + ii;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(bb);  <span class="comment">// 把二维数组传给函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="deque（双端队列）"><a href="#deque（双端队列）" class="headerlink" title="deque（双端队列）"></a>deque（双端队列）</h3><p>![[Pasted image 20231225163854.png]]<br><strong>物理结构</strong></p>
<ul>
<li>deque容器存储数据的空间是多段等长的连续空间构成，各段空间之间并不一定是连续的。</li>
<li>为了管理这些连续空间的分段，deque容器用一个数组存放着各分段的首地址。<br>![[Pasted image 20231225163918.png]]</li>
<li>通过建立数组，deque容器的分段的连续空间能实现整体连续的效果。</li>
<li>当deque容器在头部或尾部增加元素时，会申请一段新的连续空间，同时在数组中添加指向该空间的指针。<br><strong>迭代器</strong>：随机访问迭代器。<br><strong>特点</strong></li>
<li>提高了在两端插入和删除元素的效率，扩展空间的时候，不需要拷贝以前的元素。</li>
<li>在中间插入和删除元素的效率比vector更糟糕。</li>
<li>随机访问的效率比vector容器略低。<br><strong>各种操作</strong>：与vector容器相同。</li>
</ul>
<h3 id="forward-list（单链表）"><a href="#forward-list（单链表）" class="headerlink" title="forward_list（单链表）"></a>forward_list（单链表）</h3><ul>
<li>物理结构：单链表。</li>
<li>迭代器：正向迭代器。</li>
<li>特点<ul>
<li>比双链表少了一个指针，可节省一丢丢内存，减少了两次对指针的赋值操作。</li>
</ul>
</li>
<li>如果单链表能满足业务需求，建议使用单链表而不是双链表。</li>
<li>各种操作：与list容器相同。</li>
</ul>
<h3 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h3><ul>
<li>底层是红黑树</li>
<li>multimap和map的区别在：multimap允许关键字重复，而map不允许重复。</li>
<li>各种操作与map容器相同。</li>
</ul>
<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&amp;multiset"></a>set&amp;multiset</h3><ul>
<li>底层是红黑树</li>
<li>set和map的区别在：map中存储的是键值对，而set只保存关键字</li>
<li>multiset和set的区别在：multiset允许关键字重复，而set不允许重复</li>
<li>各种操作与map容器相同</li>
</ul>
<h3 id="unordered-set-unordered-multiset"><a href="#unordered-set-unordered-multiset" class="headerlink" title="unordered_set&amp;unordered_multiset"></a>unordered_set&amp;unordered_multiset</h3><ul>
<li>底层是哈希表。	</li>
<li>unordered_set和unordered_map的区别在：unordered_map中存储的是键值对，而unordered_set只保存关键字。</li>
<li>unordered_multiset和unordered_set的区别在：unordered_multiset允许关键字重复，而unordered_set不允许重复。</li>
<li>各种操作与unordered_map容器相同。</li>
</ul>
<h3 id="priority-queue（优先队列）"><a href="#priority-queue（优先队列）" class="headerlink" title="priority_queue（优先队列）"></a>priority_queue（优先队列）</h3><ul>
<li>优先级队列相当于一个有权值的单向队列queue，在这个队列中，所有元素是按照优先级排列的。</li>
<li>底层容器可以用deque和list。</li>
<li>各种操作与queue容器相同。</li>
</ul>
<h3 id="stack（栈）"><a href="#stack（栈）" class="headerlink" title="stack（栈）"></a>stack（栈）</h3><ul>
<li>底层容器可以用deque和list。</li>
</ul>
<h1 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h1><p>STL提供了很多处理容器的函数模板，它们的设计是相同的，有以下特点：</p>
<ul>
<li>用迭代器表示需要处理数据的区间。</li>
<li>返回迭代器放置处理数据的结果（如果有结果）。</li>
<li>接受一个函数对象参数（结构体模板），用于处理数据（如果需要）</li>
</ul>
<h2 id="函数的对象"><a href="#函数的对象" class="headerlink" title="函数的对象"></a>函数的对象</h2><p>很多STL算法都使用函数对象，也叫函数符（functor），包括函数名、函数指针和仿函数。<br>函数符的概念：</p>
<ul>
<li>生成器（generator）：不用参数就可以调用的函数符。</li>
<li>一元函数（unary function）：用一个参数可以调用的函数符。</li>
<li>二元函数（binary function）：用两个参数可以调用的函数符。</li>
<li>改进的概念：<ul>
<li>一元谓词（predicate）：返回bool值的一元函数。</li>
<li>二元谓词（binary predicate）：返回bool值的二元函数。</li>
</ul>
</li>
</ul>
<h2 id="预定义的函数对象"><a href="#预定义的函数对象" class="headerlink" title="预定义的函数对象"></a>预定义的函数对象</h2><ul>
<li>STL定义了多个基本的函数符，用于支持STL的算法函数。</li>
<li>包含头文件：<code>#include &lt;functional&gt;</code><br>![[Pasted image 20231225164701.png]]</li>
</ul>
<h2 id="算法函数"><a href="#算法函数" class="headerlink" title="算法函数"></a>算法函数</h2><p>STL将算法函数分成四组：<br>1）<strong>非修改式序列操作</strong>：对区间中的每个元素进行操作，这些操作不修改容器的内容。<br>2）<strong>修改式序列操作</strong>：对区间中的每个元素进行操作，这些操作可以容器的内容（可以修改值，也可以修改排列顺序）。<br>3）<strong>排序和相关操作</strong>：包括多个排序函数和其它各种函数，如集合操作。<br>4）<strong>通用数字运算</strong>：包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。通常，这些都是数组的操作特性，因此vector是最有可能使用这些操作的容器。<br>前三组在头文件<code>#include &lt;algorithm&gt;</code>中，第四组专用于数值数据，在<code>#include &lt;numeric&gt;</code>中。</p>
<p>![[Pasted image 20231225164902.png]]</p>
<p>![[Pasted image 20231225164911.png]]![[Pasted image 20231225164918.png]]![[Pasted image 20231225164929.png]]![[Pasted image 20231225164945.png]]<br>1）如果容器有成员函数，则使用成员函数，如果没有才考虑用STL的算法函数。<br>2）把全部的STL算法函数过一遍，知道大概有些什么东西。<br>3）如果打算采用某算法函数，一定要搞清楚它的原理，关注它的效率。<br>4）不要太看重这些算法函数，自己写一个也就那么回事。<br>5）不是因为简单，而是因为不常用</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul>
<li>具体示例见文档<br>1）for_each()遍历<br>2）find()遍历<br>3）find_if()遍历<br>4）find_not_if()遍历<br>5）sort()排序</li>
</ul>
<ol start="6">
<li>for_each<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">girl</span>   &#123;</span><br><span class="line">	T   m_yz;         <span class="comment">// 统计的颜值。</span></span><br><span class="line">	<span class="type">int</span> m_count;   <span class="comment">// 符合条件的元素个数。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">girl</span>(<span class="type">const</span> T yz) : <span class="built_in">m_yz</span>(yz), <span class="built_in">m_count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; yz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (yz==m_yz) 	m_count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span> &#125;;   <span class="comment">// 1-极漂亮；2-漂亮；3-普通；4-歪瓜裂枣</span></span><br><span class="line"></span><br><span class="line">	girl&lt;<span class="type">int</span>&gt; g=for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), <span class="built_in">girl</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));       <span class="comment">// 按颜值统计超女人数。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;g.m_count=&quot;</span> &lt;&lt; g.m_count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>STL的sort算法，数据量大时采用QuickSort(快速排序)，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort的递归调用带来过大的额外负荷，就改用InsertSort（插入排序）。如果递归层次过深，还会改用HeapSort（堆排序）。</li>
<li>适用于数组容器vector、string、deque（list容器有sort成员函数，红黑树和哈希表没有排序的说法）。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io/post/6ad37afc.html">https://github.com/wjl-a/data.github.io/post/6ad37afc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/wjl-a/data.github.io" target="_blank">醉卿枫の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/data.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-cpp/">程序语言/cpp</a></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2022/05/29/62939662553c9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/data.github.io/post/7148eefc.html" title="模板1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="title">模板1</div></div></a></div><div><a href="/data.github.io/post/7f157bf9.html" title="2.c++基础语法2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">2.c++基础语法2</div></div></a></div><div><a href="/data.github.io/post/36e8e938.html" title="3.c++类_基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++类_基础</div></div></a></div><div><a href="/data.github.io/post/f145b64d.html" title="1.c++类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">1.c++类</div></div></a></div><div><a href="/data.github.io/post/c010a565.html" title="3.c++模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++模板</div></div></a></div><div><a href="/data.github.io/post/2bc4fa53.html" title="2.c++类2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">2.c++类2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="this.onerror=null;this.src='/data.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">qq:2771329872</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%AE%B9%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">STL容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">string容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">构造和析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">特性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">字符操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.4.</span> <span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.5.</span> <span class="toc-text">连接操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.6.</span> <span class="toc-text">交换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%AA%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.7.</span> <span class="toc-text">截取操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.8.</span> <span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.9.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.10.</span> <span class="toc-text">替换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.11.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.12.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">特性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.3.</span> <span class="toc-text">元素操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">交换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.2.6.</span> <span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.7.</span> <span class="toc-text">插入和删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%B5%8C%E5%A5%97"><span class="toc-number">1.2.8.</span> <span class="toc-text">vector嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">正向迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">双向迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">随机访问迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">输入和输出迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.</span> <span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">特性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">元素操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.5.4.</span> <span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E3%80%81%E5%8F%8D%E8%BD%AC%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6"><span class="toc-number">1.5.5.</span> <span class="toc-text">交换、反转、排序、归并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.5.6.</span> <span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-1"><span class="toc-number">1.5.7.</span> <span class="toc-text">插入和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pair%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">1.6.</span> <span class="toc-text">pair键值对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map%E5%AE%B9%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">map容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.7.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.7.2.</span> <span class="toc-text">特性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.7.3.</span> <span class="toc-text">元素操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.7.4.</span> <span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.7.5.</span> <span class="toc-text">交换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.7.6.</span> <span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.7.7.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-2"><span class="toc-number">1.7.8.</span> <span class="toc-text">插入和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unordered-map%E5%AE%B9%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">unordered_map容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-3"><span class="toc-number">1.8.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.8.2.</span> <span class="toc-text">特性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.8.3.</span> <span class="toc-text">元素操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.8.4.</span> <span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C-3"><span class="toc-number">1.8.5.</span> <span class="toc-text">交换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C-4"><span class="toc-number">1.8.6.</span> <span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C-2"><span class="toc-number">1.8.7.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-3"><span class="toc-number">1.8.8.</span> <span class="toc-text">插入和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue%E5%AE%B9%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">queue容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-4"><span class="toc-number">1.9.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.2.</span> <span class="toc-text">常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.3.</span> <span class="toc-text">其他操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%85%B6%E5%AE%83%E5%AE%B9%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text">STL其它容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#array%EF%BC%88%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">1.10.1.</span> <span class="toc-text">array（静态数组）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque%EF%BC%88%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">deque（双端队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward-list%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">forward_list（单链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multimap"><span class="toc-number">1.10.4.</span> <span class="toc-text">multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-multiset"><span class="toc-number">1.10.5.</span> <span class="toc-text">set&amp;multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unordered-set-unordered-multiset"><span class="toc-number">1.10.6.</span> <span class="toc-text">unordered_set&amp;unordered_multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority-queue%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">1.10.7.</span> <span class="toc-text">priority_queue（优先队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack%EF%BC%88%E6%A0%88%EF%BC%89"><span class="toc-number">1.10.8.</span> <span class="toc-text">stack（栈）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">STL算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">函数的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">预定义的函数对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">算法函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">常用函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/52d1a938.html" title="8.c++_线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="8.c++_线程"/></a><div class="content"><a class="title" href="/data.github.io/post/52d1a938.html" title="8.c++_线程">8.c++_线程</a><time datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="7.c+++_智能指针_文件操作"/></a><div class="content"><a class="title" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作">7.c+++_智能指针_文件操作</a><time datetime="2023-12-23T16:00:00.000Z" title="发表于 2023-12-24 00:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="6.c++_STL"/></a><div class="content"><a class="title" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL">6.c++_STL</a><time datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="变结构无人机仿真"/></a><div class="content"><a class="title" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真">变结构无人机仿真</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/5d3e3d8b.html" title="soildworks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="soildworks"/></a><div class="content"><a class="title" href="/data.github.io/post/5d3e3d8b.html" title="soildworks">soildworks</a><time datetime="2023-10-27T13:01:00.000Z" title="发表于 2023-10-27 21:01:00">2023-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/data.github.io/js/utils.js"></script><script src="/data.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/data.github.io/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/data.github.io/js/search/local-search.js"></script></div></div></body></html>