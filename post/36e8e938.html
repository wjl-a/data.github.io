<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>3.c++类_基础 | 醉卿枫の博客</title><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c++笔记来源 类从结构体到类 对面向对象编程来说，一切都是对象，对象用类来描述 类把对象的数据和操作数据的方法作为一个整体考虑12345678910class 类名&#123;public:成员一的数据类型  成员名一;成员二的数据类型  成员名二;成员三的数据类型  成员名三;......成员n的数据类型  成员名n;&#125;; 类的成员可以是变量，也可以是函数。 类的成员变量也叫属性。">
<meta property="og:type" content="article">
<meta property="og:title" content="3.c++类_基础">
<meta property="og:url" content="https://github.com/wjl-a/data.github.io/post/36e8e938.html">
<meta property="og:site_name" content="醉卿枫の博客">
<meta property="og:description" content="c++笔记来源 类从结构体到类 对面向对象编程来说，一切都是对象，对象用类来描述 类把对象的数据和操作数据的方法作为一个整体考虑12345678910class 类名&#123;public:成员一的数据类型  成员名一;成员二的数据类型  成员名二;成员三的数据类型  成员名三;......成员n的数据类型  成员名n;&#125;; 类的成员可以是变量，也可以是函数。 类的成员变量也叫属性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png">
<meta property="article:published_time" content="2023-07-09T13:01:00.000Z">
<meta property="article:modified_time" content="2024-01-14T03:21:05.388Z">
<meta property="article:author" content="醉卿枫">
<meta property="article:tag" content="程序语言&#x2F;cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png"><link rel="shortcut icon" href="/data.github.io/img/favicon.png"><link rel="canonical" href="https://github.com/wjl-a/data.github.io/post/36e8e938.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/data.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/data.github.io/',
  algolia: undefined,
  localSearch: {"path":"/data.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '3.c++类_基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-14 11:21:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><nav id="nav"><span id="blog-info"><a href="/data.github.io/" title="醉卿枫の博客"><span class="site-name">醉卿枫の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">3.c++类_基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-09T13:01:00.000Z" title="发表于 2023-07-09 21:01:00">2023-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T03:21:05.388Z" title="更新于 2024-01-14 11:21:05">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/data.github.io/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="3.c++类_基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/553387258">c++笔记来源</a></p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="从结构体到类"><a href="#从结构体到类" class="headerlink" title="从结构体到类"></a>从结构体到类</h2><ul>
<li>对面向对象编程来说，一切都是对象，对象用类来描述</li>
<li>类把对象的数据和操作数据的方法作为一个整体考虑<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">成员一的数据类型  成员名一;</span><br><span class="line">成员二的数据类型  成员名二;</span><br><span class="line">成员三的数据类型  成员名三;</span><br><span class="line">......</span><br><span class="line">成员n的数据类型  成员名n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>类的成员可以是变量，也可以是函数。</li>
<li><strong>类的成员变量也叫属性</strong>。</li>
<li><strong>类的成员函数也叫方法</strong>&#x2F;行为，类的成员函数可以定义在类的外面。</li>
<li>用类定义一个类的变量叫创建（或实例化）一个对象。</li>
<li>对象的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGil</span>&#123;</span><br><span class="line">    string name;<span class="comment">//设置成员变量的值</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要声明，设置成员变量的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGil::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    name =name1;</span><br><span class="line">    age=age1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类.方法（）</span></span><br><span class="line"><span class="comment">//类.属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><ul>
<li>类的成员有三种访问权限：public、private 和 protected, 分别表示公有的、私有的和受保护的</li>
<li>在类的内部（类的成员函数中），无论成员被声明为 public 还是 private, 都可以访问</li>
<li>在类的外部（定义类的代码之外），只能访问 public 成员，不能访问 private、protected 成员</li>
<li>在一个类体的定义中，private 和 public 可以出现多次</li>
<li>结构体的成员缺省为 public，类的成员缺省为 private</li>
<li>private 的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为 public<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line"><span class="comment">//public可访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> speed=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        x += a * speed;</span><br><span class="line">        y += b * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x=<span class="number">5</span>;<span class="comment">//赋值</span></span><br><span class="line">    player.<span class="built_in">move</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//调用方法</span></span><br><span class="line">    cout&lt;&lt;player.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;player.y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-类与对象"><a href="#C-类与对象" class="headerlink" title="C++类与对象"></a>C++类与对象</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013921164/article/details/130929563?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=5">UML类图</a></li>
</ul>
<ol>
<li>类的成员函数可以直接访问该类其它的成员函数（可以递归）。</li>
<li>类的成员函数可以重载，可以使用默认参数。</li>
<li>类指针的用法与结构体指针用法相同。</li>
<li>类的成员可以是任意数据类型（类中枚举）。</li>
<li>可以为类的成员指定缺省值（C++11标准）。</li>
<li>类可以创建对象数组，就像结构体数组一样。</li>
<li>对象可以作为实参传递给函数，<strong>一般传引用</strong>。</li>
<li>可以用<strong>new动态创建对象，用delete释放对象</strong>。</li>
<li>在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。</li>
<li>对象一般不用memset()清空成员变量，可以写一个专用于清空成员变量的成员函数。</li>
<li>对类和对象用sizeof运算意义不大，一般不用。</li>
<li>用结构体描述纯粹的数据，用类描述对象。</li>
<li>在类的声明中定义的函数都将自动成为内联函数；在类的声明之外定义的函数如果使用了inline限定符，也是内联函数。</li>
<li>为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。</li>
<li>类的分文件编写。</li>
</ol>
<h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul>
<li>构造函数：在创建对象时，自动进行初始化工作</li>
<li>析构函数：在销毁对象前，自动完成清理工作</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>语法：类名 (){…}</li>
<li>访问权限<strong>必须是 public</strong>.</li>
<li>函数名必须<strong>与类名相同</strong>。</li>
<li>没有返回值，也不写 void。</li>
<li>可以有参数，可以重载，可以有默认参数。</li>
<li>创建对象时会自动调用一次，不能手工调用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//创建构造函数，可以多个，但是需要有不同参数</span></span><br><span class="line">    <span class="comment">//CGirl() = default; 放在类的定义中的构造函数声明处，可以告诉编译器使用默认生成的方式来生成默认构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name,<span class="type">int</span> age=<span class="number">23</span>)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//CGirl();在这里使用这个函数，含义不是调用构造函数（无参数），是创建一个匿名对象，不能这么用</span></span><br><span class="line">        m_age=age;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数2个参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>()&#123;</span><br><span class="line">    	cout&lt;&lt;<span class="string">&quot;调用析构函数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要生命，设置成员变量的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">    CGirl girl;<span class="comment">//调用没有参数的构造函数,不用括号</span></span><br><span class="line">    <span class="comment">// const char* ch=&quot;23&quot;;//等价于string ch=&quot;23&quot;,不加const 传参会报错</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;,8);//调用有两个参数的构造函数</span></span><br><span class="line">    <span class="comment">// CGirl girl&#123;&quot;西施&quot;,8&#125;;//也可以这样写，用&#123;&#125;</span></span><br><span class="line">    <span class="comment">// CGirl girl;//隐式调用构造函数，无参数无括号，常用</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl();//显示调用构造函数，无参数有括号</span></span><br><span class="line">    girl.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// girl.~CGirl();//手动调用,一般自动就会调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGirl::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    m_name =name1;</span><br><span class="line">    m_age=age1;</span><br><span class="line">    <span class="built_in">show</span>();<span class="comment">//类内部调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>语法：~类名 (){…}</li>
<li>访问权限必须是 public.</li>
<li>函数名必须在类名前加~。</li>
<li>没有返回值，也不写 void.</li>
<li>没有参数，不能重载。</li>
<li>销毁对象前只会自动调用一次，但是可以手工调用</li>
</ul>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul>
<li><p>如果没有提供构造&#x2F;析构函数，编译器将提供<strong>空实现</strong>的构造&#x2F;析构函数。</p>
</li>
<li><p>如果提供了构造&#x2F;析构函数，编译器将不提供空实现的构造&#x2F;析构函数。</p>
</li>
<li><p>创建对象的时候，如果重载了构造函数，编译器<strong>根据实参匹配</strong>相应的构造函数。</p>
</li>
<li><p>创建对象的时候<strong>不要在对象名后面加空的圆括号，编译器误认为是声明函数</strong>。(没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）</p>
</li>
<li><p>在构造函数名后面加括号和参数<strong>不是调用构造函数，是创建匿名对象</strong></p>
</li>
<li><p>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐 <code>CGirl girl=10</code></p>
</li>
<li><p>下面两行代码有本质区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGirl girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>)；<span class="comment">//显示创建对象,会调用一次构造函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CGirl girl;<span class="comment">//创建对象</span></span><br><span class="line">girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>);<span class="comment">//创建匿名对象，然后给现有对象赋值，会调用构造函数</span></span><br><span class="line"><span class="comment">//匿名对象是指在不给对象命名的情况下直接创建的对象。匿名对象通常用于临时的、一次性的操作，不需要对其进行命名和重复使用。</span></span><br></pre></td></tr></table></figure></li>
<li><p>用 new&#x2F;delete 创建&#x2F;销毁对象时，也会调用构造函数或者析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGirl *girl=<span class="keyword">new</span> <span class="built_in">CGirl</span>();<span class="comment">//显示写法用new,必须用指针形式</span></span><br><span class="line">girl-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">delete</span> girl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果类成员有指针时，析构函数需要用这段代码 <code>delete ptr;ptr=nullptr;</code></p>
</li>
<li><p>如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构自身，再析构成员类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                                  <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                                     <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="type">char</span>      m_memo[<span class="number">301</span>];                        <span class="comment">// 备注。</span></span><br><span class="line">    <span class="built_in">CGirl</span>()                                        <span class="comment">// 没有参数的构造函数。  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl()构造函数。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name)                   <span class="comment">// 一个参数（姓名）的构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(name)构造函数。\n&quot;</span>;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">int</span> age)                           <span class="comment">// 一个参数（年龄）的构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(age)构造函数。\n&quot;</span>;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name, <span class="type">int</span> age)      <span class="comment">// 两个参数的构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initdata</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(name,age)构造函数。\n&quot;</span>;</span><br><span class="line">        m_name = name; m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initdata</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>(); m_age = <span class="number">0</span>; <span class="built_in">memset</span>(m_memo, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>()                                     <span class="comment">// 析构函数。  </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了~CGirl()\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span>                               <span class="comment">// 超女自我介绍的方法。</span></span></span><br><span class="line"><span class="function">    </span>&#123;  cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;，备注：&quot;</span> &lt;&lt; m_memo&lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// CGirl girl;                     // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;);        // 创建超女对象，为成员姓名设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;,8);     // 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl();                   // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl(&quot;西施&quot;);        // 创建超女对象，为成员姓名设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl(&quot;西施&quot;,8);     // 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    <span class="comment">// CGirl girl =77;                         // 使用赋值语法初始化对象。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CGirl *girl=new CGirl;                   // 创建超女对象，不设置任何初始值。</span></span><br><span class="line">    <span class="comment">// CGirl *girl=new CGirl(&quot;西施&quot;);        // 创建超女对象，为成员姓名设置初始值。</span></span><br><span class="line">    CGirl *girl=<span class="keyword">new</span> <span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>);     <span class="comment">// 创建超女对象，为成员姓名和年龄设置初始值。</span></span><br><span class="line">    </span><br><span class="line">    girl-&gt;<span class="built_in">show</span>();    <span class="comment">// 显示超女的自我介绍。</span></span><br><span class="line">    <span class="keyword">delete</span> girl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul>
<li>用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。</li>
<li>如果类中没有定义拷贝构造函数，编译器<strong>将提供一个拷贝构造函数</strong>，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。</li>
</ul>
<p>用一个已存在的对象创建新的对象语法：</p>
<ul>
<li>类名  新对象名(已存在的对象名)；</li>
<li>类名  新对象名&#x3D;已存在的对象名；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//以无参数为例</span></span><br><span class="line">	CGirl g1;</span><br><span class="line">	g1.m_name=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line">	g1.m_age=<span class="number">18</span>;</span><br><span class="line">	<span class="comment">//写法1</span></span><br><span class="line">	<span class="function">CGirl <span class="title">g2</span><span class="params">(g1)</span></span>;</span><br><span class="line">	g2.<span class="built_in">show</span>();</span><br><span class="line">	<span class="comment">//写法2</span></span><br><span class="line">	CGirl g3=g1;</span><br><span class="line">	g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
拷贝构造函数写法：</li>
</ul>
<ol>
<li>无参数： <code>类名（const 类名&amp; 对象名）&#123;&#125;</code>；</li>
<li>有参数： <code>类名（...，connst 类名&amp; 对象名，....）&#123;&#125;</code></li>
</ol>
<ul>
<li>访问权限必须 public</li>
<li>函数名必须与类名相同</li>
<li>以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。</li>
<li>函数以值的方式返回对象时，可能会调用拷贝构造函数（VS 会调用，Linux 不会）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                                  <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">int</span>         m_age;                                     <span class="comment">// 年龄属性。</span></span><br><span class="line">    <span class="type">int</span>*       m_ptr;                                       <span class="comment">// 指针成员，计划使用堆内存。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有参数的普通构造函数。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>() &#123; m_name.<span class="built_in">clear</span>(); m_age = <span class="number">0</span>;  m_ptr = <span class="literal">nullptr</span>;  cout &lt;&lt; <span class="string">&quot;调用了CGirl()构造函数。\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有重载的拷贝构造函数（默认拷贝构造函数）。  </span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg) </span><br><span class="line">    &#123; </span><br><span class="line">        m_name = gg.m_name; m_age = gg.m_age;  </span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="type">int</span>;         <span class="comment">// 分配内存。</span></span><br><span class="line">        <span class="comment">// *m_ptr = *gg.m_ptr;   // 拷贝数据。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_ptr, gg.m_ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 拷贝数据。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(const CGirl &amp;gg)拷贝构造函数。\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数。  </span></span><br><span class="line">    ~<span class="built_in">CGirl</span>() &#123; <span class="keyword">delete</span> m_ptr; m_ptr = <span class="literal">nullptr</span>; cout &lt;&lt; <span class="string">&quot;调用了~CGirl()\n&quot;</span>;  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名和年龄。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;，m_ptr=&quot;</span>&lt;&lt; m_ptr&lt;&lt;<span class="string">&quot;，*m_ptr=&quot;</span>&lt;&lt;*m_ptr&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CGirl g1;</span><br><span class="line">    g1.m_name = <span class="string">&quot;西施&quot;</span>; g1.m_age = <span class="number">23</span>; g1.m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>);</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g2</span><span class="params">(g1)</span></span>;  *g2.m_ptr = <span class="number">8</span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">    g2.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42174306/article/details/122882267?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169017884016800186546005%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169017884016800186546005&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-122882267-null-null.142%5Ev90%5Econtrol,239%5Ev3%5Econtrol&utm_term=%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9Dc++&spm=1018.2226.3001.4187">C++浅拷贝与深拷贝</a></p>
<ol>
<li>浅拷贝： 将原对象或原数组的引用直接赋给新对象，<strong>浅拷贝只复制指向某个对象的指针</strong>，而不复制对象本身，新旧对象还是共享同一块内存</li>
<li>对于浅拷贝，对象的地址是不同的。浅拷贝只是复制成员变量的值，而不是创建新的对象</li>
<li>深拷贝： <strong>创建</strong>一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”，新对象与原对象不共享内存，修改新对象不会改到元对象</li>
<li><strong>浅拷贝和深拷贝是对类对象和指针的</strong>，如果仅修改其中的一个int变量是不变的</li>
<li>编译器提供的拷贝函数是浅拷贝，所以，在<strong>对含有指针成员的对象进行拷贝</strong>时，必须自己定义<strong>拷贝构造函数</strong>，达到深拷贝的目的，才能必变内存重复释放<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span>* m_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value) : <span class="built_in">m_name</span>(name) &#123;</span><br><span class="line">        m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg) : <span class="built_in">m_name</span>(gg.m_name), <span class="built_in">m_ptr</span>(gg.m_ptr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用浅拷贝构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> CGirl&amp; gg, <span class="type">bool</span> deepCopy) : <span class="built_in">m_name</span>(<span class="string">&quot;漂亮的&quot;</span> + gg.m_name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deepCopy) &#123;</span><br><span class="line">            m_ptr = <span class="keyword">new</span> <span class="built_in">int</span>(*(gg.m_ptr));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_ptr = gg.m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用深拷贝构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">CGirl</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象 g1</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;小红&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝对象 g2</span></span><br><span class="line">    CGirl g2 = g1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝对象 g3</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g3</span><span class="params">(g1, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 g1、g2 和 g3 的指针成员变量地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;g1.m_ptr: &quot;</span> &lt;&lt; g1.m_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;g2.m_ptr: &quot;</span> &lt;&lt; g2.m_ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;g3.m_ptr: &quot;</span> &lt;&lt; g3.m_ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">// 调用浅拷贝构造函数</span></span><br><span class="line"><span class="comment">// 调用深拷贝构造函数</span></span><br><span class="line"><span class="comment">// &amp;g1.m_ptr: 0x1e1630</span></span><br><span class="line"><span class="comment">// &amp;g2.m_ptr: 0x1e1630</span></span><br><span class="line"><span class="comment">// &amp;g3.m_ptr: 0x1e1650</span></span><br><span class="line"><span class="comment">// 从输出结果中可以看出，浅拷贝的对象g2和原对象g1共享同一块内存，因此它们的指针成员变量的地址是相同的。</span></span><br><span class="line"><span class="comment">//而深拷贝的对象g3则创建了一个新的对象，并复制了原对象g1的指针成员变量所指向的对象的副本，因此它们的指针成员变量的地址是不同的</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><ul>
<li>构造函数的执行可以分成两个阶段：初始化阶段和计算阶段。初始化阶段先于计算阶段。</li>
<li>初始化阶段：全部的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。</li>
<li>计算阶段：一般是指用于执行构造函数体内的赋值操作。</li>
<li>构造函数除了参数列表和函数体外，还可以由初始化列表<br>初始化列表的语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类名(形参列表):成员<span class="number">1</span>（值<span class="number">1</span>）,...,成员<span class="built_in">n</span>(值n)&#123;...&#125;</span><br><span class="line"><span class="comment">//对无参数构造函数调用</span></span><br><span class="line"><span class="built_in">CGirl</span>():<span class="built_in">m_name</span>(<span class="string">&quot;西施&quot;</span>),<span class="built_in">m_age</span>(<span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGirl</span>(string name,<span class="type">int</span> age):<span class="built_in">m_name</span>(<span class="string">&quot;漂亮的&quot;</span>+name),<span class="built_in">m_age</span>(age)&#123;&#125;<span class="comment">//对于有参数的构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。</li>
<li>初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。</li>
<li>初始化列表与赋值有本质的区别，如果成员是类，使用<strong>初始化列表调用的是拷贝构造函数</strong>，而赋值则是先创建对象（调用普通构造函数），然后再赋值。</li>
<li>如果成员是类，初始化列表效率更高。</li>
<li>如果成员是<strong>常量和引用</strong>，必须使用初始列表，因为常量和引用只能在定义的时候初始化。 </li>
<li>如果成员是没有默认构造函数的类，则必须使用初始列表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;        <span class="comment">// 指定缺省的命名空间。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBoy</span>                <span class="comment">// 男朋友类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_xm;                      <span class="comment">// 男朋友的姓名。</span></span><br><span class="line">    <span class="built_in">CBoy</span>()                                 <span class="comment">// 没有参数的普通构造函数，默认构造函数。  </span></span><br><span class="line">    &#123; m_xm.<span class="built_in">clear</span>();  cout &lt;&lt; <span class="string">&quot;调用了CBoy()构造函数。\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">CBoy</span>(string xm)                 <span class="comment">// 有一个参数的普通构造函数。  </span></span><br><span class="line">    &#123; m_xm = xm;  cout &lt;&lt; <span class="string">&quot;调用了CBoy(string xm)构造函数。\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">CBoy</span>(<span class="type">const</span> CBoy&amp; bb)     <span class="comment">// 默认拷贝构造函数。  </span></span><br><span class="line">    &#123; m_xm = bb.m_xm;  cout &lt;&lt; <span class="string">&quot;调用了CBoy(const CBoy &amp;bb)拷贝构造函数。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>                 <span class="comment">// 超女类CGirl。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string    m_name;                     <span class="comment">// 姓名属性。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>         m_age;                         <span class="comment">// 年龄属性。</span></span><br><span class="line">    CBoy&amp;     m_boy;                         <span class="comment">// 男朋友的信息。</span></span><br><span class="line">    <span class="comment">//CGirl()                                       // 没有参数的普通构造函数，默认构造函数。  </span></span><br><span class="line">    <span class="comment">//&#123;  </span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;调用了CGirl()构造函数。\n&quot;; </span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//CGirl(string name, int age,CBoy &amp;boy)     // 三个参数的普通构造函数。</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    m_name = name; m_age = age; m_boy.m_xm = boy.m_xm;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;调用了CGirl(name,age,boy)构造函数。\n&quot;;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">CGirl</span>(string name, <span class="type">int</span> age, CBoy&amp; boy) :<span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age),<span class="built_in">m_boy</span>(boy)      <span class="comment">// 三个参数的普通构造函数。</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了CGirl(name,age,boy)构造函数。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超女自我介绍的方法，显示姓名、年龄、男朋友。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;，年龄：&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;，男朋友：&quot;</span> &lt;&lt; m_boy.m_xm &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CBoy <span class="title">boy</span><span class="params">(<span class="string">&quot;子都&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;冰冰&quot;</span>,<span class="number">18</span>,boy)</span></span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="类嵌套类定义"><a href="#类嵌套类定义" class="headerlink" title="类嵌套类定义"></a>类嵌套类定义</h3><ul>
<li>对于类中有初始化信息的定义，类的类成员要在类的构造函数中定义</li>
<li>如果是分文件编写程序，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PID</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> Kp;   <span class="comment">// 比例系数</span></span><br><span class="line">    <span class="type">double</span> Ki;   <span class="comment">// 积分系数</span></span><br><span class="line">    <span class="type">double</span> Kd;   <span class="comment">// 微分系数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PID</span>(<span class="type">double</span> kp, <span class="type">double</span> ki, <span class="type">double</span> kd) : <span class="built_in">Kp</span>(kp), <span class="built_in">Ki</span>(ki), <span class="built_in">Kd</span>(kd) &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;测试&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PID a;  <span class="comment">// 成员变量a的声明</span></span><br><span class="line">    <span class="comment">// PID a(1,1,1);//错误写法，类成员变量的初始化必须在构造函数的成员初始化列表中完成。</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dfjgk&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    std::cout&lt;&lt; a.a.Kd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="分文件编写"><a href="#分文件编写" class="headerlink" title="分文件编写"></a>分文件编写</h4><p>Uav_info.h 文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UAV_INFO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UAV_INFO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PID.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uav_info</span> &#123;</span><br><span class="line">    PID base_pose; <span class="comment">// 成员对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Uav_info</span>(); <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// UAV_INFO_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Uav_info.cpp </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Uav_info.h&quot;</span></span></span><br><span class="line"><span class="comment">//PID构造函数：PID(double a,double b,double c)&#123;&#125;</span></span><br><span class="line">Uav_info::<span class="built_in">Uav_info</span>() : <span class="built_in">base_pose</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="comment">// 成员变量 base_pose 的初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Uav_info::someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用成员对象 base_pose</span></span><br><span class="line">    <span class="type">double</span> controlSignal = base_pose.<span class="built_in">update</span>(currentPosition);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><ul>
<li>在类的成员函数后面加 const 关键字，表示在成员函数中保证不会修改调用对象的成员变量。</li>
<li>类中调用一般用解引用去传参<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> CGirl &amp;<span class="title function_">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span> <span class="type">const</span></span><br></pre></td></tr></table></figure></li>
<li>其中，第一个<code>const</code>表示返回值是一个常引用类型，第二个<code>const</code>表示该函数是一个成员常函数，而第三个<code>const</code>则表示该成员函数不会修改任何成员变量的值。<br><strong>注意：</strong></li>
<li>mutable 可以突破 const 的限制，被 mutable 修饰的成员变量，将永远处于可变的状态，在 const 修饰的函数中，mutable 成员也可以被修改。</li>
<li>非const对象可以调用const修饰的成员函数和非const修饰的成员函数。</li>
<li>const对象只能调用const修饰的成员函数，不能调用非cosnt修饰的成员函数</li>
</ul>
<blockquote>
<p>保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，<strong>通过用const关键字来避免在函数中错误的修改了类对象的状态</strong>。并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。而mutable则是为了能突破const的封锁线，<strong>让类的一些次要的或者是辅助性的成员变量随时可以被更改</strong>。没有使用const和mutable关键字当然没有错，const和mutable 关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对成员函数的const</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//m_name=&quot;woo&quot;;//修改m_name,有const会报错</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="const类型"><a href="#const类型" class="headerlink" title="const类型"></a>const类型</h4><ul>
<li><strong>修饰变量</strong><ul>
<li>const int NUM &#x3D; 10; &#x2F;&#x2F; 常量变量</li>
<li>const float PI &#x3D; 3.14f; &#x2F;&#x2F; 常量变量</li>
<li>const MyClass obj; &#x2F;&#x2F; 常量对象</li>
<li>const int* ptr; &#x2F;&#x2F; 指向常量的指针</li>
<li>int* const ptr; &#x2F;&#x2F; 常指针</li>
</ul>
</li>
<li><strong>修饰成员函数：</strong><ul>
<li>void func() const; &#x2F;&#x2F; const成员函数，不会修改类的成员变量</li>
</ul>
</li>
<li><strong>修饰函数参数：</strong><ul>
<li>void foo(const int param); &#x2F;&#x2F; 参数是常量</li>
<li>void bar(const MyClass&amp; obj); &#x2F;&#x2F; 参数是常量引用</li>
</ul>
</li>
<li><strong>修饰返回值：</strong><ul>
<li>const int func(); &#x2F;&#x2F; 返回常量值</li>
<li>const MyClass&amp; getObject(); &#x2F;&#x2F; 返回常量引用</li>
</ul>
</li>
<li><strong>修饰指针：</strong><ul>
<li>int* const ptr; &#x2F;&#x2F; 常指针，指针本身是常量</li>
<li>const int* ptr; &#x2F;&#x2F; 指向常量的指针，指针所指的值是常量</li>
<li>const int* const ptr; &#x2F;&#x2F; 常指针，指向常量的指针</li>
</ul>
</li>
<li><strong>修饰成员变量：</strong><ul>
<li>class MyClass { const int m_value; &#x2F;&#x2F; 常量成员变量 static const int s_value; &#x2F;&#x2F; 静态常量成员变量 };</li>
</ul>
</li>
</ul>
<h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ul>
<li><p>如果类的成员函数中涉及多个对象，在这种情况下需要使用 this 指针。</p>
</li>
<li><p>this 指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。</p>
</li>
<li><p>每个成员函数（包括构造函数和析构函数）都有一个 this 指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）</p>
</li>
<li><p><code>*this</code> 可以表示整个对象。</p>
</li>
<li><p>如果在成员函数的括号后面使用 const, 那么将<strong>不能通过 this 指针</strong>修改成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规写法对比对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;gg1,<span class="type">const</span> CGirl &amp;gg2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(gg1.m_age&lt;gg2.m_age) <span class="keyword">return</span> gg2;</span><br><span class="line">	<span class="keyword">return</span> gg1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=<span class="built_in">pk</span>(g1,g2);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类中定义</span></span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g.m_age&gt;m_age) <span class="keyword">return</span> g;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=g2.<span class="built_in">pk</span>(g1);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//对比5个</span></span><br><span class="line">    <span class="comment">// CGirl g1(&quot;西施&quot;,8),g2(&quot;西瓜1&quot;,9),g3(&quot;西瓜2&quot;,10),g4(&quot;西瓜3&quot;,11),g5(&quot;西瓜4&quot;,12);</span></span><br><span class="line">    <span class="comment">// const CGirl &amp;g=g1.pk(g2).pk(g3).pk(g4).pk(g5);</span></span><br><span class="line">    <span class="comment">// g.show();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个类中存在<strong>成员变量和局部变量同名</strong>时，可以使用this关键字来访问成员变量。例如：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myVariable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVariable</span><span class="params">(<span class="type">int</span> myVariable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;myVariable = myVariable; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;myVariable: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;myVariable &lt;&lt; std::endl; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setVariable</span>(<span class="number">10</span>);</span><br><span class="line">    obj.<span class="built_in">printVariable</span>(); <span class="comment">// 输出: myVariable: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，setVariable函数中的形参myVariable和类的成员变量myVariable同名。为了区分它们，使用this-&gt;myVariable来访问成员变量。</p>
<ul>
<li>另外，也可以使用this指针来调用其他成员函数。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">function1</span>(); <span class="comment">// 使用this指针调用其他成员函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">function2</span>(); <span class="comment">// 输出: This is function1</span></span><br><span class="line">                     <span class="comment">//       This is function2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，function2通过使用this-&gt;function1()调用了function1成员函数。</li>
</ul>
<h3 id="类的静态成员变量"><a href="#类的静态成员变量" class="headerlink" title="类的静态成员变量"></a>类的静态成员变量</h3><ul>
<li>类的静态成员包括静态成员变量和静态成员函数</li>
<li>用静态成员可以变量<strong>实现多个对象之间的数据共享</strong>，比全局变量更安全性</li>
<li>用 static 关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的</li>
<li>静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解运算符）</li>
<li>静态成员使用类名加范围解析运算符：就可以访问，不需要创建类对象</li>
<li><strong>如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）</strong></li>
<li>静态成员变量在程序中只有一份 (生命周期与程序运行期相同，存放在静态存储区的)，不论是否创建了类的对象，也不论创建了多少个类的对象</li>
<li>静态成员函数<strong>只能访问静态成员</strong>，不能访问非静态成员</li>
<li>静态成员函数中没有 this 指针</li>
<li>非静态成员函数可以访问静态成员</li>
<li>私有静态变量在类外无法访问</li>
</ul>
<p><strong>优势</strong></p>
<ol>
<li><strong>无需创建对象</strong>：static 成员函数可以直接通过类名调用，无需创建类的对象。这意味着我们可以在不创建对象的情况下使用该函数，方便快捷。</li>
<li><strong>访问静态成员</strong>：static 成员函数可以访问类的静态成员变量和静态成员函数。这是因为静态成员属于类本身，而不是类的实例化对象。通过静态成员函数，我们可以直接操作和访问这些静态成员，而不需要对象的实例。</li>
<li><strong>代码复用</strong>：<strong>static 成员函数可以在不创建对象的情况下重复使用</strong>。这使得我们可以将一些通用的功能封装在静态成员函数中，并在需要时直接调用，而无需重复编写相同的代码：<strong>见示例2</strong></li>
<li>避免访问实例相关数据：由于 static 成员函数不依赖于类的实例，它无法直接访问非静态成员变量和非静态成员函数。这可以防止对实例相关数据的误操作或错误访问。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_age;<span class="comment">//设置静态变量</span></span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;构造函数无参数&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> string name,<span class="type">int</span> age)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    	m_name=name;</span><br><span class="line">    	m_age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="comment">//静态函数,只能用静态变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CGirl::m_age=<span class="number">34</span>;<span class="comment">//初始化类的静态成员变量,没有或者在其他位置不行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	CGirl::<span class="built_in">show</span>();<span class="comment">//静态函数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;CGirl::m_age:&quot;</span>&lt;&lt;CGirl::m_age&lt;&lt;endl;<span class="comment">//可以在创建对象那个前访问</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>示例2</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">incrementCount</span><span class="params">()</span> </span>&#123;  <span class="comment">// 静态成员函数</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;  <span class="comment">// 静态成员函数</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">incrementCount</span>();  <span class="comment">// 调用静态成员函数</span></span><br><span class="line">    MyClass::<span class="built_in">incrementCount</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = MyClass::<span class="built_in">getCount</span>();  <span class="comment">// 调用静态成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="PX4-C-代码形式理解"><a href="#PX4-C-代码形式理解" class="headerlink" title="PX4_C++代码形式理解"></a>PX4_C++代码形式理解</h1><h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43533553/article/details/123257675?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168906554316800227449672%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168906554316800227449672&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-123257675-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E4%B8%ADnamespace%E7%9A%84%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187">C++命名空间namespace</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一定义</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间名字</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> model1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//当前变量i只对命名空间model1可见，它的作用域被限定在model1</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">namespace</span> 命名空间<span class="number">2</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2定义</span></span><br><span class="line"><span class="keyword">using</span> model1::i;</span><br><span class="line">i= <span class="number">0</span>;  <span class="comment">//使用model1定义的变量i</span></span><br><span class="line">model2::i= <span class="number">10</span>;  <span class="comment">//使用model2定义的变量i</span></span><br></pre></td></tr></table></figure>
<p>由于使用命名空间后，变量的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>被限定，所以在使用变量时，就需要通过特定方式来完成。需要用到“::”操作符，“::”操作符是域解析操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model1::i = <span class="number">1</span>;</span><br><span class="line">model2::i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间成员使用方法总结</strong></p>
<blockquote>
<p>方法一 ：命名空间名:: 成员比如：spaceA:: a;<br>使用 using 可以使得命名空间中的成员暴露外部，以致可以使用该成员<br>方法二： using 命名空间名:: 成员 —-&gt; 把指定的成员暴露给外部<br>比如：using spaceA:: a;<br>方法三： using namespace 命名空间名 —&gt; 将其所有成员暴露给外部<br>比如： using namespace spaceA;</p>
</blockquote>
<h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@brief  ：简介，简单介绍函数作用  </span><br><span class="line">@param  ：介绍函数参数  </span><br><span class="line">@<span class="keyword">return</span>：函数返回类型说明  </span><br><span class="line">@exception NSException 可能抛出的异常.  </span><br><span class="line">@author zhangsan：  作者  </span><br><span class="line">@date <span class="number">2011</span><span class="number">-07</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">30</span>:<span class="number">00</span> ：时间  </span><br><span class="line">@version <span class="number">1.0</span> ：版本    </span><br><span class="line">@property ：属性介绍</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过多行注释实现，如下</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param _name         The name of the topic.</span></span><br><span class="line"><span class="comment"> * @param _struct       The structure the topic provides.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>[[1、数据类型#宏定义|宏定义]]<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">orb_advert_t</span> <span class="title">orb_advertise</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> orb_metadata *meta, <span class="type">const</span> <span class="type">void</span> *data)</span> __EXPORT</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li><code>extern</code>: 这是一个 C&#x2F;C++关键字，<strong>用于表明被声明的函数不在当前文件中，而在其他的源文件中实现</strong>。这样的话，其他的源文件就可以调用到这个函数   </li>
<li><code>orb_advert_t</code>: 这是返回值类型。<code>orb_advert_t</code>应该是定义在别的地方的一个类型，可能是一个结构体、枚举等。<ol start="3">
<li><code>orb_advertise</code>: 这是函数名。</li>
<li><code>__EXPORT</code>: 这个通常是一个平台相关的宏，用于标记函数或变量，使其在链接时可被其他模块看见，就是说这个函数可以被其他的文件或模块调用</li>
</ol>
</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io/post/36e8e938.html">https://github.com/wjl-a/data.github.io/post/36e8e938.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/wjl-a/data.github.io" target="_blank">醉卿枫の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/data.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-cpp/">程序语言/cpp</a></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2022/05/29/62939662553c9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/data.github.io/post/f145b64d.html" title="1.c++类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">1.c++类</div></div></a></div><div><a href="/data.github.io/post/7148eefc.html" title="模板1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="title">模板1</div></div></a></div><div><a href="/data.github.io/post/7f157bf9.html" title="2.c++基础语法2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">2.c++基础语法2</div></div></a></div><div><a href="/data.github.io/post/2bc4fa53.html" title="2.c++类2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">2.c++类2</div></div></a></div><div><a href="/data.github.io/post/c010a565.html" title="3.c++模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++模板</div></div></a></div><div><a href="/data.github.io/post/9ceaa80f.html" title="4.c++类_继承"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-09</div><div class="title">4.c++类_继承</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="this.onerror=null;this.src='/data.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">qq:2771329872</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%B0%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">从结构体到类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.2.</span> <span class="toc-text">类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">C++类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">构造函数与析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">浅拷贝和深拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">类嵌套类定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">分文件编写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">const 修饰成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">const类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">1.3.6.</span> <span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.7.</span> <span class="toc-text">类的静态成员变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PX4-C-%E4%BB%A3%E7%A0%81%E5%BD%A2%E5%BC%8F%E7%90%86%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">PX4_C++代码形式理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">2.0.1.</span> <span class="toc-text">命名空间 namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.0.2.</span> <span class="toc-text">常见注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern"><span class="toc-number">2.0.3.</span> <span class="toc-text">extern</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/52d1a938.html" title="8.c++_线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="8.c++_线程"/></a><div class="content"><a class="title" href="/data.github.io/post/52d1a938.html" title="8.c++_线程">8.c++_线程</a><time datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="7.c+++_智能指针_文件操作"/></a><div class="content"><a class="title" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作">7.c+++_智能指针_文件操作</a><time datetime="2023-12-23T16:00:00.000Z" title="发表于 2023-12-24 00:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="6.c++_STL"/></a><div class="content"><a class="title" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL">6.c++_STL</a><time datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="变结构无人机仿真"/></a><div class="content"><a class="title" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真">变结构无人机仿真</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/5d3e3d8b.html" title="soildworks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="soildworks"/></a><div class="content"><a class="title" href="/data.github.io/post/5d3e3d8b.html" title="soildworks">soildworks</a><time datetime="2023-10-27T13:01:00.000Z" title="发表于 2023-10-27 21:01:00">2023-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/data.github.io/js/utils.js"></script><script src="/data.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/data.github.io/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/data.github.io/js/search/local-search.js"></script></div></div></body></html>