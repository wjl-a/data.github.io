<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>8.c++_线程 | 醉卿枫の博客</title><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c++线程 最好在linux下面运行  g++ -pthread test.cpp -o test：产生可执行文件   .&#x2F;test：运行执行文件就行  创建线程 头文件：#include &lt;thread&gt; 线程类：std::thread  构造函数 **thread() noexcept;**：默认构造函数，构造一个线程对象，不执行任何任务（不会创建&#x2F;启动子线程）">
<meta property="og:type" content="article">
<meta property="og:title" content="8.c++_线程">
<meta property="og:url" content="https://github.com/wjl-a/data.github.io/post/52d1a938.html">
<meta property="og:site_name" content="醉卿枫の博客">
<meta property="og:description" content="c++线程 最好在linux下面运行  g++ -pthread test.cpp -o test：产生可执行文件   .&#x2F;test：运行执行文件就行  创建线程 头文件：#include &lt;thread&gt; 线程类：std::thread  构造函数 **thread() noexcept;**：默认构造函数，构造一个线程对象，不执行任何任务（不会创建&#x2F;启动子线程）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png">
<meta property="article:published_time" content="2023-12-24T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-14T03:20:19.886Z">
<meta property="article:author" content="醉卿枫">
<meta property="article:tag" content="程序语言&#x2F;cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png"><link rel="shortcut icon" href="/data.github.io/img/favicon.png"><link rel="canonical" href="https://github.com/wjl-a/data.github.io/post/52d1a938.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/data.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/data.github.io/',
  algolia: undefined,
  localSearch: {"path":"/data.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '8.c++_线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-14 11:20:19'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><nav id="nav"><span id="blog-info"><a href="/data.github.io/" title="醉卿枫の博客"><span class="site-name">醉卿枫の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">8.c++_线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-14T03:20:19.886Z" title="更新于 2024-01-14 11:20:19">2024-01-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/data.github.io/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="8.c++_线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="c-线程"><a href="#c-线程" class="headerlink" title="c++线程"></a>c++线程</h1><ul>
<li>最好在linux下面运行</li>
<li><ul>
<li>g++ -pthread test.cpp -o test：产生可执行文件</li>
</ul>
</li>
<li>.&#x2F;test：运行执行文件就行</li>
</ul>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>头文件：#<code>include &lt;thread&gt;</code></li>
<li>线程类：<code>std::thread</code></li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol>
<li>**thread() noexcept;**：默认构造函数，构造一个线程对象，不执行任何任务（不会创建&#x2F;启动子线程）<ol>
<li>noexcept 是一个异常规范说明符，表示该函数不会抛出异常</li>
</ol>
</li>
<li><strong>创建线程对象</strong>，在线程中执行任务函数fx中的代码，args是要传递给任务函数fx的参数</li>
</ol>
<ul>
<li>任务函数fx可以是普通函数、类的非静态成员函数、类的静态成员函数、lambda函数、仿函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(Function&amp;&amp; fx, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>thread(const thread&amp; ) &#x3D; delete;<ul>
<li>删除拷贝构造函数，不允许线程对象之间的拷贝。</li>
</ul>
</li>
<li>thread(thread&amp;&amp; other ) noexcept;<ul>
<li>移动构造函数，将线程other的资源所有权转移给新创建的线程对象</li>
</ul>
</li>
</ol>
<p><strong>赋值函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br><span class="line">thread&amp; <span class="keyword">operator</span>= (<span class="type">const</span> other&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>线程中的资源不能被复制，如果other是右值，会进行资源所有权的转移，如果other是左值，禁止拷贝。<br><strong>注意</strong></li>
<li>先创建的子线程不一定跑得最快（程序运行的速度有很大的偶然性）。</li>
<li>线程的任务函数返回后，子线程将终止。</li>
<li>如果主程序（主线程）退出（不论是正常退出还是意外终止），全部的子线程将强行被终止</li>
<li><strong>用linux平台去运行，直接用快捷键去运行回报错</strong>，需要在终端当前文件夹下：<ul>
<li>g++ -pthread test.cpp -o test：产生可执行文件</li>
<li>.&#x2F;test：运行执行文件就行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mythread1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">			std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中有静态成员函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mythread2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">			std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中有普通成员函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mythread3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">			std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 用普通函数创建线程。</span></span><br><span class="line">	<span class="comment">// thread t1(func, 3, &quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line">	<span class="comment">// thread t2(func, 8, &quot;我有一只小小鸟。&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用lambda函数创建线程。</span></span><br><span class="line">	<span class="comment">// auto f = [](int bh, const string&amp; str) &#123;</span></span><br><span class="line">	<span class="comment">// 	for (int ii = 1; ii &lt;= 10; ii++)</span></span><br><span class="line">	<span class="comment">// 	&#123;</span></span><br><span class="line">	<span class="comment">// 		cout &lt;&lt; &quot;第&quot; &lt;&lt; ii &lt;&lt; &quot;次表白：亲爱的&quot; &lt;&lt; bh &lt;&lt; &quot;号，&quot; &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">// 		std::this_thread::sleep_for(std::chrono::seconds(1));   // 休眠1秒。</span></span><br><span class="line">	<span class="comment">// 	&#125;</span></span><br><span class="line">	<span class="comment">// &#125;;</span></span><br><span class="line">	<span class="comment">// thread t3(f, 3, &quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用仿函数创建线程。</span></span><br><span class="line">	<span class="function">thread <span class="title">t4</span><span class="params">(mythread1(), <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用类的静态成员函数创建线程。</span></span><br><span class="line">	<span class="comment">//thread t5(mythread2::func, 3, &quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用类的普通成员函数创建线程。</span></span><br><span class="line">	mythread3 myth;   <span class="comment">// 必须先创建类的对象，必须保证对象的生命周期比子线程要长。</span></span><br><span class="line">	<span class="function">thread <span class="title">t6</span><span class="params">(&amp;mythread3::func, &amp;myth, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;  <span class="comment">// 第二个参数必须填对象的this指针，否则会拷贝对象。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;任务开始。\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;执行任务中......\n&quot;</span>;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));   <span class="comment">// 假设执行任务需要时间。</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;任务完成。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// t1.join();         // 回收线程t1的资源，回收后才不会报错</span></span><br><span class="line">	<span class="comment">// t2.join();         // 回收线程t2的资源。</span></span><br><span class="line">	<span class="comment">// t3.join();         // 回收线程t3的资源。</span></span><br><span class="line">	t4.<span class="built_in">join</span>();         <span class="comment">// 回收线程t4的资源。</span></span><br><span class="line">	<span class="comment">// t5.join();         // 回收线程t5的资源。</span></span><br><span class="line">	t6.<span class="built_in">join</span>();         <span class="comment">// 回收线程t6的资源。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="线程的回收"><a href="#线程的回收" class="headerlink" title="线程的回收"></a>线程的回收</h2><p>虽然同一个进程的多个线程共享进程的栈空间，但是，每个<strong>子线程在这个栈中拥有自己私有的栈空间</strong>。所以，线程结束时需要回收资源。<br><strong>回收子线程的资源有两种方法</strong></p>
<ul>
<li>在主程序中，调用join()成员函数等待子线程退出，回收它的资源。如果子线程已退出，join()函数立即返回，否则会阻塞等待，直到子线程退出。</li>
<li>在主程序中，调用detach()成员函数分离子线程，子线程退出时，系统将自动回收资源。分离后的子线程不可join()。</li>
<li>用joinable()成员函数可以判断子线程的分离状态，函数返回布尔类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));   <span class="comment">// 休眠1秒。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 用普通函数创建线程。</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line">	</span><br><span class="line">	t1.<span class="built_in">detach</span>(); t2.<span class="built_in">detach</span>();  <span class="comment">// 分离子线程，就退出，在后面需要加上延时函数，否则会直接退出主函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;任务开始。\n&quot;;</span></span><br><span class="line">	<span class="comment">//for (int ii = 0; ii &lt; 12; ii++) &#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;执行任务中......\n&quot;;</span></span><br><span class="line">	<span class="comment">//	std::this_thread::sleep_for(std::chrono::seconds(1));   // 假设执行任务需要时间。</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;任务完成。\n&quot;;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//t1.join();         // 回收线程t1的资源。</span></span><br><span class="line">	<span class="comment">//t2.join();         // 回收线程t2的资源。</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">12</span>));<span class="comment">//要加大点，否则会没运行就退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="this-thread的全局函数"><a href="#this-thread的全局函数" class="headerlink" title="this_thread的全局函数"></a>this_thread的全局函数</h2><ul>
<li>C++11提供了命名空间this_thread来表示当前线程，该命名空间中有四个函数：get_id()、sleep_for()、sleep_until()、yield()。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="built_in">get_id</span>()</span><br><span class="line"><span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">该函数用于获取线程ID，thread类也有同名的成员函数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）<span class="built_in">sleep_for</span>()  <span class="function">VS  <span class="title">Sleep</span><span class="params">(<span class="number">1000</span>)</span>   Linux <span class="title">sleep</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Rep, <span class="keyword">class</span> Period&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">sleep_for</span> <span class="params">(<span class="type">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line">该函数让线程休眠一段时间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）<span class="built_in">sleep_until</span>()          <span class="number">2022</span><span class="number">-01</span><span class="number">-01</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">35</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sleep_until</span> <span class="params">(<span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br><span class="line">该函数让线程休眠至指定时间点。（可实现定时任务）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）<span class="built_in">yield</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">该函数让线程主动让出自己已经抢到的CPU时间片。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）thread类其它的成员函数</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(std::thread&amp; other)</span></span>;    <span class="comment">// 交换两个线程对象。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">hardware_concurrency</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// 返回硬件线程上下文的数量。</span></span><br></pre></td></tr></table></figure>
示例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;子线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">3</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">// 休眠1秒。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 用普通函数创建线程。</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;主线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程t1：&quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程t2：&quot;</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">	t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="call-once函数"><a href="#call-once函数" class="headerlink" title="call_once函数"></a>call_once函数</h2><ul>
<li><p>在多线程环境中，某些函数只能被调用一次，例如：初始化某个对象，而这个对象只能被初始化一次。</p>
</li>
<li><p>在线程的任务函数中，可以用<strong>std::call_once()来保证某个函数只被调用一次</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头文件：<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Function&amp;&amp; fx, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个参数是std::once_flag，用于标记函数fx是否已经被执行过。</p>
</li>
<li><p>第二个参数是需要执行的函数fx。</p>
</li>
<li><p>后面的可变参数是传递给函数fx的参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>        <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>        <span class="comment">// std::once_flag和std::call_once()函数需要包含这个头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">once_flag onceflag;       <span class="comment">// once_flag全局变量。本质是取值为0和1的锁。</span></span><br><span class="line"><span class="comment">// 在线程中，打算只调用一次的函数。在创建多个子线程中也会执行一次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">once_func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span>  </span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;once_func() bh= &quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;, str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="built_in">call_once</span>(onceflag,once_func,<span class="number">0</span>, <span class="string">&quot;各位观众，我要开始表白了。&quot;</span>);<span class="comment">//在子线程中只会执行一次</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">3</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">// 休眠1秒。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 用普通函数创建线程。</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">	t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="native-handle函数"><a href="#native-handle函数" class="headerlink" title="native_handle函数"></a>native_handle函数</h2><ul>
<li>C++11定义了线程标准，不同的平台和编译器在实现的时候，本质上都是对操作系统的线程库进行封装，会损失一部分功能。</li>
<li>为了弥补C++11线程库的不足，thread类提供了native_handle()成员函数，<strong>用于获得与操作系统相关的原生线程句柄</strong>，操作系统原生的线程库就可以用原生线程句柄操作线程<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>        <span class="comment">// Linux的pthread线程库头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span>    <span class="comment">// 线程任务函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">1</span>;ii&lt;=<span class="number">10</span>;ii++)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">// 休眠1秒。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">tt</span><span class="params">(func)</span></span>;          <span class="comment">// 创建线程。</span></span><br><span class="line"></span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));    <span class="comment">// 休眠5秒，使当前线程休眠相应的时间。//这个函数可以用于在程序中暂停执行一段时间</span></span><br><span class="line"></span><br><span class="line">  <span class="type">pthread_t</span> thid= tt.<span class="built_in">native_handle</span>();  <span class="comment">// 获取Linux操作系统原生的线程句柄。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_cancel</span>(thid);  <span class="comment">// 强制取消线程，注销后这里将会运行10次；否则5次</span></span><br><span class="line">  <span class="comment">//join() 只会等待线程结束，而不会强制终止线程的执行。如果你想要强制终止线程的执行，可以使用 std::thread::native_handle() 获取线程的原生句柄，然后使用平台特定的方法来取消线程的执行，如使用 pthread_cancel() 函数来取消线程。</span></span><br><span class="line">  tt.<span class="built_in">join</span>();   <span class="comment">// 等待线程退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul>
<li>同一个进程中的多个线程共享该进程中的全部资源</li>
<li>多个线程访问同一个共享资源会产生冲突</li>
<li>顺序性，可见性，原子性<ul>
<li><strong>顺序性</strong>：程序按照代码的先后顺序执行</li>
<li><strong>可见性</strong>：线程共享变量，会将该变量从内存中加载到CPU缓存中，修改该变量后，CPU会立即更新缓存，但不一定会立即将他写入内存，这时候，如果其他线程访问该变量，从内存中读到的是旧数据，而非第一个线程操作后的数据</li>
<li><strong>原子性</strong>：CPU执行指令——读取指令，读取内存，执行指令，写回内存</li>
</ul>
</li>
</ul>
<p><strong>volatile关键字</strong></p>
<ul>
<li>保证内存变量可见性</li>
<li>禁止代码优化(重排序)<br>要解决线程安全</li>
<li>原子操作</li>
<li>线程同步锁<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>        <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> aa = <span class="number">0</span>;     <span class="comment">// 定义全局变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数，把全局变量aa加1000000次。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">1000000</span>; ii++)</span><br><span class="line">		aa++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 用普通函数创建线程。</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;     <span class="comment">// 创建线程t1，把全局变量aa加1000000次。</span></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;     <span class="comment">// 创建线程t2，把全局变量aa加1000000次。</span></span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">	t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;aa=&quot;</span> &lt;&lt; aa &lt;&lt; endl;   <span class="comment">// 显示全局变量aa的值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题所在</span></span><br><span class="line"><span class="comment">// 代码存在一个潜在的问题，即多个线程同时对全局变量 aa 进行写操作，可能导致竞态条件（Race Condition）。竞态条件是指多个线程对共享资源进行读写操作时的不确定行为，导致结果的不可预测性。</span></span><br><span class="line"><span class="comment">// 在代码中，两个线程同时对全局变量 aa 进行加法操作，可能导致以下情况之一：</span></span><br><span class="line"><span class="comment">// 1.线程之间发生了交替执行，导致最后的结果正确，aa 的值为 2000000；</span></span><br><span class="line"><span class="comment">// 2/线程之间发生了交替执行，并且发生了竞态条件，导致最后的结果不正确，aa 的值小于 2000000。</span></span><br><span class="line"><span class="comment">// 为了避免竞态条件，你可以使用互斥锁（std::mutex）来保护共享资源，确保在任意时刻只有一个线程可以访问共享资源。具体做法是在访问 aa 的代码块前后加锁和解锁操作。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>线程同步：多个线程协同工作，协商如何使用共享资源</li>
<li>有三种模型<ul>
<li>互斥锁</li>
<li>条件变量</li>
<li>生产&#x2F;消费模型</li>
</ul>
</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li>加锁和解锁，确保同一时间只有一个线程访问共享资源</li>
<li>访问共享资源之前加莎，访问完后释放</li>
<li>如果某线程持有锁，其他的线程形成等待队列</li>
</ul>
<p><strong>C++11提供了四种互斥锁</strong>：<br>    • mutex：互斥锁。<br>    • timed_mutex：带超时机制的互斥锁。<br>    • recursive_mutex：递归互斥锁。<br>    • recursive_timed_mutex：带超时机制的递归互斥锁。<br>包含头文件：<code>#include &lt;mutex&gt;</code></p>
<h4 id="mutex类"><a href="#mutex类" class="headerlink" title="mutex类"></a>mutex类</h4><p><strong>加锁lock()</strong></p>
<ul>
<li>互斥锁有锁定和未锁定两种状态。</li>
<li>如果互斥锁是未锁定状态，调用lock()成员函数的线程会得到互斥锁的所有权，并将其上锁。</li>
<li>如果互斥锁是锁定状态，调用lock()成员函数的线程就会阻塞等待，直到互斥锁变成未锁定状态。</li>
</ul>
<p><strong>解锁unlock()</strong></p>
<ul>
<li>只有持有锁的线程才能解锁。</li>
</ul>
<p><strong>尝试加锁try_lock()</strong></p>
<ul>
<li>如果互斥锁是未锁定状态，则加锁成功，函数返回true。</li>
<li>如果互斥锁是锁定状态，则加锁失败，函数立即返回false。（线程不会阻塞等待）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;        <span class="comment">// 创建互斥锁，保护共享资源cout对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">1</span>; ii &lt;= <span class="number">10</span>; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();      <span class="comment">// 申请加锁。</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;次表白：亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();  <span class="comment">// 解锁。</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));     <span class="comment">// 休眠1秒。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 用普通函数创建线程。</span></span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t3</span><span class="params">(func, <span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t4</span><span class="params">(func, <span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t5</span><span class="params">(func, <span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();         <span class="comment">// 回收线程t1的资源。</span></span><br><span class="line">	t2.<span class="built_in">join</span>();         <span class="comment">// 回收线程t2的资源。</span></span><br><span class="line">	t3.<span class="built_in">join</span>();         <span class="comment">// 回收线程t3的资源。</span></span><br><span class="line">	t4.<span class="built_in">join</span>();         <span class="comment">// 回收线程t4的资源。</span></span><br><span class="line">	t5.<span class="built_in">join</span>();         <span class="comment">// 回收线程t5的资源。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="timed-mutex类"><a href="#timed-mutex类" class="headerlink" title="timed_mutex类"></a>timed_mutex类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增加了两个成员函数：</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock_for</span><span class="params">(时间长度)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">try_lock_until</span><span class="params">(时间点)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="recursive-mutex类"><a href="#recursive-mutex类" class="headerlink" title="recursive_mutex类"></a>recursive_mutex类</h4><p>递归互斥锁允许同一线程多次获得互斥锁，可以解决同一线程多次加锁造成的死锁问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>        <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">	recursive_mutex m_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了func1()\n&quot;</span>;</span><br><span class="line">		m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了func2()\n&quot;</span>;</span><br><span class="line">		<span class="built_in">func1</span>();</span><br><span class="line">		m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AA aa;</span><br><span class="line">	<span class="comment">//aa.func1();</span></span><br><span class="line">	aa.<span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lock-guard类"><a href="#lock-guard类" class="headerlink" title="lock_guard类"></a>lock_guard类</h4><ul>
<li>lock_guard是模板类，可以简化互斥锁的使用，也更安全</li>
<li>lock_guard在构造函数中加锁，在析构函数中解锁</li>
<li>lock_guard采用了RAII思想（在类构造函数中分配资源，在析构函数中释放资源，保证资源在离开作用域时自动释放）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(Mutex&amp; mtx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条件变量-生产消费者模型"><a href="#条件变量-生产消费者模型" class="headerlink" title="条件变量-生产消费者模型"></a>条件变量-生产消费者模型</h2><ul>
<li>比较常用</li>
<li>当条件不满足时，相关线程被一直阻塞，直到每种条件出现，这些线程才被唤醒</li>
<li>为保护共享资源，条件变量需要和互斥锁结合一起使用</li>
<li>生产&#x2F;消费者模型<br>![[Pasted image 20231226111524.png]]</li>
<li>条件变量是一种线程同步机制。当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。</li>
<li>C++11的条件变量提供了两个类：<ul>
<li>condition_variable：只支持与普通mutex搭配，效率更高。</li>
<li>condition_variable_any：是一种通用的条件变量，可以与任意mutex搭配（包括用户自定义的锁类型）。</li>
</ul>
</li>
<li>包含头文件：<code>&lt;condition_variable&gt;</code></li>
</ul>
<h3 id="condition-variable类"><a href="#condition-variable类" class="headerlink" title="condition_variable类"></a>condition_variable类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">主要成员函数：</span><br><span class="line"><span class="number">1</span>）<span class="built_in">condition_variable</span>() 默认构造函数。</span><br><span class="line"><span class="number">2</span>）<span class="built_in">condition_variable</span>(<span class="type">const</span> condition_variable &amp;)=<span class="keyword">delete</span> 禁止拷贝。</span><br><span class="line"><span class="number">3</span>）condition_variable&amp; condition_variable::<span class="keyword">operator</span>=(<span class="type">const</span> condition_variable &amp;)=<span class="keyword">delete</span> 禁止赋值。</span><br><span class="line"><span class="number">4</span>）<span class="built_in">notify_one</span>() 通知一个等待的线程。</span><br><span class="line"><span class="number">5</span>）<span class="built_in">notify_all</span>() 通知全部等待的线程。</span><br><span class="line"><span class="number">6</span>）<span class="built_in">wait</span>(unique_lock&lt;mutex&gt; lock) 阻塞当前线程，直到通知到达。</span><br><span class="line"><span class="number">7</span>）<span class="built_in">wait</span>(unique_lock&lt;mutex&gt; lock,Pred pred) 循环的阻塞当前线程，直到通知到达且谓词满足。</span><br><span class="line"><span class="number">8</span>）<span class="built_in">wait_for</span>(unique_lock&lt;mutex&gt; lock,时间长度)</span><br><span class="line"><span class="number">9</span>）<span class="built_in">wait_for</span>(unique_lock&lt;mutex&gt; lock,时间长度,Pred pred)</span><br><span class="line"><span class="number">10</span>）<span class="built_in">wait_until</span>(unique_lock&lt;mutex&gt; lock,时间点)</span><br><span class="line"><span class="number">11</span>）<span class="built_in">wait_until</span>(unique_lock&lt;mutex&gt; lock,时间点,Pred pred)</span><br></pre></td></tr></table></figure>
<h3 id="unique-lock类"><a href="#unique-lock类" class="headerlink" title="unique_lock类"></a>unique_lock类</h3><ul>
<li><code>template &lt;class Mutex&gt; class unique_lock</code>是模板类，模板参数为互斥锁类型。</li>
<li>unique_lock和lock_guard都是管理锁的辅助类，都是RAII风格（在构造时获得锁，在析构时释放锁）。它们的区别在于：为了配合condition_variable，unique_lock还有lock()和unlock()成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                      <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                      <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>                      <span class="comment">// deque容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>                      <span class="comment">// queue容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  <span class="comment">// 条件变量的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex m_mutex;                                    <span class="comment">// 互斥锁。</span></span><br><span class="line">    condition_variable m_cond;                  <span class="comment">// 条件变量。</span></span><br><span class="line">    queue&lt;string, deque&lt;string&gt;&gt; m_q;   <span class="comment">// 缓存队列，底层容器用deque。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incache</span><span class="params">(<span class="type">int</span> num)</span>     <span class="comment">// 生产数据，num指定数据的个数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   <span class="comment">// 申请加锁，离开作用域会自动解锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span> ; ii&lt;num ; ii++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> bh = <span class="number">1</span>;           <span class="comment">// 超女编号。</span></span><br><span class="line">            string message = <span class="built_in">to_string</span>(bh++) + <span class="string">&quot;号超女&quot;</span>;    <span class="comment">// 拼接出一个数据。</span></span><br><span class="line">            m_q.<span class="built_in">push</span>(message);     <span class="comment">// 把生产出来的数据入队。</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_cond.<span class="built_in">notify_one</span>();     <span class="comment">// 若生产数据只有一个，用他；否则用下面那个。唤醒一个被当前条件变量阻塞的线程。</span></span><br><span class="line">        <span class="comment">//m_cond.notify_all();          // 唤醒全部被当前条件变量阻塞的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outcache</span><span class="params">()</span>       <span class="comment">// 消费者线程任务函数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            string message;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把互斥锁转换成unique_lock&lt;mutex&gt;，并申请加锁。</span></span><br><span class="line">                <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (m_q.<span class="built_in">empty</span>())    <span class="comment">// 如果队列空，进入循环，否则直接处理数据。必须用循环，不能用if</span></span><br><span class="line">                    m_cond.<span class="built_in">wait</span>(lock);  <span class="comment">// 等待生产者的唤醒信号。</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 数据元素出队。</span></span><br><span class="line">                message = m_q.<span class="built_in">front</span>();  m_q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理出队的数据（把数据消费掉）。</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));   <span class="comment">// 假设处理数据需要1毫秒。</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA aa;</span><br><span class="line">  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t1。</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t2。</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t3。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));    <span class="comment">// 休眠2秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">3</span>);      <span class="comment">// 生产3个数据。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));    <span class="comment">// 休眠3秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">5</span>);      <span class="comment">// 生产5个数据。</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();   <span class="comment">// 回收子线程的资源。</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
示例2<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                      <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                      <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>                      <span class="comment">// deque容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>                      <span class="comment">// queue容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  <span class="comment">// 条件变量的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex m_mutex;                                    <span class="comment">// 互斥锁。</span></span><br><span class="line">    condition_variable m_cond;                  <span class="comment">// 条件变量。</span></span><br><span class="line">    queue&lt;string, deque&lt;string&gt;&gt; m_q;   <span class="comment">// 缓存队列，底层容器用deque。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incache</span><span class="params">(<span class="type">int</span> num)</span>     <span class="comment">// 生产数据，num指定数据的个数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   <span class="comment">// 申请加锁。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span> ; ii&lt;num ; ii++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> bh = <span class="number">1</span>;           <span class="comment">// 超女编号。</span></span><br><span class="line">            string message = <span class="built_in">to_string</span>(bh++) + <span class="string">&quot;号超女&quot;</span>;    <span class="comment">// 拼接出一个数据。</span></span><br><span class="line">            m_q.<span class="built_in">push</span>(message);     <span class="comment">// 把生产出来的数据入队。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//m_cond.notify_one();     // 唤醒一个被当前条件变量阻塞的线程。</span></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();          <span class="comment">// 唤醒全部被当前条件变量阻塞的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outcache</span><span class="params">()</span>   </span>&#123;    <span class="comment">// 消费者线程任务函数。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)   &#123;</span><br><span class="line">            <span class="comment">// 把互斥锁转换成unique_lock&lt;mutex&gt;，并申请加锁。</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件变量虚假唤醒：消费者线程被唤醒后，缓存队列中没有数据。</span></span><br><span class="line">            <span class="comment">//while (m_q.empty())    // 如果队列空，进入循环，否则直接处理数据。必须用循环，不能用if</span></span><br><span class="line">            <span class="comment">//    m_cond.wait(lock);  // 1）把互斥锁解开；2）阻塞，等待被唤醒；3）给互斥锁加锁。</span></span><br><span class="line">            m_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !m_q.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据元素出队。</span></span><br><span class="line">            string message = m_q.<span class="built_in">front</span>();  m_q.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();      <span class="comment">// 手工解锁。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理出队的数据（把数据消费掉）。</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>));   <span class="comment">// 假设处理数据需要1毫秒。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA aa;</span><br><span class="line">  </span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t1。</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t2。</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t3。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));    <span class="comment">// 休眠2秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">2</span>);      <span class="comment">// 生产2个数据。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));    <span class="comment">// 休眠3秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">5</span>);      <span class="comment">// 生产5个数据。</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();   <span class="comment">// 回收子线程的资源。</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h2><ul>
<li>C++11提供了<code>atomic&lt;T&gt;</code>模板类（结构体），用于支持原子类型，模板参数可以是bool、char、int、long、long long、指针类型（不支持浮点类型和自定义数据类型）。</li>
<li>原子操作由CPU指令提供支持，它的性能比锁和消息传递更高，并且，不需要程序员处理加锁和释放锁的问题，支持修改、读取、交换、比较并交换等操作。</li>
<li>头文件：<code>#include &lt;atomic&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">构造函数：</span><br><span class="line"><span class="built_in">atomic</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;  <span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="built_in">atomic</span>(T val) <span class="keyword">noexcept</span>;  <span class="comment">// 转换函数。</span></span><br><span class="line"><span class="built_in">atomic</span>(<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁用拷贝构造函数。</span></span><br><span class="line">赋值函数：</span><br><span class="line">atomic&amp; <span class="keyword">operator</span>=(<span class="type">const</span> atomic&amp;) = <span class="keyword">delete</span>;   <span class="comment">// 禁用赋值函数。</span></span><br><span class="line">常用函数：</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// 把val的值存入原子变量。</span></span><br><span class="line"><span class="function">T <span class="title">load</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 读取原子变量的值。</span></span><br><span class="line"><span class="function">T <span class="title">fetch_add</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 把原子变量的值与val相加，返回原值。</span></span><br><span class="line"><span class="function">T <span class="title">fetch_sub</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 把原子变量的值减val，返回原值。</span></span><br><span class="line"><span class="function">T <span class="title">exchange</span><span class="params">(<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 把val的值存入原子变量，返回原值。</span></span><br><span class="line"><span class="function">T <span class="title">compare_exchange_strong</span><span class="params">(T &amp;expect,<span class="type">const</span> T val)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 比较原子变量的值和预期值expect，如果当两个值相等，把val存储到原子变量中，函数返回true；如果当两个值不相等，用原子变量的值更新预期值，函数返回false。CAS指令。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_lock_free</span><span class="params">()</span></span>;  <span class="comment">// 查询某原子类型的操作是直接用CPU指令（返回true），还是编译器内部的锁（返回false）。</span></span><br></pre></td></tr></table></figure>
<strong>原子类型</strong><br><strong>![[Pasted image 20231226185416.png]]</strong><br>• <code>atomic&lt;T&gt;</code>模板类重载了整数操作的各种运算符。<br>• <code>atomic&lt;T&gt;</code>模板类的模板参数支持指针，但不表示它所指向的对象是原子类型。<br>• 原子整型可以用作计数器，布尔型可以用作开关。<br>• CAS指令是实现无锁队列基础。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// atomic&lt;int&gt; a = 3; //会报错</span></span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; a; <span class="comment">// 声明一个原子变量a</span></span><br><span class="line">    a = <span class="number">3</span>; <span class="comment">// 使用赋值操作符给a赋值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 读取原子变量a的值并输出</span></span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">store</span>(<span class="number">8</span>); <span class="comment">// 把8存储到原子变量中</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 读取原子变量a的值并输出</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> old;</span><br><span class="line">    old = a.<span class="built_in">fetch_add</span>(<span class="number">5</span>); <span class="comment">// 把原子变量a的值与5相加，返回原值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;old = &quot;</span> &lt;&lt; old &lt;&lt; <span class="string">&quot;，a = &quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 输出原值和更新后的a的值</span></span><br><span class="line">    old = a.<span class="built_in">fetch_sub</span>(<span class="number">2</span>); <span class="comment">// 把原子变量a的值减2，返回原值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;old = &quot;</span> &lt;&lt; old &lt;&lt; <span class="string">&quot;，a = &quot;</span> &lt;&lt; a.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 输出原值和更新后的a的值</span></span><br><span class="line"></span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; ii; <span class="comment">// 声明一个新的原子变量ii</span></span><br><span class="line">    ii = <span class="number">3</span>; <span class="comment">// 使用赋值操作符给ii赋值</span></span><br><span class="line">    <span class="type">int</span> expect = <span class="number">4</span>; <span class="comment">// 定义一个期望值</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">5</span>; <span class="comment">// 定义要存入原子变量的值</span></span><br><span class="line">    <span class="comment">// 比较原子变量ii的值和期望值expect，</span></span><br><span class="line">    <span class="comment">// 如果两个值相等，将val存储到原子变量中；</span></span><br><span class="line">    <span class="comment">// 如果两个值不相等，用原子变量的值更新期望值。</span></span><br><span class="line">    <span class="comment">// 执行存储操作时返回true，否则返回false。</span></span><br><span class="line">    <span class="type">bool</span> bret = ii.<span class="built_in">compare_exchange_strong</span>(expect, val);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bret=&quot;</span> &lt;&lt; bret &lt;&lt; endl; <span class="comment">// 输出比较交换的结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii.<span class="built_in">load</span>() &lt;&lt; endl; <span class="comment">// 读取原子变量ii的值并输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;expect=&quot;</span> &lt;&lt; expect &lt;&lt; endl; <span class="comment">// 输出更新后的期望值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="可调用对象的绑定器和包装器"><a href="#可调用对象的绑定器和包装器" class="headerlink" title="可调用对象的绑定器和包装器"></a>可调用对象的绑定器和包装器</h1><ul>
<li>在C++中，可以像函数一样调用的有：普通函数、类的静态成员函数、仿函数、lambda函数、类的非静态成员函数、可被转换为函数的类的对象，统称可调用对象或函数对象。</li>
<li>可调用对象有类型，可以用指针存储它们的地址，可以被引用（类的成员函数除外）</li>
</ul>
<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><ul>
<li>普通函数类型可以声明函数、定义函数指针和函数引用，但是，不能定义函数的实体<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span> (<span class="type">int</span>, <span class="type">const</span> string&amp;);  <span class="comment">// 普通函数类型的别名。</span></span><br><span class="line">Fun show;        <span class="comment">// 声明普通函数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">show</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);					<span class="comment">// 直接调用普通函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>(*fp1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = show;	<span class="comment">// 声明函数指针，指向普通函数。</span></span><br><span class="line">	<span class="built_in">void</span>(&amp;fr1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = show;	<span class="comment">// 声明函数引用，引用普通函数。</span></span><br><span class="line">	<span class="built_in">fp1</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数指针调用普通函数。</span></span><br><span class="line">	<span class="built_in">fr1</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数引用调用普通函数。</span></span><br><span class="line"></span><br><span class="line">	Fun* fp2 = show;										<span class="comment">// 声明函数指针，指向普通函数。</span></span><br><span class="line">	Fun&amp; fr2 = show;									<span class="comment">// 声明函数引用，引用普通函数。</span></span><br><span class="line">	<span class="built_in">fp2</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数指针调用普通函数。</span></span><br><span class="line">	<span class="built_in">fr2</span>(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数引用调用普通函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码是错误的，不能用函数类型定义函数的实体。</span></span><br><span class="line"><span class="comment">//Func show1 &#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; bh &lt;&lt; &quot;，&quot; &lt;&lt; message &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类的静态成员函数"><a href="#类的静态成员函数" class="headerlink" title="类的静态成员函数"></a>类的静态成员函数</h3><p>类的静态成员函数和普通函数本质上是一样的，把普通函数放在类中而已</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Fun = <span class="built_in">void</span> (<span class="type">int</span>, <span class="type">const</span> string&amp;);  <span class="comment">// 普通函数类型的别名。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AA</span>	<span class="comment">// 类中有静态成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	AA::<span class="built_in">show</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);					<span class="comment">// 直接调用静态成员函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span>(*fp1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = AA::show;	<span class="comment">// 用函数指针指向静态成员函数。</span></span><br><span class="line">	<span class="built_in">void</span>(&amp;fr1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = AA::show;	<span class="comment">// 引用静态成员函数。</span></span><br><span class="line">	<span class="built_in">fp1</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数指针调用静态成员函数。</span></span><br><span class="line">	<span class="built_in">fr1</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数引用调用静态成员函数。</span></span><br><span class="line"></span><br><span class="line">	Fun* fp2 = AA::show;										<span class="comment">// 用函数指针指向静态成员函数。</span></span><br><span class="line">	Fun&amp; fr2 = AA::show;									<span class="comment">// 引用静态成员函数。</span></span><br><span class="line">	<span class="built_in">fp2</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数指针调用静态成员函数。</span></span><br><span class="line">	<span class="built_in">fr2</span>(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数引用调用静态成员函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><ul>
<li>仿函数的本质是类，调用的代码像函数。</li>
<li>仿函数的类型就是类的类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BB</span>	<span class="comment">// 仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BB bb;</span><br><span class="line">	<span class="built_in">bb</span>(<span class="number">11</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);		<span class="comment">// 用对象调用仿函数。</span></span><br><span class="line">	<span class="built_in">BB</span>()(<span class="number">12</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);		<span class="comment">// 用匿名对象调用仿函数。</span></span><br><span class="line"></span><br><span class="line">	BB&amp; br = bb;           		<span class="comment">// 引用函数</span></span><br><span class="line">	<span class="built_in">br</span>(<span class="number">13</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);		<span class="comment">// 用对象的引用调用仿函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>lambda函数的本质是仿函数，仿函数的本质是类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 创建lambda对象。</span></span><br><span class="line">	<span class="keyword">auto</span> lb = [](<span class="type">int</span> bh, <span class="type">const</span> string&amp; message) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span>&amp; lr = lb;  <span class="comment">// 引用lambda对象。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">lb</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);		<span class="comment">// 用lambda对象调用仿函数。</span></span><br><span class="line">	<span class="built_in">lr</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);		<span class="comment">// 用lambda对象的引用调用仿函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的非静态成员函数"><a href="#类的非静态成员函数" class="headerlink" title="类的非静态成员函数"></a>类的非静态成员函数</h3><ul>
<li>类的非静态成员函数有地址，但是，只能通过类的对象才能调用它，所以，C++对它做了特别处理。</li>
<li>类的非静态成员函数只有指针类型，没有引用类型，不能引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CC</span>	<span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CC cc;</span><br><span class="line">	cc.<span class="built_in">show</span>(<span class="number">14</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">void</span> (CC::* fp11)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = &amp;CC::show;		<span class="comment">// 定义类的成员函数的指针。</span></span><br><span class="line">	(cc.*fp11)(<span class="number">15</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);									<span class="comment">// 用类的成员函数的指针调用成员函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> pFun = <span class="built_in">void</span> (CC::*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);		<span class="comment">// 类成员函数的指针类型。</span></span><br><span class="line">	pFun fp12 = &amp;CC::show;										<span class="comment">// 让类成员函数的指针指向类的成员函数的地址。</span></span><br><span class="line">	(cc.*fp12)(<span class="number">16</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);							<span class="comment">// 用类成员函数的指针调用类的成员函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可被转换为函数指针的类对象"><a href="#可被转换为函数指针的类对象" class="headerlink" title="可被转换为函数指针的类对象"></a>可被转换为函数指针的类对象</h3><ul>
<li>类可以重载类型转换运算符operator 数据类型() ，如果数据类型是函数指针或函数引用类型，那么该类实例也将成为可调用对象。</li>
<li>它的本质是类，调用的代码像函数。</li>
<li>在实际开发中，意义不大<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DD</span>		<span class="comment">// 可以被转换为函数指针的类。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> Fun = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> show;	<span class="comment">// 返回普通函数。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DD dd;</span><br><span class="line">	<span class="built_in">dd</span>(<span class="number">17</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 可以被转换为函数指针的类对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="包装器function"><a href="#包装器function" class="headerlink" title="包装器function"></a>包装器function</h2><ul>
<li>std::function模板类是<strong>一个通用的可调用对象的包装器</strong>，用简单的、统一的方式处理可调用对象</li>
<li>std::function是一个通用的函数封装器，<strong>可以用来存储和调用任何可调用对象，包括函数指针、函数对象、Lambda表达式等</strong>。它类似于一个类型安全的函数指针，可以在运行时决定要调用的具体函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Fty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>……</span><br></pre></td></tr></table></figure></li>
<li><code>_Fty是可调用对象的类型，格式：返回类型(参数列表)。</code></li>
<li>包含头文件：<code>#include &lt;functional&gt;</code></li>
<li>注意：<br>  • 重载了bool运算符，用于判断是否包装了可调用对象。<br>  • 如果std::function对象未包装可调用对象，使用std::function对象将抛出std::bad_function_call异常。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>	<span class="comment">// 类中有静态成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>	<span class="comment">// 仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span>	<span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DD</span>		<span class="comment">// 可以被转换为普通函数指针的类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Fun = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);    <span class="comment">// 函数指针的别名。</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> show;	<span class="comment">// 返回普通函数show的地址。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> Fun = <span class="built_in">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;);  <span class="comment">// 函数类型的别名。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通函数。</span></span><br><span class="line">	<span class="built_in">void</span>(*fp1)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = show;	<span class="comment">// 声明函数指针，指向函数对象。</span></span><br><span class="line">	<span class="built_in">fp1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用函数指针调用普通函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn1 = show;    <span class="comment">// 包装普通全局函数show。</span></span><br><span class="line">	<span class="built_in">fn1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用普通全局函数show。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类的静态成员函数。</span></span><br><span class="line">	<span class="built_in">void</span>(*fp3)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = AA::show;	<span class="comment">// 用函数指针指向类的静态成员函数。</span></span><br><span class="line">	<span class="built_in">fp3</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);							<span class="comment">// 用函数指针调用类的静态成员函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn3 = AA::show;		<span class="comment">// 包装类的静态成员函数。</span></span><br><span class="line">	<span class="built_in">fn3</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);												<span class="comment">// 用function对象调用类的静态成员函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仿函数。</span></span><br><span class="line">	BB bb;</span><br><span class="line">	<span class="built_in">bb</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);		<span class="comment">// 用仿函数对象调用仿函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn4 = <span class="built_in">BB</span>();		<span class="comment">// 包装仿函数。</span></span><br><span class="line">	<span class="built_in">fn4</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用仿函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建lambda对象。</span></span><br><span class="line">	<span class="keyword">auto</span> lb = [](<span class="type">int</span> bh, <span class="type">const</span> string&amp; message) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">lb</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);          <span class="comment">// 调用lambda函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn5 = lb;			<span class="comment">// 包装lamba函数。</span></span><br><span class="line">	<span class="built_in">fn5</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用lamba函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类的非静态成员函数。</span></span><br><span class="line">	CC cc;</span><br><span class="line">	<span class="built_in">void</span> (CC:: * fp11)(<span class="type">int</span>, <span class="type">const</span> string&amp;) = &amp;CC::show;		<span class="comment">// 定义类成员函数的指针。</span></span><br><span class="line">	(cc.*fp11)(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);									<span class="comment">// 用类成员函数的指针调用类的成员函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(CC&amp;,<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn11 = &amp;CC::show;	<span class="comment">// 包装成员函数。</span></span><br><span class="line">	<span class="built_in">fn11</span>(cc,<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);											<span class="comment">// 用function对象调用成员函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以被转换为函数指针的类对象。</span></span><br><span class="line">	DD dd;</span><br><span class="line">	<span class="built_in">dd</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);						<span class="comment">// 用可以被转换为函数指针的类对象调用普通函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn12 = dd;			<span class="comment">// 包装可以被转换为函数指针的类。</span></span><br><span class="line">	<span class="built_in">fn12</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用它。</span></span><br><span class="line"></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fx=dd;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (fx) <span class="built_in">fx</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::bad_function_call e) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;抛出了std::bad_function_call异常。&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="适配器bind"><a href="#适配器bind" class="headerlink" title="适配器bind"></a>适配器bind</h2><ul>
<li>std::bind用于<strong>将函数和其参数绑定为一个可调用的对象</strong>。它可以创建一个新的可调用对象，使得在调用时可以传递参数、绑定参数或者重排参数的顺序</li>
<li>包含头文件：<code>#include &lt;functional&gt;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数原型：</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Fx</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">function&lt;&gt; <span class="built_in">bind</span> (Fx&amp;&amp; fx, Args&amp;...args);</span><br></pre></td></tr></table></figure></li>
<li>Fx：需要绑定的可调用对象（可以是前两节课介绍的那六种，也可以是function对象）。</li>
<li>args：绑定参数列表，可以是左值、右值和参数占位符<code>std::placeholders::_n</code>，如果参数不是占位符，缺省为值传递，std:: ref(参数)则为引用传递。</li>
<li>std::bind()返回std::function的对象。</li>
<li>std::bind()的本质是仿函数。<br>示例1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">	std::cout&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// std::placeholders::_n指的在原来函数形参的第n个位置</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyFunc = std::<span class="built_in">bind</span>(Multiply, std::placeholders::_2, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line">    <span class="comment">// 绑定Multiply函数，将第二个参数绑定为5，第一个参数绑定为占位符_2，第三个参数绑定为占位符_1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multiplyFunc</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 调用multiplyFunc，传递参数3作为占位符_2的值，传递参数2作为占位符_1的值，固定的参数5保持不变</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
示例2<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn1 = show;</span><br><span class="line">	<span class="comment">//std::placeholders::_1是C++标准库提供的一个占位符</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn2 = <span class="built_in">bind</span>(show, placeholders::_1, placeholders::_2);</span><br><span class="line">	<span class="built_in">fn1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">	<span class="built_in">fn2</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">const</span> string&amp;, <span class="type">int</span>)&gt; fn3 = <span class="built_in">bind</span>(show, placeholders::_2, placeholders::_1);</span><br><span class="line">	<span class="built_in">fn3</span>(<span class="string">&quot;我是一只傻傻鸟。&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">const</span> string&amp;)&gt; fn4 = <span class="built_in">bind</span>(show, <span class="number">3</span>, placeholders::_1);</span><br><span class="line">	<span class="built_in">fn4</span>(<span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line"></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;,<span class="type">int</span>)&gt; fn5 = <span class="built_in">bind</span>(show, placeholders::_1, placeholders::_2);</span><br><span class="line">	<span class="built_in">fn5</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>, <span class="number">88</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
示例3<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AA</span>	<span class="comment">// 类中有静态成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BB</span>	<span class="comment">// 仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CC</span>	<span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DD</span>		<span class="comment">// 可以被转换为普通函数指针的类。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">using</span> Fun = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">const</span> string&amp;);    <span class="comment">// 函数指针的别名。</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> show;	<span class="comment">// 返回普通函数show的地址。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 普通函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn1 = <span class="built_in">bind</span>(show, placeholders::_1, placeholders::_2);    <span class="comment">// 绑定普通全局函数show。</span></span><br><span class="line">	<span class="built_in">fn1</span>(<span class="number">1</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用普通全局函数show。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类的静态成员函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn3 = <span class="built_in">bind</span>(AA::show, placeholders::_1, placeholders::_2);		<span class="comment">// 绑定类的静态成员函数。</span></span><br><span class="line">	<span class="built_in">fn3</span>(<span class="number">2</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);												<span class="comment">// 用function对象调用类的静态成员函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 仿函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn4 = <span class="built_in">bind</span>(<span class="built_in">BB</span>(), placeholders::_1, placeholders::_2);			<span class="comment">// 绑定仿函数。</span></span><br><span class="line">	<span class="built_in">fn4</span>(<span class="number">3</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用仿函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建lambda对象。</span></span><br><span class="line">	<span class="keyword">auto</span> lb = [](<span class="type">int</span> bh, <span class="type">const</span> string&amp; message) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn5 = <span class="built_in">bind</span>(lb, placeholders::_1, placeholders::_2);			<span class="comment">// 绑定lamba函数。</span></span><br><span class="line">	<span class="built_in">fn5</span>(<span class="number">4</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用lamba函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类的非静态成员函数。</span></span><br><span class="line">	CC cc;</span><br><span class="line">	<span class="comment">//function&lt;void(CC&amp;, int, const string&amp;)&gt; fn11 = bind(&amp;CC::show, placeholders::_1, placeholders::_2, placeholders::_3);		// 绑定成员函数。</span></span><br><span class="line">	<span class="comment">//fn11(cc, 5, &quot;我是一只傻傻鸟。&quot;);											// 用function对象调用成员函数。</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn11 = <span class="built_in">bind</span>(&amp;CC::show,&amp;cc,placeholders::_1, placeholders::_2);		<span class="comment">// 绑定成员函数。</span></span><br><span class="line">	<span class="built_in">fn11</span>(<span class="number">5</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);											<span class="comment">// 用function对象调用成员函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以被转换为函数指针的类对象。</span></span><br><span class="line">	DD dd;</span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">const</span> string&amp;)&gt; fn12 = <span class="built_in">bind</span>(dd, placeholders::_1, placeholders::_2);			<span class="comment">// 绑定可以被转换为函数指针的类。</span></span><br><span class="line">	<span class="built_in">fn12</span>(<span class="number">6</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>);										<span class="comment">// 用function对象调用它。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可变函数和参数"><a href="#可变函数和参数" class="headerlink" title="可变函数和参数"></a>可变函数和参数</h3><ul>
<li>写一个函数，函数的参数是函数对象及参数，功能和thread类的构造函数相同。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>        </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show0</span><span class="params">()</span> </span>&#123;  <span class="comment">// 普通函数。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的，我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show1</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;  <span class="comment">// 普通函数。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CC</span>	<span class="comment">// 类中有普通成员函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show2</span><span class="params">(<span class="type">int</span> bh, <span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; bh &lt;&lt; <span class="string">&quot;号，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="comment">//std::bind函数接受一个可调用对象和一些参数，并返回一个函数对象，该函数对象绑定了可调用对象和参数。在这里，我们使用了完美转发（std::forward）来将传入的可调用对象和参数进行转发</span></span><br><span class="line"><span class="comment">//bind(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...)相当于接受传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">show</span><span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;...args)</span> -&gt; <span class="title">decltype</span><span class="params">(bind(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出表白前的准备工作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表白前的准备工作......\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用bind函数创建一个函数对象f，绑定了可调用对象fn和参数args...</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">bind</span>(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用函数对象f，执行绑定的可调用对象和参数</span></span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表白完成。\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 将函数对象f返回</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">show</span>(show0);</span><br><span class="line">	<span class="built_in">show</span>(show1,<span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">	CC cc;</span><br><span class="line">	<span class="keyword">auto</span> f = <span class="built_in">show</span>(&amp;CC::show2,&amp;cc, <span class="number">3</span>,<span class="string">&quot;我是一只傻傻鸟。&quot;</span>);</span><br><span class="line">	<span class="built_in">f</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//thread t1(show0);</span></span><br><span class="line">	<span class="comment">//thread t2(show1,&quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line">	<span class="comment">//CC cc;</span></span><br><span class="line">	<span class="comment">//thread t3(&amp;CC::show2,&amp;cc, 3,&quot;我是一只傻傻鸟。&quot;);</span></span><br><span class="line">	<span class="comment">//t1.join();</span></span><br><span class="line">	<span class="comment">//t2.join();</span></span><br><span class="line">	<span class="comment">//t3.join();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h3><ul>
<li>在消息队列和网络库的框架中，当接收到消息（报文）时，回调用户自定义的函数对象，把消息（报文）参数传给它，由它决定如何处理<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>                      <span class="comment">// 线程类头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>                      <span class="comment">// 互斥锁类的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>                      <span class="comment">// deque容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>                      <span class="comment">// queue容器的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span>  <span class="comment">// 条件变量的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;  <span class="comment">// 处理业务的普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;处理数据：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BB</span> &#123;  <span class="comment">// 处理业务的类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;处理表白数据：&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex m_mutex;                                    <span class="comment">// 互斥锁。</span></span><br><span class="line">    condition_variable m_cond;                  <span class="comment">// 条件变量。</span></span><br><span class="line">    queue&lt;string, deque&lt;string&gt;&gt; m_q;   <span class="comment">// 缓存队列，底层容器用deque。</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">const</span> string&amp;)&gt; m_callback;  <span class="comment">// 回调函数对象。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注册回调函数，回调函数只有一个参数（消费者接收到的数据）。</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">callback</span><span class="params">(Fn &amp;&amp; fn, Args&amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">        m_callback = <span class="built_in">bind</span>(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)..., std::placeholders::_1);  <span class="comment">// 绑定回调函数。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incache</span><span class="params">(<span class="type">int</span> num)</span>     <span class="comment">// 生产数据，num指定数据的个数。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   <span class="comment">// 申请加锁。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; num; ii++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> bh = <span class="number">1</span>;           <span class="comment">// 超女编号。</span></span><br><span class="line">            string message = <span class="built_in">to_string</span>(bh++) + <span class="string">&quot;号超女&quot;</span>;    <span class="comment">// 拼接出一个数据。</span></span><br><span class="line">            m_q.<span class="built_in">push</span>(message);     <span class="comment">// 把生产出来的数据入队。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//m_cond.notify_one();     // 唤醒一个被当前条件变量阻塞的线程。</span></span><br><span class="line">        m_cond.<span class="built_in">notify_all</span>();          <span class="comment">// 唤醒全部被当前条件变量阻塞的线程。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">outcache</span><span class="params">()</span> </span>&#123;    <span class="comment">// 消费者线程任务函数。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 把互斥锁转换成unique_lock&lt;mutex&gt;，并申请加锁。</span></span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1）把互斥锁解开；2）阻塞，等待被唤醒；3）给互斥锁加锁。</span></span><br><span class="line">            m_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !m_q.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据元素出队。</span></span><br><span class="line">            string message = m_q.<span class="built_in">front</span>();  m_q.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;线程：&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;，&quot;</span> &lt;&lt; message &lt;&lt; endl;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();      <span class="comment">// 手工解锁。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理出队的数据（把数据消费掉）。</span></span><br><span class="line">            <span class="keyword">if</span> (m_callback) <span class="built_in">m_callback</span>(message);  <span class="comment">// 回调函数，把收到的数据传给它。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA aa;</span><br><span class="line">    <span class="comment">// aa.callback(show);                   // 把普通函数show()注册为回调函数。</span></span><br><span class="line">    BB bb;</span><br><span class="line">    aa.<span class="built_in">callback</span>(&amp;BB::show, &amp;bb);    <span class="comment">// 把类成员函数BB::show()注册为回调函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t1。</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t2。</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(&amp;AA::outcache, &amp;aa)</span></span>;     <span class="comment">// 创建消费者线程t3。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));    <span class="comment">// 休眠2秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">2</span>);      <span class="comment">// 生产2个数据。</span></span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));    <span class="comment">// 休眠3秒。</span></span><br><span class="line">    aa.<span class="built_in">incache</span>(<span class="number">5</span>);      <span class="comment">// 生产5个数据。</span></span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();   <span class="comment">// 回收子线程的资源。</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在ros中的回调函数"><a href="#在ros中的回调函数" class="headerlink" title="在ros中的回调函数"></a>在ros中的回调函数</h3><p>[[ROS#回调函数传入多个参数|回调函数传入多个参数]]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类中的直接使用的回调函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uav_info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ros::Subscriber state_sub;<span class="comment">//订阅飞控中的当前无人机的状态，在后面的代码中使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立一个订阅消息体类型的变量，用于存储当前状态的信息</span></span><br><span class="line">    mavros_msgs::State current_state;</span><br><span class="line">    <span class="built_in">Uav_info</span>(ros::NodeHandle nh,std::string model_name)&#123;</span><br><span class="line">        state_sub = nh.<span class="built_in">subscribe</span>&lt;mavros_msgs::State&gt;(<span class="string">&quot;/&quot;</span> + model_name + <span class="string">&quot;/mavros/state&quot;</span>, <span class="number">10</span>, boost::<span class="built_in">bind</span>(&amp;Uav_info::state_cb, <span class="keyword">this</span>, _1, boost::<span class="built_in">ref</span>(current_state)));</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">state_cb</span><span class="params">(<span class="type">const</span> mavros_msgs::State::ConstPtr&amp; msg, mavros_msgs::State&amp; current_state)</span> </span>&#123;</span><br><span class="line">        current_state = *msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类中的回调函数无其他参数写法</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pose_x=nh.<span class="built_in">subscribe</span>&lt;std_msgs::Float32&gt;(<span class="string">&quot;/&quot;</span>+model_name+<span class="string">&quot;/pose_x&quot;</span>, <span class="number">10</span>,</span><br><span class="line">                                                              boost::<span class="built_in">bind</span>(&amp;Uav_info::Pose_x_cb, <span class="keyword">this</span>, _1));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Uav_info::Pose_x_cb</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">const</span> std_msgs::Float32&gt;&amp; msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setpoint_pose.pose.position.x=msg-&gt;data;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Pub_pos</span>(<span class="keyword">this</span>-&gt;setpoint_pose.pose.position.x,<span class="keyword">this</span>-&gt;setpoint_pose.pose.position.y,<span class="keyword">this</span>-&gt;setpoint_pose.pose.position.z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法（用于类内部）：</span></span><br><span class="line"><span class="comment">// state_sub = nh.subscribe&lt;mavros_msgs::State&gt;(&quot;/&quot; + model_name + &quot;/mavros/state&quot;, 10, </span></span><br><span class="line"><span class="comment">//             boost::bind(&amp;Uav_info::state_cb, this, _1, boost::ref(current_state)));</span></span><br><span class="line"><span class="comment">// 在这种写法中，使用了boost::bind将成员函数state_cb绑定到回调函数上，并使用this指针来指定对象。也就是说，回调函数中的第一个参数将是对象的指针this，用于访问类的成员变量和成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法（用于函数）：</span></span><br><span class="line"><span class="comment">// state_sub = nh.subscribe&lt;mavros_msgs::State&gt;(&quot;/&quot;+model_name+&quot;/mavros/state&quot;, 10, </span></span><br><span class="line"><span class="comment">//             boost::bind(&amp;Uav_info::state_cb, _1, boost::ref(this-&gt;current_state)));</span></span><br><span class="line"><span class="comment">// 在这种写法中，同样使用了boost::bind将成员函数state_cb绑定到回调函数上。但是这次没有使用this指针来指定对象，而是使用了_1占位符。这意味着回调函数的第一个参数将是接收到的消息指针，而不是对象的指针。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="取代虚函数"><a href="#取代虚函数" class="headerlink" title="取代虚函数"></a>取代虚函数</h2><ul>
<li>C++虚函数在执行过程中会跳转两次（先查找对象的函数表，再次通过该函数表中的地址找到真正的执行地址），这样的话，CPU会跳转两次，而普通函数只跳转一次。</li>
<li>CPU每跳转一次，预取指令要作废很多，所以效率会很低。（百度）</li>
<li>为了管理的方便（基类指针可指向派生类对象和自动析构派生类），保留类之间的继承关系。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>         <span class="comment">// 包含头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hero</span>  &#123;							<span class="comment">// 英雄基类</span></span><br><span class="line">	<span class="comment">//virtual void show() &#123; cout &lt;&lt; &quot;英雄释放了技能。\n&quot;; &#125;</span></span><br><span class="line">	function&lt;<span class="type">void</span>()&gt; m_callback;        <span class="comment">// 用于绑定子类的成员函数。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册子类成员函数，子类成员函数没有参数。</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">callback</span><span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">		m_callback = <span class="built_in">bind</span>(forward&lt;Fn&gt;(fn), forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">m_callback</span>(); &#125;   <span class="comment">// 调用子类的成员函数。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">XS</span> :<span class="keyword">public</span> Hero  &#123;			<span class="comment">// 西施派生类</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;西施释放了技能。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HX</span> :<span class="keyword">public</span> Hero  &#123;			<span class="comment">// 韩信派生类</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;韩信释放了技能。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 根据用户选择的英雄，施展技能。</span></span><br><span class="line">	<span class="type">int</span> id = <span class="number">0</span>;     <span class="comment">// 英雄的id。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入英雄（1-西施；2-韩信。）：&quot;</span>;</span><br><span class="line">	cin &gt;&gt; id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建基类指针，将指向派生类对象，用基类指针调用派生类的成员函数。</span></span><br><span class="line">	Hero* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">1</span>) &#123;            <span class="comment">// 1-西施</span></span><br><span class="line">		ptr = <span class="keyword">new</span> XS;</span><br><span class="line">		ptr-&gt;<span class="built_in">callback</span>(&amp;XS::show, <span class="built_in">static_cast</span>&lt;XS*&gt;(ptr));  <span class="comment">// 注册子类成员函数。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;     <span class="comment">// 2-韩信</span></span><br><span class="line">		ptr = <span class="keyword">new</span> HX;</span><br><span class="line">		ptr-&gt;<span class="built_in">callback</span>(&amp;HX::show, <span class="built_in">static_cast</span>&lt;HX*&gt;(ptr));  <span class="comment">// 注册子类成员函数。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		ptr-&gt;<span class="built_in">show</span>();		<span class="comment">// 调用子类的成员函数。</span></span><br><span class="line">		<span class="keyword">delete</span> ptr;			<span class="comment">// 释放派生类对象。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io/post/52d1a938.html">https://github.com/wjl-a/data.github.io/post/52d1a938.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/wjl-a/data.github.io" target="_blank">醉卿枫の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/data.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-cpp/">程序语言/cpp</a></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2022/05/29/62939662553c9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/data.github.io/post/7148eefc.html" title="模板1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="title">模板1</div></div></a></div><div><a href="/data.github.io/post/7f157bf9.html" title="2.c++基础语法2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">2.c++基础语法2</div></div></a></div><div><a href="/data.github.io/post/36e8e938.html" title="3.c++类_基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++类_基础</div></div></a></div><div><a href="/data.github.io/post/f145b64d.html" title="1.c++类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">1.c++类</div></div></a></div><div><a href="/data.github.io/post/c010a565.html" title="3.c++模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++模板</div></div></a></div><div><a href="/data.github.io/post/2bc4fa53.html" title="2.c++类2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">2.c++类2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="this.onerror=null;this.src='/data.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">qq:2771329872</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#c-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">c++线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">1.2.</span> <span class="toc-text">线程的回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-thread%E7%9A%84%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">this_thread的全局函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-once%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">call_once函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#native-handle%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">native_handle函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.6.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.7.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.7.1.</span> <span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mutex%E7%B1%BB"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">mutex类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timed-mutex%E7%B1%BB"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">timed_mutex类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#recursive-mutex%E7%B1%BB"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">recursive_mutex类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-guard%E7%B1%BB"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">lock_guard类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">条件变量-生产消费者模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#condition-variable%E7%B1%BB"><span class="toc-number">1.8.1.</span> <span class="toc-text">condition_variable类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-lock%E7%B1%BB"><span class="toc-number">1.8.2.</span> <span class="toc-text">unique_lock类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">原子类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">可调用对象的绑定器和包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">可调用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">类的静态成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">仿函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">lambda函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">类的非静态成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A2%AB%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.5.</span> <span class="toc-text">可被转换为函数指针的类对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%99%A8function"><span class="toc-number">2.2.</span> <span class="toc-text">包装器function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8bind"><span class="toc-number">2.3.</span> <span class="toc-text">适配器bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">可变函数和参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">回调函数的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8ros%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">在ros中的回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">取代虚函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/52d1a938.html" title="8.c++_线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="8.c++_线程"/></a><div class="content"><a class="title" href="/data.github.io/post/52d1a938.html" title="8.c++_线程">8.c++_线程</a><time datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="7.c+++_智能指针_文件操作"/></a><div class="content"><a class="title" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作">7.c+++_智能指针_文件操作</a><time datetime="2023-12-23T16:00:00.000Z" title="发表于 2023-12-24 00:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="6.c++_STL"/></a><div class="content"><a class="title" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL">6.c++_STL</a><time datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="变结构无人机仿真"/></a><div class="content"><a class="title" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真">变结构无人机仿真</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/5d3e3d8b.html" title="soildworks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="soildworks"/></a><div class="content"><a class="title" href="/data.github.io/post/5d3e3d8b.html" title="soildworks">soildworks</a><time datetime="2023-10-27T13:01:00.000Z" title="发表于 2023-10-27 21:01:00">2023-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/data.github.io/js/utils.js"></script><script src="/data.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/data.github.io/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/data.github.io/js/search/local-search.js"></script></div></div></body></html>