<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>1.c++类 | 醉卿枫の博客</title><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="c++笔记来源 函数重载 C++中函数重载函数名相同，但是参数类型或者参数个数不同的两个函数叫做函数重载；1234567891011121314151617181920212223242526&#x2F;&#x2F; test1.cpp#include &lt;iostream&gt;using namespace std;int MyFun(int a, float b)&#123;    a++;    b &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="1.c++类">
<meta property="og:url" content="https://github.com/wjl-a/data.github.io/post/f145b64d.html">
<meta property="og:site_name" content="醉卿枫の博客">
<meta property="og:description" content="c++笔记来源 函数重载 C++中函数重载函数名相同，但是参数类型或者参数个数不同的两个函数叫做函数重载；1234567891011121314151617181920212223242526&#x2F;&#x2F; test1.cpp#include &lt;iostream&gt;using namespace std;int MyFun(int a, float b)&#123;    a++;    b &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2022/06/05/629c5257753d1.png">
<meta property="article:published_time" content="2023-07-09T13:01:00.000Z">
<meta property="article:modified_time" content="2023-12-06T12:49:51.081Z">
<meta property="article:author" content="醉卿枫">
<meta property="article:tag" content="程序语言&#x2F;cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2022/06/05/629c5257753d1.png"><link rel="shortcut icon" href="/data.github.io/img/favicon.png"><link rel="canonical" href="https://github.com/wjl-a/data.github.io/post/f145b64d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/data.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/data.github.io/',
  algolia: undefined,
  localSearch: {"path":"/data.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '1.c++类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-06 20:49:51'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bu.dusays.com/2022/06/05/629c5257753d1.png')"><nav id="nav"><span id="blog-info"><a href="/data.github.io/" title="醉卿枫の博客"><span class="site-name">醉卿枫の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">1.c++类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-09T13:01:00.000Z" title="发表于 2023-07-09 21:01:00">2023-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-06T12:49:51.081Z" title="更新于 2023-12-06 20:49:51">2023-12-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/data.github.io/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="1.c++类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/553387258">c++笔记来源</a></p>
<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/620328348">C++中函数重载</a><br>函数名相同，但是参数类型或者参数个数不同的两个函数叫做函数重载；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyFun</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    b = b+<span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my fun -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数重载　*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyFun</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a - <span class="number">6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my fun -2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MyFun</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">MyFun</span>(<span class="number">99.99</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>函数重载判断标准</strong></p>
<ul>
<li>函数的参数个数、参数类型、参数顺序不同三者中满足其中一个，就是函数重载了</li>
<li>如果只有函数返回值不同，不是函数重载；返回值不同，参数也不同的时候，可以作为函数<strong>重载</strong></li>
</ul>
<p><strong>函数重载调用准则</strong></p>
<ul>
<li>函数重载调用时，先去找名称相同的函数，然后进行参数个数和类型的匹配。</li>
<li>找不到匹配的函数就会编译失败，找到两个匹配的函数也会编译失败；</li>
<li>重载的的函数，本质是两个不同的函数，在静态链编的时候就编链成两个不同的函数；</li>
<li>类里面的函数重载发生在同一个类中；</li>
</ul>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul>
<li>类的成员变量叫属性</li>
<li>类的成员函数叫方法&#x2F;行为，类的成员函数可以定义在类的外面</li>
<li>用类定义一个类的变量叫做创建一个对象</li>
<li>类的成员变量和成员函数的作用域和生命周期与对象的作用域和生命名周期相同<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CGil</span>&#123;</span><br><span class="line">    string name;<span class="comment">//设置成员变量的值</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要声明，设置成员变量的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGil::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    name =name1;</span><br><span class="line">    age=age1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类.方法（）</span></span><br><span class="line"><span class="comment">//类.属性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><ul>
<li>类的成员有三种访问权限：public、private 和 protected, 分别表示公有的、私有的和受保护的</li>
<li>在类的内部（类的成员函数中），无论成员被声明为 public 还是 private, 都可以访问</li>
<li>在类的外部（定义类的代码之外），只能访问 public 成员，不能访问 private、protected 成员</li>
<li>在一个类体的定义中，private 和 public 可以出现多次</li>
<li>结构体的成员缺省为 public，类的成员缺省为 private</li>
<li>private 的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为 public<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line"><span class="comment">//public可访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> speed=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        x += a * speed;</span><br><span class="line">        y += b * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Player player;</span><br><span class="line">    player.x=<span class="number">5</span>;<span class="comment">//赋值</span></span><br><span class="line">    player.<span class="built_in">move</span>(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//调用方法</span></span><br><span class="line">    cout&lt;&lt;player.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;player.y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个日志系统观察类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelError=<span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelWarning=<span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LogLevelInfo=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_LogLevel=LogLevelInfo;<span class="comment">//默认日志</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">        m_LogLevel=level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Error</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_LogLevel&gt;=LogLevelError)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;[ERROR]: &quot;</span>&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Warn</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_LogLevel&gt;=LogLevelError)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;[WARNING]: &quot;</span>&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Info</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_LogLevel&gt;=LogLevelInfo)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;[INFO]: &quot;</span>&lt;&lt;message&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log log;</span><br><span class="line">    <span class="comment">// log.SetLevel(log.LogLevelWarning);</span></span><br><span class="line">    log.<span class="built_in">Warn</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Error</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    log.<span class="built_in">Info</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-类与对象"><a href="#C-类与对象" class="headerlink" title="C++类与对象"></a>C++类与对象</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013921164/article/details/130929563?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-130929563-blog-119177373.235%5Ev38%5Epc_relevant_default_base&utm_relevant_index=5">UML类图</a></li>
<li>类的成员函数可以直接访问该类其它的成员函数（可以递归）</li>
<li>类的成员函数可以重载，可以使用默认参数</li>
<li>类指针的用法与结构体指针用法相同</li>
<li>类的成员可以是任意数据类型，类中枚举</li>
<li>可以为类的成员指定缺省值</li>
</ul>
<h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><ul>
<li>构造函数：在创建对象时，自动进行初始化工作</li>
<li>析构函数：在销毁对象前，自动完成清理工作</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>语法：类名 (){…}</li>
<li>访问权限<strong>必须是 public</strong>.</li>
<li>函数名必须<strong>与类名相同</strong>。</li>
<li>没有返回值，也不写 void。</li>
<li>可以有参数，可以重载，可以有默认参数。</li>
<li>创建对象时会自动调用一次，不能手工调用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//创建构造函数，可以多个，但是需要有不同参数</span></span><br><span class="line">    <span class="comment">//CGirl() = default; 放在类的定义中的构造函数声明处，可以告诉编译器使用默认生成的方式来生成默认构造函数</span></span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(string name,<span class="type">int</span> age=<span class="number">23</span>)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//CGirl();在这里使用这个函数，含义不是调用构造函数（无参数），是创建一个匿名对象，不能这么用</span></span><br><span class="line">        m_age=age;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;构造函数2个参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CGirl</span>()&#123;</span><br><span class="line">    	cout&lt;&lt;<span class="string">&quot;调用析构函数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>;<span class="comment">//在外面需要生命，设置成员变量的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">    CGirl girl;<span class="comment">//调用没有参数的构造函数,不用括号</span></span><br><span class="line">    <span class="comment">// const char* ch=&quot;23&quot;;//等价于string ch=&quot;23&quot;,不加const 传参会报错</span></span><br><span class="line">    <span class="comment">// CGirl girl(&quot;西施&quot;,8);//调用有两个参数的构造函数</span></span><br><span class="line">    <span class="comment">// CGirl girl&#123;&quot;西施&quot;,8&#125;;//也可以这样写，用&#123;&#125;</span></span><br><span class="line">    <span class="comment">// CGirl girl;//隐式调用构造函数，无参数无括号，常用</span></span><br><span class="line">    <span class="comment">// CGirl girl=CGirl();//显示调用构造函数，无参数有括号</span></span><br><span class="line">    girl.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// girl.~CGirl();//手动调用,一般自动就会调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类函数在外的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CGirl::setvalue</span><span class="params">(string name1,<span class="type">int</span> age1)</span></span>&#123;</span><br><span class="line">    m_name =name1;</span><br><span class="line">    m_age=age1;</span><br><span class="line">    <span class="built_in">show</span>();<span class="comment">//类内部调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>语法：~类名 (){…}</li>
<li>访问权限必须是 public.</li>
<li>函数名必须在类名前加~。</li>
<li>没有返回值，也不写 void.</li>
<li>没有参数，不能重载。</li>
<li>销毁对象前只会自动调用一次，但是可以手工调用</li>
</ul>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ul>
<li><p>如果没有提供构造&#x2F;析构函数，编译器将提供<strong>空实现</strong>的构造&#x2F;析构函数。</p>
</li>
<li><p>如果提供了构造&#x2F;析构函数，编译器将不提供空实现的构造&#x2F;析构函数。</p>
</li>
<li><p>创建对象的时候，如果重载了构造函数，编译器<strong>根据实参匹配</strong>相应的构造函数。</p>
</li>
<li><p>创建对象的时候<strong>不要在对象名后面加空的圆括号，编译器误认为是声明函数</strong>。(没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）</p>
</li>
<li><p>在构造函数名后面加括号和参数<strong>不是调用构造函数，是创建匿名对象</strong>。</p>
</li>
<li><p>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐 <code>CGirl girl=10</code></p>
</li>
<li><p>下面两行代码有本质区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGirl girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>)；<span class="comment">//显示创建对象,会调用一次构造函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CGirl girl;<span class="comment">//创建对象</span></span><br><span class="line">girl=<span class="built_in">CGirl</span>(<span class="string">&quot;西施&quot;</span>，<span class="number">10</span>);<span class="comment">//创建匿名对象，然后给现有对象赋值，会调用构造函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>用 new&#x2F;delete 创建&#x2F;销毁对象时，也会调用构造函数或者析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGirl *girl=<span class="keyword">new</span> <span class="built_in">CGirl</span>();<span class="comment">//显示写法用new,必须用指针形式</span></span><br><span class="line">girl-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">delete</span> girl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果类成员有指针时，析构函数需要用这段代码 <code>delete ptr;ptr=nullptr;</code></p>
</li>
</ul>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul>
<li>用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。</li>
<li>如果类中没有定义拷贝构造函数，编译器<strong>将提供一个拷贝构造函数</strong>，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。</li>
</ul>
<p>用一个已存在的对象创建新的对象语法：</p>
<ul>
<li>类名  新对象名(已存在的对象名)；</li>
<li>类名  新对象名&#x3D;已存在的对象名；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//以无参数为例</span></span><br><span class="line">	CGirl g1;</span><br><span class="line">	g1.m_name=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line">	g1.m_age=<span class="number">18</span>;</span><br><span class="line">	<span class="comment">//写法1</span></span><br><span class="line">	<span class="function">CGirl <span class="title">g2</span><span class="params">(g1)</span></span>;</span><br><span class="line">	g2.<span class="built_in">show</span>();</span><br><span class="line">	<span class="comment">//写法2</span></span><br><span class="line">	CGirl g3=g1;</span><br><span class="line">	g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
拷贝构造函数写法：</li>
</ul>
<ol>
<li>无参数： <code>类名（const 类名&amp; 对象名）&#123;&#125;</code>；</li>
<li>有参数： <code>类名（...，connst 类名&amp; 对象名，....）&#123;&#125;</code></li>
</ol>
<ul>
<li>访问权限必须 public</li>
<li>函数名必须与类名相同</li>
<li>以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。</li>
<li>函数以值的方式返回对象时，可能会调用拷贝构造函数（VS 会调用，Linux 不会）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参数直接用</span></span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp;gg)<span class="comment">//没有重载的拷贝函数,针对的是无参数的构造函数，默认执行，先构造后拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name=<span class="string">&quot;漂亮的&quot;</span>+gg.m_name;</span><br><span class="line">        m_age=gg.m_age<span class="number">-1</span>;</span><br><span class="line">     </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//有参数是写法</span></span><br><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp;gg,<span class="type">int</span> age)<span class="comment">//带有一个参数的拷贝函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name=<span class="string">&quot;漂亮的&quot;</span>+gg.m_name;</span><br><span class="line">        m_age=gg.m_age-age;</span><br><span class="line">     </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	CGirl g1;</span><br><span class="line">	g1.m_name=<span class="string">&quot;西施&quot;</span>;</span><br><span class="line">	g1.m_age=<span class="number">18</span>;</span><br><span class="line">	<span class="function">CGirl <span class="title">g2</span><span class="params">(g1,<span class="number">3</span>)</span></span>;</span><br><span class="line">	g2.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42174306/article/details/122882267?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169017884016800186546005%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169017884016800186546005&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-122882267-null-null.142%5Ev90%5Econtrol,239%5Ev3%5Econtrol&utm_term=%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9Dc++&spm=1018.2226.3001.4187">C++浅拷贝与深拷贝</a></p>
<ol>
<li>浅拷贝： 将原对象或原数组的引用直接赋给新对象，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存</li>
<li>深拷贝： <strong>创建</strong>一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”，新对象与原对象不共享内存，修改新对象不会改到元对象</li>
<li>编译器提供的拷贝函数是浅拷贝，所以，在<strong>对含有指针成员的对象进行拷贝</strong>时，必须自己定义<strong>拷贝构造函数</strong>，达到深拷贝的目的，才能必变内存重复释放<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGirl</span>(<span class="type">const</span> CGirl &amp;gg)<span class="comment">//没有重载的拷贝函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name=<span class="string">&quot;漂亮的&quot;</span>+gg.m_name;</span><br><span class="line">        <span class="comment">//分配内存，赋值</span></span><br><span class="line">        m_prt=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//分配内存,</span></span><br><span class="line">        *m_ptr=<span class="number">3</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;调用拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><ul>
<li>构造函数的执行可以分成两个阶段：初始化阶段和计算阶段。初始化阶段先于计算阶段。</li>
<li>初始化阶段：全部的成员都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中。</li>
<li>计算阶段：一般是指用于执行构造函数体内的赋值操作。</li>
<li>构造函数除了参数列表和函数体外，还可以由初始化列表<br>初始化列表的语法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类名(形参列表):成员<span class="number">1</span>（值<span class="number">1</span>）,...,成员<span class="built_in">n</span>(值n)&#123;...&#125;</span><br><span class="line"><span class="comment">//对无参数构造函数调用</span></span><br><span class="line"><span class="built_in">CGirl</span>():<span class="built_in">m_name</span>(<span class="string">&quot;西施&quot;</span>),<span class="built_in">m_age</span>(<span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;构造函数无参数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGirl</span>(string name,<span class="type">int</span> age):<span class="built_in">m_name</span>(<span class="string">&quot;漂亮的&quot;</span>+name),<span class="built_in">m_age</span>(age)&#123;&#125;<span class="comment">//对于有参数的构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。</li>
<li>初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。</li>
<li>初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是拷贝构造函数，而赋值则是先创建对象（调用普通构造函数），然后再赋值。</li>
<li>如果成员是类，初始化列表效率更高。</li>
<li>如果成员是<strong>常量和引用</strong>，必须使用初始列表，因为常量和引用只能在定义的时候初始化。 </li>
<li>如果成员是没有默认构造函数的类，则必须使用初始列表。</li>
</ol>
<h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><ul>
<li>在类的成员函数后面加 const 关键字，表示在成员函数中保证不会修改调用对象的成员变量。</li>
<li>类中调用一般用解引用去传参<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> CGirl &amp;<span class="title function_">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span> <span class="type">const</span></span><br></pre></td></tr></table></figure></li>
<li>其中，第一个<code>const</code>表示返回值是一个常引用类型，第二个<code>const</code>表示该函数是一个成员常函数，而第三个<code>const</code>则表示该成员函数不会修改任何成员变量的值。<br><strong>注意：</strong></li>
<li>mutable 可以突破 const 的限制，被 mutable 修饰的成员变量，将永远处于可变的状态，在 const 修饰的函数中，mutable 成员也可以被修改。</li>
<li>非 const 成员函数可以调用 const 成员函数和非 const 成员函数。</li>
<li>const 成员函数不能调用非 const 成员函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//m_name=&quot;woo&quot;;//修改m_name,有const会报错</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ul>
<li><p>如果类的成员函数中涉及多个对象，在这种情况下需要使用 this 指针。</p>
</li>
<li><p>this 指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。</p>
</li>
<li><p>每个成员函数（包括构造函数和析构函数）都有一个 this 指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）</p>
</li>
<li><p><code>*this</code> 可以表示整个对象。</p>
</li>
<li><p>如果在成员函数的括号后面使用 const, 那么将不能通过 this 指针修改成员变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规写法对比对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;,年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;gg1,<span class="type">const</span> CGirl &amp;gg2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(gg1.m_age&lt;gg2.m_age) <span class="keyword">return</span> gg2;</span><br><span class="line">	<span class="keyword">return</span> gg1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=<span class="built_in">pk</span>(g1,g2);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类中定义</span></span><br><span class="line"><span class="function"><span class="type">const</span> CGirl &amp;<span class="title">pk</span><span class="params">(<span class="type">const</span> CGirl &amp;g)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g.m_age&gt;m_age) <span class="keyword">return</span> g;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span>,<span class="title">g2</span><span class="params">(<span class="string">&quot;西瓜&quot;</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> CGirl &amp;g3=g2.<span class="built_in">pk</span>(g1);</span><br><span class="line">    g3.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//对比5个</span></span><br><span class="line">    <span class="comment">// CGirl g1(&quot;西施&quot;,8),g2(&quot;西瓜1&quot;,9),g3(&quot;西瓜2&quot;,10),g4(&quot;西瓜3&quot;,11),g5(&quot;西瓜4&quot;,12);</span></span><br><span class="line">    <span class="comment">// const CGirl &amp;g=g1.pk(g2).pk(g3).pk(g4).pk(g5);</span></span><br><span class="line">    <span class="comment">// g.show();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个类中存在<strong>成员变量和局部变量同名</strong>时，可以使用this关键字来访问成员变量。例如：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myVariable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVariable</span><span class="params">(<span class="type">int</span> myVariable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;myVariable = myVariable; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;myVariable: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;myVariable &lt;&lt; std::endl; <span class="comment">// 使用this指针访问成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setVariable</span>(<span class="number">10</span>);</span><br><span class="line">    obj.<span class="built_in">printVariable</span>(); <span class="comment">// 输出: myVariable: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，setVariable函数中的形参myVariable和类的成员变量myVariable同名。为了区分它们，使用this-&gt;myVariable来访问成员变量。</p>
<ul>
<li>另外，也可以使用this指针来调用其他成员函数。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">function1</span>(); <span class="comment">// 使用this指针调用其他成员函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is function2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">function2</span>(); <span class="comment">// 输出: This is function1</span></span><br><span class="line">                     <span class="comment">//       This is function2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在上面的例子中，function2通过使用this-&gt;function1()调用了function1成员函数。</li>
</ul>
<h3 id="类的静态成员变量"><a href="#类的静态成员变量" class="headerlink" title="类的静态成员变量"></a>类的静态成员变量</h3><ul>
<li>类的静态成员包括静态成员变量和静态成员函数。</li>
<li>用静态成员可以变量<strong>实现多个对象之间的数据共享</strong>，比全局变量更安全性。</li>
<li>用 static 关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。</li>
<li>静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解运算符）。</li>
<li>静态成员使用类名加范围解析运算符：就可以访问，不需要创建类对象。</li>
<li><strong>如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）</strong>。</li>
<li>静态成员变量在程序中只有一份 (生命周期与程序运行期相同，存放在静态存储区的)，不论是否创建了类的对象，也不论创建了多少个类的对象。</li>
<li>静态成员函数<strong>只能访问静态成员</strong>，不能访问非静态成员。</li>
<li>静态成员函数中没有 this 指针。</li>
<li>非静态成员函数可以访问静态成员。</li>
<li>私有静态变量在类外无法访问<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGirl</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_age;<span class="comment">//设置静态变量</span></span><br><span class="line">    <span class="type">char</span> m_memo[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">CGirl</span>()<span class="comment">//没有参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name.<span class="built_in">clear</span>();m_age=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(m_memo,<span class="number">0</span>,<span class="built_in">sizeof</span>(m_memo));</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;构造函数无参数&quot;&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGirl</span>(<span class="type">const</span> string name,<span class="type">int</span> age)<span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    	m_name=name;</span><br><span class="line">    	m_age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="comment">//静态函数,只能用静态变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CGirl::m_age=<span class="number">34</span>;<span class="comment">//初始化类的静态成员变量,没有或者在其他位置不行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	CGirl::<span class="built_in">show</span>();<span class="comment">//静态函数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;CGirl::m_age:&quot;</span>&lt;&lt;CGirl::m_age&lt;&lt;endl;<span class="comment">//可以在创建对象那个前访问</span></span><br><span class="line">    <span class="function">CGirl <span class="title">g1</span><span class="params">(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="结构体与类的对比"><a href="#结构体与类的对比" class="headerlink" title="结构体与类的对比"></a>结构体与类的对比</h2><p>区别：</p>
<blockquote>
<p>作用上：class默认private，struct默认public。<br>使用上：引入 struct 是为了让 C++向后兼容 C</p>
</blockquote>
<p>推荐选用：</p>
<blockquote>
<p>若只包含一些变量结构或POD(plain old data)时，选用struct。例如数学中的向量类。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span>&#123;</span><br><span class="line"> <span class="type">float</span> x, y;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Vec2&amp; other)</span></span>&#123;</span><br><span class="line">     x += other.x;</span><br><span class="line">     y += other.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若要实现很多功能的类，则选用class</p>
<h2 id="c-中的静态"><a href="#c-中的静态" class="headerlink" title="c++中的静态"></a>c++中的静态</h2><p>static 关键字两种用法</p>
<ul>
<li>在类或结构体外部使用 static 关键字</li>
</ul>
<blockquote>
<p>这意味着你定义的函数和变量只对它的声明所在的cpp文件（编译单元）是“可见”的。换句话说此时static修饰的符号,（在link的时候）它只对定义它的翻译单元(.obj)可见（internal linkage）。</p>
</blockquote>
<ul>
<li>在类或结构体内部使用static关键字</li>
</ul>
<blockquote>
<p>此时表示这部分内存（static变量）是这个类的<strong>所有实例共享</strong>的。即：该静态变量在类中创建的所有实例中，静态变量只有一个实例。<strong>一个改变就改变所有。</strong></p>
</blockquote>
<p>类中的静态方法也一样，静态方法中没有该实例的指针（this）。在类中没有实例会传递给该方法。</p>
<h2 id="C-类和结构体中的静态（static）"><a href="#C-类和结构体中的静态（static）" class="headerlink" title="C++类和结构体中的静态（static）"></a>C++类和结构体中的静态（static）</h2><ul>
<li><strong>静态方法</strong>不能访问<strong>非静态变量</strong></li>
<li><strong>静态方法没有类实例</strong></li>
<li>本质上你在类里写的每个<strong>非静态方法</strong>都会获得当前的类实例作为参数（this指针）</li>
<li>静态成员变量在编译时存储在静态存储区，即<strong>定义过程应该在编译时完成</strong>，因此<strong>一定要在类外进行定义</strong>，但可以不初始化。 <strong>静态成员变量是所有实例共享的</strong>，但是其<strong>只是在类中进行了声明，并未定义或初始化</strong>（分配内存），类或者类实例就无法访问静态成员变量，这显然是不对的，<strong>所以必须先在类外部定义</strong>，也就是分配内存。</li>
</ul>
<blockquote>
<p>在几乎所有面向对象的语言里，static在一个类中意味着特定的东西。<strong>如果是static变量，这意味着在类的所有实例中，这个变量只有一个实例。</strong>比如一个entity类，有很多个entity实例，若其中一个实例更改了这个static变量，它会在所有实例中反映这个变化。这是因为即使创建了很多实例，static的变量仍然只有一个。正因如此，<strong>通过类实例来引用静态变量是没有意义的</strong>。因为这就像类的全局实例。<br>静态方法也是一样，无法访问类的实例。静态方法可以被调用，不需要通过类的实例。而在静态方法内部，你不能写引用到类实例的代码，因为你不能引用到类的实例。</p>
</blockquote>
<p>比如一段最简单的测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然编译不会报错，但是链接会报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.obj : error LNK2001: unresolved external symbol <span class="string">&quot;public: static int Entity::x&quot;</span></span><br></pre></td></tr></table></figure>

<p>于是我们需要给出定义，让链接器可以链接到合适的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再创建一个实例对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    e1.<span class="built_in">print</span>();</span><br><span class="line">    e2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为两个2，这是因为两个实例化对象共享的是同一个变量，正因如此，<strong>通过类实例来引用静态变量是没有意义的</strong>，最好写为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    Entity::x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    Entity::x= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    e1.<span class="built_in">print</span>();</span><br><span class="line">    e2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把print()函数改为static，仍然正常，<strong>因为它引用的x，y也是静态的变量</strong>，同样的，正确代调用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Entity::x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    Entity::x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    Entity::x= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在这个例子里我们都用不到类的实例，因为这些全是静态的，故代码改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity::x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity::x= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line">    Entity::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但如果把x改为非静态的，则会报错，因为静态方法不能访问非静态变量，原因就是静态方法没有类实例，我们在编写类的时候，本质上我们在类里写的每个非静态方法都会获得当前的类实例作为参数（this指针）。</strong></p>
<p>因此静态方法和在类外部编写的方法是一样的。</p>
<p>如果在类外面写一个print()函数，则就会报错，这就能为什么说明不能访问到x；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 报错，不能访问到非静态变量x</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外面写一个print()函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; x &lt;&lt; endl;  <span class="comment">// 报错，x是什么？没被定义。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity e1;</span><br><span class="line">    e1.x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Entity e2;</span><br><span class="line">    e2.x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    e1.<span class="built_in">print</span>();</span><br><span class="line">    e2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果这样就可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类外面写一个print()函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(Entity e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; e.x &lt;&lt; endl;  <span class="comment">// 成功运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们刚刚写的方法，<strong>本质上就是一个类的非静态方法在编译时的真正样子</strong></p>
<p>但如果我把<strong>Entity实例去掉</strong>，就是<strong>把static关键字加到类方法时所做的</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类外面写一个print()函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span>       <span class="comment">//把Entity实例去掉</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; e.x &lt;&lt; endl;  <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是为什么会错，他不知道要怎么访问 Entity 的 x，y 因为你没有给他一个 Entity 的引用。</p>
<h1 id="PX4-C-代码形式理解"><a href="#PX4-C-代码形式理解" class="headerlink" title="PX4_C++代码形式理解"></a>PX4_C++代码形式理解</h1><h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43533553/article/details/123257675?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168906554316800227449672%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168906554316800227449672&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-123257675-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=c++%E4%B8%ADnamespace%E7%9A%84%E4%BD%BF%E7%94%A8&spm=1018.2226.3001.4187">C++命名空间namespace</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一定义</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间名字</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> model1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;<span class="comment">//当前变量i只对命名空间model1可见，它的作用域被限定在model1</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空间嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> 命名空间<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">namespace</span> 命名空间<span class="number">2</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2定义</span></span><br><span class="line"><span class="keyword">using</span> model1::i;</span><br><span class="line">i= <span class="number">0</span>;  <span class="comment">//使用model1定义的变量i</span></span><br><span class="line">model2::i= <span class="number">10</span>;  <span class="comment">//使用model2定义的变量i</span></span><br></pre></td></tr></table></figure>
<p>由于使用命名空间后，变量的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>被限定，所以在使用变量时，就需要通过特定方式来完成。需要用到“::”操作符，“::”操作符是域解析操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model1::i = <span class="number">1</span>;</span><br><span class="line">model2::i = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>命名空间成员使用方法总结</strong></p>
<blockquote>
<p>方法一 ：命名空间名:: 成员比如：spaceA:: a;<br>使用 using 可以使得命名空间中的成员暴露外部，以致可以使用该成员<br>方法二： using 命名空间名:: 成员 —-&gt; 把指定的成员暴露给外部<br>比如：using spaceA:: a;<br>方法三： using namespace 命名空间名 —&gt; 将其所有成员暴露给外部<br>比如： using namespace spaceA;</p>
</blockquote>
<h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@brief  ：简介，简单介绍函数作用  </span><br><span class="line">@param  ：介绍函数参数  </span><br><span class="line">@<span class="keyword">return</span>：函数返回类型说明  </span><br><span class="line">@exception NSException 可能抛出的异常.  </span><br><span class="line">@author zhangsan：  作者  </span><br><span class="line">@date <span class="number">2011</span><span class="number">-07</span><span class="number">-27</span> <span class="number">22</span>:<span class="number">30</span>:<span class="number">00</span> ：时间  </span><br><span class="line">@version <span class="number">1.0</span> ：版本    </span><br><span class="line">@property ：属性介绍</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过多行注释实现，如下</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param _name         The name of the topic.</span></span><br><span class="line"><span class="comment"> * @param _struct       The structure the topic provides.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>[[1、数据类型#宏定义|宏定义]]<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">orb_advert_t</span> <span class="title">orb_advertise</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> orb_metadata *meta, <span class="type">const</span> <span class="type">void</span> *data)</span> __EXPORT</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li><code>extern</code>: 这是一个 C&#x2F;C++关键字，<strong>用于表明被声明的函数不在当前文件中，而在其他的源文件中实现</strong>。这样的话，其他的源文件就可以调用到这个函数   </li>
<li><code>orb_advert_t</code>: 这是返回值类型。<code>orb_advert_t</code>应该是定义在别的地方的一个类型，可能是一个结构体、枚举等。<ol start="3">
<li><code>orb_advertise</code>: 这是函数名。</li>
<li><code>__EXPORT</code>: 这个通常是一个平台相关的宏，用于标记函数或变量，使其在链接时可被其他模块看见，就是说这个函数可以被其他的文件或模块调用</li>
</ol>
</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io/post/f145b64d.html">https://github.com/wjl-a/data.github.io/post/f145b64d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/wjl-a/data.github.io" target="_blank">醉卿枫の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/data.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-cpp/">程序语言/cpp</a></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2022/06/05/629c5257753d1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/data.github.io/post/7148eefc.html" title="模板1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-01</div><div class="title">模板1</div></div></a></div><div><a href="/data.github.io/post/7f157bf9.html" title="2.c++基础语法2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-12</div><div class="title">2.c++基础语法2</div></div></a></div><div><a href="/data.github.io/post/2bc4fa53.html" title="2.c++类2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">2.c++类2</div></div></a></div><div><a href="/data.github.io/post/c010a565.html" title="3.c++模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++模板</div></div></a></div><div><a href="/data.github.io/post/36e8e938.html" title="3.c++类_基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">3.c++类_基础</div></div></a></div><div><a href="/data.github.io/post/2f83c309.html" title="5.c++_模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-09</div><div class="title">5.c++_模板</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="this.onerror=null;this.src='/data.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">qq:2771329872</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.1.</span> <span class="toc-text">类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.</span> <span class="toc-text">C++类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造函数与析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">拷贝构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">浅拷贝和深拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">初始化列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">const 修饰成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E6%8C%87%E9%92%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">this 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.6.</span> <span class="toc-text">类的静态成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.</span> <span class="toc-text">结构体与类的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81"><span class="toc-number">2.4.</span> <span class="toc-text">c++中的静态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%EF%BC%88static%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">C++类和结构体中的静态（static）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PX4-C-%E4%BB%A3%E7%A0%81%E5%BD%A2%E5%BC%8F%E7%90%86%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">PX4_C++代码形式理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">3.0.1.</span> <span class="toc-text">命名空间 namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.0.2.</span> <span class="toc-text">常见注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern"><span class="toc-number">3.0.3.</span> <span class="toc-text">extern</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/52d1a938.html" title="8.c++_线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="8.c++_线程"/></a><div class="content"><a class="title" href="/data.github.io/post/52d1a938.html" title="8.c++_线程">8.c++_线程</a><time datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="7.c+++_智能指针_文件操作"/></a><div class="content"><a class="title" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作">7.c+++_智能指针_文件操作</a><time datetime="2023-12-23T16:00:00.000Z" title="发表于 2023-12-24 00:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="6.c++_STL"/></a><div class="content"><a class="title" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL">6.c++_STL</a><time datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="变结构无人机仿真"/></a><div class="content"><a class="title" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真">变结构无人机仿真</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/5d3e3d8b.html" title="soildworks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="soildworks"/></a><div class="content"><a class="title" href="/data.github.io/post/5d3e3d8b.html" title="soildworks">soildworks</a><time datetime="2023-10-27T13:01:00.000Z" title="发表于 2023-10-27 21:01:00">2023-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bu.dusays.com/2022/06/05/629c5257753d1.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/data.github.io/js/utils.js"></script><script src="/data.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/data.github.io/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/data.github.io/js/search/local-search.js"></script></div></div></body></html>