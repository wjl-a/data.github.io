<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>3.树与二叉树 | 醉卿枫の博客</title><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树与二叉树树的基本概念树的定义 树是n个结点的有限集，空树:结点为0的树 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 非空树应满足 有且只有一个特定的称为根的结点 当n&gt;1时，其余结点可以分为m个互不相交的有限集合，其中每个集合本身又是一棵树，并称为根的子树   非空树特性 有且只有一个根节点 没有后继的结点称为叶子结点（终端结点）——注：只有一个结点的树，该节点不是叶子节点">
<meta property="og:type" content="article">
<meta property="og:title" content="3.树与二叉树">
<meta property="og:url" content="https://github.com/wjl-a/data.github.io/post/65d6c3b7.html">
<meta property="og:site_name" content="醉卿枫の博客">
<meta property="og:description" content="树与二叉树树的基本概念树的定义 树是n个结点的有限集，空树:结点为0的树 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 非空树应满足 有且只有一个特定的称为根的结点 当n&gt;1时，其余结点可以分为m个互不相交的有限集合，其中每个集合本身又是一棵树，并称为根的子树   非空树特性 有且只有一个根节点 没有后继的结点称为叶子结点（终端结点）——注：只有一个结点的树，该节点不是叶子节点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png">
<meta property="article:published_time" content="2022-07-01T00:00:00.000Z">
<meta property="article:modified_time" content="2023-12-06T12:49:17.971Z">
<meta property="article:author" content="醉卿枫">
<meta property="article:tag" content="程序语言&#x2F;数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png"><link rel="shortcut icon" href="/data.github.io/img/favicon.png"><link rel="canonical" href="https://github.com/wjl-a/data.github.io/post/65d6c3b7.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/data.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/data.github.io/',
  algolia: undefined,
  localSearch: {"path":"/data.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '3.树与二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-06 20:49:17'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><nav id="nav"><span id="blog-info"><a href="/data.github.io/" title="醉卿枫の博客"><span class="site-name">醉卿枫の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">3.树与二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-01T00:00:00.000Z" title="发表于 2022-07-01 08:00:00">2022-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-06T12:49:17.971Z" title="更新于 2023-12-06 20:49:17">2023-12-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/data.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="3.树与二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><ul>
<li>树是n个结点的有限集，空树:结点为0的树</li>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>非空树应满足<ul>
<li>有且只有一个特定的称为根的结点</li>
<li>当n&gt;1时，其余结点可以分为m个互不相交的有限集合，其中每个集合本身又是一棵树，并称为根的子树</li>
</ul>
</li>
<li>非空树特性<ul>
<li>有且只有一个根节点</li>
<li>没有后继的结点称为<strong>叶子结点</strong>（终端结点）——注：只有一个结点的树，该节点不是叶子节点</li>
<li>有后继的结点称为<strong>分支结点</strong>（非终端结点）</li>
<li>除了根节点外，任何结点都有且<strong>只有一个前驱</strong></li>
<li>每个结点可以有0个或多个后继</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207012108033.png" alt="image-20220701210802760"></p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="结点之间的关系描述"><a href="#结点之间的关系描述" class="headerlink" title="结点之间的关系描述"></a>结点之间的关系描述</h4><ul>
<li>祖先结点：从根到该节点所经分支上的所有节点（该分支上的其他结点都是）</li>
<li>子孙结点：以某节点为根的子树中任一节点都称为该节点的子孙（该结点分支后面的所有结点）</li>
<li>父节点(双亲结点)：若一个节点含有子节点，则这个节点称为其子节点的父节点（结点的前驱）</li>
<li>子节点：一个节点含有的子树的根节点称为该节点的子节点</li>
<li>兄弟节点：具有<strong>相同父节点</strong>的节点互称为兄弟节点</li>
<li>堂兄弟结点：父节点在同一层的节点互为堂兄弟（就是父亲结点的兄弟结点的子节点），在同一层</li>
<li><strong>路径</strong>：只能从上往下</li>
<li><strong>路径长度</strong>：经过的边数</li>
<li>树的路径长度：从根结点到每个结点的路径长度之和</li>
</ul>
<h4 id="结点、树的属性描述"><a href="#结点、树的属性描述" class="headerlink" title="结点、树的属性描述"></a>结点、树的属性描述</h4><ul>
<li>结点的层次（深度）：从上往下数</li>
<li>结点的高度：从下往上数</li>
<li>树的高度：总共多少层</li>
<li><strong>结点的度</strong>：一个节点含有的<strong>子结点</strong>的个数称为该节点的度</li>
<li><strong>树的度</strong>：一棵树中，<strong>结点最大的度</strong>称为树的度</li>
<li>森林：m棵互不相交的树的集合</li>
<li>有序树：从逻辑上看，树中结点的各子树<strong>从左至右</strong>是<strong>有次序</strong>的，不能互换</li>
<li>无序树：从逻辑上看，树中结点的各子树<strong>从左至右</strong>是<strong>无次序</strong>的，可以互换</li>
</ul>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ol>
<li>树的结点总数 &#x3D; 所有结点的度数之和 + 1</li>
<li>度为<code>m</code>的树、<code>m</code>叉数的区别</li>
</ol>
<table>
<thead>
<tr>
<th>度为 <code>m</code> 的树</th>
<th><code>m</code> 叉树</th>
</tr>
</thead>
<tbody><tr>
<td>树的度：<code>m</code>为各结点的度的最大值</td>
<td><code>m</code>叉树：每个结点最多只能有 <code>m</code> 个孩子的树</td>
</tr>
<tr>
<td>任意结点的度 ≦ m</td>
<td>任意结点的度 ≦ m</td>
</tr>
<tr>
<td>至少有一个结点度 &#x3D; m</td>
<td>允许所有结点的度 &lt; m</td>
</tr>
<tr>
<td>一定是非空树，至少有m+1个结点</td>
<td>可以是空树</td>
</tr>
<tr>
<td>第i层至多有 $m^{i-1}$个结点</td>
<td>第i层至多有 $m^{i-1}$个结点</td>
</tr>
<tr>
<td>高度为<code>h</code>、度为 <code>m</code> 的树<strong>至少</strong>有<code>h+m-1</code>个结点（允许一层只有一个结点）</td>
<td>高度为<code>h</code>的<code>m</code>叉树至多有$\frac{m^h-1}{m-1}$个结点</td>
</tr>
<tr>
<td></td>
<td>具有<code>n</code>个结点的<code>m</code>叉树，最小高度为$⌈ log_m(n(m-1)+1)⌉$</td>
</tr>
</tbody></table>
<p>⌈  ⌉：向上取整</p>
<p>已知不同度的结点个数，求叶子结点</p>
<ul>
<li>关键，先求出树的结点数，然后判断出不同度的结点个数，相减就是叶子结点</li>
<li>叶子结点的度为0</li>
</ul>
<p>结点度为$0,1,…,m$分别为$n_0,n_1,…n_m$</p>
<ul>
<li>总结点数&#x3D;$n_0+n_1+…+n_m$</li>
<li>(总度数)总分支数&#x3D;$1n_1+2n_2…+mn_m$</li>
<li>总结点数&#x3D;总分支数+1      (结点数&#x3D;总度数+1)</li>
</ul>
<p>对于m叉树(根节点标号为1)，结点标号为i的第一个子孩子下标为$(i-1)*m+2$</p>
<p>过程推导 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210202129638.png" alt="image-20221020212946468"></p>
<p>一颗有m个结点的树，该树对应二叉树无右孩子的结点个数为n,则该树叶节点的个数为m-n+1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211282027507.png" alt="image-20221128202705945"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211282026588.png" alt="image-20221128202613357"></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>二叉树是n个结点的有限集合</li>
<li>由一个根节点和两个互不相交的被称为根的<strong>左子树</strong>和<strong>右子树</strong>组成。左子树和右子树分别是一个二叉树</li>
<li>特点<ul>
<li>每个结点至多只有两棵子树</li>
<li>左右子树不能颠倒</li>
<li>二叉树是<strong>有序树</strong></li>
</ul>
</li>
</ul>
<h3 id="几种特殊的二叉树"><a href="#几种特殊的二叉树" class="headerlink" title="几种特殊的二叉树"></a>几种特殊的二叉树</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><ul>
<li>一棵树高度为h，且含有$2^h-1$个结点的二叉树，每层满结点</li>
<li>特点<ul>
<li>只有最后一层为叶子结点</li>
<li>不存在度为1的结点（要不度为0，要不度为2）</li>
<li>按层序从1开始编号，结点i的左孩子为<code>2i</code> ，右孩子为<code>2i+1</code>;结点i的父节点为<code>⌊i/2⌋</code> (如果有)。⌊⌋ :向下取整</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022122956.png" alt="image-20220702212156606"></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><ul>
<li>当且仅当其每个结点都与高度为h的满二叉树中编号为<code>1~n</code>的结点一一对应时，称为完全二叉树</li>
<li>特点<ul>
<li>只有最后两层可能有叶子节点</li>
<li>最多只有一个度为1的结点（只有左孩子没有右孩子）</li>
<li>按层序从1开始编号，结点i的左孩子为<code>2i</code> ，有孩子为<code>2i+1</code>;结点i的父节点为<code>⌊i/2⌋</code> (如果有)。⌊⌋ :向下取整</li>
<li><code>i&lt;=⌊n/2⌋</code>为分支结点，<code>i&gt;⌊n/2⌋</code>为叶子结点</li>
<li>n为奇数，每个分支结点都有左右孩子</li>
<li>n为偶数，编号为n&#x2F;2的结点只有左孩子</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022128470.png" alt="image-20220702212826288"></p>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><ul>
<li>一棵二叉树有如下性质<ul>
<li><strong>左子树</strong>上的所有结点的关键字均<strong>小于根节点</strong>的关键字</li>
<li><strong>右子树</strong>上的所有结点的关键字<strong>均大于根节点</strong>的关键字</li>
<li>左子树和右子树分别是一棵二叉排序树</li>
</ul>
</li>
<li>该树可用于元素的排序、搜索</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022133497.png" alt="image-20220702213343598"></p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><ul>
<li>树上的任一结点的左子树和右子树的<strong>深度之差不超过1</strong></li>
<li>该树有更高的搜索效率</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022135724.png" alt="image-20220702213514829"></p>
<h3 id="二叉树常见性质"><a href="#二叉树常见性质" class="headerlink" title="二叉树常见性质"></a>二叉树常见性质</h3><ul>
<li>设非空二叉树中度为0，1，2的结点个数分别为$n_0,n_1,n_2$,则$n_0&#x3D;n_2+1$</li>
<li>二叉树第ｉ层最多$2^{i-1}$个结点</li>
<li>高度为h的二叉树最多$2^h- 1$(满二叉树)</li>
</ul>
<h4 id="完全二叉树性质"><a href="#完全二叉树性质" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h4><ul>
<li>具有n个结点的完全二叉树的高度为$⌈log_2 (n+1)⌉$或者$⌊log_2 n⌋$+1<ul>
<li>通过高度为h-1和高度为h的结点判断</li>
</ul>
</li>
<li>设非空二叉树中度为0，1，2的结点个数分别为$n_0,n_1,n_2$<ul>
<li>完全二叉树中度为1的结点最多一个;$n_0+n_2$一定为奇数</li>
<li>若完全二叉树有<code>2k</code>个结点,则必有$n_1&#x3D;1,n_0&#x3D;k,n_2&#x3D;k-1$</li>
<li>若完全二叉树有<code>2k-1</code>个结点,则必有$n_1&#x3D;0,n_0&#x3D;k,n_2&#x3D;k-1$</li>
</ul>
</li>
</ul>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">   ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">   <span class="type">bool</span> isEmpty;   <span class="comment">//结点是否为空</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   TreeNode t[MaxSize];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=MaxSize; i++)&#123;</span><br><span class="line">      t[i].isEmpty = <span class="literal">true</span>;<span class="comment">//无存储信息设为true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>考点：</strong></p>
<ul>
<li><code>i</code>的左孩子：<code>2i</code></li>
<li><code>i</code>的右孩子：<code>2i + 1</code></li>
<li><code>i</code>的父节点：$⌊i&#x2F;2⌋$</li>
<li><code>i</code>所在的层次：$⌊log_2n⌋ + 1 或 ⌈log_2(n+1)⌉$</li>
</ul>
<p><strong>若完全二叉树中共有n个结点</strong>（非完全二叉树不能用）</p>
<ul>
<li>判断<code>i</code>是否有左孩子：<code>2i ≦ n</code></li>
<li>判断<code>i</code>是否有右孩子：<code>2i+1 ≦ n</code></li>
</ul>
<p><strong>最坏情况：</strong> <strong>高度为h且只有h个结点</strong>的单支树（所有结点只有右孩子），也至少需要$2^h-1$个存储单元；</p>
<p><strong>结论：</strong> 二叉树的顺序存储结构，<strong>只适合存储完全二叉树和满二叉树</strong></p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">root -&gt; data = <span class="number">1</span>;</span><br><span class="line">root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode *p = (BiTree) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">p -&gt; data = <span class="number">2</span>;</span><br><span class="line">p -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">p -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">root -&gt; lchild = p; <span class="comment">//作为根节点的左孩子</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207032054999.png" alt="image-20220703205422393"></p>
<ul>
<li>找到指定结点p的左&#x2F;右孩子；</li>
<li>n个结点的二叉链表共有n+1个空链域,(有n-1个变连接，共2n个指针)</li>
<li>找到指定节点p的父结点: 只能从根结点开始遍历；</li>
</ul>
<p><strong>三叉链表</strong>：方便找到其父节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">//左、右孩子指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span>          <span class="comment">//父节点指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45525272/article/details/105837185">二叉树的遍历和线索二叉树</a></p>
<p>遍历：按照某种次序把所有的结点访问一遍</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p><strong>先序遍历</strong>：根左右</p>
<p><strong>中序遍历</strong>：左根右</p>
<p><strong>后序遍历</strong>：左右根</p>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul>
<li>若二叉树为空，不用操作</li>
<li>若二叉树非空：<ul>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
</li>
</ul>
<p>小仙儿从树根开始绕着整棵树的外围转一圈，经过结点的顺序就是先序遍历的顺序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071910649.gif"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);                 <span class="comment">//访问根结点</span></span><br><span class="line">      PreOrder(T-&gt;lchild);      <span class="comment">//递归遍历左子树</span></span><br><span class="line">      PreOrder(T-&gt;rchild);      <span class="comment">//递归遍历右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将访问根节点，遍历左树和右树交换位置,就可以实现中序和后序遍历</span></span><br></pre></td></tr></table></figure>

<p>手算层次遍历</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207032058178.png" alt="image-20220703205803539"></p>
<p><strong>空间复杂度：</strong> O(h)</p>
<p>中序遍历和后序遍历与先序遍历类似</p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul>
<li><p>顺序：左根右</p>
</li>
<li><p>中序遍历可以看成，二叉树每个节点，垂直方向投影下来（可以理解为每个节点从最左边开始垂直掉到地上），然后从左往右数，得出的结果便是中序遍历的结果</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071914581.gif"></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul>
<li>就是围着树的外围绕一圈，如果发现一剪刀就能剪下的葡萄（必须是一颗葡萄）（也就是葡萄要一个一个掉下来，不能一口气掉超过1个这样），就把它剪下来，组成的就是后序遍历了。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071917460.gif"></p>
<p>程序遍历序列</p>
<ul>
<li>先序：第一次路过时访问</li>
<li>中序：第二次路过时访问</li>
<li>后序：第三次路过时访问</li>
</ul>
<h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4><p>层次遍历很好理解，就是从根节点开始，一层一层，从上到下，每层从左到右，依次写值就可以了</p>
<ul>
<li>相当广度优先遍历</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071919769.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208292014087.gif"></p>
<p>算法思想：</p>
<ul>
<li>初始化一个<strong>辅助队列</strong></li>
<li>根节点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，依次将其左、右孩子插入队尾（如果有的话）</li>
<li>重复以上操作直至队列为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTnode</span>&#123;</span></span><br><span class="line">   ElemType data;          </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">   BiTNode * data;</span><br><span class="line">   <span class="keyword">typedef</span> LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   LinkNode *front, *rear;  </span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">   LinkQueue Q;</span><br><span class="line">   InitQueue(Q);          <span class="comment">//初始化辅助队列</span></span><br><span class="line">   BiTree p;</span><br><span class="line">   EnQueue(Q,T);           <span class="comment">//将根节点入队</span></span><br><span class="line">   <span class="keyword">while</span>(!isEmpty(Q))&#123;     <span class="comment">//队列不空则循环</span></span><br><span class="line">      DeQueue(Q,p);        <span class="comment">//队头结点出队</span></span><br><span class="line">      visit(p);            <span class="comment">//访问出队结点</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;lchild);   <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">         EnQueue(Q,p-&gt;rchild);   <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>:若只给出一棵二叉树得前&#x2F;中&#x2F;后&#x2F;层 序遍历序列中得一种，不能确定一棵二叉树</p>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><p><strong>关键</strong>：找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点、</p>
<h4 id="先序序列-中序序列"><a href="#先序序列-中序序列" class="headerlink" title="先序序列 + 中序序列"></a>先序序列 + 中序序列</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071931027.png" alt="image-20220707193144845"></p>
<p>先序序列的第一个元素一定是根节点</p>
<p>关键：<strong>该方法的核心就是用先序序列元素作即根节点分割中序序列</strong></p>
<p><strong>动图</strong></p>
<blockquote>
<p>先序：1  2  3  4  5  6  7 </p>
<p>中序：4  2  5  1  6  3  7 </p>
<p>对1中序左边425，在先序找到425的排序245，则2作为下一棵树的根节点</p>
<pre><code>      1
    /   \
   2     3
  / \   / \ 
 4   5 6   7
</code></pre>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071933398.gif"></p>
<h4 id="后序序列-中序序列"><a href="#后序序列-中序序列" class="headerlink" title="后序序列 + 中序序列"></a>后序序列 + 中序序列</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207071938477.png" alt="image-20220707193808450"></p>
<p><strong>关键</strong>：</p>
<ol>
<li>先确定后序最后一个元素为根节点，</li>
<li>然后用后序序列元素即根节点分割中序序列，</li>
</ol>
<p><strong>动图</strong></p>
<blockquote>
<p>后序：E F A H C I G B D</p>
<p>中序：E A F D H C B G I</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     D</span><br><span class="line">   /   \</span><br><span class="line">  A      B</span><br><span class="line"> / \    / \ </span><br><span class="line">E   F  C   G</span><br><span class="line">       /    \ </span><br><span class="line">      H      I</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072042235.gif"></p>
<h4 id="层序序列-中序序列"><a href="#层序序列-中序序列" class="headerlink" title="层序序列 + 中序序列"></a>层序序列 + 中序序列</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072044019.png" alt="image-20220707204447135"></p>
<p><strong>动图</strong></p>
<blockquote>
<p>层序：ABCDE</p>
<p>中序：ACBED</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072100311.gif"></p>
<p><strong>结论</strong>：前序，后序，层序序列的<strong>两两组合无法唯一确定</strong>一棵二叉树</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><ol>
<li>线索二叉树的概念与作用<ul>
<li>遍历二叉树是以一定规则将二叉树中的结点排列出个成一个线性组合</li>
<li>线索二叉树是为了加快查找结点前驱和后继的速度</li>
</ul>
</li>
<li>线索二叉树的存储结构</li>
</ol>
<ul>
<li>中序线索二叉树——线索指向中序前驱、中序后继</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ltag &#x3D;&#x3D; 0: 指针指向孩子</p>
<p>rtag &#x3D;&#x3D; 1: 指针是“线索”</p>
<p><code>*lchild：指向前驱结点（前驱线索）或者左孩子</code></p>
</blockquote>
<p>   <code>*rchild：指向后继结点（后继线索）或者右孩子</code></p>
<blockquote>
<p>结构：</p>
<p>二叉链表：<code>*lchild , data  ,  *rchild</code></p>
<p>线索链表：<code>*lchild , ltag , data , rtag , *rchild</code></p>
</blockquote>
<h3 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h3><p><strong>关键</strong>：画出图形，确定好各个结点的顺序，然后根据是否有孩子判断线索化</p>
<h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><p><strong>中序线索二叉树</strong>：线索指向中序前驱，中序后继</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072124463.png" alt="image-20220707212418284"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T-&gt;lchild);    <span class="comment">//中序遍历左子树</span></span><br><span class="line">        visit(T);               <span class="comment">//访问根节点</span></span><br><span class="line">        InThread(T-&gt;rchild);    <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//q为当前结点，pre和q相当于中序相邻关系</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">    <span class="comment">//建立当前结点的前驱线索,只有左子树为空才能建立前驱线索</span></span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid == <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//pre无右子树才能得到后继线索</span></span><br><span class="line">    <span class="comment">//建立pre结点的后继线索，前驱不空且前驱后继为空建立，可通过中间的图形判断</span></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;                     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      InThread(T);            <span class="comment">//中序线索化二叉树</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202208292043490.png" alt="image-20220829204345948"></p>
<p>注意：后面结点的E为G，难的改</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207091940437.gif"></p>
<h4 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h4><p><strong>先序线索二叉树</strong>：线索指向先序前驱，先序后继</p>
<p>先确定好先序遍历的排序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125676.png" alt="image-20220707212513691"></p>
<p>注意【转圈】问题，当<code>ltag==0</code>时，才能对左子树先序线索化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(T);</span><br><span class="line">      <span class="keyword">if</span>(T-&gt;ltag == <span class="number">0</span>)         <span class="comment">//lchild不是前驱线索，有左子树</span></span><br><span class="line">         PreThread(T-&gt;lchild);</span><br><span class="line">      PreThread(T-&gt;rchild);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid == <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PreThread(T);            <span class="comment">//先序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h4><p><strong>后序线索二叉树</strong>：线索指向后序前驱，后序后继</p>
<p>先确定好后序元素pai’xu</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125827.png" alt="image-20220707212547580"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">   <span class="type">int</span> ltag, rtag;                <span class="comment">// 左、右线索标志</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量pre, 指向当前访问的结点的前驱</span></span><br><span class="line">TreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历二叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      PostThread(T-&gt;lchild);</span><br><span class="line">      PostThread(T-&gt;rchild);</span><br><span class="line">      visit(T);                  <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;lchid = <span class="literal">NULL</span>)&#123;                 <span class="comment">//左子树为空，建立前驱线索   </span></span><br><span class="line">      q-&gt;lchild = pre;</span><br><span class="line">      q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild = <span class="literal">NULL</span>)&#123; </span><br><span class="line">      pre-&gt;rchild = q;           <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">      pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   pre = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">   pre = <span class="literal">NULL</span>;                <span class="comment">//pre初始为NULL</span></span><br><span class="line">   <span class="keyword">if</span>(T!=<span class="literal">NULL</span>);&#123;              <span class="comment">//非空二叉树才能进行线索化</span></span><br><span class="line">      PostThread(T);            <span class="comment">//后序线索化二叉树</span></span><br><span class="line">      <span class="keyword">if</span>(pre-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">         pre-&gt;rtag=<span class="number">1</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="线索二叉树中找前驱、后继"><a href="#线索二叉树中找前驱、后继" class="headerlink" title="线索二叉树中找前驱、后继"></a>线索二叉树中找前驱、后继</h3><h4 id="中序二叉树"><a href="#中序二叉树" class="headerlink" title="中序二叉树"></a>中序二叉树</h4><p><strong>后继</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072124463.png" alt="image-20220707212418284"></p>
<p>中序线索二叉树找中序后继：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 则 next &#x3D; p的右子树中最左下结点;</p>
</blockquote>
<p>根结点指的是指定结点*p ——情况如下（F结点指向A结点）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092002611.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//循环找到最左下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;lchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Nextnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//右子树最左下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p!=<span class="literal">NULL</span>; p = Nextnode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 &#x3D; O(1)</p>
<p><strong>前驱</strong></p>
<p>中序线索二叉树找中序前驱：在中序线索二叉树中找到指定节点 <code>*p</code> 的中序前驱 <code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子, 则 next &#x3D; p的左子树中最右下结点;</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092014851.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Lastnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//循环找到最右下的结点（不一定是叶结点）</span></span><br><span class="line">   <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">      p=p-&gt;rchild;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Prenode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">   <span class="comment">//左子树最右下结点</span></span><br><span class="line">   <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//rtag==1，直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RevInorder</span><span class="params">(ThreadNode *T)</span>&#123;            <span class="comment">//T为根节点指针</span></span><br><span class="line">   <span class="keyword">for</span>(ThreadNode *p = Lastnode(T); p!=<span class="literal">NULL</span>; p = Prenode(p))</span><br><span class="line">      visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先序二叉树"><a href="#先序二叉树" class="headerlink" title="先序二叉树"></a>先序二叉树</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125676.png" alt="image-20220707212513691"></p>
<p><strong>后继</strong></p>
<p>根为当前结点，黄色部分为后继(左)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092017361.png"></p>
<p>先序线索二叉树找先序后继：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序后继 <code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子（左孩子不知道）——<code>*p不能指向</code></p>
<blockquote>
<p>case1: 若p有左孩子 ——— 根 <strong>左</strong> 右  &#x2F;  根 (<strong>根</strong> 左 右) 右</p>
<p>case2: 若p没有左孩子 ——— 根 <strong>右</strong>  &#x2F;  根 (<strong>根</strong> 左 右)</p>
</blockquote>
</blockquote>
<p><strong>先序</strong></p>
<p>先序线索二叉树找先序前驱：在先序线索二叉树中找到指定节点 <code>*p</code> 的先序前驱<code>pre</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092030251.png" alt="image-20220709202819459"></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找p的先序前驱，（除非从头开始遍历&#x2F;三叉链表</p>
</blockquote>
<h4 id="后序二叉树"><a href="#后序二叉树" class="headerlink" title="后序二叉树"></a>后序二叉树</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207072125827.png" alt="image-20220707212547580"></p>
<p><strong>前驱</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092032086.png"></p>
<p>后序线索二叉树找后序前驱：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序前驱<code>pre</code></p>
<blockquote>
<p>若 <code>p-&gt;ltag == 1</code>, 则 <code>next = p-&gt;lchild</code>;</p>
<p>若 <code>p-&gt;ltag == 0</code>, 则 p 必有左孩子（不知道有没有右孩子）</p>
<blockquote>
<p>case1: 若p有右孩子 ——— 左 <strong>右</strong> 根 &#x2F; 左 (左 右 <strong>根</strong>) 根</p>
<p>case2: 若p没有右孩子 ——— <strong>左</strong> 根 （左子树按后序遍历，最后一个结点，p的左孩子）</p>
</blockquote>
</blockquote>
<p><strong>后继</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207092037903.png" alt="image-20220709203740011"></p>
<p>后序线索二叉树找后序后继：在后序线索二叉树中找到指定节点 <code>*p</code> 的后序后继<code>next</code></p>
<blockquote>
<p>若 <code>p-&gt;rtag == 1</code>, 则 <code>next = p-&gt;rchild</code>;</p>
<p>若 <code>p-&gt;rtag == 0</code>, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非从头开始遍历&#x2F;三叉链表</p>
</blockquote>
<ul>
<li>后序遍历找后序时麻烦，所以需要栈的支持</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>后续线索二叉树找后继难，先序线索二叉树找前驱难，需要父节点</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>中序线索二叉树</th>
<th>先序线索二叉树</th>
<th>后续线索二叉树</th>
</tr>
</thead>
<tbody><tr>
<td>找前驱</td>
<td>Ture</td>
<td>False</td>
<td>Ture</td>
</tr>
<tr>
<td>找后继</td>
<td>Ture</td>
<td>Ture</td>
<td>False</td>
</tr>
</tbody></table>
<h1 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><ul>
<li>顺序存储，每个结点中保存指向双亲的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100  <span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>      <span class="comment">//树的结点定义</span></span><br><span class="line">   ElemType data; </span><br><span class="line">   <span class="type">int</span> parent;      <span class="comment">//双亲位置域，用来存储父节点的数组下标信息</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                   <span class="comment">//树的类型定义</span></span><br><span class="line">   PTNode nodes[MAX_TREE_SIZE];   <span class="comment">//双亲表示</span></span><br><span class="line">   <span class="type">int</span> n;                         <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102236747.png" alt="image-20220710223636837"></p>
<ul>
<li>增：新增数据元素，无需按逻辑上的次序存储；（需要更改结点数<code>n</code>）</li>
<li>删（叶子结点）：① 将伪指针域设置为<code>-1</code>；②或者用后面的数据填补；（需要更改结点数<code>n</code>）</li>
<li>查询：①优点-查指定结点的双亲很方便；②缺点-查指定结点的孩子只能从头遍历，空数据导致遍历更慢；</li>
</ul>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><ul>
<li>孩子表示法(顺序+链式)，顺序存储各个结点，每个结点中保存孩子链表头指针</li>
<li>把每个结点的孩子结点排列起来，看成是一个线性表，以单链表作存储结构，则n个结点有n个孩子链表（叶子结点的孩子链表为空），然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</li>
<li>特点：找孩子易，找双亲难</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102242382.png" alt="image-20220710224230720"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> child;    <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 下一个孩子的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType data;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>    <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">   <span class="type">int</span> n, r;   <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>

<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><ul>
<li>链式存储，优点：可以将树之转换为二叉树操作</li>
<li>结点X的左孩子作为结点X的左孩子，结点X的左孩子的兄弟结点作为结点X的右孩子</li>
<li>每个结点有两个指针域，分别指向“第一个孩子”和”下一个兄弟结点”</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102249716.png" alt="image-20220710224942563"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">   ElemType data;                               <span class="comment">//数据域</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>     <span class="comment">//第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<p><strong>树、森林与二叉树的转换</strong></p>
<p>森林：是m棵互不相交的树的集合</p>
<p><strong>本质</strong>：森林中各个树的根节点之间视为兄弟关系，用二叉链表存储森林</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102251412.png" alt="image-20220710225107038"></p>
<h2 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><ul>
<li><strong>先根遍历</strong>：若树非空，先访问根节点，再依次对每棵子树进行先根遍历；（与对应二叉树的<strong>先序遍历序列</strong>相同）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PreOrder(T);      <span class="comment">//先跟遍历下一个子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>后根遍历</strong>：若树非空，先依次对每棵子树进行后根遍历，最后再返回根节点；（与对应二叉树的<strong>中序遍历序列相同</strong>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *R)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(R还有下一个子树T)</span><br><span class="line">         PostOrder(T);      <span class="comment">//后跟遍历下一个子树</span></span><br><span class="line">      visit(R);    <span class="comment">//访问根节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>层序遍历</strong>（队列实现）：<ul>
<li>若树非空，则根结点入队；</li>
<li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；</li>
<li>重复以上操作直至队尾为空；</li>
</ul>
</li>
</ul>
<h3 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h3><ul>
<li>二叉树先序遍历：等同于依次对各个树进行<strong>先根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>先序遍历</strong>；</li>
<li>二叉树中序遍历：等同于依次对各个树进行<strong>后根遍历</strong>；也可以先转换成与之对应的二叉树，对二叉树进行<strong>中序遍历</strong>；</li>
</ul>
<p><strong>对比</strong></p>
<table>
<thead>
<tr>
<th>树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td>先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody></table>
<h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207022133497.png" alt="image-20220702213343598"></p>
<ul>
<li>定义：<strong>左子树结点值&lt;根结点值&lt;右子树结点值</strong></li>
<li>利用<strong>中序排序</strong>可以得到有序递增序列</li>
<li>用于元素的有序搜索和查找</li>
<li>左子树的所有结点值小于根节点</li>
<li>右子树的所有结点值大于根节点</li>
</ul>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul>
<li>若树非空，目标值与根节点的值比较</li>
<li>若相等，查找成功</li>
<li>若小于根结点，则在左子树上查找，否则在右子树查找</li>
<li>查找成功，返回结点指针；失败返回NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（非递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(1)</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(T!=<span class="literal">NULL</span> &amp;&amp; key!=T-&gt;key)&#123;        <span class="comment">//若树空或等于跟结点值，则结束循环</span></span><br><span class="line">      <span class="keyword">if</span>(key &lt; T-&gt;key)       <span class="comment">//值小于根结点值，在左子树上查找</span></span><br><span class="line">         T = T-&gt;lchild;</span><br><span class="line">      <span class="keyword">else</span>                  <span class="comment">//值大于根结点值，在右子树上查找</span></span><br><span class="line">         T = T-&gt;rchild;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)  树的高度</span></span><br><span class="line">BSTNode *<span class="title function_">BSTSearch</span><span class="params">(BSTree T, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)        <span class="comment">//值为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(key == T-&gt;key)    <span class="comment">//查找成功</span></span><br><span class="line">      <span class="keyword">return</span> T;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)   <span class="comment">//遍历左子树</span></span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;lchild, key);</span><br><span class="line">   <span class="keyword">else</span>                    <span class="comment">//遍历右子树</span></span><br><span class="line">      <span class="keyword">return</span> BSTSearch(T-&gt;rchild, key);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ul>
<li>树为空，直接插入结点；</li>
<li>否则，若关键字小于根节点值，则插入左子树，若关键字K大于根节点值，则插入到右子树</li>
<li>存在相同的关键字，插入则失败</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中插入关键字为k的新结点（递归）</span></span><br><span class="line"><span class="comment">//最坏空间复杂度：O(h)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;           <span class="comment">//原树为空，新插入的结点为根结点</span></span><br><span class="line">      T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">      T-&gt;key = k;</span><br><span class="line">      T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;                       <span class="comment">//插入成功</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;key)               <span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)                 </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h3><ul>
<li>不同关键字序列可以构成不同的二叉排序树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[]中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Crear_BST</span><span class="params">(BSTree &amp;T, <span class="type">int</span> str[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">   T = <span class="literal">NULL</span>;                     <span class="comment">//初始时T为空树</span></span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">      BST_Insert(T,str[i]);     <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>始终要按照这种规律：<strong>左子树结点值&lt;根结点值&lt;右子树结点值</strong></p>
<p>先搜索找到目标结点</p>
<ul>
<li>若被删除结点z为<strong>叶节点</strong>，则直接删除</li>
<li>若结点<strong>z只有一棵左子树或者右子树</strong>，则让z的子树成为z父节点的子树，代替z的位置</li>
<li>若结点<strong>z有左，右两颗子树</strong>，则令z的直接后继（或者直接前驱）代替z，然后从二叉树中删除这个直接后继（或直接前驱），然后就作为第一或第二种情况<ul>
<li>前驱和后继通过<strong>中序遍历</strong>得到</li>
<li>z的直接后继q代替删除结点z，原后继位置由q的右子树的根代替</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121252128.png" alt="image-20220712125220888"></p>
<h4 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul>
<li>查找长度：查找运算中，需要对比关键字的次数，反映了查找操作时间复杂度；<ul>
<li>计算：每个关键字对比次数(从头开始)之和除以总个数</li>
</ul>
</li>
<li>每层对比一次</li>
<li>查找成功的平均查找长度<code>ASL</code><ul>
<li>最好情况:n个结点的二叉树最小高度为$⌊log_2n⌋+1$，则平均查找长度&#x3D;$O(⌊log_2n⌋)$</li>
<li>最坏情况：每个结点只有一个分支，平均查找长度&#x3D;O(n),n为结点数</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121254663.png" alt="image-20220712125437593"></p>
<ul>
<li>查找失败的平均查找长度<code>ASL</code><ul>
<li>在每个叶节点后面添加失败结点，算失败结点的平均查找长度</li>
<li>对比关键字次数乘以失败结点个数之和</li>
<li>注意：失败关键字次数<strong>不算</strong></li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121255944.png" alt="image-20220712125509789"></li>
</ul>
</li>
</ul>
<h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><p><strong>定义</strong>：树上任一结点的左子树和右子树的高度之差不超过1</p>
<p><strong>结点的平衡因子</strong>&#x3D;左子树高 — 右子树高</p>
<p>平衡二叉树不是二叉排序树，但可以根据二叉排序树构造平衡二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">   <span class="type">int</span> key;         <span class="comment">//数据域</span></span><br><span class="line">   <span class="type">int</span> balance;     <span class="comment">//平衡因子</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>;</span> *rchild; </span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121303050.png" alt="image-20220712130337037"></p>
<h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><ul>
<li>插入新节点后如何调整“不平衡”问题</li>
<li>每次<strong>调整最小不平衡子树</strong></li>
<li>根据特性判断（这是基于二叉排序树判断）</li>
</ul>
<p><strong>做题插入判断</strong></p>
<ul>
<li>先找到<strong>最小不平衡子树</strong>，路径是平衡因子为2到插入结点方向的路径的<strong>三个结点</strong></li>
<li>在三个结点中，找到<strong>第二个大的数</strong>来作为新的根节点，<strong>最小</strong>作为新根节点的<strong>左子树的根，最大则为右子树的根</strong>，插入后移动二叉树， 直到没有最小平衡二叉树为止</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207142237100.jpg"></p>
<h4 id="LL-需右旋"><a href="#LL-需右旋" class="headerlink" title="LL(需右旋)"></a>LL(需右旋)</h4><ul>
<li><p>在A结点的<strong>左孩子的左子树</strong>中插入导致不平衡</p>
</li>
<li><p>调整： A的<strong>左孩子结点右上旋</strong>代替A成为根节点，将<strong>A结点向下旋转为B的右子树</strong>的根节点，而B的原右子树则作为A结点的左子树</p>
</li>
<li><p>子树左右顺序一样</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121308312.png"></p>
<h4 id="RR（需左旋）"><a href="#RR（需左旋）" class="headerlink" title="RR（需左旋）"></a>RR（需左旋）</h4><ul>
<li>调整： A的<strong>右孩子</strong>结点<strong>左上旋</strong>代替A成为根节点，将A结点<strong>向下旋转</strong>成为B的<strong>左子树</strong>的根节点，而B的原左子树则作为A结点的右子树</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121308481.png"></p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><ul>
<li><p>在A结点的左孩子的右子树中插入导致不平衡</p>
</li>
<li><p>调整： A的左孩子的右子树，先左上旋再右上旋(先左旋再右旋)</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121309007.png"></p>
<h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><ul>
<li><p>在A结点的<strong>右孩子的左子树</strong>中插入导致不平衡</p>
</li>
<li><p>调整： A的右孩子的左子树，先右上旋再左上旋</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207121309870.png"></p>
<p><strong>左孩子右上旋，右孩子左上旋</strong></p>
<h3 id="查找与效率分析"><a href="#查找与效率分析" class="headerlink" title="查找与效率分析"></a>查找与效率分析</h3><p>假设以$n_h$表示深度为h的平衡树中含有的最少结点数</p>
<p>则$n_0&#x3D;0,n_1&#x3D;1,n_2&#x3D;2$,并且有$n_h&#x3D;n_{h-1}+n_{h-2}+1$</p>
<p>含有n个结点的平衡二叉树的最大深度为$O(log_2 n)$,平衡树二叉树的平均查找长度为$O(log_2 n)$</p>
<h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>高度为n的平衡二叉树最少需要多少个节点</p>
<ul>
<li>利用公式F(h) &#x3D; F(h-1) + F(h -2 ) + 1</li>
<li>其中F(0)&#x3D;0,F(1)&#x3D;1,f(2)&#x3D;2…</li>
</ul>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>结点的权：有某种显示含义的数值（结点的重要性等）</li>
<li>结点的带权路径长度：从树的根到该结点的<strong>路径长度</strong>(经过的边数)与该结点上的<strong>权值</strong>的乘积</li>
<li>树的带权路径长度：树中所有<strong>叶子结点</strong>的带权路劲长度之和<strong>WPL</strong></li>
<li>哈夫曼树（最优二叉树）：在含有n个带权叶节点的二叉树中，其中<strong>带权路径长度（WPL）最小</strong>的二叉树</li>
</ul>
<h3 id="哈夫曼树构造"><a href="#哈夫曼树构造" class="headerlink" title="哈夫曼树构造"></a>哈夫曼树构造</h3><p>给定n个权值分别为$w_1,w_2,…,w_n$的结点，构造算法描述如下</p>
<ol>
<li>将n个结点分别作为n棵仅含有一个结点的二叉树，构成森林F</li>
<li>构造一个新的结点，从F中选取两颗根节点<strong>权值最小的树作为新结点的左、右子树</strong>，并且将<strong>新结点</strong>的权值置为左右树上根节点的<strong>权值之和</strong><ul>
<li>关键：每次到两个权值最小的结点合并</li>
</ul>
</li>
<li>从F中删除刚才选出的两棵树，同时将新得到的树中加入F中</li>
<li>重复步骤2，3,直到F中只剩下一棵树位置</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202209012006345.gif"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102314120.png" alt="image-20220710231422068"></p>
<p><strong>注意</strong></p>
<ul>
<li>每个初始结点最终都成为叶结点，且<strong>权值越小</strong>的结点到根节点的路径长度越大</li>
<li>哈夫曼树的结点总数为2n-1</li>
<li>哈夫曼树不存在度为1的结点</li>
<li>哈夫曼树不唯一，但WPL必然相同且为最优</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p><strong>固定长度编码</strong>：每个字符都用相等长度的二进制位表示</p>
<p><strong>可变长度编码</strong>：允许对不同字符用不等长的二进制位表示</p>
<p><strong>前缀编码</strong>：若没有一个编码是其他编码的前缀，则称这样的编码为前缀编码</p>
<p><strong>由哈夫曼树得到哈夫曼编码</strong>：字符集中的每个字符作为一个叶子结点，各个字符出现的<strong>频度</strong>作为结点的权值，哈夫曼编码可用于数据压缩</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202207102325658.png" alt="image-20220710232521625"></p>
<h3 id="k叉树构造最小路径和"><a href="#k叉树构造最小路径和" class="headerlink" title="k叉树构造最小路径和"></a>k叉树构造最小路径和</h3><p>对于 k 叉树，设 m 为叶子数 , 若 <code>( m - 1 ) % ( k - 1 ) != 0</code> , 要增加虚(子叶)结点。第一次构造用 <code>( m - 1 ) % ( k - 1 ) + 1</code> 个结点，之后都用 k 个结点构造 k 叉树。</p>
<p>在哈夫曼树中，由此组成的字符串的编码有多少位，其实就是算该树的带权路径长度</p>
<h4 id="常见编码区别"><a href="#常见编码区别" class="headerlink" title="常见编码区别"></a>常见编码区别</h4><p>前缀编码：若没有一个编码是其他编码的前缀，则称这样的编码为前缀编码</p>
<p>Huffman编码：是一种构造最优前缀编码的方式</p>
<p>最优前缀编码</p>
<p>Huffman编码一定是前缀编码和最优前缀编码</p>
<p>最优前缀编码不一定是Huffman编码</p>
<ul>
<li>一般先判断是不是Huffman编码，在判断是最优前缀编码</li>
</ul>
<h1 id="课后代码习题"><a href="#课后代码习题" class="headerlink" title="课后代码习题"></a>课后代码习题</h1><h2 id="二叉树遍历习题"><a href="#二叉树遍历习题" class="headerlink" title="二叉树遍历习题"></a>二叉树遍历习题</h2><ol>
<li><p>编写后续遍历二叉树的非递归算法</p>
<p>思想:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//后面再看</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">InitStack</span>(S);</span><br><span class="line">	r=<span class="literal">NULL</span>;</span><br><span class="line">	p=T;</span><br><span class="line">	<span class="keyword">while</span>(p || !<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h2 id="二叉排序树-1"><a href="#二叉排序树-1" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><h2 id="树常用代码"><a href="#树常用代码" class="headerlink" title="树常用代码"></a>树常用代码</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43506256/article/details/122096393">树常用代码</a></p>
<p><strong>总结</strong>：通过二叉链表存储结构存储的，一般都是用递归的方法，递归到叶子节点的后的空结点(叶子结点左右孩子指向NULL)，然后回溯得到相应的结果，注意条件一般需要区分空结点、叶子节点和分支结点(在这里的条件一般都同时包含左右子树递归等式，如下图的意思)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202210272107579.png" alt="image-20221027210732025"></p>
<p>1.假设<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020">二叉树</a>采用二叉链存储结构存储，设计一个算法计算一棵给定二叉树的所有叶子节点个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">leafNode</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> num1,num2;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点无叶子结点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild ==<span class="literal">NULL</span> &amp;&amp; b-&gt;rchild==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//说明本身为叶子结点，左右孩子无结点</span></span><br><span class="line">	<span class="comment">//分支结点利用不断递归到叶子结点，然后回溯记录左右子树的个数</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		num1=leafNode(b-&gt;lchild);<span class="comment">//当前结点左子树的叶子结点个数</span></span><br><span class="line">		num2=leafNode(b-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (num1+num2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/202211162130841.png" alt="image-20221025213316476"></p>
<p>2.假设二叉树采用二叉链<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">存储结构</a>存储，设计一个算法计算一棵给定二叉树的所有双分支节点 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DSonNodes</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> num1,num2,n;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild==<span class="literal">NULL</span> || b-&gt;rchild==<span class="literal">NULL</span>) n=<span class="number">0</span>;<span class="comment">//说明是叶子结点</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		n=<span class="number">1</span>;<span class="comment">//说明本身为分支结点</span></span><br><span class="line">		num1=<span class="built_in">DSonNodes</span>(b-&gt;lchild);</span><br><span class="line">		num2=<span class="built_in">DSonNodes</span>(b-&gt;rchild);</span><br><span class="line">		<span class="built_in">retrun</span> (num1+num2+n);<span class="comment">//返回的是包含当前结点的分支总数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.假设二叉树采用二叉链存储结构存储，设计一个算法求其中最小值的节点值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FindMinNode</span><span class="params">(BTNode *b,ElemType &amp;min)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(b-&gt;data&lt;min) min=b-&gt;data;</span><br><span class="line">	FindMinNode(b-&gt;lchild,min);<span class="comment">//递归左子树</span></span><br><span class="line">	FindMinNode(b-&gt;rchild,min);<span class="comment">//递归右子树</span></span><br><span class="line">	<span class="comment">//通过不断递归子树，从叶子结点往分子结点不断回溯得到最小值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根节点找最小值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MinNode</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		ElemType min=b-&gt;data;</span><br><span class="line">		FinMinNode(b,min);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;min&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.假设二叉树采用二叉链存储结构存储，所有节点的值为正整数，设计一个算法求所有节点值之和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindSum</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点返回0</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (b-&gt;data+FindSum(b-&gt;lchild)+FindSum(b-&gt;rchild));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不为空结点,返回当前结点,左子树和右子树数据之和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.假设二叉树采用二叉链存储结构存储，为设计一个算法求其中节点值为 x的节点个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FindCount</span><span class="params">(BTNode *b,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点返回0;</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data==x)&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span>+FindCount(b-&gt;lchild,x)+FindCount(b-&gt;rchild,x));</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (FindCount(b-&gt;lchild,x)+FindCount(b-&gt;rchild,x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.假设二叉树采用二叉<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%93%BE%E8%A1%A8&spm=1001.2101.3001.7020">链表</a>存储结构，设计一个递归算法求二叉树的高度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BTNodeDepth</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点为0</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		l=BTNodeDepth(b-&gt;lchild);<span class="comment">//求左子树的高度</span></span><br><span class="line">		r=BTNodeDepth(b-&gt;rchild);<span class="comment">//求右子树的高度</span></span><br><span class="line">		<span class="keyword">return</span> (l&gt;r) ? (l+<span class="number">1</span>) : (r+<span class="number">1</span>);<span class="comment">//在本轮中返回左右子树最大的并加上本次的结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.假设二叉树 b 采用二叉链存储结构，设计一个算法 <code>void findparent(BTNode*b,ElemType x,BTNode *&amp;p)</code>求指定值为 x 的节点的双亲节点 p。<br>提示：根节点的双亲为 NULL，若在 b 中未找到值为 x 的节点,p 亦为 NULL，并假设二叉树中所有节点值是唯一的。<br>算法思想：设在二叉树 b 中查找 x 节点的双亲 p 的过程为 f(b,x,p)，找到后 p 指向 x 节点的双亲节点,否则 p&#x3D;NULL。当 b 为空树或根节点值为 x 时，p&#x3D;NULL，否则在左子树中查找，若未找到则在右子树中查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意BTNode *&amp;p等价与BTree &amp;p ;b只作为指针遍历所以用BTNode,p需要改边其指针所以引用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findparent</span><span class="params">(BTNode *b,ElemType x,BTNode *&amp;p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b-&gt;data==x) p=<span class="literal">NULL</span>;<span class="comment">//树的根节点的双亲结点为NULL</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;lchild !=<span class="literal">NULL</span> &amp;&amp; b-&gt;lchild-&gt;data==x) p=b;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;rchild !=<span class="literal">NULL</span> &amp;&amp; b-&gt;rchild-&gt;data==x) p=b;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			findparent(b-&gt;lchild,x,p);</span><br><span class="line">			<span class="keyword">if</span>(p==<span class="literal">NULL</span>) findparent(b-&gt;rchild,x,p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> p=<span class="literal">NULL</span>;<span class="comment">//本身为空结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种情况根节点为空，p=NULL</span></span><br><span class="line"><span class="comment">//第二种情况左孩子不为空，且左孩子的值为x,指针 p=b</span></span><br><span class="line"><span class="comment">//第三种情况右孩子不为空，且右孩子的值为x,指针 p=b</span></span><br><span class="line"><span class="comment">//第四种情况，左右孩子的值都不为x,先遍历左子树,直到找到，否则返回p=NULL，然后遍历右子树</span></span><br></pre></td></tr></table></figure>

<p>8.二叉树 T 采用二叉链表存储结构，用根结点用 t 指示， 设计一个算法，求指针 p 所指结点的双亲结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BTNode* <span class="title function_">getParent</span><span class="params">(BTNode  *t,BTNode *p)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//空树</span></span><br><span class="line">	<span class="keyword">if</span>(t==p) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//没有双亲结点</span></span><br><span class="line">	<span class="keyword">if</span>(t-&gt;lchild==p || t-&gt;rchild==p) <span class="keyword">return</span> t;<span class="comment">//找到双亲结点</span></span><br><span class="line">	<span class="comment">//普通情况</span></span><br><span class="line">	BTNode *parent=getParent(t-&gt;lchild,p);<span class="comment">//先遍历左子树</span></span><br><span class="line">	<span class="keyword">if</span>(parent!=<span class="literal">NULL</span>) <span class="keyword">return</span> parent;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> getParent(t-&gt;rchild,p);<span class="comment">//在遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先确定边界条件,在看普通情况加上子树遍历</span></span><br><span class="line"><span class="comment">//相当就是找p的双亲结点是否为t</span></span><br></pre></td></tr></table></figure>

<p>9.假设二叉树采用二叉链存储结构，设计一个算法输出值为 x的结点的所有祖先。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ancestor</span><span class="params">(BTNode *b,ElemType x)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空结点</span></span><br><span class="line">	<span class="comment">//若结点 b 的左孩子或右孩子的 data 域为 x</span></span><br><span class="line">	<span class="comment">//条件2</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((b-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; b-&gt;lchild-&gt;data==x) || (b-&gt;rchild!=<span class="literal">NULL</span> &amp;&amp; b-&gt;rchild-&gt;data==x))&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;b-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//条件3,若 f(b-&gt;lchild,x) 为 true 或 f(b-&gt;rchild,x) 为 true</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ancestor(b-&gt;lchild,x) || ancestor(b-&gt;rchild,x))&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;b-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="literal">false</span>;<span class="comment">//其他情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过把b作为祖先节点,判断他的左右孩子是否满足x,若是直接输出b的值即可</span></span><br><span class="line"><span class="comment">//逻辑:一般情况先用条件3递归到空结点,在回溯的时候满足条件2,则后面一直返回true,输出其祖先结点</span></span><br></pre></td></tr></table></figure>

<p>10.设计一个算法把树 b 的左、右子树进行交换。要求算法的空间复杂度为 O(1)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(BTree &amp;b)</span>&#123;</span><br><span class="line">	BTNode *temp;</span><br><span class="line">	<span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		Swap(b-&gt;lchild);<span class="comment">//交换左子树</span></span><br><span class="line">		Swap(b-&gt;rchild);<span class="comment">//交换右子树</span></span><br><span class="line">		<span class="comment">//交换左右指针域</span></span><br><span class="line">		temp=b-&gt;lchild;</span><br><span class="line">		b-&gt;lchild=b-&gt;rchild;</span><br><span class="line">		b-&gt;rchild=temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个题从叶子结点开始着手想,先一直递归到底层,底层作为操作交换</span></span><br><span class="line"><span class="comment">//在叶子结点交换了空指针,其他就是交换了左右子树的指针域</span></span><br><span class="line"><span class="comment">//在b!=NULL条件中,需同时写递归左右子树,才能保证回溯到同一层时,他们的都是交换后的</span></span><br></pre></td></tr></table></figure>

<p>11.假设二叉树采用链式存储结构进行存储，设计一个算法，求二叉树 b 中值为 x 的结点层号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用本算法时h指出根节点层次为1,h表示的是当前结点所在层数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Nodelevel</span><span class="params">(BTNode *b,ElemType x,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">	<span class="type">int</span> h1;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空结点</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(b-&gt;data==x) <span class="keyword">return</span> h;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		h1=Nodelevel(b-&gt;lchild,x,h+<span class="number">1</span>);<span class="comment">//往下递归要加一层,在左子树递归</span></span><br><span class="line">		<span class="keyword">if</span>(h1==<span class="number">0</span>) <span class="keyword">return</span> Nodelevel(b-&gt;rchild,x,h+<span class="number">1</span>);<span class="comment">//左子树未找到,右子树递归</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> h1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先先递归往最左子树遍历,若找到返回高度,不断回溯到最初点;</span></span><br><span class="line"><span class="comment">//若是没找到,遍历到空结点,返回0,就遍历当前结点的右子树</span></span><br></pre></td></tr></table></figure>

<p>12.求先序遍历序列中第k(1≤k≤二叉树中节点个数)个节点的值。<br>算法思想：用一个全局变量 n(初值为 1)保存先序遍历时访问节点的序号。当二叉树 b为空时返回特殊字符‘ ’ (空格字符)，当 k&#x3D;&#x3D;n 时表示找到了满足条件的节点，返回 b-&gt;data；当 k≠n 时，在左子树中查找，若找到了返回该值，否则在右子树中查找，并返回其结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line">ElemType <span class="title function_">PreNode</span><span class="params">(BTNode *b,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    ElemType ch;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==k) <span class="keyword">return</span> (b-&gt;data);</span><br><span class="line">    n++;</span><br><span class="line">    ch=PreNode(b-&gt;lchild,k);<span class="comment">//遍历左子树</span></span><br><span class="line">    <span class="keyword">if</span>(ch!=<span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> ch;</span><br><span class="line">    ch=PreNode(b-&gt;rchild,k);<span class="comment">//遍历右子树</span></span><br><span class="line">    <span class="keyword">return</span> ch;              <span class="comment">//返回右子树中的遍历结果   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.求中序遍历序列中第k(1≤k≤二叉树中节点个数)个节点的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">1</span>;<span class="comment">//全局变量</span></span><br><span class="line">ElemType <span class="title function_">InNode</span><span class="params">(BTNode *b,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">	ElemType ch;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	ch=InNode(b-&gt;lchild,k);</span><br><span class="line">	<span class="keyword">if</span>(ch!=<span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> ch;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==k) <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">		n++;</span><br><span class="line">		<span class="keyword">return</span> InNode(b-&gt;rchild,k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.求后序遍历序列中第k(1≤k≤二叉树中节点个数)个节点的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">1</span>; <span class="comment">//全局变量</span></span><br><span class="line">ElemType <span class="title function_">PostNode</span><span class="params">(BTNode *b,<span class="type">int</span> k)</span></span><br><span class="line">&#123; </span><br><span class="line">ElemType ch;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">ch=PostNode(b-&gt;<span class="number">1</span>child,k); 			<span class="comment">//遍历左子树</span></span><br><span class="line"><span class="keyword">if</span> (ch!=<span class="string">&#x27; &#x27;</span>) 						<span class="comment">//在左子树找到了便返回 ch</span></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">    ch=PostNode(b-&gt;rchild,k); 		<span class="comment">//遍历右子树</span></span><br><span class="line">    <span class="keyword">if</span> (ch!=<span class="string">&#x27; &#x27;</span>) 					<span class="comment">//在右子树找到了便返回 ch</span></span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    <span class="keyword">if</span> (n==k)</span><br><span class="line">        <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>15.二叉树的带权路径长度为每个叶结点的深度与权值之积的总和，可以采用先序遍历或层序遍历解决。<br>算法思想：基于先序递归遍历的算法思想：采用一个 static 变量记录 wpl,把每个结点的深度作为递归函数的一个参数传递。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wpl_PreOrder</span><span class="params">(BiTree root, <span class="type">int</span> deep)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> wpl = <span class="number">0</span>; 								<span class="comment">//定义一个 static 全局变量存储 wpl</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">    wpl = wpl + deep*root-&gt;weight; 					<span class="comment">//为叶子结点直接累计 wpl</span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">    wpl_PreOrder(root-&gt;leight, deep+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">    wpl_PreOrder(root-&gt;rchild, deep+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> wpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wpl_PreOrder</span><span class="params">(BiTree root ,<span class="type">int</span>  deep)</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> wpl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild==<span class="literal">NULL</span> &amp;&amp; root-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//为叶子结点直接累计 wpl</span></span><br><span class="line">        wpl=wpl+deep*root-&gt;weight;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;lchild!=<span class="literal">NULL</span>) wpl_PreOrder(root-&gt;lchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rchild!=<span class="literal">NULL</span>) wpl_PreOrder(root-&gt;rchild,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> wpl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态局部变量存储在静态存储区，当静态局部变量离开作用域后，并没有被销毁。当该函数再次被调用的时候，该变量的值为上次函数调用结束时的值。</span></span><br></pre></td></tr></table></figure>

<p>16.设计一个算法，将给定的表达式树（二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2e2ce613a0b54d088ffce149e7ba4383.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Lic5ZGxUUFR,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出等价的中缀表达式分别为 (a+b)<em>(c</em>(-d)) 和 (a*b)+(-(c-d)) 。<br>算法思想：将二叉树的中序遍历递归算法稍加变形即可得到。除根结点和叶子结点外，遍历到其他结点是在遍历其左子树之前加上左括号，遍历完右子树后加上右括号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;BTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BtreeToExp</span><span class="params">(BTree *root, <span class="type">int</span> deep)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) 			<span class="comment">//若为叶子结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); 										<span class="comment">//若有子表达式则加 1 层括号</span></span><br><span class="line">        BtreeToExp(root-&gt;left, deep+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data);</span><br><span class="line">        BtreeToExp(root-&gt;right, deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(deep &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;）&quot;</span>); 										<span class="comment">//若有子表达式则加 1 层括号</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io/post/65d6c3b7.html">https://github.com/wjl-a/data.github.io/post/65d6c3b7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/wjl-a/data.github.io" target="_blank">醉卿枫の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/data.github.io/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">程序语言/数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2022/05/29/62939662553c9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/data.github.io/post/750c418c.html" title="1.线性表"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-03</div><div class="title">1.线性表</div></div></a></div><div><a href="/data.github.io/post/54ac7a95.html" title="7.802数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="title">7.802数据结构</div></div></a></div><div><a href="/data.github.io/post/b5847043.html" title="5.查找"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-27</div><div class="title">5.查找</div></div></a></div><div><a href="/data.github.io/post/cc7ab6f2.html" title="2.栈与队列"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-04</div><div class="title">2.栈与队列</div></div></a></div><div><a href="/data.github.io/post/ac84d2d9.html" title="6.排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-01</div><div class="title">6.排序</div></div></a></div><div><a href="/data.github.io/post/c32bee47.html" title="4.图"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/26/628fa0426213d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-10</div><div class="title">4.图</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="this.onerror=null;this.src='/data.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">树的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.2.</span> <span class="toc-text">基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">结点之间的关系描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E3%80%81%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">结点、树的属性描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">树的性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">几种特殊的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">二叉树常见性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">完全二叉树性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.2.</span> <span class="toc-text">二叉树的遍历和线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">二叉树的层次遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">由遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97-%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">先序序列 + 中序序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97-%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">后序序列 + 中序序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E5%BA%8F%E5%88%97-%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97"><span class="toc-number">2.3.0.3.</span> <span class="toc-text">层序序列 + 中序序列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">2.4.1.</span> <span class="toc-text">二叉树的线索化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">中序线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">先序线索化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">后序线索化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%89%8D%E9%A9%B1%E3%80%81%E5%90%8E%E7%BB%A7"><span class="toc-number">2.4.2.</span> <span class="toc-text">线索二叉树中找前驱、后继</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">中序二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">先序二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">后序二叉树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="toc-number">3.</span> <span class="toc-text">树、森林</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">双亲表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">孩子表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">孩子兄弟表示法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.</span> <span class="toc-text">树、森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">森林的遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">树与二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">二叉排序树（BST）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.1.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">4.1.3.</span> <span class="toc-text">二叉排序树的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">查找效率分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">平衡二叉树（AVL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">4.2.1.</span> <span class="toc-text">平衡二叉树的插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-%E9%9C%80%E5%8F%B3%E6%97%8B"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">LL(需右旋)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR%EF%BC%88%E9%9C%80%E5%B7%A6%E6%97%8B%EF%BC%89"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">RR（需左旋）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">LR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RL"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">RL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">查找与效率分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">常见问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">4.3.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0"><span class="toc-number">4.3.2.</span> <span class="toc-text">哈夫曼树构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">4.3.3.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k%E5%8F%89%E6%A0%91%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">4.3.4.</span> <span class="toc-text">k叉树构造最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">常见编码区别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%BB%A3%E7%A0%81%E4%B9%A0%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">课后代码习题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B9%A0%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">二叉树遍历习题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">5.2.</span> <span class="toc-text">树和森林</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-1"><span class="toc-number">5.3.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">5.4.</span> <span class="toc-text">树常用代码</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="变结构无人机仿真"/></a><div class="content"><a class="title" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真">变结构无人机仿真</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/5d3e3d8b.html" title="soildworks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="soildworks"/></a><div class="content"><a class="title" href="/data.github.io/post/5d3e3d8b.html" title="soildworks">soildworks</a><time datetime="2023-10-27T13:01:00.000Z" title="发表于 2023-10-27 21:01:00">2023-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/93b2f74a.html" title="mavros"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="mavros"/></a><div class="content"><a class="title" href="/data.github.io/post/93b2f74a.html" title="mavros">mavros</a><time datetime="2023-08-08T16:00:00.000Z" title="发表于 2023-08-09 00:00:00">2023-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/15fa7048.html" title="ROS"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/06/05/629c5257753d1.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="ROS"/></a><div class="content"><a class="title" href="/data.github.io/post/15fa7048.html" title="ROS">ROS</a><time datetime="2023-07-28T16:00:00.000Z" title="发表于 2023-07-29 00:00:00">2023-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/c010a565.html" title="3.c++模板"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="3.c++模板"/></a><div class="content"><a class="title" href="/data.github.io/post/c010a565.html" title="3.c++模板">3.c++模板</a><time datetime="2023-07-09T13:03:00.000Z" title="发表于 2023-07-09 21:03:00">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/data.github.io/js/utils.js"></script><script src="/data.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/data.github.io/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/data.github.io/js/search/local-search.js"></script></div></div></body></html>