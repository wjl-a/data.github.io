<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>7.c+++_智能指针_文件操作 | 醉卿枫の博客</title><meta name="author" content="醉卿枫"><meta name="copyright" content="醉卿枫"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="智能指针unique_ptr unique_ptr独享它指向的对象，也就是说，同时只有一个unique_ptr指向同一个对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁。 包含头文件：#include &lt;memory&gt;  123456789101112131415161718192021222324252627282930template &lt;typename T,">
<meta property="og:type" content="article">
<meta property="og:title" content="7.c+++_智能指针_文件操作">
<meta property="og:url" content="https://github.com/wjl-a/data.github.io/post/861cd88b.html">
<meta property="og:site_name" content="醉卿枫の博客">
<meta property="og:description" content="智能指针unique_ptr unique_ptr独享它指向的对象，也就是说，同时只有一个unique_ptr指向同一个对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁。 包含头文件：#include &lt;memory&gt;  123456789101112131415161718192021222324252627282930template &lt;typename T,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png">
<meta property="article:published_time" content="2023-12-23T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-04T05:34:13.426Z">
<meta property="article:author" content="醉卿枫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2022/05/29/62939662553c9.png"><link rel="shortcut icon" href="/data.github.io/img/favicon.png"><link rel="canonical" href="https://github.com/wjl-a/data.github.io/post/861cd88b.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/data.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/data.github.io/',
  algolia: undefined,
  localSearch: {"path":"/data.github.io/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '7.c+++_智能指针_文件操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-04 13:34:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><nav id="nav"><span id="blog-info"><a href="/data.github.io/" title="醉卿枫の博客"><span class="site-name">醉卿枫の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/data.github.io/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/data.github.io/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/data.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/data.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">7.c+++_智能指针_文件操作</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-23T16:00:00.000Z" title="发表于 2023-12-24 00:00:00">2023-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-04T05:34:13.426Z" title="更新于 2024-03-04 13:34:13">2024-03-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="7.c+++_智能指针_文件操作"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul>
<li><strong>unique_ptr独享它指向的对象</strong>，也就是说，同时只有一个unique_ptr指向同一个对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁。</li>
<li>包含头文件：<code>#include &lt;memory&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer p) <span class="keyword">noexcept</span>;	<span class="comment">// 不可用于转换函数。</span></span><br><span class="line">	~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span>;    </span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() <span class="type">const</span>;            <span class="comment">// 重载*操作符。</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span>;  <span class="comment">// 重载-&gt;操作符。</span></span><br><span class="line">	<span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;   <span class="comment">// 禁用拷贝构造函数。</span></span><br><span class="line">	unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁用赋值函数。</span></span><br><span class="line">	<span class="built_in">unique_ptr</span>(unique_ptr &amp;&amp;) <span class="keyword">noexcept</span>;	  <span class="comment">// 右值引用。</span></span><br><span class="line">	unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr &amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// 右值引用。</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	pointer ptr;  <span class="comment">// 内置的指针。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一个模板参数T：指针指向的数据类型。</span></span><br><span class="line"><span class="comment">//第二个模板参数D：指定删除器，缺省用delete释放资源。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">测试类AA的定义：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function">unique_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>;     <span class="comment">// 分配内存并初始化。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">unique_ptr&lt;AA&gt; p0 = <span class="built_in">make_unique</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);   <span class="comment">// C++14标准。</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; pp1=<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;();         <span class="comment">// 数据类型为int。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pp2 = <span class="built_in">make_unique</span>&lt;AA&gt;();       <span class="comment">// 数据类型为AA，默认构造函数。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pp3 = <span class="built_in">make_unique</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 数据类型为AA，一个参数的构造函数。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pp4 = <span class="built_in">make_unique</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>); <span class="comment">// 数据类型为AA，两个参数的构造函数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法三（不推荐）：</span><br><span class="line">AA* p = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(p)</span></span>;                  <span class="comment">// 用已存在的地址初始化。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>使用方法</strong></p>
<ul>
<li>智能指针重载了<code>*和-&gt;</code>操作符，可以像使用指针一样使用unique_ptr</li>
<li>不支持普通的拷贝和赋值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AA* p = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>);</span><br><span class="line">unique_ptr&lt;AA&gt; pu2 = p;              <span class="comment">// 错误，不能把普通指针直接赋给智能指针。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pu3 = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>); <span class="comment">// 错误，不能把普通指针直接赋给智能指针。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pu2 = pu1;           <span class="comment">// 错误，不能用其它unique_ptr拷贝构造。</span></span><br><span class="line">unique_ptr&lt;AA&gt; pu3;</span><br><span class="line">pu3 = pu1;                            <span class="comment">// 错误，不能用=对unique_ptr进行赋值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>不要用同一个裸指针初始化多个unique_ptr对象。</li>
<li>get()方法返回裸指针。</li>
<li>不要用unique_ptr管理不是new分配的内存。</li>
</ul>
<p><strong>用于函数的参数</strong></p>
<ul>
<li>传引用（不能传值，因为unique_ptr没有拷贝构造函数）</li>
<li>裸指针</li>
</ul>
<p><strong>不支持指针的运算（+、-、++、–）</strong></p>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>1）将一个unique_ptr赋给另一个时，如果源unique_ptr是一个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器禁止这样做。一般用于函数的返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;AA&gt; p0;</span><br><span class="line">p0 = <span class="built_in">unique_ptr</span>&lt;AA&gt;(<span class="keyword">new</span> <span class="built_in">AA</span> (<span class="string">&quot;西瓜&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>2）用nullptr给unique_ptr赋值将释放对象，空的<code>unique_ptr==nullptr。</code><br>3）release()释放对原始指针的控制权，将unique_ptr置为空，返回裸指针。（可用于把unique_ptr传递给子函数，子函数将负责释放对象）<br>4）std::move()可以转移对原始指针的控制权。（可用于把unique_ptr传递给子函数，子函数形参也是unique_ptr）<br>5）reset()释放对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T * _ptr= (T *) <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">pp.<span class="built_in">reset</span>();        <span class="comment">// 释放pp对象指向的资源对象。</span></span><br><span class="line">pp.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);  <span class="comment">// 释放pp对象指向的资源对象</span></span><br><span class="line">pp.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;bbb&quot;</span>));  <span class="comment">// 释放pp指向的资源对象，同时指向新的对象。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6）swap()交换两个unique_ptr的控制权：<code>void swap(unique_ptr&lt;T&gt; &amp;_Right);</code><br>7）unique_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样<br>8）unique_ptr不是绝对安全，如果程序中调用exit()退出，全局的unique_ptr可以自动释放，但局部的unique_ptr无法释放<br>9）unique_ptr提供了支持数组的具体化版本。：数组版本的unique_ptr，重载了操作符<code>[]</code>，操作符[]返回的是引用，可以作为左值使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_ptr&lt;int[]&gt; parr1(new int[3]);          // 不指定初始值。</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">parr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123; <span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span> &#125;)</span></span>;  <span class="comment">// 指定初始值。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr1[0]=&quot;</span> &lt;&lt; parr1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr1[1]=&quot;</span> &lt;&lt; parr1[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr1[2]=&quot;</span> &lt;&lt; parr1[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;AA[]&gt; <span class="title">parr2</span><span class="params">(<span class="keyword">new</span> AA[<span class="number">3</span>]&#123;string(<span class="string">&quot;西施&quot;</span>), string(<span class="string">&quot;冰冰&quot;</span>), string(<span class="string">&quot;幂幂&quot;</span>)&#125;)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[0].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">0</span>].m_name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[1].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">1</span>].m_name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parr2[2].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">2</span>].m_name &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func1()需要一个指针，但不对这个指针负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> AA* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func2()需要一个指针，并且会对这个指针负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(AA* a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func3()需要一个unique_ptr，不会对这个unique_ptr负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">const</span> unique_ptr&lt;AA&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数func4()需要一个unique_ptr，并且会对这个unique_ptr负责。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(unique_ptr&lt;AA&gt; a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;AA&gt; <span class="title">pu</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始调用函数。\n&quot;</span>;</span><br><span class="line">	<span class="comment">//func1(pu.get());        // 函数func1()需要一个指针，但不对这个指针负责。</span></span><br><span class="line">	<span class="comment">//func2(pu.release());  // 函数func2()需要一个指针，并且会对这个指针负责。</span></span><br><span class="line">	<span class="comment">//func3(pu);                // 函数func3()需要一个unique_ptr，不会对这个unique_ptr负责。</span></span><br><span class="line">	<span class="built_in">func4</span>(<span class="built_in">move</span>(pu));     <span class="comment">// 函数func4()需要一个unique_ptr，并且会对这个unique_ptr负责。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用函数完成。\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pu == <span class="literal">nullptr</span>) cout &lt;&lt; <span class="string">&quot;pu是空指针。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//AA* parr1 = new AA[2];   // 普通指针数组。</span></span><br><span class="line">	<span class="comment">////AA* parr1 = new AA[2]&#123; string(&quot;西施&quot;), string(&quot;冰冰&quot;) &#125;;</span></span><br><span class="line">	<span class="comment">//parr1[0].m_name = &quot;西施1&quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;parr1[0].m_name=&quot; &lt;&lt; parr1[0].m_name &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//parr1[1].m_name = &quot;西施2&quot;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;parr1[1].m_name=&quot; &lt;&lt; parr1[1].m_name &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//delete [] parr1;</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">unique_ptr&lt;AA[]&gt; <span class="title">parr2</span><span class="params">(<span class="keyword">new</span> AA[<span class="number">2</span>])</span></span>;   <span class="comment">// unique_ptr数组。</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;AA[]&gt; parr2(new AA[2]&#123; string(&quot;西施&quot;), string(&quot;冰冰&quot;) &#125;);</span></span><br><span class="line">	parr2[<span class="number">0</span>].m_name = <span class="string">&quot;西施1&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;parr2[0].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">0</span>].m_name &lt;&lt; endl;</span><br><span class="line">	parr2[<span class="number">1</span>].m_name = <span class="string">&quot;西施2&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;parr2[1].m_name=&quot;</span> &lt;&lt; parr2[<span class="number">1</span>].m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><ul>
<li>[[6、数组、指针和字符串#智能指针|智能指针]]</li>
<li>shared_ptr共享它指向的对象，<strong>多个shared_ptr可以指向（关联）相同的对象</strong>，在内部采用计数机制来实现。</li>
<li>当新的shared_ptr与对象关联时，引用计数增加1。</li>
<li>当shared_ptr超出作用域时，引用计数减1。当引用计数变为0时，则表示没有任何shared_ptr与对象关联，则释放该对象</li>
</ul>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li><strong>shared_ptr的构造函数也是explicit</strong>，但是，没有删除拷贝构造函数和赋值函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>;     <span class="comment">// 分配内存并初始化。</span></span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">shared_ptr&lt;AA&gt; p0 = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);  <span class="comment">// C++11标准，效率更高。</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; pp1=<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();         <span class="comment">// 数据类型为int。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pp2 = <span class="built_in">make_shared</span>&lt;AA&gt;();       <span class="comment">// 数据类型为AA，默认构造函数。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pp3 = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 数据类型为AA，一个参数的构造函数。</span></span><br><span class="line">shared_ptr&lt;AA&gt; pp4 = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施&quot;</span>,<span class="number">8</span>); <span class="comment">// 数据类型为AA，两个参数的构造函数。</span></span><br><span class="line"></span><br><span class="line">方法三：</span><br><span class="line">AA* p = <span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;西施&quot;</span>);</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(p)</span></span>;                  <span class="comment">// 用已存在的地址初始化。</span></span><br><span class="line"></span><br><span class="line">方法四：</span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施&quot;</span>))</span></span>; </span><br><span class="line"><span class="function">shared_ptr&lt;AA&gt; <span class="title">p1</span><span class="params">(p0)</span></span>;                 <span class="comment">// 用已存在的shared_ptr初始化，计数加1。</span></span><br><span class="line">shared_ptr&lt;AA&gt; p1=p0;                 <span class="comment">// 用已存在的shared_ptr初始化，计数加1。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>智能指针重载了<code>*和-&gt;</code>操作符，可以像使用指针一样使用shared_ptr</li>
<li>use_count()方法返回引用计数器的值</li>
<li>unique()方法，如果use_count()为1，返回true，否则返回false</li>
<li>shared_ptr支持赋值，左值的shared_ptr的计数器将减1，右值shared_ptr的计算器将加1</li>
<li>get()方法返回裸指针</li>
<li>不要用同一个裸指针初始化多个shared_ptr</li>
<li>不要用shared_ptr管理不是new分配的内存</li>
</ul>
<p><strong>用于函数的参数</strong>：与unique_ptr的原理相同。<br><strong>不支持指针的运算（+、-、++、–）</strong></p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>2）用nullptr给shared_ptr赋值将把计数减1，如果计数为0，将释放对象，空的<code>shared_ptr==nullptr</code><br>4）std::move()可以转移对原始指针的控制权。还可以将unique_ptr转移成shared_ptr。<br>5）reset()改变与资源的关联关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pp.<span class="built_in">reset</span>();        <span class="comment">// 解除与资源的关系，资源的引用计数减1。</span></span><br><span class="line">pp. <span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">AA</span>(<span class="string">&quot;bbb&quot;</span>));  <span class="comment">// 解除与资源的关系，资源的引用计数减1。关联新资源。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6）swap()交换两个shared_ptr的控制权：<code>void swap(shared_ptr&lt;T&gt; &amp;_Right);</code><br>7）shared_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样。<br>8）shared_ptr不是绝对安全，如果程序中调用exit()退出，全局的shared_ptr可以自动释放，但局部的shared_ptr无法释放。<br>9）shared_ptr提供了支持数组的具体化版本。<br>数组版本的shared_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用。<br>10）shared_ptr的线程安全性：</p>
<ul>
<li>shared_ptr的引用计数本身是线程安全（引用计数是原子操作）。</li>
<li>多个线程同时读同一个shared_ptr对象是线程安全的。</li>
<li>如果是多个线程对同一个shared_ptr对象进行读和写，则需要加锁。</li>
<li>多线程读写shared_ptr所指向的同一个对象，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，也需要加锁保护。</li>
</ul>
<p>11）如果unique_ptr能解决问题，就不要用shared_ptr。unique_ptr的效率更高，占用的资源更少。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;AA&gt; <span class="title">pa0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施a&quot;</span>))</span></span>;     <span class="comment">// 初始化资源西施a。</span></span><br><span class="line">	shared_ptr&lt;AA&gt; pa1 = pa0;                       <span class="comment">// 用已存在的shared_ptr拷贝构造，计数加1。</span></span><br><span class="line">	shared_ptr&lt;AA&gt; pa2 = pa0;                       <span class="comment">// 用已存在的shared_ptr拷贝构造，计数加1。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pa0.use_count()=&quot;</span> &lt;&lt; pa0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为3。</span></span><br><span class="line"></span><br><span class="line">	<span class="function">shared_ptr&lt;AA&gt; <span class="title">pb0</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施b&quot;</span>))</span></span>;    <span class="comment">// 初始化资源西施b。</span></span><br><span class="line">	shared_ptr&lt;AA&gt; pb1 = pb0;                      <span class="comment">// 用已存在的shared_ptr拷贝构造，计数加1。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pb0.use_count()=&quot;</span> &lt;&lt; pb0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为2。</span></span><br><span class="line"></span><br><span class="line">	pb1 = pa1;      <span class="comment">// 资源西施a的引用加1，资源西施b的引用减1。</span></span><br><span class="line">	pb0 = pa1;      <span class="comment">// 资源西施a的引用加1，资源西施b的引用成了0，将被释放。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pa0.use_count()=&quot;</span> &lt;&lt; pa0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为5。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pb0.use_count()=&quot;</span> &lt;&lt; pb0.<span class="built_in">use_count</span>() &lt;&lt; endl;   <span class="comment">// 值为5。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="智能指针的删除器"><a href="#智能指针的删除器" class="headerlink" title="智能指针的删除器"></a>智能指针的删除器</h2><ul>
<li>在默认情况下，智能指针过期的时候，用delete原始指针; 释放它管理的资源。</li>
<li>程序员可以自定义删除器，<strong>改变智能指针释放资源的行为</strong>。</li>
<li>删除器可以是全局函数、仿函数和Lambda表达式，形参为原始指针。</li>
<li>智能指针（如 std::unique_ptr、std::shared_ptr）默认使用 delete 操作符来释放资源。但在某些情况下，可能需要自定义资源的释放方式，例如使用 C 标准库的 free 函数释放动态分配的内存，或使用自定义的析构函数来释放资源。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> string &amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span>&lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletefunc</span><span class="params">(AA* a)</span> </span>&#123;    <span class="comment">// 删除器，普通函数。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自定义删除器（全局函数）。\n&quot;</span>;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">deleteclass</span>               <span class="comment">// 删除器，仿函数。</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(AA* a)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;自定义删除器（仿函数）。\n&quot;</span>;</span><br><span class="line">		<span class="keyword">delete</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> deleterlamb = [](AA* a) &#123;   <span class="comment">// 删除器，Lambda表达式。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自定义删除器（Lambda）。\n&quot;</span>;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;AA&gt; <span class="title">pa1</span><span class="params">(<span class="keyword">new</span> AA(<span class="string">&quot;西施a&quot;</span>), deletefunc)</span></span>;</span><br><span class="line">	<span class="comment">//shared_ptr&lt;AA&gt; pa2(new AA(&quot;西施b&quot;), deleteclass());</span></span><br><span class="line">	<span class="comment">//shared_ptr&lt;AA&gt; pa3(new AA(&quot;西施c&quot;), deleterlamb);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//unique_ptr&lt;AA,decltype(deletefunc)*&gt; pu1(new AA(&quot;西施1&quot;), deletefunc);</span></span><br><span class="line">    <span class="comment">// unique_ptr&lt;AA, void (*)(AA*)&gt; pu0(new AA(&quot;西施1&quot;), deletefunc);</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;AA, deleteclass&gt; pu2(new AA(&quot;西施2&quot;), deleteclass());</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;AA, decltype(deleterlamb)&gt; pu3(new AA(&quot;西施3&quot;), deleterlamb);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><strong>shared_ptr存在的问题</strong></p>
<ul>
<li>shared_ptr内部维护了一个共享的引用计数器，多个shared_ptr可以指向同一个资源。</li>
<li>如果出现了循环引用的情况，引用计数永远无法归0，资源不会被释放。</li>
</ul>
<p><strong>weak_ptr</strong></p>
<ul>
<li>weak_ptr 是为了配合shared_ptr而引入的，它指向一个由shared_ptr管理的资源但不影响资源的生命周期。也就是说，<strong>将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数</strong></li>
<li>不论是否有weak_ptr指向，如果最后一个指向资源的shared_ptr被销毁，资源就会被释放</li>
<li><strong>weak_ptr更像是shared_ptr的助手而不是智能指针</strong></li>
</ul>
<p><strong>使用weak_ptr</strong></p>
<ul>
<li>weak_ptr没有重载 -&gt;和 <code>*操作符</code>，不能直接访问资源。</li>
<li>有以下成员函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）<span class="keyword">operator</span>=();  <span class="comment">// 把shared_ptr或weak_ptr赋值给weak_ptr。</span></span><br><span class="line"><span class="number">2</span>）<span class="built_in">expired</span>();     <span class="comment">// 判断它指资源是否已过期（已经被销毁）。</span></span><br><span class="line"><span class="number">3</span>）<span class="built_in">lock</span>();        <span class="comment">// 返回shared_ptr，如果资源已过期，返回空的shared_ptr。</span></span><br><span class="line"><span class="number">4</span>）<span class="built_in">reset</span>();       <span class="comment">// 将当前weak_ptr指针置为空。</span></span><br><span class="line"><span class="number">5</span>）<span class="built_in">swap</span>();       <span class="comment">// 交换。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>weak_ptr不控制对象的生命周期，但是，它知道对象是否还活着</li>
<li>用lock()函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr</li>
<li>提升的行为（lock()）是线程安全的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="built_in">AA</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数AA()。\n&quot;</span>; &#125;</span><br><span class="line">	<span class="built_in">AA</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">AA</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~AA(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	weak_ptr&lt;BB&gt; m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="built_in">BB</span>() &#123; cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;调用构造函数BB()。\n&quot;</span>; &#125;</span><br><span class="line">	<span class="built_in">BB</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">m_name</span>(name) &#123; cout &lt;&lt; <span class="string">&quot;调用构造函数BB(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	~<span class="built_in">BB</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用了析构函数~BB(&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;)。\n&quot;</span>; &#125;</span><br><span class="line">	weak_ptr&lt;AA&gt; m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;AA&gt; pa = <span class="built_in">make_shared</span>&lt;AA&gt;(<span class="string">&quot;西施a&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		shared_ptr&lt;BB&gt; pb = <span class="built_in">make_shared</span>&lt;BB&gt;(<span class="string">&quot;西施b&quot;</span>);</span><br><span class="line"></span><br><span class="line">		pa-&gt;m_p = pb;</span><br><span class="line">		pb-&gt;m_p = pa;</span><br><span class="line"></span><br><span class="line">		shared_ptr&lt;BB&gt; pp = pa-&gt;m_p.<span class="built_in">lock</span>();            <span class="comment">// 把weak_ptr提升为shared_ptr。</span></span><br><span class="line">		<span class="keyword">if</span> (pp == <span class="literal">nullptr</span>)</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;语句块内部：pa-&gt;m_p已过期。\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;语句块内部：pp-&gt;m_name=&quot;</span> &lt;&lt; pp-&gt;m_name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shared_ptr&lt;BB&gt; pp = pa-&gt;m_p.<span class="built_in">lock</span>();            <span class="comment">// 把weak_ptr提升为shared_ptr。</span></span><br><span class="line">	<span class="keyword">if</span> (pp == <span class="literal">nullptr</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;语句块外部：pa-&gt;m_p已过期。\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;语句块外部：pp-&gt;m_name=&quot;</span> &lt;&lt; pp-&gt;m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="写入文本文件"><a href="#写入文本文件" class="headerlink" title="写入文本文件"></a>写入文本文件</h2><ul>
<li>文本文件一般以行的形式组织数</li>
<li>包含头文件：<code>#include &lt;fstream&gt;</code></li>
<li>类：<code>ofstream（output file stream）</code><br><strong>ofstream打开文件的模式（方式）</strong></li>
<li>对于ofstream，不管用哪种模式打开文件，如果文件不存在，都会创建文件。</li>
<li>ios::out                 缺省值：会截断文件内容。</li>
<li>ios::trunc  		截断文件内容。（truncate）</li>
<li>ios::app   		不截断文件内容，只在文件未尾追加文件。（append）<br>示例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ofstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line">	<span class="comment">//  1）&quot;D:\data\txt\test.txt&quot;       // 错误。</span></span><br><span class="line">	<span class="comment">//  2）R&quot;(D:\data\txt\test.txt)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line">	<span class="comment">//  3）&quot;D:\\data\\txt\\test.txt&quot;   // 转义字符。</span></span><br><span class="line">	<span class="comment">//  4）&quot;D:/tata/txt/test.txt&quot;        // 把斜线反着写。</span></span><br><span class="line">	<span class="comment">//  5）&quot;/data/txt/test.txt&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">	string filename = <span class="string">R&quot;(C:\Users\wjl\Desktop\code\test\test.txt)&quot;</span>;</span><br><span class="line">	<span class="comment">//char    filename[] = R&quot;(D:\data\txt\test.txt)&quot;;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建文件输出流对象，打开文件，如果文件不存在，则创建它。</span></span><br><span class="line">	<span class="comment">// ios::out     		缺省值：会截断文件内容。</span></span><br><span class="line">	<span class="comment">// ios::trunc  		截断文件内容。（truncate）</span></span><br><span class="line">	<span class="comment">// ios::app   			不截断文件内容，只在文件未尾追加文件。（append）</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename);</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename, ios::out);</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename, ios::trunc);</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename, ios::app);</span></span><br><span class="line">	</span><br><span class="line">	ofstream fout;</span><br><span class="line">	fout.<span class="built_in">open</span>(filename,ios::app);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line">	<span class="comment">// 失败的原因主要有：1）目录不存在；2）磁盘空间已满；3）没有权限，Linux平台下很常见。</span></span><br><span class="line">	<span class="keyword">if</span> (fout.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向文件中写入数据。</span></span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;西施|19|极漂亮\n&quot;</span>;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;冰冰|22|漂亮\n&quot;</span>;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;幂幂|25|一般\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	fout.<span class="built_in">close</span>();	   <span class="comment">// 关闭文件，fout对象失效前会自动调用close()。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><ul>
<li>包含头文件：<code>#include &lt;fstream&gt;</code></li>
<li>类：ifstream</li>
<li>ifstream打开文件的模式（方式）：</li>
<li>对于ifstream，如果文件不存在，则打开文件失败。</li>
<li>ios::in     		缺省值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ifstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>     <span class="comment">// getline()函数需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line">	<span class="comment">//  1）&quot;D:\data\txt\test.txt&quot;       // 错误。</span></span><br><span class="line">	<span class="comment">//  2）R&quot;(D:\data\txt\test.txt)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line">	<span class="comment">//  3）&quot;D:\\data\\txt\\test.txt&quot;   // 转义字符。</span></span><br><span class="line">	<span class="comment">//  4）&quot;D:/tata/txt/test.txt&quot;        // 把斜线反着写。</span></span><br><span class="line">	<span class="comment">//  5）&quot;/data/txt/test.txt&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">	string filename = <span class="string">R&quot;(C:\Users\wjl\Desktop\code\test\test.txt)&quot;</span>;</span><br><span class="line">	<span class="comment">//char    filename[] = R&quot;(D:\data\txt\test.txt)&quot;;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建文件输入流对象，打开文件，如果文件不存在，则打开文件失败。。</span></span><br><span class="line">	<span class="comment">// ios::in     			缺省值。</span></span><br><span class="line">	<span class="comment">//ifstream fin(filename);</span></span><br><span class="line">	<span class="comment">//ifstream fin(filename, ios::in);</span></span><br><span class="line">	</span><br><span class="line">	ifstream fin;</span><br><span class="line">	fin.<span class="built_in">open</span>(filename,ios::in);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line">	<span class="comment">// 失败的原因主要有：1）目录不存在；2）文件不存在；3）没有权限，Linux平台下很常见。</span></span><br><span class="line">	<span class="keyword">if</span> (fin.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//// 第一种方法。</span></span><br><span class="line">	<span class="comment">//string buffer;  // 用于存放从文件中读取的内容。</span></span><br><span class="line">	<span class="comment">//// 文本文件一般以行的方式组织数据。</span></span><br><span class="line">	<span class="comment">//while (getline(fin, buffer))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//// 第二种方法。</span></span><br><span class="line">	<span class="comment">//char buffer[16];   // 存放从文件中读取的内容。</span></span><br><span class="line">	<span class="comment">//// 注意：如果采用ifstream.getline()，一定要保证缓冲区足够大。</span></span><br><span class="line">	<span class="comment">//while (fin.getline(buffer, 15))</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三种方法。</span></span><br><span class="line">	string buffer;</span><br><span class="line">	<span class="keyword">while</span> (fin &gt;&gt; buffer)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fin.<span class="built_in">close</span>();	   <span class="comment">// 关闭文件，fin对象失效前会自动调用close()。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="写入二进制文件"><a href="#写入二进制文件" class="headerlink" title="写入二进制文件"></a>写入二进制文件</h2><ul>
<li>二进制文件以数据块的形式组织数据，把内存中的数据直接写入文件。</li>
<li>包含头文件：<code>#include &lt;fstream&gt;</code></li>
<li>类：ofstream（output file stream）</li>
<li>ofstream打开文件的模式（方式）：</li>
<li>对于ofstream，不管用哪种模式打开文件，如果文件不存在，都会创建文件。<ul>
<li>ios::out     		缺省值：会截断文件内容。</li>
<li>ios::trunc  		截断文件内容。（truncate）</li>
<li>ios::app   		不截断文件内容，只在文件未尾追加文件。（append）</li>
<li>ios::binary   	以二进制方式打开文件。</li>
</ul>
</li>
</ul>
<p><strong>操作文本文件和二进制文件的一些细节</strong><br>1）在windows平台下，文本文件的换行标志是<code>&quot;\r\n&quot;</code>。<br>2）在linux平台下，文本文件的换行标志是<code>&quot;\n&quot;</code>。<br>3）在windows平台下，如果以<strong>文本方式打开文件，写入数据的时候，系统会将”\n”转换成”\r\n”；读取数据的时候，系统会将”\r\n”转换成”\n”。 如果以二进制方式打开文件，写和读都不会进行转换</strong>。<br>4）在Linux平台下，以文本或二进制方式打开文件，系统不会做任何转换。<br>5）以文本方式读取文件的时候，遇到换行符停止，读入的内容中没有换行符；以二制方式读取文件的时候，遇到换行符不会停止，读入的内容中会包含换行符（换行符被视为数据）。</p>
<ul>
<li>在实际开发中，从兼容和语义考虑，一般：<ul>
<li>以<strong>文本模式</strong>打开文本文件，用<strong>行</strong>的方法操作它；</li>
<li>以<strong>二进制模式</strong>打开二进制文件，用<strong>数据块</strong>的方法操作它；</li>
<li>以二进制模式打开文本文件和二进制文件，用数据块的方法操作它，这种情况表示不关心数据的内容。（例如复制文件和传输文件）</li>
<li>不要以文本模式打开二进制文件，也不要用行的方法操作二进制文件，可能会破坏二进制数据文件的格式，也没有必要。（因为二进制文件中的某字节的取值可能是换行符，但它的意义并不是换行，可能是整数n个字节中的某个字节）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ofstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line">	<span class="comment">//  1）&quot;D:\data\bin\test.dat&quot;       // 错误。</span></span><br><span class="line">	<span class="comment">//  2）R&quot;(D:\data\bin\test.dat)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line">	<span class="comment">//  3）&quot;D:\\data\\bin\\test.dat&quot;   // 转义字符。</span></span><br><span class="line">	<span class="comment">//  4）&quot;D:/tata/bin/test.dat&quot;        // 把斜线反着写。</span></span><br><span class="line">	<span class="comment">//  5）&quot;/data/bin/test.dat&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">	string filename = <span class="string">R&quot;(D:\data\bin\test.dat)&quot;</span>;</span><br><span class="line">	<span class="comment">//char    filename[] = R&quot;(D:\data\bin\test.dat)&quot;;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建文件输出流对象，打开文件，如果文件不存在，则创建它。</span></span><br><span class="line">	<span class="comment">// ios::out     		缺省值：会截断文件内容。</span></span><br><span class="line">	<span class="comment">// ios::trunc  		截断文件内容。（truncate）</span></span><br><span class="line">	<span class="comment">// ios::app   			不截断文件内容，只在文件未尾追加文件。（append）</span></span><br><span class="line">	<span class="comment">// ios::binary   		以二进制方式打开文件。</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename, ios::binary);</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename, ios::out | ios::binary);</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename, ios::trunc | ios::binary);</span></span><br><span class="line">	<span class="comment">//ofstream fout(filename, ios::app | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	ofstream fout;</span><br><span class="line">	fout.<span class="built_in">open</span>(filename, ios::app | ios::binary);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line">	<span class="comment">// 失败的原因主要有：1）目录不存在；2）磁盘空间已满；3）没有权限，Linux平台下很常见。</span></span><br><span class="line">	<span class="keyword">if</span> (fout.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向文件中写入数据。</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">st_girl</span> &#123;               <span class="comment">// 超女结构体。</span></span><br><span class="line">		<span class="type">char</span> name[<span class="number">31</span>];         <span class="comment">// 姓名。</span></span><br><span class="line">		<span class="type">int</span>    no;                    <span class="comment">// 编号。   </span></span><br><span class="line">		<span class="type">char</span> memo[<span class="number">301</span>];      <span class="comment">// 备注。</span></span><br><span class="line">		<span class="type">double</span> weight;         <span class="comment">// 体重。</span></span><br><span class="line">	&#125;girl;</span><br><span class="line">	girl = &#123; <span class="string">&quot;西施&quot;</span>,<span class="number">3</span>,<span class="string">&quot;中国历史第一美女。&quot;</span> ,<span class="number">45.8</span> &#125;;</span><br><span class="line">	fout.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp; girl, <span class="built_in">sizeof</span>(st_girl));   <span class="comment">// 写入第一块数据。</span></span><br><span class="line">	girl = &#123; <span class="string">&quot;冰冰&quot;</span>,<span class="number">8</span>,<span class="string">&quot;也是个大美女哦。&quot;</span>,<span class="number">55.2</span>&#125;;</span><br><span class="line">	fout.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;girl, <span class="built_in">sizeof</span>(st_girl));     <span class="comment">// 写入第二块数据。</span></span><br><span class="line">	fout.<span class="built_in">close</span>();	   <span class="comment">// 关闭文件，fout对象失效前会自动调用close()。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><ul>
<li>包含头文件：<code>#include &lt;fstream&gt;</code></li>
<li>类：ifstream</li>
<li>ifstream打开文件的模式（方式）：</li>
<li>对于ifstream，如果文件不存在，则打开文件失败</li>
<li>ios::in     		缺省值</li>
<li>ios::binary   	以二进制方式打开文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// ifstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 文件名一般用全路径，书写的方法如下：</span></span><br><span class="line">	<span class="comment">//  1）&quot;D:\data\bin\test.dat&quot;       // 错误。</span></span><br><span class="line">	<span class="comment">//  2）R&quot;(D:\data\bin\test.dat)&quot;   // 原始字面量，C++11标准。</span></span><br><span class="line">	<span class="comment">//  3）&quot;D:\\data\\bin\\test.dat&quot;   // 转义字符。</span></span><br><span class="line">	<span class="comment">//  4）&quot;D:/tata/bin/test.dat&quot;        // 把斜线反着写。</span></span><br><span class="line">	<span class="comment">//  5）&quot;/data/bin/test.dat&quot;          //  Linux系统采用的方法。</span></span><br><span class="line">	string filename = <span class="string">R&quot;(D:\data\bin\test.dat)&quot;</span>;</span><br><span class="line">	<span class="comment">//char    filename[] = R&quot;(D:\data\bin\test.dat)&quot;;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建文件输入流对象，打开文件，如果文件不存在，则打开文件失败。。</span></span><br><span class="line">	<span class="comment">// ios::in     			缺省值。</span></span><br><span class="line">	<span class="comment">// ios::binary   		以二进制方式打开文件。</span></span><br><span class="line">	<span class="comment">//ifstream fin(filename , ios::binary);</span></span><br><span class="line">	<span class="comment">//ifstream fin(filename , ios::in | ios::binary);</span></span><br><span class="line"></span><br><span class="line">	ifstream fin;</span><br><span class="line">	fin.<span class="built_in">open</span>(filename, ios::in | ios::binary);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断打开文件是否成功。</span></span><br><span class="line">	<span class="comment">// 失败的原因主要有：1）目录不存在；2）文件不存在；3）没有权限，Linux平台下很常见。</span></span><br><span class="line">	<span class="keyword">if</span> (fin.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二进制文件以数据块（数据类型）的形式组织数据。</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">st_girl</span> &#123;               <span class="comment">// 超女结构体。</span></span><br><span class="line">		<span class="type">char</span> name[<span class="number">31</span>];         <span class="comment">// 姓名。</span></span><br><span class="line">		<span class="type">int</span>    no;                    <span class="comment">// 编号。   </span></span><br><span class="line">		<span class="type">char</span> memo[<span class="number">301</span>];      <span class="comment">// 备注。</span></span><br><span class="line">		<span class="type">double</span> weight;         <span class="comment">// 体重。</span></span><br><span class="line">	&#125;girl;</span><br><span class="line">	<span class="keyword">while</span> (fin.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;girl, <span class="built_in">sizeof</span>(girl)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; girl.name &lt;&lt; <span class="string">&quot;，no=&quot;</span> &lt;&lt; girl.no &lt;&lt; </span><br><span class="line">			<span class="string">&quot;，memo=&quot;</span> &lt;&lt; girl.memo &lt;&lt; <span class="string">&quot;，weight=&quot;</span> &lt;&lt; girl.weight &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	fin.<span class="built_in">close</span>();	   <span class="comment">// 关闭文件，fin对象失效前会自动调用close()。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="随机存取"><a href="#随机存取" class="headerlink" title="随机存取"></a>随机存取</h2><h3 id="fstream类"><a href="#fstream类" class="headerlink" title="fstream类"></a>fstream类</h3><ul>
<li>fstream类既可以读文本&#x2F;二进制文件，也可以写文本&#x2F;二进制文件。</li>
<li>fstream类的缺省模式是ios::in | ios::out，如果文件不存在，则创建文件；但是，不会清空文件原有的内容。</li>
</ul>
<p><strong>普遍的做法是</strong></p>
<ul>
<li>如果只想写入数据，用ofstream；如果只想读取数据，用ifstream；如果想写和读数据，用fstream，这种情况不多见。不同的类体现不同的语义。</li>
<li>在Linux平台下，文件的写和读有严格的权限控制。（需要的权限越少越好）</li>
</ul>
<h3 id="文件的位置指针"><a href="#文件的位置指针" class="headerlink" title="文件的位置指针"></a>文件的位置指针</h3><ul>
<li>对文件进行读&#x2F;写操作时，文件的位置指针指向当前文件读&#x2F;写的位置。</li>
<li>很多资料用“文件读指针的位置”和“文件写指针的位置”，容易误导人。不管用哪个类操作文件，文件的位置指针只有一个。</li>
</ul>
<ol>
<li><strong>获取文件位置指针</strong></li>
</ol>
<ul>
<li>ofstream类的成员函数是tellp()；ifstream类的成员函数是tellg()；fstream类两个都有，效果相同。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::streampos <span class="title">tellp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::streampos <span class="title">tellg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>移动文件位置指针</strong></li>
</ol>
<ul>
<li>ofstream类的函数是seekp()；ifstream类的函数是seekg()；fstream类两个都有，效果相同<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="function">std::istream &amp; <span class="title">seekg</span><span class="params">(std::streampos _Pos)</span></span>;  </span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">128</span>);   <span class="comment">// 把文件指针移到第128字节。</span></span><br><span class="line">fin.<span class="built_in">seekp</span>(<span class="number">128</span>);   <span class="comment">// 把文件指针移到第128字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(ios::beg) <span class="comment">// 把文件指针移动文件的开始。</span></span><br><span class="line">fin.<span class="built_in">seekp</span>(ios::end) <span class="comment">// 把文件指针移动文件的结尾。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="function">std::istream &amp; <span class="title">seekg</span><span class="params">(std::streamoff _Off,std::ios::seekdir _Way)</span></span>;</span><br><span class="line">在ios中定义的枚举类型：</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">seek_dir</span> &#123;beg, cur, end&#125;;  <span class="comment">// beg-文件的起始位置；cur-文件的当前位置；end-文件的结尾位置。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">30</span>, ios::beg);    <span class="comment">// 从文件开始的位置往后移30字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">-5</span>, ios::cur);     <span class="comment">// 从当前位置往前移5字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>( <span class="number">8</span>, ios::cur);     <span class="comment">// 从当前位置往后移8字节。</span></span><br><span class="line">fin.<span class="built_in">seekg</span>(<span class="number">-10</span>, ios::end);   <span class="comment">// 从文件结尾的位置往前移10字节。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="随机存取-1"><a href="#随机存取-1" class="headerlink" title="随机存取"></a>随机存取</h3><ul>
<li>随机存取是指直接移动文件的位置指针，在指定位置读取&#x2F;写入数据<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// fstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string filename = <span class="string">R&quot;(C:\Users\wjl\Desktop\code\test\test.txt)&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	fstream fs;</span><br><span class="line">	fs.<span class="built_in">open</span>(filename, ios::in | ios::out);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fs.<span class="built_in">is_open</span>() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="string">&quot;失败。\n&quot;</span>;  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fs.<span class="built_in">seekg</span>(<span class="number">26</span>);    <span class="comment">// 把文件位置指针移动到第26字节处。</span></span><br><span class="line">	fs &lt;&lt; <span class="string">&quot;我是一只傻傻的小菜鸟。\n&quot;</span>; </span><br><span class="line">	<span class="comment">/*string buffer; </span></span><br><span class="line"><span class="comment">	while (fs &gt;&gt; buffer)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; buffer &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	fs.<span class="built_in">close</span>();	   <span class="comment">// 关闭文件，fs对象失效前会自动调用close()。</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;操作文件完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="打开文件的模式"><a href="#打开文件的模式" class="headerlink" title="打开文件的模式"></a>打开文件的模式</h4><p>如果文件不存在，各种模式都会创建文件。</p>
<ul>
<li>ios::out                会截断文件；可以用seekp()移动文件指针。</li>
<li>ios:trunc  	     会截断文件；可以用seekp()移动文件指针。</li>
<li>ios::app   	      不会截断文件；文件指针始终在文件未尾，不能用seekp()移动文件指针。</li>
<li>ios::ate    		打开文件时文件指针指向文件末尾，但是，可以在文件中的任何地方写数据。</li>
<li>ios::in        		打开文件进行读操作，即读取文件中的数据。</li>
<li>ios::binary       	打开文件为二进制文件，否则为文本文件。</li>
<li>注：ate是at end的缩写，trunc是truncate（截断）的缩写，app是append（追加）的缩写。</li>
</ul>
<h2 id="缓冲区及流状态"><a href="#缓冲区及流状态" class="headerlink" title="缓冲区及流状态"></a>缓冲区及流状态</h2><h3 id="文件缓冲区"><a href="#文件缓冲区" class="headerlink" title="文件缓冲区"></a>文件缓冲区</h3><ul>
<li>文件缓冲区（缓存）是系统预留的内存空间，用于存放输入或输出的数据。</li>
<li>根据输出和输入流，分为输出缓冲区和输入缓冲区。</li>
<li>注意，在C++中，<strong>每打开一个文件，系统就会为它分配缓冲区</strong>。不同的流，缓冲区是独立的。</li>
<li>程序员不用关心输入缓冲区，只关心输出缓冲区就行了。</li>
<li>在缺省模式下，输出缓冲区中的数据满了才把数据写入磁盘，但是，这种模式不一定能满足业务的需求。</li>
</ul>
<p><strong>输出缓冲区的操作</strong></p>
<ul>
<li>flush()成员函数：刷新缓冲区，把缓冲区中的内容写入磁盘文件</li>
<li>endl：换行，然后刷新缓冲区</li>
<li>unitbuf：fout &lt;&lt; unitbuf;<ul>
<li>设置fout输出流，在每次操作之后自动刷新缓冲区。</li>
</ul>
</li>
<li>nounitbuf：fout &lt;&lt; nounitbuf;<ul>
<li>设置fout输出流，让fout回到缺省的缓冲方式。</li>
</ul>
</li>
</ul>
<h3 id="流状态"><a href="#流状态" class="headerlink" title="流状态"></a>流状态</h3><ul>
<li>流状态有三个：<strong>eofbit、badbit和failbit</strong>，取值：1-设置；或0-清除。</li>
<li>当三个流状成都为0时，表示一切顺利，good()成员函数返回true。</li>
<li>eofbit<ul>
<li>当输入流操作到达文件未尾时，将设置eofbit。</li>
<li>eof()成员函数检查流是否设置了eofbit。</li>
</ul>
</li>
<li>badbit<ul>
<li>无法诊断的失败破坏流时，将设置badbit。（例如：对输入流进行写入；磁盘没有剩余空间）。</li>
<li>bad()成员函数检查流是否设置了badbit。</li>
</ul>
</li>
<li>failbit<ul>
<li>当输入流操作未能读取预期的字符时，将设置failbit（非致命错误，可挽回，一般是软件错误，例如：想读取一个整数，但内容是一个字符串；文件到了未尾）I&#x2F;O失败也可能设置failbit。</li>
<li>fail()成员函数检查流是否设置了failbit。</li>
</ul>
</li>
<li>clear()成员函数清理流状态。</li>
<li>setstate()成员函数重置流状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>          <span class="comment">// ofstream类需要包含的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;C:/Users/wjl/Desktop/code/test/test.txt&quot;</span>)</span></span>;   <span class="comment">// 打开文件。</span></span><br><span class="line">  fout &lt;&lt; unitbuf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">1000</span>; ii++)  <span class="comment">// 循环1000次。</span></span><br><span class="line">  &#123;</span><br><span class="line">    fout &lt;&lt; <span class="string">&quot;ii=&quot;</span> &lt;&lt; ii &lt;&lt; <span class="string">&quot;，我是一只傻傻傻傻傻傻傻傻傻傻傻傻傻傻的鸟。\n&quot;</span>;</span><br><span class="line">    <span class="comment">//fout.flush();      // 刷新缓冲区。</span></span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">100000</span>);    <span class="comment">// 睡眠十分之一秒。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fout.<span class="built_in">close</span>();  <span class="comment">// 关闭文件。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="C-异常"><a href="#C-异常" class="headerlink" title="C++异常"></a>C++异常</h1><h2 id="异常的语法"><a href="#异常的语法" class="headerlink" title="异常的语法"></a>异常的语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）捕获全部的异常</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的代码。</span></span><br><span class="line">        <span class="comment">// throw 异常对象;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不管什么异常，都在这里统一处理。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2</span>）捕获指定的异常</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的代码。</span></span><br><span class="line">        <span class="comment">// throw 异常对象;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception1 e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发生exception1异常时的处理代码。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception2 e)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 发生exception2异常时的处理代码。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在try语句块中，如果没有发生异常，执行完try语句块中的代码后，将继续执行try语句块之后的代码；如果发生了异常，用throw抛出异常对象，异常对象的类型决定了应该匹配到哪个catch语句块，如果没有匹配到catch语句块，程序将调用abort()函数中止。</li>
<li>如果try语句块中用throw抛出异常对象，并且匹配到了catch语句块，执行完catch语句块中的代码后，将继续执行catch语句块之后的代码，不会回到try语句块中。</li>
<li>如果程序中的异常没有被捕获，程序将异常中止。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可能抛出异常的代码。</span></span><br><span class="line">        <span class="type">int</span> ii = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你是一只什么鸟？（1-傻傻鸟；2-小小鸟）&quot;</span>;</span><br><span class="line">        cin &gt;&gt; ii;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ii==<span class="number">1</span>)  <span class="keyword">throw</span> <span class="string">&quot;不好，有人说我是一只傻傻鸟。&quot;</span>;            <span class="comment">// throw抛出const char *类型的异常。</span></span><br><span class="line">        <span class="keyword">if</span> (ii==<span class="number">2</span>)  <span class="keyword">throw</span> ii;                                                             <span class="comment">// throw抛出int类型的异常。</span></span><br><span class="line">        <span class="keyword">if</span> (ii==<span class="number">3</span>)  <span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;不好，有人说我是一只傻傻鸟。&quot;</span>); <span class="comment">// throw抛出string类型的异常。</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我不是一只傻傻鸟，哦耶。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> ii)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;异常的类型是int=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* ss)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;异常的类型是const char *=&quot;</span> &lt;&lt; ss &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (string str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;异常的类型是string=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//catch (...)  // 不管什么异常，都在这里处理。</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; &quot;捕获到异常，具体没管是什么异常。\n&quot;;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序继续运行......\n&quot;</span>;   <span class="comment">// 执行完try ... catch ...后，将继续执行程序中其它的代码。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h3><ul>
<li>异常被抛出后，从进入try语句块开始，到异常被抛出之前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。</li>
<li>也就是在执行throw前，在try执行期间构造的所有对象被自动析构后，才会进入catch匹配。</li>
<li>在堆上构造的对象肿么办？</li>
</ul>
<h2 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++<span class="number">98</span>标准提出了异常规范，目的是为了让使用者知道函数可能会引发哪些异常</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A, B, C)</span></span>;     <span class="comment">// 表示该函数可能会抛出A、B、C类型的异常。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;           <span class="comment">// 表示该函数不会抛出异常。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>;                  <span class="comment">// 该函数不符合C++98的异常规范。</span></span><br><span class="line"><span class="comment">//C++11标准弃用了异常规范，使用新增的关键字noexcept指出函数不会引发异常。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;         <span class="comment">// 该函数不会抛出异常。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在实际开发中，大部分程序员懒得在函数后面加noexcept，弃用异常已是共识，没必要多此一举。</li>
<li>关键字noexcept也可以用作运算符，判断表达试（操作数）是否可能引发异常；如果表达式可能引发异常，则返回false，否则返回true。</li>
</ul>
<h2 id="C-标准库异常"><a href="#C-标准库异常" class="headerlink" title="C++标准库异常"></a>C++标准库异常</h2><p>![[Pasted image 20231225193731.png]]</p>
<h3 id="重点关注的异常"><a href="#重点关注的异常" class="headerlink" title="重点关注的异常"></a>重点关注的异常</h3><p>1）std::bad_alloc</p>
<ul>
<li>如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。<br>2）std::bad_cast</li>
<li>dynamic_cast可以用于引用，但是，C++没有与空指针对应的引用值，如果转换请求不正确，会出现std::bad_cast异常。<br>3）std::bad_typeid</li>
<li>假设有表达式<code>typeid(*ptr)</code>，当ptr是空指针时，如果ptr是多态的类型，将引发std::bad_typeid异常。</li>
</ul>
<h1 id="C-断言"><a href="#C-断言" class="headerlink" title="C++断言"></a>C++断言</h1><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><ul>
<li>断言（assertion）是一种常用的编程手段，用于排除程序中不应该出现的逻辑错误。</li>
<li>使用断言需要包含头文件<code>&lt;cassert&gt;</code>或<code>&lt;assert.h&gt;</code>，头文件中提供了带参数的宏assert，用于程序在运行时进行断言。</li>
<li>语法：<strong>assert(表达式);</strong></li>
<li><strong>断言就是判断(表达式)的值，如果为0（false），程序将调用abort()函数中止，如果为非0（true），程序继续执行</strong>。</li>
<li>断言可以提高程序的可读性，帮助程序员定位违反了某些前提条件的错误。<br><strong>注意</strong></li>
<li>断言用于处理程序中不应该发生的错误，而非逻辑上可能会发生的错误。</li>
<li>不要把需要执行的代码放到断言的表达式中。</li>
<li>断言的代码一般放在函数&#x2F;成员函数的第一行，表达式多为函数的形参。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span>              <span class="comment">// 断言assert宏需要包含的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">copydata</span><span class="params">(<span class="type">void</span> *ptr1,<span class="type">void</span> *ptr2)</span>   <span class="comment">// 把ptr2中的数据复制到ptr1中。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(ptr1&amp;&amp;ptr2);  <span class="comment">// 断言ptr1和ptr2都不会为空。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;继续执行复制数据的代码......\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ii=<span class="number">0</span>,jj=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">copydata</span>(&amp;ii, &amp;jj);  <span class="comment">// 把ptr2中的数据复制到ptr1中。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-11静态断言"><a href="#C-11静态断言" class="headerlink" title="C++11静态断言"></a>C++11静态断言</h2><ul>
<li>assert宏是运行时断言，在程序运行的时候才能起作用。</li>
<li>C++11新增了静态断言static_assert，用于在编译时检查源代码。</li>
<li>使用静态断言不需要包含头文件。</li>
<li>语法：<strong>static_assert(常量表达式,提示信息);</strong></li>
<li>注意：static_assert的第一个参数是常量表达式。而assert的表达式既可以是常量，也可以是变量</li>
</ul>
<h1 id="C-新标准"><a href="#C-新标准" class="headerlink" title="C++新标准"></a>C++新标准</h1><p><strong>long long类型</strong></p>
<ul>
<li>新增了类型long long和unsigned long long，以支持64位（或更宽）的整型。</li>
<li>在VS中，int和long都是4字节，long long是8字节。</li>
<li>在Linux中，int是4字节，long和long long是8字节。</li>
</ul>
<h2 id="统一的初始化（列表）"><a href="#统一的初始化（列表）" class="headerlink" title="统一的初始化（列表）"></a>统一的初始化（列表）</h2><p>C++11丰富了大括号的使用范围，用大括号括起来的列表（统一的初始化列表）可以用于所有内置类型和用户自定义类型。使用统一的初始化列表时，可以添加等号（&#x3D;），也可以不添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=&#123;<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span> y&#123;<span class="number">2.75</span>&#125;;</span><br><span class="line"><span class="type">short</span> quar[<span class="number">5</span>]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">76</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一的初始化列表也可以用于new表达式中：</span></span><br><span class="line"><span class="type">int</span> *ar=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象时，也可以使用大括号（而不是圆括号）来调用构造函数：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_bh;</span><br><span class="line">    string m_name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>(<span class="type">int</span> bh,string name) : <span class="built_in">m_bh</span>(bh),<span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Girl <span class="title">g1</span><span class="params">(<span class="number">3</span>, <span class="string">&quot;西施&quot;</span>)</span></span>;    <span class="comment">// C++98的风格。</span></span><br><span class="line">Girl g2=&#123;<span class="number">5</span>, <span class="string">&quot;冰冰&quot;</span>&#125;;  <span class="comment">// C++11的风格。</span></span><br><span class="line">Girl g3&#123;<span class="number">8</span>, <span class="string">&quot;幂幂&quot;</span>&#125;;    <span class="comment">// C++11的风格。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//STL容器提供了将initializer_list模板类作为参数的构造函数：</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// 把v1初始化为10个元素。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;   <span class="comment">// 把v2初始化为1个元素，这个元素的值是10。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;   <span class="comment">// 把v3初始化为3个元素，值分别是3、5、8。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="强类型枚举（枚举类）"><a href="#强类型枚举（枚举类）" class="headerlink" title="强类型枚举（枚举类）"></a>强类型枚举（枚举类）</h2><ul>
<li>传统的C++枚举提供了一种创建常量的方式，但类型检查比较低级。还有，如果在同一作用域内定义的两个枚举，它们的成员不能同名。</li>
<li>针对枚举的缺陷，C++11 标准引入了枚举类，又称强类型枚举。</li>
<li>声明强类型枚举非常简单，只需要在enum后加上关键字 class。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">e1</span>&#123; red, green &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e2</span> &#123; red, green, blue &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e3</span> &#123; red, green, blue, yellow &#125;;</span><br><span class="line"><span class="comment">//使用强类型枚举时，要在枚举成员名前面加枚举名和::，以免发生名称冲突，如：e2::red，e3::blue</span></span><br><span class="line"><span class="comment">//强类型枚举默认的类型为int，也可以显式地指定类型，具体做法是在枚举名后面加上:type，type可以是除wchar_t以外的任何整型。</span></span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e2</span>:<span class="type">char</span> &#123; red, green, blue &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul>
<li>final关键字用于<strong>限制某个类不能被继承，或者某个虚函数不能被重写</strong>。</li>
<li>final关键字放在类名或虚函数名的后面。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AA class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">public</span> AA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span>    <span class="comment">// 如果有其它类继承BB，test()方法将不允许重写。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BB class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CC</span> : <span class="keyword">public</span> BB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span>  <span class="comment">// 错误，BB类中的test()后面有final，不允许重写。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CC class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="override关键字"><a href="#override关键字" class="headerlink" title="override关键字"></a>override关键字</h2><ul>
<li>在<strong>派生类中，把override放在成员函数的后面，表示重写基类的虚函数</strong>，提高代码的可读性。</li>
<li>在派生类中，如果某成员函数不是重写基类的虚函数，随意的加上override关键字，编译器会报错。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AA class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> : <span class="keyword">public</span> AA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BB class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="常量表达式constexpr关键字"><a href="#常量表达式constexpr关键字" class="headerlink" title="常量表达式constexpr关键字"></a>常量表达式constexpr关键字</h2><p>const关键字从功能上来说有双重语义：<strong>只读变量和修饰常量</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> len1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// len1是只读变量，不是常量。</span></span><br><span class="line">    <span class="type">int</span> array1[len1]=&#123;<span class="number">0</span>&#125;;        <span class="comment">// VS会报错，Linux平台的数组长度支持变量，不会报错。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len2 = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> array2[len2]=&#123;<span class="number">0</span>&#125;;      <span class="comment">// 正确，len2是常量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>C++11标准为了解决const关键字的双重语义问题，保留了const表示“只读”的语义，而将<strong>“常量”的语义划分给了新添加的constexpr关键字</strong>。</li>
<li>所以，C++11 标准中，建议将const和constexpr的功能区分开，<strong>表达“只读”语义的场景用const，表达“常量”语义的场景用constexpr。</strong></li>
</ul>
<h2 id="默认函数控制-default与-delete"><a href="#默认函数控制-default与-delete" class="headerlink" title="默认函数控制&#x3D;default与&#x3D;delete"></a>默认函数控制&#x3D;default与&#x3D;delete</h2><ul>
<li>在C++中自定义的类，编译器会默认生成一些成员函数：</li>
<li>无参构造函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值函数</li>
<li>移动构造函数</li>
<li>移动赋值函数</li>
<li>析构函数</li>
<li>&#x3D;default表示启用默认函数。</li>
<li>&#x3D;delete表示禁用默认函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_bh = <span class="number">20</span>;                  <span class="comment">// 年龄。</span></span><br><span class="line">    string m_name = <span class="string">&quot;美女&quot;</span>;  <span class="comment">// 姓名。</span></span><br><span class="line">    <span class="type">char</span> m_xb = <span class="string">&#x27;X&#x27;</span>;               <span class="comment">// 性别。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Girl</span>() = <span class="keyword">default</span>;                          <span class="comment">// 启用默认构造函数。</span></span><br><span class="line">    <span class="built_in">Girl</span>(<span class="type">int</span> bh, string name) : <span class="built_in">m_bh</span>(bh), <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line">    <span class="built_in">Girl</span>(<span class="type">const</span> Girl&amp; g) = <span class="keyword">delete</span>;      <span class="comment">// 删除拷贝构造函数。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;bh=&quot;</span> &lt;&lt; m_bh &lt;&lt; <span class="string">&quot;,m_name=&quot;</span> &lt;&lt; m_name &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Girl g1;</span><br><span class="line">    g1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// Girl g2 = g1;            // 错误，拷贝构造函数已删除。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="委托构造和继承构造"><a href="#委托构造和继承构造" class="headerlink" title="委托构造和继承构造"></a>委托构造和继承构造</h2><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><ul>
<li>在实际的开发中，为了满足不同的需求，一个类可能会重载多个构造函数。多个构造函数之间可能会有重复的代码。例如变量初始化，如果在每个构造函数中都写一遍，这样代码会显得臃肿。</li>
<li><strong>委托构造就是在一个构造函数的初始化列表中调用另一个构造函数</strong>。</li>
<li>不要生成环状的构造过程。</li>
<li>一旦使用委托构造，就不能在初始化列表中初始化其它的成员变量。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>      m_a;</span><br><span class="line">    <span class="type">int</span>      m_b;</span><br><span class="line">    <span class="type">double</span>   m_c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有一个参数的构造函数，初始化m_c</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">double</span> c) &#123;</span><br><span class="line">        m_c = c + <span class="number">3</span>;     <span class="comment">// 初始化m_c</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; AA(double c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有两个参数的构造函数，初始化m_a和m_b</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        m_a = a + <span class="number">1</span>;     <span class="comment">// 初始化m_a</span></span><br><span class="line">        m_b = b + <span class="number">2</span>;    <span class="comment">// 初始化m_b</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; AA(int a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数委托AA(int a, int b)初始化m_a和m_b</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">const</span> string&amp; str) : <span class="built_in">AA</span>(a, b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_a=&quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot;,m_b=&quot;</span> &lt;&lt; m_b &lt;&lt; <span class="string">&quot;,str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数委托AA(double c)初始化m_c</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">double</span> c, <span class="type">const</span> string&amp; str) : <span class="built_in">AA</span>(c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_c=&quot;</span> &lt;&lt; m_c &lt;&lt; <span class="string">&quot;,str=&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AA <span class="title">a1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;我是一只傻傻鸟。&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">AA <span class="title">a2</span><span class="params">(<span class="number">3.8</span>, <span class="string">&quot;我有一只小小鸟。&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><ul>
<li>在C++11之前，派生类如果要使用基类的构造函数，可以在派生类构造函数的初始化列表中指定</li>
<li>C++11推出了继承构造（Inheriting Constructor），<strong>在派生类中使用using来声明继承基类的构造函数</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>       <span class="comment">// 基类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>      m_a;</span><br><span class="line">    <span class="type">int</span>      m_b;</span><br><span class="line">    <span class="comment">// 有一个参数的构造函数，初始化m_a</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a) : <span class="built_in">m_a</span>(a) &#123; cout &lt;&lt; <span class="string">&quot; AA(int a)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 有两个参数的构造函数，初始化m_a和m_b</span></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b) &#123; cout &lt;&lt; <span class="string">&quot; AA(int a, int b)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> :<span class="keyword">public</span> AA       <span class="comment">// 派生类。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span>   m_c;</span><br><span class="line">    <span class="keyword">using</span> AA::AA;     <span class="comment">// 使用基类的构造函数。</span></span><br><span class="line">    <span class="comment">// 有三个参数的构造函数，调用A(a,b)初始化m_a和m_b，同时初始化m_c</span></span><br><span class="line">    <span class="built_in">BB</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> c) : <span class="built_in">AA</span>(a, b), <span class="built_in">m_c</span>(c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; BB(int a, int b, double c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;m_a=&quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot;,m_b=&quot;</span> &lt;&lt; m_b &lt;&lt; <span class="string">&quot;,m_c=&quot;</span> &lt;&lt; m_c &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将使用基类有一个参数的构造函数，初始化m_a</span></span><br><span class="line">    <span class="function">BB <span class="title">b1</span><span class="params">(<span class="number">10</span>)</span></span>;       </span><br><span class="line">    b1.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用基类有两个参数的构造函数，初始化m_a和m_b</span></span><br><span class="line">    <span class="function">BB <span class="title">b2</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;  </span><br><span class="line">    b2.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用派生类自己有三个参数的构造函数，调用A(a,b)初始化m_a和m_b，同时初始化m_c</span></span><br><span class="line">    <span class="function">BB <span class="title">b3</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">10.58</span>)</span></span>;  </span><br><span class="line">    b3.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><ul>
<li>lambda函数是C++11标准新增的语法糖，<strong>也称为lambda表达式或匿名函数</strong>。</li>
<li>lambda函数的特点是：距离近、简洁、高效和功能强大</li>
<li><strong>捕获列表用于获取外部变量的值或引用</strong>，<strong>参数列表用于传递参数</strong>，返回类型指定函数返回值的类型，函数体定义Lambda函数的具体逻辑。</li>
<li>示例：<code>[](const int&amp; no) -&gt; void &#123; cout &lt;&lt; &quot;亲爱的&quot; &lt;&lt; no &lt;&lt; &quot;号：我是一只傻傻鸟。\n&quot;; &#125;;</code></li>
<li>语法：![[Pasted image 20231225201706.png]]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表白函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zsshow</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; no)</span>  </span>&#123;  </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表白仿函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">czs</span>   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; no)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vv = &#123; <span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span> &#125;;   <span class="comment">// 存放超女编号的容器。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 第三个参数是普通函数。</span></span><br><span class="line">	for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), zsshow);  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三个参数是仿函数。</span></span><br><span class="line">	for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), <span class="built_in">czs</span>());       </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三个参数是lambda表达式。</span></span><br><span class="line">	for_each(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>(), </span><br><span class="line">		[](<span class="type">const</span> <span class="type">int</span>&amp; no) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; no &lt;&lt; <span class="string">&quot;号：我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>参数列表</strong></li>
<li>参数列表是可选的，类似普通函数的参数列表，如果没有参数列表，()可以省略不写。</li>
<li>与普通函数的不同：<ul>
<li>lambda函数不能有默认参数。</li>
<li>所有参数必须有参数名。</li>
<li>不支持可变参数。</li>
</ul>
</li>
</ul>
<p><strong>返回类型</strong></p>
<ul>
<li>用后置的方法书写返回类型，类似于普通函数的返回类型，如果不写返回类型，编译器会根据函数体中的代码推断出来</li>
<li>如果有返回类型，建议显式的指定，自动推断可能与预期不一致</li>
</ul>
<p><strong>函数体</strong>：类似于普通函数的函数体。<br><strong>捕获列表</strong></p>
<ul>
<li>通过捕获列表，<strong>lambda函数可以访问父作用域中的非静态局部变量</strong>（静态局部变量可以直接访问，不能访问全局变量）。</li>
<li>捕获列表书写在<code>[]</code>中，与函数参数的传递类似，捕获方式可以是值和引用。</li>
<li>以下列出了不同的捕获列表的方式。<br>![[Pasted image 20231225202050.png]]<br><strong>值捕获</strong></li>
<li>与传递参数类似，采用值捕获的前提是变量可以拷贝。</li>
<li>与传递参数不同，变量的值是在lambda函数创建时拷贝，而不是调用时拷贝</li>
<li>由于被捕获的值是在lambda函数创建时拷贝，因此在随后对其修改不会影响到lambda内部的值</li>
<li>默认情况下，如果以传值方式捕获变量，则在lambda函数中不能修改变量的值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [ v1 ]  &#123; <span class="keyword">return</span> v1; &#125;;	<span class="comment">// 使用了值捕获，将v1拷贝到名为f的可调用对象。</span></span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();    <span class="comment">// j为42，f保存了我们创建它是v1的拷贝。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>引用捕获</strong></li>
<li>和函数引用参数一样，引用变量的值在lambda函数体中改变时，将影响被引用的对象</li>
<li>如果采用引用方式捕获变量，就必须保证被引用的对象在lambda执行的时候是存在的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [ &amp;v1 ]  &#123; <span class="keyword">return</span> v1; &#125;;	 <span class="comment">// 引用捕获，将v1拷贝到名为f的可调用对象。</span></span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();	   <span class="comment">// j为0。</span></span><br></pre></td></tr></table></figure>
<strong>隐式捕获</strong></li>
<li>除了显式列出我们希望使用的父作域的变量之外，还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。</li>
<li>隐式捕获有两种方式，分别是<code>[=]和[&amp;]</code>。<code>[=]</code>表示以值捕获的方式捕获外部变量，<code>[&amp;]</code>表示以引用捕获的方式捕获外部变量。</li>
</ul>
<p><strong>混合方式捕获</strong></p>
<ul>
<li>lambda函数还支持混合方式捕获，即同时使用显式捕获和隐式捕获</li>
<li>混合捕获时，捕获列表中的第一个元素必须是 &#x3D; 或 &amp;，此符号指定了默认捕获的方式是值捕获或引用捕获</li>
<li>需要注意的是：显式捕获的变量必须使用和默认捕获不同的方式捕获<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>  j = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [ =, &amp;i] () &#123; <span class="keyword">return</span> j + i; &#125;;		<span class="comment">// 正确，默认值捕获，显式是引用捕获</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [ =, i] () &#123; <span class="keyword">return</span> i + j; &#125;;		<span class="comment">// 编译出错，默认值捕获，显式值捕获，冲突了</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [ &amp;, &amp;i] () &#123; <span class="keyword">return</span> i +j; &#125;;		<span class="comment">// 编译出错，默认引用捕获，显式引用捕获，冲突了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>修改值捕获变量的值</strong></li>
<li>在lambda函数中，如果以传值方式捕获变量，则函数体中不能修改该变量，否则会引发编译错误</li>
<li>在lambda函数中，如果希望修改值捕获变量的值，可以加mutable选项，但是，在lambda函数的外部，变量的值不会被修改<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; cout &lt;&lt; ++a &lt;&lt; endl; &#125;; <span class="comment">// 不会报错</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; 	<span class="comment">// 输出：123</span></span><br><span class="line"><span class="built_in">f</span>(); 					<span class="comment">// 输出：124</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; 	<span class="comment">// 输出：123</span></span><br></pre></td></tr></table></figure>
<strong>异常说明</strong></li>
<li>lambda可以抛出异常，用throw(…)指示异常的类型，用noexcept指示不抛出任何异常</li>
</ul>
<h3 id="lambda函数的本质"><a href="#lambda函数的本质" class="headerlink" title="lambda函数的本质"></a>lambda函数的本质</h3><ul>
<li>当我们编写了一个lambda函数之后，编译器将它翻译成一个类，该类中有一个重载了()的函数。<br><strong>采用值捕获</strong></li>
<li>采用值捕获时，lambda函数生成的类用捕获变量的值初始化自己的成员变量</li>
<li>默认情况下，由lambda函数生成的类是const成员函数，所以变量的值不能修改。如果加上mutable，相当于去掉const。这样上面的限制就能讲通了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> addfun = [=] (<span class="type">const</span> <span class="type">int</span> c ) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a+c; &#125;;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">addfun</span>(b);    </span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">等同于：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_a;		<span class="comment">// 该成员变量对应通过值捕获的变量。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>( <span class="type">int</span> a ) : <span class="built_in">m_a</span>(a)&#123;&#125;;	<span class="comment">// 该形参对应捕获的变量。</span></span><br><span class="line">	<span class="comment">// 重载了()运算符的函数，返回类型、形参和函数体都与lambda函数一致。</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> c)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>采用引用捕获</strong></p>
<ul>
<li>如果lambda函数采用引用捕获的方式，编译器直接引用就行了。</li>
<li>唯一需要注意的是，lambda函数执行时，程序必须保证引用的对象有效<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Lambda函数作为参数传递给标准库的算法函数</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda函数的变量捕获和调用</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> sum = [x, y]() &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">sum</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> product = [&amp;x, &amp;y]() &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product: &quot;</span> &lt;&lt; <span class="built_in">product</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; <span class="built_in">sum</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Product: &quot;</span> &lt;&lt; <span class="built_in">product</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h3><ul>
<li>在C++中，所有的值不是左值，就是右值。<strong>左值是指表达式结束后依然存在的持久化对象</strong>，<strong>右值是指表达式结束后就不再存在的临时对象</strong>。有名字的对象都是左值，右值没有名字。</li>
<li>还有一个可以区分左值和右值的便捷方法：看能不能对<strong>表达式取地址，如果能，则为左值</strong>，否则为右值。</li>
<li>C++11扩展了右值的概念，将右值分为了纯右值和将亡值。</li>
<li>纯右值<ul>
<li>非引用返回的临时变量；</li>
<li>运算表达式产生的结果；</li>
<li>字面常量（C风格字符串除外，它是地址）。</li>
</ul>
</li>
<li>将亡值<ul>
<li>与右值引用相关的表达式，例如：将要被移动的对象、T&amp;&amp;函数返回的值、std::move()的返回值、转换成T&amp;&amp;的类型的转换函数的返回值。</li>
</ul>
</li>
<li>不懂纯右值和将亡值的区别其实没关系，统一看作右值即可，不影响使用。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">AA <span class="title">getTemp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ii = <span class="number">3</span>;       <span class="comment">// ii是左值，3是右值。</span></span><br><span class="line"><span class="type">int</span> jj = ii+<span class="number">8</span>;    <span class="comment">// jj是左值，ii+8是右值。</span></span><br><span class="line">AA aa = <span class="built_in">getTemp</span>();   <span class="comment">// aa是左值 ，getTemp()的返回值是右值（临时变量）。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h3><ul>
<li>C++98中的引用很常见，就是给变量取个别名，在C++11中，因为增加了右值引用(rvalue reference)的概念，所以C++98中的引用都称为了左值引用(lvalue reference)。</li>
<li>右值引用就是给右值取个名字。</li>
<li>语法：<code>数据类型&amp;&amp; 变量名=右值;</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a=<span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">AA <span class="title">getTemp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; a = <span class="number">3</span>;         <span class="comment">// 3是右值。</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">8</span>;               <span class="comment">// b是左值。</span></span><br><span class="line">    <span class="type">int</span>&amp;&amp; c = b + <span class="number">5</span>;   <span class="comment">//  b+5是右值。</span></span><br><span class="line">    AA&amp;&amp; aa = <span class="built_in">getTemp</span>();   <span class="comment">// getTemp()的返回值是右值（临时变量）。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;aa.m_a=&quot;</span> &lt;&lt; aa.m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>getTemp()的返回值本来在表达式语句结束后其生命也就该终结了（因为是临时变量），而通过右值引用重获了新生，其生命周期将与右值引用类型变量aa的生命周期一样，只要aa还活着，该右值临时变量将会一直存活下去。</li>
<li><strong>引入右值引用的主要目的是实现移动语义</strong>。</li>
<li>左值引用只能绑定（关联、指向）左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。</li>
<li>但是，常量左值引用却是个奇葩，它可以算是一个万能的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;        </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ra = a;   <span class="comment">// a是非常量左值。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">1</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rb = b;  <span class="comment">// b是常量左值。</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rc = <span class="number">1</span>;   <span class="comment">// 1是右值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结一下，其中T是一个具体类型：<br>1）左值引用， 使用 <strong>T&amp;,</strong> <strong>只能绑定左值</strong>。<br>2）右值引用， 使用 <strong>T&amp;&amp;， 只能绑定右值</strong>。<br>3）<strong>已命名的右值引用是左值</strong>。<br>4）常量左值，使用 const T&amp;, 既可以绑定左值又可以绑定右值。</p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><ul>
<li>如果一个对象中有堆区资源，需要编写拷贝构造函数和赋值函数，实现深拷贝。</li>
<li>深拷贝把对象中的堆区资源复制了一份，如果源对象（被拷贝的对象）是临时对象，拷贝完就没什么用了，这样会造成没有意义的资源申请和释放操作。<strong>如果能够直接使用源对象拥有的资源</strong>，可以节省资源申请和释放的时间。C++11新增加的<strong>移动语义就能够做到这一点</strong></li>
<li>实现移动语义要增加两个函数：<strong>移动构造函数和移动赋值函数</strong>。</li>
<li>移动构造函数的语法：<strong>类名(类名&amp;&amp; 源对象){……}</strong></li>
<li>移动赋值函数的语法：<strong>类名&amp; operator&#x3D;(类名&amp;&amp; 源对象){……}</strong><br>注意：<br>1）对于一个左值，会调用拷贝构造函数，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11为了解决这个问题，提供了std::move()方法来将左值转义为右值，从而方便使用移动语义。它其实就是告诉编译器，虽然我是一个左值，但不要对我用拷贝构造函数，用移动构造函数吧。左值对象被转移资源后，不会立刻析构，只有在离开自己的作用域的时候才会析构，如果继续使用左值中的资源，可能会发生意想不到的错误。<br>2）如果没有提供移动构造&#x2F;赋值函数，只提供了拷贝构造&#x2F;赋值函数，编译器找不到移动构造&#x2F;赋值函数就去寻找拷贝构造&#x2F;赋值函数。<br>3）C++11中的所有容器都实现了移动语义，避免对含有资源的对象发生无谓的拷贝。<br>4）移动语义对于拥有资源（如内存、文件句柄）的对象有效，如果是基本类型，使用移动语义没有意义。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* m_data = <span class="literal">nullptr</span>;  <span class="comment">// 数据成员，指向堆区资源的指针。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AA</span>() = <span class="keyword">default</span>;             <span class="comment">// 启用默认构造函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;                <span class="comment">// 给数据成员m_data分配内存。</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">int</span>;                       <span class="comment">// 分配内存。</span></span><br><span class="line">        <span class="built_in">memset</span>(m_data, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 初始化已分配的内存。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AA</span>(<span class="type">const</span> AA&amp; a) &#123;     <span class="comment">// 拷贝构造函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了拷贝构造函数。\n&quot;</span>;            <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data == <span class="literal">nullptr</span>) <span class="built_in">alloc</span>();                     <span class="comment">// 如果没有分配内存，就分配。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_data, a.m_data, <span class="built_in">sizeof</span>(<span class="type">int</span>));     <span class="comment">// 把数据从源对象中拷贝过来。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AA</span>(AA&amp;&amp; a) &#123;     <span class="comment">// 移动构造函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了移动构造函数。\n&quot;</span>;            <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) <span class="keyword">delete</span> m_data;         <span class="comment">// 如果已分配内存，先释放掉。</span></span><br><span class="line">        m_data = a.m_data;                                   <span class="comment">// 把资源从源对象中转移过来。</span></span><br><span class="line">        a.m_data = <span class="literal">nullptr</span>;                                    <span class="comment">// 把源对象中的指针置空。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AA&amp; <span class="keyword">operator</span>=(<span class="type">const</span> AA&amp; a) &#123; <span class="comment">// 赋值函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了赋值函数。\n&quot;</span>;                   <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a)   <span class="keyword">return</span> *<span class="keyword">this</span>;                      <span class="comment">// 避免自我赋值。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data == <span class="literal">nullptr</span>) <span class="built_in">alloc</span>();                     <span class="comment">// 如果没有分配内存，就分配。</span></span><br><span class="line">        <span class="built_in">memcpy</span>(m_data, a.m_data, <span class="built_in">sizeof</span>(<span class="type">int</span>));    <span class="comment">// 把数据从源对象中拷贝过来。</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AA&amp; <span class="keyword">operator</span>=(AA&amp;&amp; a) &#123; <span class="comment">// 移动赋值函数。</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了移动赋值函数。\n&quot;</span>;            <span class="comment">// 显示自己被调用的日志。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a)   <span class="keyword">return</span> *<span class="keyword">this</span>;                      <span class="comment">// 避免自我赋值。</span></span><br><span class="line">        <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) <span class="keyword">delete</span> m_data;         <span class="comment">// 如果已分配内存，先释放掉。</span></span><br><span class="line">        m_data = a.m_data;                                   <span class="comment">// 把资源从源对象中转移过来。</span></span><br><span class="line">        a.m_data = <span class="literal">nullptr</span>;                                    <span class="comment">// 把源对象中的指针置空。</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     ~<span class="built_in">AA</span>() &#123;                 <span class="comment">// 析构函数。</span></span><br><span class="line">         <span class="keyword">if</span> (m_data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">             <span class="keyword">delete</span> m_data; m_data = <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA a1;                  <span class="comment">// 创建对象a1。</span></span><br><span class="line">    a1.<span class="built_in">alloc</span>();             <span class="comment">// 分配堆区资源。</span></span><br><span class="line">    *a1.m_data = <span class="number">3</span>;   <span class="comment">// 给堆区内存赋值。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1.m_data=&quot;</span> &lt;&lt; *a1.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    AA a2 = a1;         <span class="comment">// 将调用拷贝构造函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2.m_data=&quot;</span> &lt;&lt; *a2.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    AA a3;</span><br><span class="line">    a3 = a1;              <span class="comment">// 将调用赋值函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a3.m_data=&quot;</span> &lt;&lt; *a3.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [] &#123; AA aa; aa.<span class="built_in">alloc</span>(); *aa.m_data = <span class="number">8</span>; <span class="keyword">return</span> aa; &#125;;   <span class="comment">// 返回AA类对象的lambda函数。</span></span><br><span class="line">    AA a4 = <span class="built_in">f</span>();                <span class="comment">// lambda函数返回临时对象，是右值，将调用移动构造函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a4.m_data=&quot;</span> &lt;&lt; *a4.m_data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    AA a6;</span><br><span class="line">    a6 = <span class="built_in">f</span>();              <span class="comment">// lambda函数返回临时对象，是右值，将调用移动赋值函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a6.m_data=&quot;</span> &lt;&lt; *a6.m_data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><ul>
<li>在函数模板中，可以将参数“完美”的转发给其它函数。所谓完美，即不仅能准确的转发参数的值，还能保证被转发参数的左、右值属性不变</li>
<li>C++11标准引入了右值引用和移动语义，所以，能否实现完美转发，决定了该参数在传递过程使用的是拷贝语义还是移动语义</li>
<li>为了支持完美转发，C++11提供了以下方案：<ul>
<li>如果模板中（包括类模板和函数模板）函数的参数书写成为T&amp;&amp; 参数名，那么，函数既可以接受左值引用，又可以接受右值引用</li>
<li>提供了模板函数<code>std::forward&lt;T&gt;(参数)</code> ，用于转发参数，如果 参数是一个右值，转发之后仍是右值引用；如果参数是一个左值，转发之后仍是左值引用</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp; ii)</span> </span>&#123;        <span class="comment">// 如果参数是左值，调用此函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数是左值=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp;&amp; ii)</span> </span>&#123;     <span class="comment">// 如果参数是右值，调用此函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;参数是右值=&quot;</span> &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）如果模板中（包括类模板和函数模板）函数的参数书写成为T&amp;&amp; 参数名，</span></span><br><span class="line"><span class="comment">// 那么，函数既可以接受左值引用，又可以接受右值引用。</span></span><br><span class="line"><span class="comment">// 2）提供了模板函数std::forward&lt;T&gt;(参数) ，用于转发参数，</span></span><br><span class="line"><span class="comment">// 如果参数是一个右值，转发之后仍是右值引用；如果 参数是一个左值，转发之后仍是左值引用。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(TT&amp;&amp; ii)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>(forward&lt;TT&gt;(ii));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ii = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">func</span>(ii);       <span class="comment">// 实参是左值。</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">8</span>);       <span class="comment">// 实参是右值。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><ul>
<li>可变参数模版是C++11新增的最强大的特性之一，它对参数进行了泛化，能支持任意个数、任意数据类型的参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T girl)</span>      <span class="comment">// 向超女表白的函数，参数可能是超女编号，也可能是姓名，所以用T。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;亲爱的&quot;</span> &lt;&lt; girl &lt;&lt; <span class="string">&quot;，我是一只傻傻鸟。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终止时调用的非模板函数，函数名要与展开参数包的递归函数模板相同。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;递归终止。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开参数包的递归函数模板。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T arg, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;参数： &quot; &lt;&lt; arg &lt;&lt; endl;         // 显示本次展开的参数。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">show</span>(arg);        <span class="comment">// 把参数用于表白。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;还有&quot; &lt;&lt; sizeof...(args) &lt;&lt; &quot;个参数未展开。&quot; &lt;&lt; endl;  // 显示未展开变参的个数。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(args...);     <span class="comment">// 继续展开参数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> string&amp; str, Args...args)</span>   <span class="comment">// 除了可变参数，还可以有其它常规参数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; str &lt;&lt; endl;    <span class="comment">// 表白之前，喊句口号。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(args...);    <span class="comment">// 展开可变参数包。</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;表白完成。\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//print(&quot;金莲&quot;, 4, &quot;西施&quot;);   </span></span><br><span class="line">	<span class="comment">//print(&quot;冰冰&quot;, 8, &quot;西施&quot;, 3);</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="string">&quot;我是绝世帅歌。&quot;</span>, <span class="string">&quot;冰冰&quot;</span>, <span class="number">8</span>, <span class="string">&quot;西施&quot;</span>, <span class="number">3</span>);  <span class="comment">// &quot;我是绝世帅歌。&quot;不是可变参数，其它的都是。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="时间操作chrono库"><a href="#时间操作chrono库" class="headerlink" title="时间操作chrono库"></a>时间操作chrono库</h1><ul>
<li>C++11提供了chrono模版库，实现了一系列时间相关的操作（时间长度、系统时间和计时器）。</li>
<li>头文件：<code>#include &lt;chrono&gt;</code></li>
<li>命名空间：<code>std::chrono</code></li>
</ul>
<h2 id="时间长度"><a href="#时间长度" class="headerlink" title="时间长度"></a>时间长度</h2><ul>
<li><strong>duration模板类用于表示一段时间</strong>（时间长度、时钟周期），如：1小时、8分钟、5秒。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">duration的定义如下:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration</span><br><span class="line">&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>为了方便使用，定义了一些常用的时间长度，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于std::chrono命名空间下，定义如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> hours			= duration&lt;Rep, std::ratio&lt;<span class="number">3600</span>&gt;&gt;	<span class="comment">// 小时</span></span><br><span class="line"><span class="keyword">using</span> minutes			= duration&lt;Rep, std::ratio&lt;<span class="number">60</span>&gt;&gt;		<span class="comment">// 分钟</span></span><br><span class="line"><span class="keyword">using</span> seconds			= duration&lt;Rep&gt;						<span class="comment">// 秒</span></span><br><span class="line"><span class="keyword">using</span> milliseconds		= duration&lt;Rep, std::milli&gt;			<span class="comment">// 毫秒</span></span><br><span class="line"><span class="keyword">using</span> microseconds  	= duration&lt;Rep, std::micro&gt;  		<span class="comment">// 微秒</span></span><br><span class="line"><span class="keyword">using</span> nanoseconds 	= duration&lt;Rep, std::nano&gt;  			<span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure>
<strong>注意</strong></li>
<li>duration模板类重载了各种算术运算符，用于操作duration对象。</li>
<li>duration模板类提供了count()方法，获取duration对象的值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>      <span class="comment">// chrono库的头文件。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">chrono::hours  <span class="title">t1</span><span class="params">(<span class="number">1</span>)</span></span>;                                  <span class="comment">// 1小时</span></span><br><span class="line">    <span class="function">chrono::minutes  <span class="title">t2</span><span class="params">(<span class="number">60</span>)</span></span>;                            <span class="comment">//  60分钟</span></span><br><span class="line">    <span class="function">chrono::seconds  <span class="title">t3</span><span class="params">(<span class="number">60</span> * <span class="number">60</span>)</span></span>;                    <span class="comment">//  60*60秒</span></span><br><span class="line">    <span class="function">chrono::milliseconds  <span class="title">t4</span><span class="params">(<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span></span>;  <span class="comment">// 60*60*1000毫秒</span></span><br><span class="line">    <span class="function">chrono::microseconds <span class="title">t5</span><span class="params">(<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span></span>;          <span class="comment">// 警告：整数溢出。</span></span><br><span class="line">    <span class="function">chrono::nanoseconds <span class="title">t6</span><span class="params">(<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">1000</span>*<span class="number">1000</span>)</span></span>;  <span class="comment">// 警告：整数溢出。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t1 == t2)    cout &lt;&lt; <span class="string">&quot;t1==t2\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == t3)    cout &lt;&lt; <span class="string">&quot;t1==t3\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == t4)    cout &lt;&lt; <span class="string">&quot;t1==t4\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时钟周期的值，返回的是int整数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1=&quot;</span> &lt;&lt; t1.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t2=&quot;</span> &lt;&lt; t2.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t3=&quot;</span> &lt;&lt; t3.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t4=&quot;</span> &lt;&lt; t4.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">chrono::seconds <span class="title">t7</span><span class="params">(<span class="number">1</span>)</span></span>;                                         <span class="comment">// 1秒</span></span><br><span class="line">    <span class="function">chrono::milliseconds  <span class="title">t8</span><span class="params">(<span class="number">1000</span>)</span></span>;                           <span class="comment">// 1000毫秒</span></span><br><span class="line">    <span class="function">chrono::microseconds <span class="title">t9</span><span class="params">(<span class="number">1000</span> * <span class="number">1000</span>)</span></span>;              <span class="comment">// 1000*1000微秒</span></span><br><span class="line">    <span class="function">chrono::nanoseconds <span class="title">t10</span><span class="params">(<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>)</span></span>;  <span class="comment">//  1000*1000*1000纳秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t7 == t8)    cout &lt;&lt; <span class="string">&quot;t7==t8\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t7 == t9)    cout &lt;&lt; <span class="string">&quot;t7==t9\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (t7 == t10)  cout &lt;&lt; <span class="string">&quot;t7==t10\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时钟周期的值。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t7=&quot;</span> &lt;&lt; t7.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t8=&quot;</span> &lt;&lt; t8.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t9=&quot;</span> &lt;&lt; t9.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t10=&quot;</span> &lt;&lt; t10.<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="系统时间"><a href="#系统时间" class="headerlink" title="系统时间"></a>系统时间</h2><p>system_clock类支持了对系统时钟的访问，提供了三个静态成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前时间的时间点。</span></span><br><span class="line"><span class="type">static</span> std::<span class="function">chrono::time_point&lt;std::chrono::system_clock&gt; <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间点time_point类型转换为std::time_t 类型。</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::<span class="type">time_t</span> <span class="title">to_time_t</span><span class="params">( <span class="type">const</span> time_point&amp; t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将std::time_t类型转换为时间点time_point类型。</span></span><br><span class="line"><span class="type">static</span> std::chrono::<span class="function">system_clock::time_point <span class="title">from_time_t</span><span class="params">( std::<span class="type">time_t</span> t )</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS  <span class="comment">// localtime()需要这个宏。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>   <span class="comment">// put_time()函数需要包含的头文件。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1）静态成员函数chrono::system_clock::now()用于获取系统时间。（C++时间）</span></span><br><span class="line">    <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2）静态成员函数chrono::system_clock::to_time_t()把系统时间转换为time_t。（UTC时间）</span></span><br><span class="line">    <span class="keyword">auto</span> t_now = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t_now = t_now + 24*60*60;   // 把当前时间加1天。</span></span><br><span class="line">    <span class="comment">// t_now = t_now + -1*60*60;   // 把当前时间减1小时。</span></span><br><span class="line">    <span class="comment">// t_now = t_now + 120;           // 把当前时间加120秒。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3）std::localtime()函数把time_t转换成本地时间。（北京时）</span></span><br><span class="line">    <span class="comment">// localtime()不是线程安全的，VS用localtime_s()代替，Linux用localtime_r()代替。</span></span><br><span class="line">    <span class="keyword">auto</span> tm_now = std::<span class="built_in">localtime</span>(&amp;t_now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4）格式化输出tm结构体中的成员。</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y-%m-%d&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y%m%d%H%M%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    stringstream ss;   <span class="comment">// 创建stringstream对象ss，需要包含&lt;sstream&gt;头文件。</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(tm_now, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);    <span class="comment">// 把时间输出到对象ss中。</span></span><br><span class="line">    string timestr = ss.<span class="built_in">str</span>();     <span class="comment">// 把ss转换成string的对象。</span></span><br><span class="line">    cout &lt;&lt; timestr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><ul>
<li>steady_clock类相当于秒表，操作系统只要启动就会进行时间的累加，常用于耗时的统计（精确到纳秒）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态成员函数chrono::steady_clock::now()获取开始的时间点。</span></span><br><span class="line">    <span class="keyword">auto</span> start = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些代码，让它消耗一些时间。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;计时开始 ...... \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; <span class="number">1000000</span>; ii++) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;我是一只傻傻鸟。\n&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;计时完成 ...... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数chrono::steady_clock::now()获取结束的时间点。</span></span><br><span class="line">    <span class="keyword">auto</span> end = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算消耗的时间，单位是纳秒。</span></span><br><span class="line">    <span class="keyword">auto</span> dt = end - start;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;耗时: &quot;</span> &lt;&lt; dt.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;纳秒（&quot;</span>&lt;&lt;(<span class="type">double</span>)dt.<span class="built_in">count</span>()/(<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000</span>)&lt;&lt;<span class="string">&quot;秒）&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io">醉卿枫</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/wjl-a/data.github.io/post/861cd88b.html">https://github.com/wjl-a/data.github.io/post/861cd88b.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/wjl-a/data.github.io" target="_blank">醉卿枫の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2022/05/29/62939662553c9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wjlpicture.oss-cn-beijing.aliyuncs.com/img/12.png" onerror="this.onerror=null;this.src='/data.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">醉卿枫</div><div class="author-info__description">学习记录</div></div><div class="card-info-data site-data is-center"><a href="/data.github.io/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/data.github.io/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/data.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">qq:2771329872</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr"><span class="toc-number">1.1.</span> <span class="toc-text">unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr"><span class="toc-number">1.2.</span> <span class="toc-text">shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">智能指针的删除器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr"><span class="toc-number">1.4.</span> <span class="toc-text">weak_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">写入文本文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">读取文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">写入二进制文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">读取二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96"><span class="toc-number">2.3.</span> <span class="toc-text">随机存取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fstream%E7%B1%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">fstream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%8C%87%E9%92%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">文件的位置指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">随机存取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">打开文件的模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%8A%E6%B5%81%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.</span> <span class="toc-text">缓冲区及流状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.4.1.</span> <span class="toc-text">文件缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">流状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%BC%82%E5%B8%B8"><span class="toc-number">3.</span> <span class="toc-text">C++异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">异常的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E8%A7%A3%E6%97%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">栈解旋</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83"><span class="toc-number">3.2.</span> <span class="toc-text">异常规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%E5%BC%82%E5%B8%B8"><span class="toc-number">3.3.</span> <span class="toc-text">C++标准库异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">3.3.1.</span> <span class="toc-text">重点关注的异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%96%AD%E8%A8%80"><span class="toc-number">4.</span> <span class="toc-text">C++断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">4.1.</span> <span class="toc-text">断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-11%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80"><span class="toc-number">4.2.</span> <span class="toc-text">C++11静态断言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-number">5.</span> <span class="toc-text">C++新标准</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">统一的初始化（列表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE%EF%BC%88%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">强类型枚举（枚举类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.3.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#override%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.4.</span> <span class="toc-text">override关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8Fconstexpr%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.5.</span> <span class="toc-text">常量表达式constexpr关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6-default%E4%B8%8E-delete"><span class="toc-number">5.6.</span> <span class="toc-text">默认函数控制&#x3D;default与&#x3D;delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-number">5.7.</span> <span class="toc-text">委托构造和继承构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-number">5.7.1.</span> <span class="toc-text">委托构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0"><span class="toc-number">5.7.2.</span> <span class="toc-text">继承构造</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="toc-number">5.8.</span> <span class="toc-text">lambda函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.8.1.</span> <span class="toc-text">lambda函数的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.9.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC"><span class="toc-number">5.9.1.</span> <span class="toc-text">左值、右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.9.2.</span> <span class="toc-text">左值引用、右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">5.10.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">5.11.</span> <span class="toc-text">完美转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.12.</span> <span class="toc-text">可变参数模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9Cchrono%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">时间操作chrono库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E9%95%BF%E5%BA%A6"><span class="toc-number">6.1.</span> <span class="toc-text">时间长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4"><span class="toc-number">6.2.</span> <span class="toc-text">系统时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">计时器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/52d1a938.html" title="8.c++_线程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="8.c++_线程"/></a><div class="content"><a class="title" href="/data.github.io/post/52d1a938.html" title="8.c++_线程">8.c++_线程</a><time datetime="2023-12-24T16:00:00.000Z" title="发表于 2023-12-25 00:00:00">2023-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="7.c+++_智能指针_文件操作"/></a><div class="content"><a class="title" href="/data.github.io/post/861cd88b.html" title="7.c+++_智能指针_文件操作">7.c+++_智能指针_文件操作</a><time datetime="2023-12-23T16:00:00.000Z" title="发表于 2023-12-24 00:00:00">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="6.c++_STL"/></a><div class="content"><a class="title" href="/data.github.io/post/6ad37afc.html" title="6.c++_STL">6.c++_STL</a><time datetime="2023-12-20T16:00:00.000Z" title="发表于 2023-12-21 00:00:00">2023-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="变结构无人机仿真"/></a><div class="content"><a class="title" href="/data.github.io/post/b7b02208.html" title="变结构无人机仿真">变结构无人机仿真</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/data.github.io/post/5d3e3d8b.html" title="soildworks"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/29/62939662553c9.png" onerror="this.onerror=null;this.src='/data.github.io/img/404.jpg'" alt="soildworks"/></a><div class="content"><a class="title" href="/data.github.io/post/5d3e3d8b.html" title="soildworks">soildworks</a><time datetime="2023-10-27T13:01:00.000Z" title="发表于 2023-10-27 21:01:00">2023-10-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://bu.dusays.com/2022/05/29/62939662553c9.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 醉卿枫</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/data.github.io/js/utils.js"></script><script src="/data.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/data.github.io/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/data.github.io/js/search/local-search.js"></script></div></div></body></html>